基础理论知识：
*⚫•
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

HotSpot是什么？

1. HotSpot历史


    SUN的JDK版本从1.3.1开始运用HotSpot虚拟机， 2006年底开源，主要使用C++实现，JNI接口部分用C实现。
    
    HotSpot是较新的Java虚拟机，用来代替JIT(Just in Time)，可以大大提高Java运行的性能。 
    
    Java原先是把源代码编译为字节码在虚拟机执行，这样执行速度较慢。
    而HotSpot将常用的部分代码编译为本地(原生，native)代码，这样显着提高了性能。 
    
    HotSpot JVM 参数可以分为规则参数(standard options)和非规则参数(non-standard options)。 
    
    规则参数相对稳定，在JDK未来的版本里不会有太大的改动。 
    
    非规则参数则有因升级JDK而改动的可能。


2.HotSpot基础知识

    HotSpot包括一个解释器和两个编译器（client 和 server，二选一的），解释与编译混合执行模式，默认启动解释执行。

    编译器：java源代码被编译器编译成class文件（字节码），
    java字节码在运行时可以被动态编译（JIT）成本地代码(前提是解释与编译混合执行模式且虚拟机不是刚启动时)。

    解释器： 解释器用来解释class文件（字节码），java是解释语言（书上这么说的）。

    server启动慢，占用内存多，执行效率高，适用于服务器端应用；

    client启动快，占用内存小，执行效率没有server快，默认情况下不进行动态编译，适用于桌面应用程序。

    由-XX:+RewriteFrequentPairs参数控制  client模式默认关闭，server模式默认开启

    在jre安装目录下的lib/i386/jvm.cfg 文件下。

   

java -version

Java HotSpot(TM) Client VM (build 14.3-b01, mixed mode, sharing)

mixed mode 解释与编译 混合的执行模式 默认使用这种模式



java -Xint -version

Java HotSpot(TM) Client VM (build 14.3-b01, interpreted mode, sharing)

interpreted  纯解释模式 禁用JIT编译



java -Xcomp -version

Java HotSpot(TM) Client VM (build 14.3-b01, compiled mode, sharing)

compiled  纯编译模式（如果方法无法编译，则回退到解释模式执行无法编译的方法）

   

3.动态编译

    动态编译(compile during run-time)，英文称Dynamic compilation；Just In Time也是这个意思。
    
    HotSpot对bytecode的编译不是在程序运行前编译的，而是在程序运行过程中编译的。
    HotSpot里运行着一个监视器（Profile Monitor），用来监视程序的运行状况。
    
    java字节码（class文件）是以解释的方式被加载到虚拟机中(默认启动时解释执行)。 程序运行过程中，那一部分运用频率大，那些对程序的性能影响重要。对程序运行效率影响大的代码，称为热点（hotspot），HotSpot会把这些热点动态地编译成机器码（native code），同时对机器码进行优化，从而提高运行效率。对那些较少运行的代码，HotSpot就不会把他们编译。
    
    HotSpot对字节码有三层处理：不编译(字节码加载到虚拟机中时的状态。也就是当虚拟机执行的时候再编译)，编译(把字节码编译成本地代码。虚拟机执行的时候已经编译好了，不要再编译了)，编译并优化（不但把字节码编译成本地代码，而且还进行了优化）。
    
    至于那些程序那些不编译，那些编译，那些优化，则是由监视器（Profile Monitor）决定。

 

4.为什么不静态编译那？

    为什么字节码在装载到虚拟机之前就编译成本地代码那？ 

    动态编译器也在许多方面比静态编译器优越。静态编译器通常很难准确预知程序运行过程中究竟什么部分最需要优化。

    函数调用都是很浪费系统时间的，因为有许多进栈出栈操作。因此有一种优化办法，就是把原来的函数调用，通过编译器的编译，改成非函数调用，把函数代码直接嵌到调用出，变成顺序执行。

    面向对象的语言支持多态，静态编译无效确定程序调用哪个方法，因为多态是在程序运行中确定调用哪个方法。
    
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Java 沙箱安全模型是什么？


一：为什么需要安全性

　　1：因为网络允许多台计算机共享数据和分布式处理，所以它提供了一条
侵入计算机系统的潜在途径，使得恶意用户可能窃取信息，改变或者破坏信息，
盗取计算机资源等。因此计算机连入网络很容易产生安全问题。

　　2：如果在一个环境中，软件可以通过在网络中下载并且在本地运行，这个
问题尤其严重。比如Applet 和Jini服务对象就是这样的例子。因为当用户在浏览器
打开网页时，Applet的Class文件会自动下载，很有可能用户会遇到来自不可靠来源的Applet。

　　3：当一个Jini服务对象用JiNI查找服务进行服务注册时，它的Class将从服务供应商
指定的代码库进行下载。Jini实现了一个自发的网络互连，客户机进行一个新的环境
查找并访问本地服务。因此JINI可能会遇到来自不可靠的服务对象。

　　如果没有任何安全机制，这些自动下载的模式为恶意代码发布提供了便捷的途径。
JAVA的安全机制使得JAVA适用于网络，因为它们建立了堆网络移动代码安全秩序必要的可信机制。

二：JAVA沙箱的基本组件

　　1：类加载器结构  https://blog.csdn.net/qpzkobe/article/details/78792683

　　　　它防止了恶意代码去干涉善意的代码，这是通过为不同的类加载器装入的类提供了不同的命名空间来实现的，命名空间互相独立。

　　　　它守护了被信任类库的边界，这是通过分别使用不同的类加载器装载可靠的包和不可靠的包来实现的。

　　　　它将代码归入某类（命名空间），该类确定了代码可以执行哪些操作，一个保护域定义了这个代码在运行时将得到的权限。

　　2：class文件效验器   https://my.oschina.net/xionghui/blog/501154

　　　　class文件结构的检查

　　　　类型数据的语义检查

　　　　字节码验证

　　　　符号引用的检查

　　　　二进制兼容

　　3：内置于JAVA虚拟机（及语言）的安全特性   https://my.oschina.net/xionghui/blog/501165

　　　　类型安全的引用转换

　　　　结构化的内存访问（无指针算法）

　　　　自动垃圾收集（不必显示的释放被分配的内存）

　　　　数组边界检查

　　　　空引用检查

　　4：安全管理器及API   https://my.oschina.net/xionghui/blog/501225

　　　　虽然安全管理器是JAVA安全模型最大的优点之一，但是也有一个潜在的弱点。编写一个安全管理器是一项负责的任务，并可能导致出错。在实现安全管理器的check方法

时，任何错误都将变成运行时的安全漏洞。

　　5：代码签名和认证


三：什么是字节码

字节码代码了java的方法，它是由称为操作码的单字节指令组成的序列，每一个操作码后面多跟着一个或者多个操作数。

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------