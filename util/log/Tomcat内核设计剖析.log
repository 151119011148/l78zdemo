步书
Tomcat
内蔽设计剖析
江建◎著
中国倍出版集影民邮电出版社Tomcat
内蔽设计剖析
汪建◎著
人民邮电出版社
北京图书在版编目(CIP)数据
Tomcat内核设计剖析/汪建著
比京:人民邮
电出版社,2017.6
ISBN978-7-115-45130-9
I.①T…Ⅱ.①汪…Ⅲ.①JAVA语言一程序设计
Ⅳ.①TP312.8
中国版本图书馆CIP数据核字(2017)第069990号
内容提要
Tomcat是一款免费的开源应用服务器,因其性能稳定、体积小巧、扩展性好等特点而被传统和
互联网行业广泛应用。
本书是深入剖析 Tomcat Web服务器运行机制的权威图书,共分为22章。本书从Web服务器相
关的基础知识及原理开始逐渐深入Tomcat内部设计,比如涵盖了HTTP协议、Socket通信及服务器
模型等必备的基础知识。另外还包括 Servlet规范,这些都是深入 Tomcat必不可少的知识。然后介
绍了 Tomcat的启动与关闭过程,接着从整体预览 Tomcat的内部结构,让读者对 Tomcat内部有个整
体的了解。最后开始层层剖析 Tomcat内部结构,包括 Server组件, Service组件,内存泄漏检测,
Connector组件(HTTP协议、AJP协议、BIO模式、NO模式和APR模式),Engine容器,Host容
器, Context容器, Wrapper容器( Servlet种类机制、 Comet模式、 Web Socket协议、异步 Servlet),
生命周期管理,日志框架及其国际化(日志系统、日志国际化及访问日志),公共与隔离的加载器(多
个web应用如何做到资源隔离), Mapper组件(局部路由、全局路由), Tomcat集成八D,JSP编
译器(JSP语法解析、JSP编译成 Servlet、 Servlet编译成Clas,运行及通信的安全管理,处理请求
和响应的管道(管道杋制),多样化的会话管理器(标准会话管理器、持久化会话管理器、集群增量
会话管理器及集群备份管理器),高可用的 Tomcat集群的实现(从单机到集群), Tomcat集群通信
框架, Tomcat内部监控与管理。
本书适用于想深入了解Web服务器原理、想知道在浏览器上点击某个按钮后发生的事情、想了
解 Tomcat内部工作原理、想基于 Tomcat做二次开发的人员。
著
汪建
责任编辑傅道坤
责任印制焦志炜
人民邮电出版社出版发行北京市丰台区成寿寺路11号
邮编100164电子邮件315@ptpress.com.cn
网址htp:/vww.ptpress.com.cn
三河市海波印务有限公司印刷
◆开本:787×10921/16
印张:22.75
字数:487千字
2017年6月第1版
印数:1-2500册
2017年6月河北第1次印刷
定价:7900元
读者服务热线:(010)81055410印装质量热线:(010)81055316
反盗版热线:(010)81055315
广告经营许可证:京东工商广字第8052号作者简介
汪建,毕业于广东工业大学光信息科学与技术专业,毕业后从事航空系统、电信系统、中
间件、基础架构、智能客服等研发工作,目前主要关注分布式、高并发、大数据、搜索引擎、
机器学习等方面的技术。崇尚开源,崇尚技术自由,更崇尚思想自由。个人博客地址为
blog. csdn. net/wangyangzhizhou
致谢
首先,感谢读者,你的阅读让本书更加有价值
其次,感谢在本书编写过程中帮助过我的人,感谢公司提供的平台让我得到了很多学习和
成长的机会,还要感谢人民邮电出版社的傅道坤编辑,根据他的建议我对本书内容进行了多处
改进,使内容更加丰富,结构更加清晰。
最后,感谢一直鼓励我、支持我的家人,特别是我的爱妻,挺着身孕仍然孜孜不倦地帮我
审稿,你们让我的世界更丰富多彩。同时也将本书献给我即将出生的孩子。前言
Tomcat作为一款免费的开源应用服务器,凭借技术先进、性能稳定、体积小巧、扩
展性好等优势,深受开发者和软件开发商认可。鉴于 Tomcat是一款较轾量级的应用服务
器,它广泛使用在中小型系统中,并且是一个很流行的Web服务器。那么,如此优秀的
Tomcat是怎样创造出来的呢?它的架构是怎样的呢?内部到底又是怎样运作的呢?需要
哪些技术来支撑呢?有很多疑问都需要我们去研究和探索,作者试图在本书中阐明
Tomcat内部的秘密。
虽然 Tomcat已经广泛使用了很长时间,市面上也有很多相关图书,但多数关于 Tomcat
的图书基本都停留在如何使用 Tomcat、如何在 Tomcat服务器上进行Web应用开发等方面。本
书将从Web服务器基础知识开始讲起,循序渐进,让读者不仅能了解 Tomcat内核的设计,还
能掌握Web服务器的原理,体会到一个工业级的Web服务器是如何设计的。本书可以帮助读
者快速建立 Tomcat的内部运作模型。
重复发明轮子不是我们提倡的,本书并不鼓励读者重复开发轮子,而是鼓励大家去硏究开
源软件,学习其中的优秀架构,从中借签优秀的设计理念,看看这些优秀开源产品的过人之处,
从而提高自己的软件素养。
本书具备如下特点。
所探讨的 Tomcat基于 Tomcat7版本。
通篇大量采用图解,方便读者理解。
对各个设计要点都做深入剖析,读者可以体会到其中为什么要这样设计,原来工业级软件
要考虑的如此多、如此细。
脉络结构比较清晰,由整体到部分,由浅到深,循序渐进,知识点的连贯性比较强,对于
基础知识有补充说明,避免读者读到一半无法继续阅读。
组织结构
本书旨在剖析 Tomcat的内核设计及其原理,全书共分为22章,主要内容如下。
〉第1章:web服务器机制,介绍web相关的基础知识,如HTTP、套接字通信及服务器模
型等。
第2章: Servlet规范,介绍Java体系Web容器的 Servlet规范
第3章: Tomcat的启动与关闭,介绍 Tomcat启动、关闭的批处理及相关的变量。前言
第4章:从整体预览 Tomcat,先从整体介绍 Tomcat内部结构以及请求处理的整个过程,
让读者能从整体了解 Tomcat结构,为后面深入介绍各个组件做铺垫。
第5章: Server组件与 Service组件,介绍 Server和 Service组件,以及 Tomcat中对内存
泄漏的监听检查。
第6章:Connector组件,介绍Tomcat包含的HTTP和AJP两种协议的连接器,以及它们
不同的O模式,如BIO模式、NO模式和APR模式
>第7章: Engine容器,介绍 Engine容器。
>第8章:Host容器,介绍Host容器及其包含的内部组件。
>第9章: Context容器,介绍 Context容器及其包含的内部组件。
第10章: Wrapper容器,介绍 Wrapper容器及 Servlet的种类和工作机制,以及 Comet模
式的实现、 WebSocket协议的实现和异步 Servlet的实现。
第11章:生命周期管理,介绍 Tomcat的生命周期管理机制及其事件监听机制。
>第12章:日志框架及其国际化,介绍 Tomcat的日志系统及日志的国际化,同时还有 Tomcat
的访问日志的设计及使用介绍。
>第13章:公共与隔离的类加载器,介绍 Tomcat内部的类加载器结构,如何达到多个Web
应用既能共用某些类库又能互相隔离。
第14章:请求URI映射器 Mapper,介绍 Tomcat对请求UR处理的原理,以及局部路由
和全局路由两种 Mapper
>第15章: Tomcat的JND,介绍 Tomcat内部对JND的集成支持,以及在 Tomcat中如何
使用JNDI
第16章:JSP编译器 Jasper,介绍JSP的语法及 Tomcat如何对其进行解析,介绍从JsP
到 Servlet,再从 Servlet到 Class的整个编译过程。
第17章:运行、通信及访问的安全管理,介绍 Tomcat内部运行时的安全管理, Tomcat
通信信道的安全实现,以及客户端访问认证机制
≯第18章:处理请求和响应的管道,介绍 Tomcat中对请求和响应处理的管道模式的设计,
以及在 Tomcat中如何定制阀门。
第19章:多样化的会话管理器,介绍 Tomcat内部的会话管理机制,以及标准会话管
理器、持久化会话管理器、集群增量会话管理器和集群备份会话管理器的实现机制及
原理。
第20章:高可用的集群实现,介绍 Tomcat如何实现集群的高可用性, Tomcat从单机模式
到集群模式的会话管理,以及 Tomcat的 Cluster组件。
〉第21章:集群通信框架,介绍 Tomcat的集群通信框架 Tribes,剖析 Tribes的原理机制
以及 Tomcat如何使用 Tribes进行会话同步和集群部署。
第22章:监控与管理,介绍了 Tomcat如何实现自身内部的监控及其管理。前言
读者对象
假如你对浏览器上单击某个按钮后发生的事情感兴趣,那么这本书适合你。
假如你想深入了解Web服务器原理,那么这本书适合你,
≯假如你想深入了解 Tomcat核心架构的原理及 Tomcat内组件的工作原理,那么这本书
适合你。
假如你想设计开发一个类似 Tomcat的中间件,那么这本书适合你
假如你想基于 Tomcat做二次开发,自定义 Tomcat,那么这本书适合你。
反馈
在本书交稿时,我仍在担心本书是否遗漏了某些知识点,其中的内容是否翔实齐备,是否
能让读者有更多收获,是否会因为自己理解的偏差而误导读者。由于写作水平和写作时间所限,
本书中难免存在谬误,恳请读者评判指正。
读者可将任何意见及建议发送到邮箱wz88afoxmail.com,本书相关的勘误也会发布
到我的个人博客 blog. csdn. net/wangyangzhizhou上。欢迎读者通过邮件或博客与我交流。
3目录
第1章Web服务器机制
1.1通信协议
1.1.1httP/httpS
1.1.2HTTP请求/响应模型……
1.1.3解析HTTP报文
12套接字通信
1.2.1单播通信…
789
1.2.2组播通信
..,,·.,,,.,··,,.,,,··,··,
1.2.3广播通信…
………………12
1.3服务器模型
…………13
1.3.1单线程阻塞IO模型
…………14
1.3.2多线程阻塞IO模型·
15
3.3单线程非阻塞LO模型……
…16
1.3.4多线程非阻塞IO模型
……………19
第2章 Servlet规范
……………………02
2.1 Servlet接口…
……22
22 Servletrequest接口
…23
2.3 ServletContext接口…
…23
24 Servletresponse接口
……………24
2.5 Filter接口
24
2.6会话…
……25
2.7注解
25
28可插拔性
,,,
…26
29请求分发器
……………26
2.10Web应用
………26
Servlet映射
………27
2.12部署描述文件…
…………28目录
第3章 Tomcat的启动与关闭
…………………29
3.1 Tomcat的批处理
……………………………………………29
3. 1.1 startup. bat
…29
3.1.2 shutdown.bat……………
…31
3.1.3 catalina.bat…
……31
3.1.4 setclasspath.bat……
.,4,,.,,,,···,,,.,,,,,,,,
39
3.2 Tomcat中的变量及属性
40
3.2.1环境变量
41
3.22JVM系统变量…
……………………………41
323 Tomcat属性
第4章从整体预览 Tomcat……
41整体结构及组件介绍
…45
4.2请求处理的整体过程
…50
第5章 Server组件与 Service组件……
…………52
5.1 Server组件
52
51.1生命周期监听器
…53
51.2全局命名资源
……………………………57
5.1.3监听 SHUTDOWN命令
……58
52 Service组件
…………59
第6章 Connector组件
…63
6.1HTTP阻塞模式协议—Httpllprotocol…
……64
61.1套接字接收终端— JloEndpoint
………65
6.12HTTP阻塞处理器—Httpllprocessor…………………………………………73
62HTTP非阻塞模式协议—Htpl|NioProtocol…
102
62.1非阻塞接收终端— -NioEndpoint
102
622HTTP非阻塞处理器—Ht1|NioProcessor
…111
63 Http Apr模式协议— Http1l aprprotocol…
631APR接收终端—— Apr Endpoint
…114
632 Http Apr处理器—Htp| AprProcessor…………119
6.4 AJP Connector
…121
64lAJP阻塞模式协议—— AjpProtocol
123
642 AJP APR模式协议— AjpAprProtocol
……………………125目录
65HTP三种模式的 Connector
,,..··,,,,·,,··.··,·
………126
66AJP三种模式的 Connector…
……………126
第7章 Engine容器
………………127
第8章Host容器
…129
8.1Web应用— Context…
.。曲,·······
非,,中·,.中··
129
8.2访问日志— AccessLog
130
8.3管道— Pipeline
130
84Host集群— Cluster
………130
85Host域—— realm…
a自,·,,.,·
…130
86生命周期监听器 Host Config
…………13
86.1 Descriptor描述符类型
……………131
862WAR包类型…
………………132
86.3目录类型
…………133
第9章 Context容器
…134
9.1 Context容器的配置文件
……134
92包装器— Wrapper
135
9.3 Context域—— Realm
………135
94访问日志— AccessLog………
··非
………135
9.5错误页面— ErrorPage
……135
96会话管理器— Manager
……………137
97目录上下文— DirContext
………………………………………………137
98安全认证
138
99Jar扫描器— JarScanner
138
90过滤器
139
911命名资源— NamingResource
140
912 Servlet映射器— -Mappe
er
……………………141
913管道— Pipeline…
………141
914Web应用载入器— WebappLoader
………142
915 Servletcontext的实现— Application Context
143
916实例管理器 -InstanceManager…
145
9.17 ServletContainerInitializer初始化器………
…145
9.18 Context容器的监听器…
……147目录
9.18.1 Context Config监听器
.,,,,
……148
9.182 TIdConfig监听器
…151
9. 18.3 Naming ContextListener
监听器
151
9.18.4 Memory LeakTrackingListener监听器…
…………151
第10章 Wrapper容器
…154
10.1 Servlet工作机制
…154
10.2 Servlet对象池
……156
10.3过滤器链
…………………157
104 Servlet种类
,,,,,,,,·,,,,,,,,,
………………………………158
10.5 Comet模式的支持……
………161
10.6 WebSocket协议的支持
……………………………………163
10.7异步 Servlet
…166
第11章生命周期管理……
………169
111生命周期统一接口— Lifecycle
………169
12生命周期的状态转化
…170
1.3生命周期事件监听机制
…172
第12章日志框架及其国际化
……17
12.1系统内日志…
………177
12.2日志的国际化
…………………179
123客户端访问日志…
181
12.3.1访问日志组件的设计
……182
12.32访间日志格式的自定义
…184
第13章公共与隔离的类加载器
186
13.1类加载器
¨…………………186
13.2自定义类加载器
189
13.3 Tomcat中的类加载器
……192
134类加载器工厂— Class LoaderFactory………
………194
13.5遭遇 ClassNotFoundException
…………………………196
第14章请求∪R|映射器 Mapper
…200
14.1请求的映射模型
200目录
14.2 Mapper的实现
…201
14.3局部路由 Mapper
…203
144全局路由 Mapper
………………
04
第15章 Tomcat的JND
……………205
15.1JNDI简介
…205
152JNDI运行机制…
…206
15.3在 Tomcat中集成JDI
210
154在 Tomcat中使用JNDl
…………222
154.1web应用的局部配置方式…
…………………………………222
1542服务器的全局配置方式
………………………223
15.5 Tomcat的标准资源
……226
第16章JSP编译器 Jasper
227
16.1从JSP到 Servlet
228
16.1.1语法树的生成——语法解析
16.1.2语法树的遍历—访问者模式
…………230
16.1.3JSP编译后的 Servlet
……………232
162从 Servlet到 Class字节码
235
162.1JSR45标准…
……………………235
16.2.2 JDT Compiler编译器…
……236
162.3 Jasper自动检测机制
……………………241
第17章运行、通信及访问的安全管理
…243
17.1运行安全管理
………243
17.1.1Java安全管理器—— Security Manager
…………243
17.1.2 Tomcat的系统安全管理
………246
17.1.3安全管理器特权…
…248
17.2安全的通信
…249
17.21SSL/LS协议
··…················“
249
17,22Java安全套接字扩展—JSSE
…………251
17.2.3 Tomcat中SSL安全信道的实现
264
17.3客户端访问认证机制
…266
17.3.1web资源认证原理
…266
17.3.2认证模式
…267目录
17.33 Realm域……
……272
7.3.4 Tomcat如何实现资源安全管理
……………………273
17.3.5如何让你的Web具备权限认证
……274
第18章处理请求和响应的管道
…276
18.1管道模式——管道与阀门
……276
18.2 Tomcat中的管道…………280
18.3 Tomcat中的定制阀门
…………………………282
第19章多样化的会话管理器
…285
19.1Web容器的会话机制
…………286
192标准会话对象— StandardSession
………………………………287
193增量会话对象— Delta Session
………………288
194标准会话管理器— StandardManager
…………………290
19.5持久化会话管理器 -PersistentManager……291
19.5.1 File Store
,,,
…292
19.5.2 JDBCStore…
29
196集群增量会话管理器— DeltaManager…………294
197集群备份会话管理器— Backup Manager
……………………………96
197.1机制与原理…
………………………297
19.7.2高可用性及故障转移机制
·,,,.·,.·,,·,,··,,
299
19.7.3集群RPC通信…
…301
198 Tomcat会话管理器的集成
……………308
第20章高可用的集群实现
·,,,,,,,·
………11
20.1从单机到集群的会话管理
311
20.1.1单机模式
…311
20.1.2集群模式……
…………………………313
202 Cluster组件
……………………315
203 Tomcat的 Cluster工作机制…
…………………317
204 Tomcat中 Cluster的级别
,,,,、
………………………………………318
20.5如何让 Tomcat实现集群功能
…318
第21章集群通信框架…
………320
211 Tribes简介
………………………320
6目录
21.2集群成员维护服务—— MembershipService
…321
21.3平行的消息发送通道— Channelsender
…325
21.4消息接收通道— ChannelReceiver
………………327
21.5通道拦截器— - ChannellInterceptor
…………328
21.6应用层处理入口— MembershipListener与 Channellistener…………331
21.7如何使用 Tribes进行数据传输
332
218 Tomcat使用 Tribes同步会话
334
21.9 Tomcat使用 Tribes部署集群应用
…………334
第22章监控与管理·
337
221Java管理扩展—JMX
337
221.JMX的基本结构
…337
221.2JMX例子
…338
222JMX管理下的 Tomcat
……339
22.3 Manager Servlet
…343第1章Web服务器机制
所有的web服务器都根据规定好的协议机制进行不同的实现及扩展。有的Web服务器只
能处理静态资源,而有的可以完成动态处理。有的Web服务器用C++语言实现,而有的用Java
语言实现。但不管web服务器具体如何实现及扩展,它都必须要遵循基本的协议规定。在深
入研究 Tomcat之前很有必要先了解Web服务器的一些机制。
本章分别从通信协议、 Socket通信、web服务器模型三方面对web服务器机制进行
介绍。
11通信协议
1.1.1 Http/htTps
HTTP是HyperTextTransferProtocol(超文本传输协议)的缩写。HTTP协议是用于从Web
服务器传输超文本到本地浏览器的协议,它能使浏览器更加高效,使网络传输减少,保证计算
机正确快速地传输超文本文档。现在我们普遍使用的版本是 Httpi.1。
HTP是一个应用层协议,它由请求和响应组成,是一个标准的BS模型。同时,它也是
一个无状态的协议,即同一个客户端上,此次请求与上一次请求是没有对应关系的
而Https简单地说就是HTTP的安全版。通常,在安全性要求比较高的网站(例如银行
网站)上会看到HTPS,它本质上也是HTTP协议,只是在HTTP增加了一个SSL或TS协
议层。如图1.1所示,如果在TCP协议上加一层SSL或TLS协议,就构成 Https协议了。
SSL/TLS协议提供了加解密的机制,所以它比HTTP明文传输更安全。从图1.1中可以看出,
HTTP可以直接进入TCP传输层,也可以在TCP层上加一层SSL/TLS层,这样就先经过
SSL/TLS再进入TCP传输层。这两种方式便是HTP与Https。一般HTTP的端口号为80,
而 Https的端口号为443
简单地说,SSL/TLS协议层主要的职责就是借助下层协议的信道安全地协商出一份
加密密钥,并且用此密钥来加密HTTP请求响应报文。它解决了以下三个安全性方面的
议题。
提供验证服务,验证本次会话实体身份的合法性第1章Web服务器机制
提供加密服务,强加密机制能保证通信过程中的消息不会被破译。
提供防篡改服务,利用Hash算法对消息进行签名,通过验证签名保证通信内容不被
篡改。
Http
应用层
TLS/SSL
TCP
传输层
网络层
链路协议
链路层
▲图1.1HTTP与Https
Https运用越来越广泛,而且在安全场景中它是一个很好的解决方案,一般作为解决安
全传输的首选解决方案。下面深入了解一下 Https的工作原理及流程。
在理解 Https工作原理前,先了解一些加密解密算法与Hash算法。
〉对称加密。密钥只有一个,加密、解密都是这个密码,加解密速度快,典型的对称加密算
法有DES、AES、RC4等。
非对称加密。密钥成对出现,分别为公钥与私钥,从公钥无法推知私钥,反之,从私钥也
不能推知公钥。加密、解密使用不同的密钥,公钥加密需要私钥解密,反之,私钥加密需
要公钥解密。非对称加密速度较慢,典型的非对称加密算法有RSA、DSA、DSS等。
Hash算法,这是一种不可逆的算法,它常用于验证数据的完整性。
图1.2详细描述了 Https完成一次通信要做哪些事情。因为 Https是基于TCPP协议
通信的,属于可靠传输,所以它必须要先进行三次握手,完成连接的建立。接着是SSL的握
手协议,此协议非常有效地让客户和服务器之间完成相互之间的身份验证及密钥协商。
①客户端浏览器向服务器发送SSL/TLS协议的版本号、加密算法的种类、产生的随机数,
以及其他需要的各种信息。
②服务器从客户端支持的加密算法中选择一组加密算法与Hash算法,并且把自己的证书
(包含网站地址、加密公钥、证书颁发机构等)也发送给客户端。
③浏览器获取服务器证书后验证其合法性,验证颁发机构是否合法,验证证书中的网址是
否与正在访问的地址一致,通过验证的浏览器会显示一个小锁头,否则,提示证书不受信。1.1通信协议
④客户端浏览器生成一串随机数并用服务器传来的公钥加密,再使用约定好的Hash算法
计算握手消息,发送到服务器端。
⑤服务器接到握手消息后用自己的私钥解密,并用散列算法验证,这样双方都有了此次
通信的密钥。
⑥服务器再使用密钥加密一段握手消息,返回给客户端浏览器
⑦浏览器用密钥解密,并用散列算法验证,确定算法与密钥。
完成以上7步后双方就可以利用此次协商好的密钥进行通信
有先先完成3次握手
①客户端发出安全访问请求,包含自己可实现的算法列表
②确定此次通信使用的加密算法与散列算法,并发送证书、服务器公钥
Http
③客户端用
已知CA列
SL/tls
表验证证书
合法性
④客户端生成随机对称密钥,用公钥加密,使用散列算法计算握手消息ˇ
TCP/IP
⑤服务器用自己的私钥
解密,并用散列算法
验证,双方都有了此
次通信的密钥
服务器
⑥再次使用密钥加密一段握手消息
⑦浏览器用密钥解密,
并用散列算法验证,
确定算法与密钥
双万和用此协商的密行值
▲图1.2 Https的工作原理及流程
1.1.2HTTP请求/响应模型
从某种意义上来说,HTTP协议永远都由客户端发起请求,由服务器进行响应并发送回响
应报文。如果没有客户端进行请求或曾经请求过,那么服务器是无法将消息推送到客户端的。
HTTP采用了请求响应模型,一个HTTP请求与响应一般如图1.3所示,客户端向服务器发送
个请求,请求头包含请求方法、URI、协议版本、请求修饰符、客户信息,以及类似于MME
结构的消息内容。服务器以一个状态行作为响应,内容包括消息协议版本、成功(或失败)编
码、服务器信息、实体元信息及一些实体内容。这样就完成了一个请求/响应过程。
通常,一个HTP请求响应的工作流程大概可以用以下4步来概括。
①客户端浏览器先要与服务器建立连接,即通过三次握手建立连接。在浏览器上最常见
的场景就是单击一个链接,这就触发了连接的建立。
②连接建立后,客户端浏览器发送一个请求到服务器,这个过程其实是组装请求报文的
过程,详细的报文格式与解析会在下一节介绍。第1章Web服务器机制
③服务器端接收到请求报文后,对报文进行解析,组装成一定格式的响应报文,返回给
客户端
④客户端浏览器接收到响应报文后,通过浏览器内核对其进行解析,按照一定的外观进
行显示,然后与服务器断开连接。
HTMI
请求
响应
程序
图1.3HTP请求/响应模型
1.1.3解析HTTP报文
上一节介绍了HTTP请求响应模型,那么具体请求与响应报文格式是怎样的?报文又是
怎样解析的?本节将论述HTTP报文解析的整体格式。要深入理解Web服务器就必须对HTTP
协议报文有所了解。HTTP报文是面向文本的,报文中每个字段都是一些ASC∏码串,它包括
请求报文和响应报文。
首先看看HTTP请求报文。一个HTP请求由三部分组成:请求行、请求头部、请求体。图
14详细展示了一个HITP请求报文的结构。请求行( request line)由请求方法字段、URL字段和
HTTP协议版本字段组成,它们用空格分隔并以“rn”结尾。请求头部(requestheader)包含若
干个属性与属性值,它们通过冒号分隔,格式为“属性名:属性值”,每个属性-属性值对以“rn”
结尾,整个请求头部又以“rn”结尾。请求体( request body)一般在POST方法里使用,而不在
GET方法中使用,例如浏览器将表单中的组件格式化成 paramI=auel& param2=alue2键值对组,
然后将其存放至请求体中,以此完成对表单参数的传输。
GET和POST是最常见的请求方法,除此之外,还包括 DELETE、HEAD、 OPTIONS、
PUT、 TRACE。当我们单击网页链接或在浏览器输入网址访问时,就使用了GET方法,请求
参数和值附加在URL后面,用问号隔开,如/ index. jsp?id=10000用GET方法传递的参数都
能在地址栏上看到,大多浏览器对地址的字符长度做了限制,最多是1024个字符,所以要传1.1通信协议
送大量数据,就要选择用POST方法。POST方法允许客户端提交更多信息给服务器,它把请
求参数封装到请求体中,可以传输大量数据,不会对数据大小进行限制,同时也不在地址栏显
示参数。其他请求方法不再展开讨论,感兴趣的读者可查阅相关资料。
请求行
请求头部
请求体
请求行
请求方法空格URL空格协议版本
请求头部
字段名
值
字段名:值
r
请求体
请求体的内容
▲图1.4HTTP请求报文
请求头部常见的典型属性有以下几种。
User- Agent:客户端请求的浏览器类型,更确切地说,是客户端应用程序的名称,不同版
本、不同厂商的值都可能不相同。
Accept:告诉服务器客户端可识别的媒体类型列表。这个属性的值可以是一个或多个
MIME类型的值,服务器可以根据这个判断是否发送这个媒体类型。
Host:供客户端访问的那台机器的主机名和端口号。
Cookie:用于传输客户端的 Cookie到服务器,服务器维护的 Session就是通过 Cookie附带
的 JSESSIONID值来区分哪个客户端关联哪个 Session的。当然,我们还可以通过重写URL
的方式将 JSESSIONID附带在URL后面。
Referer:表示这个请求是从哪个URL过来的,可以让服务器知道客户端从哪里获得其请
求的RUL。例如在A网站的页面单击一个链接进入B网站的页面,浏览器就会在请求中
插入一个带有A网站中该页面地址的 Referer头部。第1章Web服务器机制
Cache- Control:通过这个属性可以对缓存进行控制
接着看HTTP响应报文。与请求报文一样,响应报文由三部分组成:响应行、响应头部、
响应体(如图1.5所示)。响应行( response line)包含协议及版本、状态码及描述,并以“rn”
结尾。响应头部( response header)包含若干个属性与属性值,它们通过冒号分隔,格式为“属
性名:属性值”,每个属性-键值对都以“ri”结尾,并且响应头部最后以“rn”结尾。响应
体( response body)一般存放我们真正需要的文本。
响应行
响应头部
响应体
响应行
协议及版本
状态码
描述
响应头部
字段号
值
字段号
值
响应体
响应体的内容
▲图1.5HTTP响应报文
响应状态码由三位数字组成,常用的状态码如下。
200OK:客户端请求成功。
>400 Bad request:客户端请求有语法错误,服务器无法识别。
401 Unauthorized:请求未经授权。
403 Forbidden:服务器收到请求,但拒绝提供服务。
404 Not found:请求资源不存在。
500 Internal Server error:服务器发生不可预期的错误。12套接字通信
≯503 Server Unavailable:服务器当前不能处理客户端的请求,一段时间后可能恢复正常
常用的响应报文头属性如下。
Cache-Control:服务器通过该报文头属性告诉客户端如何对响应的内容进行缓存,例如,
值为max-age=600,则表示客户端对响应内容缓存600秒,在此期间,如果客户端再次访
问该资源,可以直接从客户端缓存中获取内容,不必再向服务器获取。
Location:这个属性用于网页重定向,例如,服务器把重定向的地址添加到响应报文头部
的这个属性,这样客户端浏览器解析报文后就直接重新跳转到这个地址。
Set- Cookie:利用这个属性服务器端可对客户端的 Cookie进行设置。
12套接字通信
套接字通信是应用层与TCPP协议族通信的中间抽象层,它是一组接口。应用层通过调
用这些接口发送和接收数据。一般这种抽象层由操作系统提供或者由JVM自己实现。使用套
接字通信可以简单地实现应用程序在网络上的通信。一台机器上的应用向套接字中写入信息,
另外一台相连的机器能读取到。TCPP协议族中有两种套接字类型,分别是流套接字和数据
报套接字,分别对应TCP协议和UDP协议。一个TCPP套接字由一个互联网地址、一个协
议及一个端口号唯一确定。
如图1.6所示,套接字抽象层位于传输层与应用层之间。增加这一层不但很有必要而
且很有用。它类似于设计模式中的门面模式,用户没必要知道和处理复杂的TCPP协议
族业务逻辑的细节,这时套接字就展现出它的优势了。它把这些复杂的处理过程都隐藏在
套接字接口下面,帮助用户解析组织TCPP协议族报文数据,以符合TCP/P协议族,这
样用户只要简单调用接口即可实现数据的通信操作
用户进程
用户进程
用户进程应用层
套接字抽象层
TCP
UDP
传输层
网络层
链路协议
链路层
▲图1.6套接字通信第1章Web服务器机制
1.2.1单播通信
单播通信是网络节点之间通信方式的一种。单个网络节点与单个网络节点之间的通信就称
为单播通信。它是一种一对一的模式,发送、接收信息只在两者之间进行,同时它也是最常见
的一种通信。如图17所示,你浏览网页访问服务器时发生的通信属于单播通信,报文的发送
与接收发生在你的电脑与网站的服务器之间。
图1.7单播通信
Java提供了JDK库,能方便实现单播通信。
在服务器端实现单播通信的代码如下。
Public class Socketserver
public static void main(String[] args)(
ServerSocket serverSocket null
rY
serverSocket = new ServerSocket(8888)i
Socket socket serversocket accept()i
Dataoutputstream dos new DataOutputstream(socket
getoutputstream())i
DataInputstream dis
new DataInputStream(socket. getInputstream())
System.out. println("服务器接收到客户端的连接请求:"+dis. readmE();
dos. writeuP("接受连接请求,连接成功!");
socket. close(i
serverSocket close()i
s catch (IOException e)(
e. printstackTraceoi
首先,绑定本地888(端口,然后调用 acceptO方法进行阻塞,等待客户端的连接,一旦有
连接到来就创建一个套接字并返回。接着,获取输入输出流,输入流用于获取客户端传输的
数据,而输出流则用来向客户端响应发送数据,处理完后关闭套接字。为了简化代码,这里完
成一次响应后便把 Server Socket关闭。
在客户端实现单播通信的代码如下。1.2套接字通信
public class Socketclient
ublic static void main(String[] args)
Socket socket nulli
try i
socket= new Socket("localhost",8888)
DataOutputstream dos new Dataoutputstream(socket
getoutputstream())氵
DataInputstream dis new DataInputstream (socket. getInputstream (
dos, writeUP("我是客户端,请求连接!");
System. out. println(dis. readUTF())i
socket. close()
3 catch (UnknownHostException e)
e printstackTrace()i
catch (IOException e) i
e printstackTrace()i
服务器端的8888端口已经处于监听状态,客户端如果要与之通信,只须简单地先指定服
务器端IP与端口号以实例化一个套接字,然后获取套接字的输出流与输入流。输出流用于向
服务器发送数据,输入流用于读取服务器发送过来的数据。交互处理完后关闭套接字。
1.2.2组播通信
组播通信是为了优化单播通信某些场景下的不足。例如,一份数据要从某台主机发送到其
余若干台主机上,这时如果还是使用单播通信模式,数据必须依次发送给其他若干台主机。单
播通信的一个特点就是有多少台主机就要发送多少次,当主机的数量越来越大时可能会导致网
络阻塞。此外,这种传送方式效率极低。于是引入了组播通信的概念
如图1.8所示,(a)图为单播通信模式,机器S1向机器S2、S3和S4发送消息时必须发
送三次,且每次都是从S1出发到各自目的地,传输效率低且浪费网络资源;(b)图为组播通
信模式,S1向S2、S3和S4发送消息只须S1发送一次到路由器,连接S2、S3、S4客户端的
路由器将负责向它们发送消息,解决了传输效率低及浪费网络资源的问题。
所以组播通信其实是为了弥补单播通信在某些使用场景的局限性,它是一种一对多的传播方
式。假如某个主机结点想接收相关的信息,它只需要向路由器或交换机申请加入某组即可,路由
器或交换机在接收到相关信息后就会负责向组内所有成员发送信息。组播通信有以下特点:
节省网络资源:
有针对性地向组内成员传播;
可以在互联网上进行传播;
没有可靠传输协议,会导致数据不可靠。第1章Web服务器机制
SI
(a)单播摸式
(b)组播摸式
$2
▲图1.8单播模式与组播模式
组播通信中最重要的内容是如何维护路由器与主机之间的关系,其主要通过IGMP协议进
行维护。它主要维护不同路由器与不同主机之间的成员关系,具体的维护方式比较复杂,因为
涉及多个路由器且路由之间互相连接组成一个树状网络,而组内成员可能处于任何一个路由
中,即树的任何叶结点,所以需要复杂的算法去维护这些关系才知道信息要往哪里发送。IGMP
协议主要负责组成员的加入和退出、组内成员査询等功能,使用组播通信需要通过IGMP协议
申请加入组成员才能接收组播的消息,而退出组后将无法接收消息。
因为组播通信相当于把主机与主机之间的通信压力转嫁到了路由器上面,所以要得到路由及
网络的支持才能进行组播通信,整个传输过程中涉及的路由器或交换杋都要支持组播通信,否则
将无法使用组播通信。另外,你的主机必须支持组播通信,在TCPP层面支持组播发送与接收。
在IP层面需要一个组播地址以指定组播,它称为D类地址,范围是224.0.0.0~
239.2553255.255。这些地址根据范围大致分为局域网地址和因特网地址,22400.0~2440.0255
用于局域网,224.0.10~238.25525255用于因特网。 Tomcat默认的组播地址为2280.04,而
Tomcat为何会涉及组播通信则要归到集群的概念,因为集群涉及内存的共享问题,所以需要
使用组播通信进行数据同步,第20章和第21章将进行更加深入的探讨。
在单播通信模式中有服务器端和客户端之分,而组播通信模式与单播通信模式不同,每个
端都是以路由器或交換机作为中转广播站,任意一端向路由器或交换机发送消息,路由器或交
换机负责发送给其他节点,每个节点都是等同的。
101.2套接字通信
为方便开发者实现组播通信,Java在JDK中提供了 java. net. MulticastSocket类。下面展示
个简单的例子,说明两个节点之间通过组播通信传输消息。
①节点1,指定组播地址为228.0.0.4,端口号为8000。节点1通过调用 MulticastSocket
的 Join group方法申请将节点1加入到组播队伍中,接着使用一个无限循环往组里发“Helo
from nodel”消息,这是为了方便节点2加入后接收节点1的消息。需要说明的是,组播通信
是通过 Datagram Packet对象发送消息的,调用 MulticastSocket的send方法即可把消息发送出
去。为了缩减例子长度,这里省去了退出组及关闭套接字的一些操作,实际使用中须完善
public class Nodel t
private static int port =8000;
private static String address =228.0.0."i
public static void main(String[] args) throws Exception f
try i
InetAddress group InetAddress getByName (address)i
MulticastSocket mss null;
mss new Multicastsocket(port)i
mss. joinGroup(group)i
while (true)(
String message ="Hello from nodel"i
byte[] buffer message getBytes ()i
DatagramPacket dp= new DatagramPacket(buffer, buffer length
group, port)
mss. send (dp)i
Thread. sleep(1000)i
catch (IOException e)(
e printstackTrace()i
②节点2,指定同样的组播地址与端口,以申请加入与节点1相同的组播组。接着通过
循环不断接收从其他节点发送的消息,通过 MulticastSocket的 Receive方法可读取消息,将不
断接收到从节点1发送的消息“ receive from nodel: Hello from node1”。当然,节点2也可以向
组播组发送消息,因为每个节点都是等同的,只要其他节点对组播消息进行接收。如果你还想
增加其他节点,尽管申请加入组播组,所有节点都可以接收、发送消息。
public class Node2 i
private static int port =8000;
private static String address =228.0.0.4"i
public static void main (String[] args) throws Exception t
InetAddress group InetAddress getByName(address)i
Multicastsocket msr null第1章Web服务器机制
try i
msr new Multicastsocket(port)i
msrjoinGroup(group)i
byte [ buffer new byte[1024];
while (true)
DatagramPacket dp= new DatagramPacket(buffer, buffer length)i
msrreceive(dp)i
String s= new String(dp getData(), 0, dp. getLength())i
System. out. println("receive from node1: "+s);
catch (IOException e
eprintstackTrace(
1.2.3广播通信
上一节说到的组播通信是一种一对多的传播方式,同样属于一对多的传播方式的还有广播
通信。它与组播通信又有不同的地方。广播通信的重点在于广,它向路由器连接的所有主机都
发送消息而不管主机想不想要,虽然浪费了网络资源,但它可以不用维护路由器与主机之间的
成员关系。组播通信的重点在于组,它只会向加入了组的所有成员发送消息,具有针对性强、
不浪费网络资源的特点。广播通信只能在局域网内传播,组播通信能在公网内传播。
如图1.9所示,在某局域网内,机器S1向网络中广播消息,网络中其他机器都将接收到
消息。机器S2、S3、S4、S5和S6预先启动进程监听端口,S1将消息发往交换机,交换机负
责将消息广播到这些机器上。
S3
▲图1.9广播通信
121.3服务器模型
Java的JK为我们提供了 java. net. Datagram Socket类以实现广播通信功能。
在接收端,监听88端口,一旦接收到广播消息则输出消息。
public class BroadcastReceiver t
public static void main(String [] args)t
try i
DatagramSocket ds new DatagramSocket(8888)i
byte[] buf= new byte[5];
DatagramPacket dp= new DatagramPacket(buf, buf length)i
ds receive(dp)i
System. out. println(new string(buf))i
i catch (Exception e)(
e printstackTrace()i
在发送端,所属的网段为192.168.0,子网掩码为255.255.255.0,所以广播地址为
192168:0.255,然后往该网络中所有机器的88端口发送“helo”消息,接收端将接收到此
消息。
public class broadcastsender
public static void main(String[] args) i
try i
InetAddress ip= InetAddress getByName(192.168.0.255);
DatagramSocket ds new DatagramSocket ()i
String str =hello";
DatagramPacket dp
new DatagramPacket(str getBytes()
str getBytes().length, ip,8888)i
ds. send(dp)i
ds. closed
i catch (Exception e)i
e printstackTrace()i
13服务器模型
这里探讨的服务器模型主要指的是服务器端对IO的处理模型。从不同维度可以有不同的
分类,本节将从IO的阻塞与非阻塞、ⅠO处理的单线程与多线程角度探讨服务器模型。对于
I/O,可以分成阻塞IO与非阻塞IO两大类型。阻塞IO在做IO读写操作时会使当前线程进
入阻塞状态,而非阻塞IO则不进入阻塞状态。对于线程,单线程情况下由一条线程负责所有
13第1章Web服务器机制
客户端连接的IO操作,而多线程情况下则由若干线程共同处理所有客户端连接的1O操作。
下面将对线程和(非)阻塞组合成的模型进行分析,看看各种服务器模型有哪些不同,各
自的优缺点又有哪些。
1.3.1单线程阻塞O模型
单线程阻塞IO模型是最简单的一种服务器模型,几乎所有程序员在刚开始接触网络编程
时都从这个简单的模型开始。这种模型只能同时处理一个客户端访问,并且在IO操作上是阻
塞的,线程会一直在等待,而不会做其他事情。对于多个客户端访问,必须要等到前一个客户
端访问结束才能进行下一个访问的处理,请求一个一个排队,只提供一问一答服务
图1.10展示了同步阻塞服务器响应客户端访问的时间节点图。首先,服务器必须初始化
个套接字服务器,并绑定某个端口号并使之监听客户端的访问。接着,客户端1调用服务器
的服务,服务器接收到请求后对其进行处理,处理完后写数据回客户端1,整个过程都是在
个线程里面完成的。最后,处理客户端2的请求并写数据回客户端2,期间就算客户端2在服
务器处理完客户端1之前就进行请求,也要等服务器对客户端1响应完后才会对客户端2进行
响应处理。
服务器
客户端1)调用
客户端2
调用
处理客户端1的请求
响应完客户端1的时刻
写数据回客户端1
时间
处理客户端2的请求
响应完客户端2的时刻
写数据回客户端2
时间
▲图1.10单线程阻塞10模型
这种模型的特点在于单线程和阻塞IO。单线程即服务器端只有一个线程处理客户端的所
有请求,客户端连接与服务器端的处理线程比是n:1,它无法同时处理多个连接,只能串行处
理连接。而阻塞IO是指服务器在读写数据时是阻塞的,读取客户端数据时要等待客户端发送
141.3服务器模型
数据并且把操作系统内核复制到用户进程中,这时才解除阻塞状态。写数据回客户端时要等待
用户进程将数据写入内核并发送到客户端后才解除阻塞状态。这种阻塞给网络编程带来了
个问题,服务器必须要等到客户端成功接收才能继续往下处理另外一个客户端的请求,在
此期间线程将无法响应任何客户端请求
该模型的特点:它是最简单的服务器模型,整个运行过程都只有一个线程,只能支持同时
处理一个客户端的请求(如果有多个客户端访问,就必须排队等待),服务器系统资源消耗较
小,但并发能力低,容错能力差。
1.3.2多线程阻塞O模型
针对单线程阻塞IO模型的缺点,我们可以使用多线程对其进行改进,使之能并发地对多
个客户端同时进行响应。多线程模型的核心就是利用多线程机制为每个客户端分配一个线程。
如图1.11所示,服务器端开始监听客户端的访问,假如有两个客户端发送请求过来,服务器
端在接收到客户端请求后分别创建两个线程对它们进行处理,每条线程负责一个客户端连接,
直到响应完成。期间两个线程并发地为各自对应的客户端处理请求,包括读取客户端数据、处
理客户端数据、写数据回客户端等操作。
服务器
客户端1
调用
客户端2
调丿
处理客户端I
的请求
处理客户端2的请求
写数据回客户端1
响应完客户端l的时刻
写数据回客户端2
1······
响应完客户端2的时刻
时间
时间
时间
时间
▲图1.11多线程阻塞|0模型
这种模型的IO操作也是阻塞的,因为每个线程执行到读取或写入操作时都将进入阻塞状
态,直到读取到客户端的数据或数据成功写入客户端后才解除阻塞状态。尽管IO操作阻塞,
但这种模式比单线程处理的性能明显高了,它不用等到第一个请求处理完才处理第二个,而是
并发地处理客户端请求,客户端连接与服务器端处理线程的比例是1:1。
多线程阻塞I○模型的特点:支持对多个客户端并发响应,处理能力得到大幅提高,有较
大的并发量,但服务器系统资源消耗量较大,而且多线程之间会产生线程切换成本,同时拥有第1章Web服务器机制
较复杂的结构
1.3.3单线程非阻塞MO模型
多线程阻塞ⅠO模型通过引入多线程确实提高了服务器端的并发处理能力,但每个连接都需
要一个线程负责IO操作。当连接数量较多时可能导致机器线程数量太多,而这些线程大多数时
间却处于等待状态,造成极大的资源浪费。鉴于多线程阻塞IO模型的缺点,有没有可能用一个
线程就可以维护多个客户端连接并且不会阻塞在读写操作呢?下面介绍单线程非阻塞IO模型。
单线程非阻塞ⅣO模型最重要的一个特点是,在调用读取或写入接口后立即返回,而不会
进入阻塞状态。在探讨单线程非阻塞IO模型前必须要先了解非阻塞情况下套接字事件的检测
机制,因为对于单线程非阻塞模型最重要的事情是检测哪些连接有感兴趣的事件发生。一般会
有如下三种检测方式。
(1)应用程序遍历套接字的事件检测
如图1.12所示,当多个客户端向服务器请求时,服务器端会保存一个套接字连接列表中,
应用层线程对套接字列表轮询尝试读取或写入。对于读取操作,如果成功读取到若干数据,则
对读取到的数据进行处理;如果读取失败,则下一个循环再继续尝试。对于写入操作,先尝试
将数据写入指定的某个套接字,写入失败则下一个循环再继续尝试。
应用层
套接字1
套接字2
套接字3
遍历处理所
有套接字,
尝试读写
!
图1.12非阻塞遍历套接字
这样看来,不管有多少个套接字连接,它们都可以被一个线程管理,一个线程负责遍历这些
套接字列表,不断地尝试读取或写入数据。这很好地利用了阻塞的时间,处理能力得到提升。但
这种模型需要在应用程序中遍历所有的套接字列表,同时需要处理数据的拼接,连接空闲时可能
也会占用较多CPU资源,不适合实际使用。对此改进的方法是使用事件驱动的非阻塞方式。
(2)内核遍历套接字的事件检测
这种方式将套接字的遍历工作交给了操作系统内核,把对套接字遍历的结果组织成一系列
的事件列表并返回应用层处理。对于应用层,它们需要处理的对象就是这些事件,这就是其中
种事件驱动的非阻塞方式的实现。
如图1.13所示,服务器端有多个客户端连接,应用层向内核请求读写事件列表。内核
61.3服务器模型
遍历所有套接字并生成对应的可读列表 readList和可写列表 whiteList, readList标明了每个
套接字是否可读,例如套接字1的值为1,表示可读, socket2的值为0,表示不可读。 whitelist
则标明了每个套接字是否可写。应用层遍历读写事件列表 readlist和 whitelist,做相应的
读写操作
内核层
应用层
麼套接字1
请求读、写事件列表
套接字2
套接字3
read
write
List List
遍历 readList
和 whiteList
处理可读可
写事件
▲图1.13内核遍历套接字的事件检测
内核遍历套接字时已经不用在应用层对所有套接字进行遍历,将遍历工作下移到内核层,
这种方式有助于提高检测效率。然而,它需要将所有连接的可读事件列表和可写事件列表传到
应用层,假如套接字连接数量变大,列表从内核复制到应用层也是不小的开销。另外,当活跃
连接较少时,内核与应用层之间存在很多无效的数据副本,因为它将活跃和不活跃的连接状态
都复制到应用层中。
(3)内核基于回调的事件检测
通过遍历的方式检测套接字是否可读可写是一种效率比较低的方式,不管是在应用层
中遍历还是在内核中遍历。所以需要另外一种机制来优化遍历的方式,那就是回调函数。
内核中的套接字都对应一个回调函数,当客户端往套接字发送数据时,内核从网卡接收数
据后就会调用回调函数,在回调函数中维护事件列表,应用层获取此事件列表即可得到所
有感兴趣的事件
内核基于回调的事件检测方式有两种。第一种是用可读列表 readList和可写列表
whitelist标记读写事件,套接字的数量与 readList和 whiteList两个列表的长度一样, readList
第一个元素标为1则表示套接字1可读,同理, whitelist第二个元素标为1则表示套接字2
可写。如图1.14所示,多个客户端连接服务器端,当客户端发送数据过来时,内核从网卡
复制数据成功后调用回调函数将 readlist第一个元素置为1,应用层发送请求读、写事件列
表,返回内核包含了事件标识的 readList和 whitelist事件列表,进而分表遍历读事件列表
readList和写事件列表 whitelist,,对置为1的元素对应的套接字进行读或写操作。这样就避
免了遍历套接字的操作,但仍然有大量无用的数据(状态为0的元素)从内核复制到应用
层中。于是就有了第二种事件检测方式。
内核基于回调的事件检测方式二如图1.15所示。服务器端有多个客户端套接字连接。首
17第1章Web服务器机制
先,应用层告诉内核每个套接字感兴趣的事件。接着,当客户端发送数据过来时,对应会
有一个回调函数,内核从网卡复制数据成功后即调回调函数将套接字1作为可读事件 event1
加入到事件列表。同样地,内核发现网卡可写时就将套接字2作为可写事件 event2添加到
事件列表中。最后,应用层向内核请求读、写事件列表,内核将包含了 event1和 event2的
事件列表返回应用层,应用层通过遍历事件列表得知套接字1有数据待读取,于是进行读
操作,而套接字2则可以写入数据。
内核层
应用层
请求读、写
套接字
事件列表
套接字2
接字读
可写
read write
List
遍历 readList
可读留
和 whiteList,
圆
处理可读可
写事件
▲图1.14内核基于回调的事件检测方式
告诉内核
内核层
感兴趣的应用层
事件
数据
麼接字1
套接字
套接字3\可读
请求读、写
事件列表
可写
遍历事件
event I
列表并处
even
nt2
理事件对
应套接字
▲图1.15内核基于回调的事件检测方式二
上面两种方式由操作系统内核维护客户端的所有连接并通过回调函数不断更新事件列表,
而应用层线程只要遍历这些事件列表即可知道可读取或可写入的连接,进而对这些连接进行读
写操作,极大提高了检测效率,自然处理能力也更强。
对于Java来说,非阻塞IO的实现完全是基于操作系统内核的非阻塞IO,它将操作系统
的非阻塞IO的差异屏蔽并提供统一的API,让我们不必关心操作系统。JDK会帮我们选择非
阻塞IO的实现方式,例如对于 Linux系统,在支持 epoll I的情况下JDK会优先选择用epol
实现Java的非阻塞IO。这种非阻塞方式的事件检测机制就是效率最高的“内核基于回调的事
件检测”中的第二种方式。
在了解了非阻塞模式下的事件检测方式后,重新回到对单线程非阻塞IO模型的讨论。虽
181.3服务器模型
然只有一个线程,但是它通过把非阻塞读写操作与上面几种检测机制配合就可以实现对多个连
接的及时处理,而不会因为某个连接的阻塞操作导致其他连接无法处理。在客户端连接大多数
都保持活跃的情况下,这个线程会一直循环处理这些连接,它很好地利用了阻塞的时间,大大
提高了这个线程的执行效率。
单线程非阻塞IO模型的主要优势体现在对多个连接的管理,一般在同时需要处理多个连
接的发场景中会使用非阻塞NO模式,此模型下只通过一个线程去维护和处理连接,这样大
大提高了机器的效率。一般服务器端才会使用NIO模式,而对于客户端,出于方便及习惯,
可使用阻塞模式的套接字进行通信。
1.3.4多线程非阻塞O模型
单线程非阻塞IO模型已经大大提高了机器的效率,而在多核的机器上可以通过多线程继
续提高机器效率。最朴实、最自然的做法就是将客户端连接按组分配给若干线程,每个线程负
责处理对应组内的连接。如图1.16所示,有4个客户端访问服务器,服务器将套接字1和套
接字2交由线程1管理,而线程2则管理套接字3和套接字4,通过事件检测及非阻塞读写就
可以让每个线程都能高效处理。
应用层
套接字卜线程管理
套接字2套接字1和
→
套接字2
套接字3
线程2管理
套接字4
套接字3和
套接字4
▲图1.16多线程非阻塞|/0模型
最经典的多线程非阻塞IO模型方式是 Reactor模式。首先看单线程下的 Reactor, Reactor
将服务器端的整个处理过程分成若干个事件,例如分为接收事件、读事件、写事件、执行事件
等。 Reactor通过事件检测机制将这些事件分发给不同处理器去处理。如图1.17所示,若干客
户端连接访问服务器端, Reactor负责检测各种事件并分发到处理器,这些处理器包括接收连
接的 accept处理器、读数据的read处理器、写数据的 write处理器以及执行逻辑的 process处
理器。在整个过程中只要有待处理的事件存在,即可以让 Reactor线程不断往下执行,而不会
阻塞在某处,所以处理效率很高。
基于单线程 Reactor模型,根据实际使用场景,把它改进成多线程模式。常见的有两种方
式:一种是在耗时的 process处理器中引入多线程,如使用线程池;另一种是直接使用多个
Reactor实例,每个 Reactor实例对应一个线程。
19第1章Web服务器机制
accept
客户端
Reactor
处理器
rea
处理器
客户端
分发
write
处理器
客户端
proces
处理器
▲图1.17 Reactor模式
Reactor模式的一种改进方式如图1.18所示。其整体结构基本上与单线程的 Reactor类
似,只是引入了一个线程池。由于对连接的接收、对数据的读取和对数据的写入等操作基
本上都耗时较少,因此把它们都放到 Reactor线程中处理。然而,对于逻辑处理可能比较
耗时的工作,可以在 process处理器中引入线程池, process处理器自己不执行任务,而是
交给线程池,从而在 Reactor线程中避免了耗时的操作。将耗时的操作转移到线程池中后
尽管 Reactor只有一个线程,它也能保证 Reactor的高效。
acce
客户端
Reactor
处理器
rea
处理器
客户端
分发
A write
处理器
线程池
process
处理器
▲图1.18 Reactor模式改进
Reactor模式的另一种改进方式如图1.19所示。其中有多个 Reactor实例,每个 Reactor
实例对应一个线程。因为接收事件是相对于服务器端而言的,所以客户端的连接接收工作统
由一个 accept处理器负责, accept处理器会将接收的客户端连接均匀分配给所有 Reactor
实例,每个 Reactor实例负责处理分配到该 Reactor上的客户端连接,包括连接的读数据、写
数据和逻辑处理。这就是多 Reactor实例的原理。
多线程非阻塞IO模式让服务器端处理能力得到很大提高,它充分利用机器的CPU,适合
用于处理高并发的场景,但它也让程序更复杂,更容易出现问题。1.3服务器模型
Reactor
处理器
客户
write
分发
处理器
客户端
处理器
处理器
Reactor
客启
处理器
分发
处理器
客户端
rocess
处理器
图1.19 Reactor模式改进二
21第2章 Servlet规范
Java体系的web服务器基本上都会遵循Servlet规范,该规范描述了HTTP请求及响应处
理过程相关的对象及其作用。 Tomcat其实可以看成一个 Servlet容器,所以它也需要遵守 Servlet
规范。为了方便深入剖析 Tomcat,本章将介绍 Servlet规范主要的一些对象。
21 Servlet接口
Servlet规范的核心接口即是 Servlet接口,它是所有 Servlet类必须实现的接口。在Java
Servelt api中已经提供了两个抽象类方便开发者实现 Servlet类,分别是 Generic Servlet和
Httpservlet, GenericServlet定义了一个通用的、协议无关的 Servlet,而 Httpservlet则定义了
HTTP的Servlet,这两个抽象类可以使Servlet类复用很多共性功能。
Servlet接口的核心方法为 service方法,它是处理客户端请求的方法,客户端发起的请求
会被路由到对应的Servlet对象上。前面说到的Httpservlet类的service方法把对HTTP协议的
GET、POST、PUT、 DELETE、HEAD、 OPTIONS、 TRACE等请求转发到各自的处理方法中,
即 doGet、 doPost、 doNut、 doDelete、 tohead、 dooptions、 do trace等方法。 Httpservlet提供了
这些共性的处理逻辑,其他继承它的类就不用再各自实现,只需要在对应的方法中做具体的处
理逻辑即可。例如我们做Web开发时常常会自己定义一个 Servlet,并在 doGet和 doPost方法
中做业务逻辑处理。
般来说,在 Servlet容器中,每个 Servlet类只能对应一个 Servlet对象,所有请求都由同
个 Servlet对象处理,但如果 Servlet实现了 SingleThreadModel接口则可能会在Web容器中
存在多个 Servlet对象。对于Web容器来说,实现了 Single ThreadModel接口意味着一个 Servlet
对象对应着一个线程,所以此时 Servlet的成员变量不存在线程安全问题。
Servlet的生命周期主要包括加载实例化、初始化、处理客户端请求、销毁。加载实例化
主要由web容器完成,而其他三个阶段则对应 Servlet的init、 service和 destroy方法。 Servlet
对象被创建后需要对其进行初始化操作,初始化工作可以放在以 ServletConfig类型为参数的
in方法中, Servlet Config为 web. xml配置文件中配置的对应的初始化参数,由Web容器完成
web. xml配置读取并封装成 Servlet Config对象。当 Servlet初始化完成后,开始接受客户端的
请求,这些请求被封装成 ServletRequest类型的请求对象和 Servletresponse类型的响应对象,2.3 ServletContext接口
通过 service方法处理请求并响应客户端。当一个 Servlet需要从Web容器中移除时,就会调用
对应的 destroy方法以释放所有的资源,并且调用 destroy方法之前要保证所有正在执行 service
方法的线程都完成执行。
228 servletRequest接囗
ServletRequest接口的实现类封装了客户端请求的所有信息,如果使用HTTP协议通信则
包括HTTP的请求行和请求头部。HTTP对应的请求对象类型是HttpServletrequest类。
Servletrequest接口的实现类中的信息包括以下几部分。
一些HTTP请求头部的获取方法,如getHeader、getHeaders和getHeaderNames
些获取请求路径的方法,如 get ContextPath、 getServletPath和 getPathInfo,对于路径变量,
其中 requestOR= contextPath+servlet Path+ pathInfo,而 getRealPath方法则是获取某个相对路
径对应的文件系统路径。
获取 Cookie的方法,如 getCookies方法:提供了判断标识是否为 Https的方法,如 inSecure
方法。
获取客户端语言环境的方法,如getLocale和getLocales,它们对应HTTP的Accept-Language
头部。
获取客户端编码的方法,如getCharacterEncoding,对应HTTP协议的Content-Type头部。
ServletRequest接口的对象只在 Servlet的 service方法或过滤器的 doFilter方法作用域内有
效,除非启用了异步处理以调用 ServletRequest接口对象的 startAsync方法,此时 request对象
会一直有效,直到调用 Async Context的 complete方法。另外,web容器通常会出于性能原因
而不销毁 ServletRequest接口的对象,而是重复利用 ServletRequest接口对象。
23 Servletcontext接口
Servletcontext接口定义了运行所有 Servlet的Web应用的视图。其提供的内容包括以下几
个部分。
某个web应用的 Servlet全局存储空间,某Web应用对应的所有 Servlet共有的各种资源和
功能的访问。
获取Web应用的部署描述配置文件的方法,例如 getInitParameter和 getInitParameterNames。
添加 Servlet到 Servletcontext里面的方法,例如 addServlet
添加 Filter(过滤器)到 Servletcontext里面的方法,例如 addFilter o
添加 Listener(监听器)到 Servletcontext里面的方法,例如 addListener
全局的属性保存和获取功能,例如 setAttribute, getAttribute, getAttribute Names和
remove Attribute等。
23第2章 Servlet规范
访问Web应用静态内容的方法,例如 getResource和 getResourceAsStream,以路径作为参
数进行查询,此参数要以“”开头,相对于Web应用上下文的根或相对于Web应用
WEB-INF/ib目录下jar包的META- Nf/resources
所有 Servlet及它们使用的类需要由一个单独的类加载器加载。每个实现 Servletcontext
接口的对象都需要一个临时存储目录, Servlet容器必须为每个 Servletcontext分配一个临时目
录,并可在 Servletcontext接口中通过 javax. servlet context. tempdir属性获取该目录。
24 ServletResponse接囗
ServletResponse接口的对象封装了服务器要返回客户端的所有信息。如果使用HTTP,则
包含了HTTP的响应行、响应头部和响应体。
为了提高效率,一般 Servletresponse接口对响应提供了输出缓冲。其中, getBuffer Size
用于获取缓冲区大小; set BufferSize用于设置缓冲区大小; flush Buffer强制刷新缓冲区;
reset Buffer将清空缓冲区中的内容,但不清空请求头部和状态码; is Committed判断是否有任
何响应字节已经返回给客户端; reset清空缓冲区内容,同时清空头部信息和状态码。
ServletResponse接口对应HTTP的实现对象为HttpservletrEsponse,可以通过setheader
和 addHeader方法向 HttpservletrEsponse中添加头部;可以通过 send Redirect将客户端重定向
到另外一个地址;可以通过 senderror将错误信息输出到客户端。
当 ServletResponse接口关闭时,缓冲区中的内容必须立即刷新到客户端, ServletResponse
接口只在 Servlet的 service方法或过滤器的 do Filter方法的作用域内有效,除非它关联的
ServletResponse接口调用了 startAsync方法启用异步处理,此时 Servletresponse接口会一直有
效,直到调用 Async Context的 complete方法。另外,Web容器通常会出于性能原因而不销毁
ServletResponse接口对象,而是重复利用 Servletresponse接口对象。
25Fer接口
Filter接口允许Web容器对请求和响应做统一处理。例如,统一改变HTTP请求内容和响
应内容,它可以作用于某个 Servlet或一组 Servlet
web应用部署完成后,必须实例化过滤器并调用其init方法。当请求进来时,获取第一个
过滤器并调用 do filter方法,接着传入 Servletrequest对象、 ServletResponse对象及过滤器链
( Filter Chain), doFilter方法负责过滤器链中下一个实体的 dofilter方法调用。当容器要移除某
过滤器时必须先调用过滤器的 destroy方法。
可以用“@ a Web Filter”注解或部署描述文件定义过滤器,XML配置形式使用< filter>元素
定义,包括< filter-name>、< filter-class>和<init- params>子节点,并使用< filter-mapping>定义
Web应用的 Servlet和其他静态资源通过过滤器。
242.7注解
26会话
Servlet没有提出协议无关的会话规定,而是每个通信协议自己规定,HTTP对应的会话接
口是 Http Session Cookie是常用的会话跟踪机制,其中 Cookie的标准名字必须为 JSESSIONID
另外一种会话跟踪机制则是URL重写,即在URL后面添加一个 jsessionid参数,当支持 Cookie
和SSL会话的情况下,不应该使用URL重写作为会话跟踪机制。
会话ID通过调用 Http sessioN. getido获取,且能在创建后通过调用 Http Servletrequest
change Sessionldo改变。 Httpsession对象必须限定在 Servletcontext级别,会话里面的属性不能
在不同 Servletcontext之间共享。
Servlet可将某对象以键值对形式保存到 Httpsession中,处于同一个 Servletcontext和相同
会话中的任意 Servlet都可以使用会话中保存的对象。如果某些对象想要在保存到会话或从会
话中移除时得到通知,可以让某个对象实现 Http sessionBinding Listener接口,里面的 value Bound
和 valueUnbound分别会在对应时刻触发
Servlet容器默认会话的超时时间,可以通过 Http Session的 getMaxInactivelnterval方法获
取和 setMaxInactiveInterval方法设置。
分布式环境中,会话的所有请求在同一时间必须仅被一个JM处理,分布式容器迁移会
话时会通知实现了 Httpsession Activationlistener接口的所有会话属性。
27注解
Web应用中,使用了注解的类只有被放到WEB-NF/ classes目录中或WEB-INF/ib目录下
的jar中,注解才会被Web容器处理。web.xml配置文件的< web-ap元素的 metadata-complete
默认为 false,这表示web容器必须检査类的注解和 Web Fragment,否则忽略注解和web
Fragment。下面介绍几个注解。
WebServlet注解用于在Web项目中定义 Servlet,,它必须指定 urlPatterns或 value属性,默认
的name属性为完全限定类名,@WebServlet注解的类必须继承javax.servlet.httpHttpservleT类。
@WebFilter注解用于在web项目定义 Filter,它必须指定 urlPatterns、 ervletnames或 value属
性,默认的 filter Name属性为完全限定类名,使用@ WebFilter注解的类必须实现 javax. servlet Filter
WebInitParam注解用于指定传递到 Servlet或 Filter的初始化参数,它是 WebServlet和
Web Filter注解的一个属性。
@WebListener注解用于定义Web应用的各种监听器,使用@ Weblistener注解的类必须实
现以下接口中的一个:
javax servlet Servlet ContextListener
javax servlet. ServletContextAttribute Listener第2章 Servlet规范
javax servlet. ServletRequestListener
javax servlet. ServletRequestAttributeListener
javax.servlethttpHttpsessionlIstener
javax.servlet.httpHttpSessionattributelistEner
javax.servlet.httpHttpSessionidlistener;
@ Multipart Config注解用于指定 Servlet请求期望的是mime/ multipart类型。
28可插拔性
为了给Web开发人员提供更好的可插拔性和更少的配置,可以在一个库类或框架jar包的
META-INF目录中指定 Web Fragment,即web- fragment.xml配置文件,它可以看成Web的逻
辑分区, web-fragment. xml与 web. xm1包含的元素基本上都相同。部署期间,Web容器会扫描
WEB-INF/ib目录下jar包的META-lNF/web- fragment. xml文件,并根据配置文件生成对应的
组件。
一个Web应用可能会有一个 web. xm和若干个 web-fragment. xml文件,web容器加载时
会涉及顺序问题。有两种方式定义它们加载的顺序:绝对顺序, web. xml中的< absolute- ordering
元素用于描述加载资源的顺序;相对顺序, web-fragment. xml中的< ordering>元素用于描述
web- fragment. xml之间的顺序。
29请求分发器
请求分发器负责把请求转发给另外一个 Servlet处理,或在响应中包含另外一个 Servlet的输出,
RequestDispatcher接口提供了此实现机制。用户可以通过 Servletcontext的 getRequestDispatcher方
法和 getNamedDispatcher方法分别以路径或 Servlet名称作为参数获取对应 Servlet的
RequestDispatcher
请求分发器有 include和 forward两个方法。 include方法是将目标 Servlet包含到当前的
Servlet中,主控制权在当前 Servlet上。 forward方法是将当前 Servlet的请求转移到目标 Servlet
上,主控权在目标 Servlet上,当前 Servlet的执行终止。
210Wh应用
Web应用和 ServletContext接口对象是一对一的关系, Servletcontext对象提供了一个
Servlet和它的应用程序视图。Web应用可能包括 Servlet、JSP、工具类、静态文件、客户端Java
Applet等。Web应用结构包括 WEB-INF/web, xml文件、WEB- -INF/lib/目录下存放的所有jar包、
WEB-INF/ classes/目录中存放的所有类、 META-INF目录存放的项目的一些信息,以及其他根
262.11 Servlet映射
据具体目录存放的资源。一般WEB-INF目录下的文件都不能由容器直接提供给客户端访问,
但 WEB-INF目录中的内容可以通过 Servlet代码调用 ServletContext的 getResource和
getResourceAsStream方法来访问,并可使用 RequestDispatcher调用公开这些内容。
Web容器用于加载WAR文件中 Servlet的类加载器必须提供 getResource方法,以加载
WAR文件的JAR包中包含的任何资源。容器不允许wWeb应用程序覆盖或访问容器的实现
类。一个类加载器的实现必须保证部署到容器的每个Web应用,在调用 Thread. current Thread
getContextClassloaderO时返回一个规定的 Classloader实例。部署的每个Web应用程序的
Classloader实例必须是一个单独的实例。
服务器应该能在不重启Web容器的情况下更新一个Web应用程序,而更新Web应用程序
时Web容器应该提供可靠的方法保存这些web应用的会话
如果调用 response的 senderror方法或如果 Servlet产生一个异常或把错误传播给容器,容
器要按照web应用部署描述文件中定义的错误页面列表,根据状态码或异常试图返回一个匹
配的错误页面。如果Web应用部署描述文件的 error-page元素没有包含 exception-type或
error-code子元素,则错误页面使用默认的错误页面。
Web应用的部署描述符中可以配置欢迎文件列表。当一个Web的请求UR没有映射到一个Web
资源时,可以从欢迎文件列表中按顺序匹配适合的资源返回给客户端,如欢迎页为 index html,则
htp:/caos:8080 webapps请求实际变为htp:/ localhost:8080/ webapp/index. html如果找不到对应的
欢迎页,则返回404响应。
当一个Web应用程序部署到容器中时,在web应用程序开始处理客户端请求之前,必须
按照下述步骤顺序执行。
①实例化部署描述文件中< listener>元素标识的每个事件监听器的一个实例。
②对于已实例化且实现了 ServletcontextListener接口的监听器实例,调用 contextlnitializedo
方法。
③实例化部署描述文件中< filter>元素标识的每个过滤器的一个实例,并调用每个过滤器
实例的init0方法。
④根据load-on- startup元素值定义的顺序,包含<oad-on- startup>元素的< servlet>元素为
每个 Servlet实例化一个实例,并调用每个 Servlet实例的inO方法。
对于不包含任何 Servlet、 Filter或 Listener的Web应用,或使用注解声明的web应用,可
以不需要 web. xml部署描述符
21 Servlet映射
对于请求的URL,web容器根据最长的上下文路径匹配请求URL,然后匹配 Servlet, Servlet
的路径是从整个请求URL中减去上下文和路径参数。匹配规则如下:
web容器尝试匹配一个精确的 Servlet路径,如果匹配成功,则选择该 Servlet o
27第2章 Servlet规范
Web容器递归尝试匹配最长的路径前缀。
如果URL最后包含扩展名,例如jsp,Web容器将试图匹配一个专门用于处理此扩展名的
Servlet。
如果前三个规则都不匹配,则匹配一个默认的 Servlet
212部署描述文件
所有 Servlet容器的web应用程序部署描述文件需要支持以下类型的配置和部署信息:
Servletcontext初始化参数;
Session配置;
Servlet声明
Servlet映射;
应用程序生命周期监听器类
过滤器定义和过滤器映射;
MME类型映射;
欢迎文件列表
错误页面;
语言环境和编码映射;
>安全配置(包括 login-config、 security-constraint、 security-constraint、 security-role-ref和 Irun-as)。
28第3章 Tomcat的启动与关闭
31T0mea的批处理
Tomcat的启动和关闭批处理脚本放在安装目录的bn子目录里,其中不仅包含了 Windows
系统的bat文件,同时还包含了UNIX/inux的 shell文件。这里就以开发时常用的 Windows
系统为例讲解 Tomcat的启动命令。
3.1.1 startup. bat
从文件命名上看,就知道 startup.bat是一个启动批处理脚本,它的主要功能就是找到另一个批
处理脚本 catalina. bat,并且执行 catalina. bat,所以,将整个 startup. bat的内容分成两部分讲解。
startup.bat脚本的第一部分如下所示。
if ngOs "=="Windows nt setlocal
set CUrRent dir=ocd
if not CATALINA HOME"== goto gotHome
set cATALINA hOMe=% CURRENT DIR%'
if exist "%CATALINA HOME%\bin\catalina. bat" goto okHome
set cATAlINA HOMe=cd
cd"各 URRENT D工R8"
gotHome
if exist "8CATALINA HOME bin\catalina. bat" goto okHome
echo The CATALINA HOME environment variable is not defined correctly
echo This environment variable is needed to run this program
goto end
okHome
set "EXECutABle=CATALINA HOME\bin\catalina. bat
if exist "gEXECUTABLE" goto okExec
goto end
okExec
开始先用if"%oS%"==" Windows nt" setlocal判断系统是否为 Windows nt,如果是,第3章 Tomcat的启动与关闭
则使用 setlocal命令。此命令表示之后所有对环境变量的改变只限于该批处理文件。要还原原先的
设置,可以执行 endlocal,如果未显式执行,则会在批处理的最后自动隐式执行 endlocal命令。
接下来,设置 CATALINA HOME环境变量,并最终确定 catalina.bat的路径。图3.1展示
了 CATALINA HOME变量值确定的逻辑
/
设置 CURRENT DIR
变量,值为当前目录
%CATALINA HOME
CATALINA HOME=
%是否为空?
是
%CURRENT DIR%O
%CATALINA HOMEOO
否
CATALINA HOME=
\bin\catalina. bat
当前目录的上一级目录
是否存在?
否
是
DoCATALINA HOME%
\bin\catalina bat
否
是否存在?
确定 CATALINA HOME
是
找不到
环境变量的值
CATALINA HOME
环境变量并结束执行
▲图3.1 CATALINA HOME变量值确定的逻辑
如果环境变量设置了 CATALINA HOME,则直接使用环境变量设置的值作为 Tomcat安
装目录。假如未设置环境变量 CATALINA HOME,则以当前目录作为 CATALINA HOME。
此时,如果% CATALINA HOMES% bin catalina.bat存在,则批处理或命令行当前目录作为
CATALINA HOME。假如% CATALINA HOME% abin \catalina. bat不存在,则把当前目录的上
级目录作为 CATALINA HOME,然后再判断% CATALⅠ NA HOME% binicatalina.bat是否存
在。如果存在,则上一级目录就是 CATALINA HOME:;否则,提示找不到 CATALINA HOME
环境变量并结束执行。
确定了 CATALⅠ NA HOME的值即已经确定了 catalina. bat。接下来接收参数,在启动时经
常会附带一些命令参数。 startup.bat通过以下程序完成对参数的收集。
set CMD LINE ARGS=
retArds
if 1==l" goto donesetArgs
set CMD LIne_ARGS=8 CMD LINE ARGS号1∥将参数组成一行,接在后面
shift
goto setArgs
303.1 Tomcat的批处理
donesetArgs
Ca11"各 EXECUTABLE8" start各 CMD LINE ARGS各
end
首先判断第一个参数是否为空,为空则表示没有参数,直接跳到 done SetArgs位置。如果
第一个参数不为空,则把第一个参数赋给 CMD LINE ARGS。shit命令的作用是把参数前移
一位,这时%1代表的就是原来的第二个参数, shift然后又跳到 setArgs位置,此时判断的是
第二个参数,如果不为空,则把参数追加到 CMD LINE ARGS后面。以此类推,把参数一个
个前移,直到%1为空,则表示全部参数都已经收集完。
call"% EXECUTABLE%" start%CMDLⅠ NE ARGS%,这条命令以刚刚收集的所有参数
CMD LINE ARGS作为参数,调用并执行 catalina, bat批处理脚本
3.1.2 shutdown. bat
以下关闭脚本 shutdown.bat的内容与启动脚本 startup.bat的内容基本一样,其执行顺序也
是先找到另一个批处理脚本 catalina. bat的路径,然后执行 catalina.bat。不同的是,执行
catalina. bat时传入的参数不同,如启动时传入的参数为 start,而关闭时传入的参数为stop,相
关脚本为call"% EXECUTABlE%"stop% CMD LINE ARGS%。
set CMD LINE ARGs
setArgs
if 1== goto doneSetArgs
set CMD LINE args=%CMD LINE ARGs 21
shift
goto setArgs
:donesetArg
call EXeCUTaBLE" stop %CMD_LINE_ ARGS o
end
3.1.3 catalina. bat
catalina bat批处理脚本才是 Tomcat服务器启动和关闭的核心脚本,它的最终目的是组合
出一个最终的执行命令,组合时会涉及多个变量和组合逻辑。本节将详细讲解这个批处理脚本
的逻辑,由于命令较多,会分成7部分进行讲解。
第一部分脚本如下所示,它主要目的是在按CtH+C组合键终止程序时自动确认。当执行
catalina bat run命令时开始启动 Tomcat,然后如果按Ctrl+C组合键则会终止进程,而且命令窗
口还会输出“终止批处理操作吗(YN)?”让用户确认,而这里做的就是帮你自动输入Y。
1 if not 81== run" goto mainEntry
2 if TEMP"== goto mainEntry
3 if exist "TEMP%\nxO run" goto mainEntry
4 echo Y>"TEMP.nxO run"
31第3章 Tomcat的启动与关闭
5 if not exist "TEMP%\nxO run" goto mainEntry
6 echo Y>"TEMP\%nxOY"
7ca11"8~f0"号*<"8TEMP%\8~nx0.Y
8 set RetVal= %ERRoRLeVEL.
9 del /Q"gTEMP.\%nxO Y">NUL 2>&1
10exit/ b oRETVAL各
11 mainEntry
12 del /Q"TEMP.\%"nxO run">NUL 2>61
第1行中,如果%1(即第一个参数)不等于run,则直接跳到 main Entry,使用两个双引
号是为了防止参数中带有空格。
第2行中,如果TEMP环境变量为空,则直接跳到 mainEntry。
第3行中,如果TEMP环境变量目录下存在 catalina. bat. run文件,则直接跳到 main Entry。
第4行把字母Y输入 catalina. bat,run文件中。
第5行中,如果不存在 catalina. bat. run文件,则跳到 mainEntry。
第6行将字母Y输入到 catalina.batY文件中。
第7行以 catalina bat.Y作为输入执行当前批处理脚本,%*表示所有的参数。
第8行把上面执行后的% ERRORLEVEL%变量赋值给 RETVAL,如果执行过程出现问题
则赋予它非零值
第9行删除 catalina.batY文件,并且不输出执行结果,另外,把标准错误输岀 STDERR
重定向到标准输出 STDOUT。
第10行退出当前批处理脚本,并把 RETVAL变量作为返回值。
第二部分脚本主要用于设置 CATALⅠ NA HOME、 CATALINA BASE两个变量。
set CURRenT diR=cd%
if not CATALINA_ HOME"== goto gotHome
set"catalina home= CUrRenT diro
if exist "%CATALINA_ HOME\bin\catalina. bat" goto okHome
set CATALINA HOME=cd%
cd "%CURRENT DIR%"
gotHome
if exist "CATALINA HOME\bin\catalina. bat" goto okHome
goto end
okHome
if not" CATALINA BASE号
goto gotBase
set caTAlina base=%CATALINA HOME
gotBase
首先设置 CATALINA HOME环境变量,该部分的逻辑和 startup. bat的一样,但这里为什
么还要进行一次 CATALINA HOME环境变量的设置呢?简单地说,是为了支持用户直接运行
323.1 Tomcat的批处理
catalina, bat,而非通过 startup.bat运行。接着设置 CATALINA_BASE环境变量,这里直接把
CATALINA HOME的值赋给它。
第三部分脚本主要用于尝试寻找 setenv bat和 setclasspath bat并执行它们,然后再将 Tomcat
的启动包 bootstrap jar和日志包 tomcat-juli jar添加到 CLASSPATH环境变量下。
set CLASSPATH=
if not exist "%CATALINA_ BASE \bin\setenv bat" goto checkSetenvHome
call "%CATALINA BASE\bin\setenv. bat"
goto setenvDone
checksetenyhome
if exist "CATALINA HOME%bin\setenv bat" call "%CATALINA HOME bin\setenv. bat
setenvDone
if exist "CATALINA HOME bin\setclasspath bat goto okSetclasspath
goto end
okSetclasspath
call "CATALINA_HOME\bin\setclasspath bat"1
if errorlevel 1 goto end
if "CLASSPATH%"== goto emptyClasspath
set CLASSPATH=%ClASSPATH%;
:emptyClasspath
set" CLASSPATH=8 CLASSPATH号号 CATAL工NA_HOME号\bin\ bootstrap,jar"
if not CATALINA_ TMPDIR%"== goto gotTmpdir
set" CATALINA TMPDIR=号 CATALINA BASE号temp"
: gotTmpdir
if not exist "%CATALINA_BASEbin\tomcat-julijar" goto juliclasspathHome
set ClASSPATH=%CLASSPATH%; CATALINA_ BASE \bin\tomcat-julijar
goto juliclasspathDone
juliclasspathHome
set "CLASSPATH=%CLASSPATH%i CATALINA_HOME%\bin\tomcat-julijar
juliclasspathDone
这里的逻辑比较清晰。首先,把 CLASSPATH设为空,判断% CATALⅠ NA BASE%bin目
录下是否存在 setenv.bat,如果存在则调用此批处理文件,否则判断% CATALINA HOME%bin
目录下是否存在 setenv. bat,如存在则执行。然后,继续判断是否存在% CATALINA HOME%
bin\setclasspath.bat文件,如果不存在则直接跳到结尾,这表明 setclasspath.bat是必要的批处理
脚本。接着,执行 setclasspath bat脚本,%1表示参数。 if errorlevel 1 goto end表示执行到此处
时如果错误值大于等于1,则直接跳到结尾,如果没有错误,则继续往下,判断环境变量
% CLASSPATH%是否为空,不为空则把 CLASSPATH设置为% CLASSPATH%并加上分号。此
后把% CATALINA HOME% \\ bootstrap jar加入到 classpath中,这个包是 Tomcat的核心包
接着,设置临时目录temp,追加 tomcat-juli jar包到 classpath中,逻辑是先从% CATALINA
BASE%bin目录下找,如果找不到,再去% CATALINA HOME%bin目录下找。 tomcat-juli jar
这个包主要包含了 Tomcat系统日志处理类。
33第3章 Tomcat的启动与关闭
第四部分是对日志配置的设置。
if not"号 LOGGING CONFIG各
goto noJuliConfig
set LOGGING CONFIG=-Dnop
if not exist "%CATALINA_BASE\conf\logging properties"goto noJuliconfig
set LOGGING_ CONFIG=-Djava util logging. config file="%CATALINA_BASE%\conf\log
ging properties
:noJuliconfig
set jAva opts=%JAVA opts % LOGGING CONFIGo
if not LOGGING_ MANAGER"== goto noJuliManager
set LOGGING_MANAGER=-Djavautil logging. manager=org. apache. juli ClassLoader
ogManager
noJuliManager
set jAvA opts=JAVa opts LOGGING MANAGER.
Tomcat中的日志实现使用jdk自带的日志工具。其中主要有两项属性可以配置,分别为
java util. logging. config file Fl java util. logging. manager
为了设置 LOGGING CONFIG,首先,要判断环境变量是否存在 LOGGING CONFIG,若
存在,即直接使用,否则把 LOGGING CONFIG设为-Dnop。接着,判断是否存在% CATALINA
BASE% \conf\logging properties,如果存在,则又把 LOGGING CONFIG设为- Djava. util.logging
config file=%CATALINA BASE%\ conf\logging properties
为了设置 LOGGING MANAGER,要判断环境变量是否存在 LOGGING MANAGER,若
存在,即直接使用,否则把 LOGGING MANAGER设为 Djava util. logging. manager= org. apache
juli. ClassLoaderLog Manager
第五部分是执行命令前一些参数的初始化。
set execjava= ruNJAvA%
set MAINCLASS=org. apache. catalina. startup Bootstrap
set ACTIoN=start
set SECURITY POLICY FIle
set DEBUG OPTs=
set PDA=
if not l==]pda" goto noJpda
set JPDA=]pda
if not % JPDA_ TRANSPORT"==" goto gotJpdaTransport
set JPDA TRANS PORT=dt socket
gotJpdaTransport
f not JPDA_ ADDRESS"== goto gotJpdaAddress
set JPDA ADDRESS=8000
gotjpdaAddress
if not hJPDA SUSPEND
goto gotJpdaSuspend
set jPDA SUSPEND=n
gotUpda Suspend
343.1 Tomcat的批处理
if not "JPDA OPTS"==goto gotJpdaopts
set JPDA_OPTS=-agentlib: jdwp=transport=%JPDA_TRANSPORT%, address=%JPDA_ADDRES
S%, server=y, suspend=%JPDA_SUSPEND%
gotJpdaopts
shift
noNda
把% RUNJAVA%变量赋给 EXECJAVA,% RUNJAⅥA%变量在 setclasspath bat脚本中已
经被设置为% OJRE HOME% \ java,设置 MAINCLASS为 Tomcat的启动类org. apache.
catalina. startup. Bootstrap,设置 ACTION为 start,其他变量先不初始化。如果第一个参数为jpda,
则把PDA变量设为值jpda,jpda即是Java平台调试体系结构,它可以提供很方便的远程调
试。如果 JPDA TRANSPORT变量为空,则把它设置为 dt socket。如果JPDA_ ADDRESS变
量为空,则把它设置为8000。如果JPDA_ SUSPEND变量为空,则把它设置为n。如果JPDA
OPTS变量为空,则把它设置为- agentlib: jdwp- transport=% OJPDA TRANSPORT%, address=
% JPDA ADDRESS%, server=y, suspend=% JPDA SUSPEND%。最后用了一个 shift,把参数前
移一位。这段脚本主要初始化JPDA启动命令项,把JDWP代理加载到应用程序的JVM中。
第六部分命令主要根据不同的参数跳转到不同的位置执行不同的命令,其实也组装一些参
数,为下一步真正执行命令做准备。
if "1"==""debug"n goto doDebug
if ""1"==""run" goto doRun
if 1"==""start"n goto dostart
if 1=="stop""goto doStop
if 1"==""configtest" goto doConfigrest
if l==version" goto doversion
doDebug
shift
set eXecuava= RUNUDB.
set DEBUG OPTS=-sourcepath "CATALINA_ HOME%\.\. ava"
if not "1""=="-security'n goto exec Cmd
shift
set "SECURITY POLICY FILE- CATALINA BASE\conf\catalina. policy
goto exec Cmd
doran
shift
if not "1" ==-securityn goto execCmd
shift
set "SECURITY POLICY FILE=%CATALINA BASE\conf\catalina. policy
goto execCmd
dostart
shift
if not oS%
"Windows NT" goto noTtle
if title = set TITlE=Tomcat
35第3章 Tomcat的启动与关闭
set EXECUAVA= start"% TITLE8"号 RUNJAVA各
goto gotTitle
nottle
set EXeCjava-start o runjavaO
gotTitle
if not 81 ==" -security goto execCmd
shift
set "SECURITY- POLICY_FILE=% CATALINA_BASE\conf\catalina. policy
goto execcmd
dostop
shift
set ACTION=stop
set CATALINA OPTS=
goto execCmd
doConfigTest
shift
set ACTIoN=configtest
set CATAL工 NA OPTS
goto execCmd
diversion
8_EXECJAVA8 -classpath "%CATALINA_HOME\lib\catalina. jar" org. apache catalin
a util. Serverinfo
goto end
前面已经用shit把参数前移一位,此时%1表示的参数已经是下一个参数,分别按照 debug、
run、 start、stop、 configtest、 version跳到 doDebug、 doran、 costar.、 dostop、 do Config Test、
do version标签的位置执行不同的操作。下面对这6个操作进行分析。
doDebug的逻辑如下。首先把参数前移一位,并设置 EXECJAVA变量赋为% RUNJDB‰,
RUNJDB变量在 setclasspath批处理脚本中已经设置为% JAVA HOME% \binds,然后,设置
DEBUG OPTS变量。接着,判断参数是否等于- -security,即是否启动安全管理器,如果不启
动,则直接跳到 execCmd位置,否则把参数前移一位,并且设置 SECURITY POLICY FILE
变量为% CATALINA BASE% conf\catalina, policy。最后,跳到 execCmd位置。
doRan的逻辑如下。首先,把参数前移一位,并判断是否使用安全管理器,如果不使用安
全管理器,则直接跳到 exec Cmd位置,否则参数前移一位。然后,设置 SECURITY POLICY
FILE变量。最后,跳到 exec Cmd位置。
diStant的逻辑如下。首先,把参数前移一位,根据系统是不是 Windows nt系统设置命
令窗口的标题,把 TITLE变量设置为 Tomcat字符串。然后,设置 EXECJAVA变量,如果有
标题,则添加到启动命令中。接着,判断是否使用安全管理器,把参数前移一位并设置
SECURITY POLICY FILE。最后跳到 exec Cmd位置。
do stop、 do Config Test的逻辑差不多,都是把参数前移一位,分别设置 ACTION变量为stop、
configtest,清空 CATALINA OPTS变量,跳到 execCmd位置。
3631 Tomcat的批处理
do version其实就是显示服务器的信息,直接用% OJRE HOME%bin目录下的Java执行
%6 CATALINA_ HOME%Ib\catalina. jar包的 org. apache. catalina. util. ServerInfo类,即可输出服务
器相关信息,然后结束命令。
第七部分属于命令真正执行的过程,它将前面所有脚本运行后组成一个最终的命令开
始执行
execcmd
set CMD LINE ARGS=
retArds
if 91 =="l"" goto donesetArgs
set CMD LINE ARGS=%CMD LINE ARGS% %1
shift
goto setArgs
:doneSetArgs
if not""号JPDA8"
E I II
goto doJpda
if not SECURITY POLICY__FILE%"==" goto dosecurity
8 EXECUAVA号号 JAVA OPTS号号 CATAL工NA_OPTS号号 DEBUG_OPTS号- D]ava, endorsed,dirs="号
JAVA_ ENDORSED_ DIRS"-classpath oClASSPATH-Dcatalina base="CATALINA BAS
E8"- Data1ina.home="% CATAL工 NA HOME号"- DJava.io. impair="号 CATAL工NA_ TMPDIR号"号
MAIncLASS %CMD LINE ARGS. actIon
goto end
:doSecurity
6_EXECUAVA6 JAVA_OPTS CATALINA_ OPTS DEBUG_OPTS -Djava endorsed dirs="%
JAVA ENDORSED DIRS%"classpath 8CLASSPATH-Djava. security manager -Djava
security policy=="%SECURITY_POLICY_FILE%"-Dcatalina base="%CATALINA BASE%"
-Catalina. home=% CATALINA_HOME %"-Djava io tmpdir=8CATALINA TMPDIR"MAI
NCLASS8号 CMD LINE ARGS各号 ACTION8
goto end
doula
if not "gSECURITY_ POLICY_FILE%"== " goto doSecurityJpda
8 EXECUAVA号号JAVA_OPTS8号 CATALINA OPTS号号JPDA_OPTS号号 DEBUG_OPTS号- DJava.endo
rseddirs="JAVA_ ENDORSED_ DIRS%"-classpath "CLASSPATH%"-Dcatalina base=8
CATALINA BASE8-Dcatalina home=%CATALINA_HOME%"-Djavaio tmpdir="%CATALIN
A TMPDIR oMAinclaSS %CMD LINE ARGS ACTIon.
goto end
:dosecurityJpda
3_ EXeCJAVA% JAVA_OPTS3号 CATALINA_OPTS号各JPDA_OPTS8号 DEBUG_OPTS号- DJava,endo
rsed dirs="JAVA_ENDORSED_DIRS-classpath ClASSPATH% -Djava security.ma
nager -Djava security policy=="SECURITY_ POLICY__ FILE%"-Dcatalina base="CAT
ALINA_ BASE -Catalina. home= CATALINA_HOME"-Djavaio tmpdir="CATALINA_T
MPDIR"器 MAINCLASS号8 CMD LINE ARGS88 ACTION号
goto end
end
首先,收集参数,这个在前面已经见过,这里不再赘述。接下来,根据参数的值执行不同
37第3章 Tomcat的启动与关闭
的命令。用图3.2能更清楚地描述其中的逻辑,主要是通过JPDA、 SECURITY POLICY FILE
两个变量进行判断,它们分别代表是否使用Java平台调试体系结构和安全管理器。存在的组
合情况如下。
既没有使用Java平台调试体系结构也没有使用安全管理器。
使用了Java平台调试体系结构但没有使用安全管理器。
没有使用Java平台调试体系结构但使用了安全管理器。
既使用Java平台调试体系结构又使用了安全管理器。
是
<%JPDA%不为空?
doOda
否
%SECURITY POLICY
跳到 doSecurity Jpda
FLE%不为空?
是
OSECURITY POLICY
是
doSecurity
FLE%不为空?
否
否
执行命令
执行命令
执行命令
执行命令
▲图3.2安全管理器和调试体系结构
这样就能组成四种不同的命令。下面介绍命令的详细信息。
如果既使用安全管理器又使用Java平台调试体系来启动,则会跳到 do securityJpda位置,
此时变量值如下
>% EXECJAVA%为sat" mcat"D: ljava java"(假设Java安装路径为D: jjavajdk)。
>%JAVA_OPTS%>]-Djava util logging. config file="D: java\apache-tomcat-70 39\conf\logging
properties"-Djava util logging. managerorg. apache. juli Class Log Manager
% CATaLINA OPTS%为空。
%JPDA_OPTS%%]-agentlib: jdwp=transport=dt_socket, address=8000, server=y, suspend=n
% DEBUG OPTS%为空。
3831 Tomcat的批处理
% JAVA ENDORSED DIRS%为D: apache-tomcat\endorsed(假设 Tomcat安装目录为
D: apache- - tomcat)。
%CLASSPATH%*J D: lapache-tomcat\binl\bootstrap jar; D: \apache-tomcat bin tomcat -juli. jar
%SECURITY POLICY_FILE%% D: \apache-tomcat\conf\catalina. policy
%CATALINA BASE%>]D: apache-tomcat
%CATALINA HOME%/ D: \apache-tomcat
%CATALINA TMPDIR%>J D: \apache-tomcat\temp
%MAINCLASS%>] org. apache. catalina. startup Bootstrap
% CMD LINE ARGS%为空。
% ACTION%为 start
将以上的变量值组装成一个命令行就是最终启动的脚本
3.1.4 setclasspath. bat
在 catalina. bat批处理脚本中会调 setclasspath bat批处理脚本, setclasspath.bat的职责很简
单,它只负责寻找、检査 JAVA HOME和 JRE HOME两个环境变量。其内容如下。
if "1""==""debug"" goto needJavaHome
if not"为 URE HOME各"=="" goto gotJreHome
if not"各JAVA_HOME号"=="" goto gotJavaHome
goto exit
needJavaHome
if "JAVA HOME%"== goto noJavaHome
if not exist "JAVA HOME\bin\java. exe "goto noJavaHome
if not exist "JAVA HOME \bin\javaw. exe" goto noJavaHome
if not exist "JAVA_HOME%\bin\jdb. exe"goto noJavaHome
if not exist "JAVA_HOME\bin\javac. exe" goto noJavaHome
set JRe HOME=%JAVA HOME%
goto okJava
noJavaHome
goto exit
gotJavaHome
set JRE HOME=JAVA HOME
gotJreHome
if not exist "%JRE_HOME%\bin \java. exe"goto noJreHome
if not exist "JRE HOME \bin\javaw. exe" goto noJreHome
goto okJava
noRthOme
goto exit
okJava
if not "JAVA ENDORSED_DIRS%"== goto gotEndorseddir
set W JAVA ENDORSED DIRS=%CATALINA HOME.\endorsed
gotEndorseddir
39第3章 Tomcat的启动与关闭
set_ RUNJAVA="JRE_ HOME%bin\java
set_RUNJDB="JAVA_homE\bin\idb"
goto end
exit
exit
end
exit /b o
首先,判断是否在 debug模式下,此模式下必须要设置JAVA_HOME环境变量,即跳到
needJavaHome位置。接着,分别判断 JRE HOME、 JAVA HOME两个环境变量,如果不为空,
则分别跳到 gotreHome、 gotJavaHome位置。 needJavaHome做的事情包括检査 JAVA HOME
环境变量是否为空,如果不为空,确认它的bin目录下是否存在
Java. exe、 Javaw.exe、jdb.exe、
Javac.exe等文件,这些文件都是运行时必要的执行文件。最后,把 JAVA HOME变量的值赋
给 JRE HOME。这里有必要说明一下exit标签与end标签的不同,exit/b1即退出当前命令窗
口并返回值1,exit/0则退出当前命令窗口并返回0,0表示在这段脚本运行时没有出现错误。
所以,如果一切运行正常,最终会得到 JAVA ENDORSED DIRS="% CATALINA HOME%
endorsed",_RUNJAVa="%JRE_HOME%\bin java",_RUNJDB="%JAVA_HOME%bin jdb
32T0mGa中的变量及属性
变量及属性的目的主要是将某些参数剥离出程序,以实现可配置性。在 Tomcat中,启
动时会涉及大量环境变量、JVM系统属性及 Tomcat属性。环境变量在操作系统中配置,
也可以在批处理中添加或修改环境变量,在 Tomcat程序中可通过 System. getenv(name)获取
环境变量。JM系统属性可以是JVM自带的属性,也可以在Java执行命令中通过-D参数
配置,在 Tomcat程序中可通过 System getProperty(name)获取JVM系统属性。而 Tomcat
属性主要通过 catalina. properties配置文件配置,在 Tomcat启动时会加载, Tomcat程序通
过 Catalina Properties获取。
图3.3清楚地展示 Tomcat、JM及操作系统之间相关的变量属性及操作。最底层的是操
作系统的环境变量,假如我们在脚本 catalina.bat中想获取它,可以通过%变量名%直接获取
假如在 Tomcat t中想获取它,则可以通过 System. getevn("变量名")获取。假如我们想在脚本
catalina. bat中启动Java时传入参数作为JM系统属性,则可以附带 Param= value参数,而
在 Tomcat中则通过 System getproperty(" param")获取该JVM系统属性值。除此之外, Tomcat
自身配置文件 catalina. properties则通过 CatalinaProperties类获取。
下面介绍一些常见的变量和属性。
4032 Tomcat中的变量及属性
Tomcat
①通过 System. getenv变量名)获取环境变量
②通过 System getproperty( param”)取M系统属性值
③通过 CatalinaProperties类获取 Catalina. properties属性
catalina. bat
①通过%变量名%取环境变量
②执行Java时附带参数 Param=vaue
OS环境变量
图33 Toma变量
3.2.1环境变量
1 %JAVA HOMEO
表示JDK的安装目录。
2)%CLASSPATH%
JDK搜索cass时优先搜索% CLASSPATH%指定的jar包。
3)%PATH%
执行某命令时,如果在本地找不到此命令或文件,则会从‰PATH%变量声明的目录中区
查找
3.2.2JVM系统变量
user. dir
表示当前用户工作目录。
2) java. io. tmpdir
表示系统默认的临时文件目录。不同操作系统的目录不同。
3) java. home
表示Java安装目录。
4)user home
表示用户目录。
5)java vm vendor
表示Java虚拟机实现供应商。
6)java runtime version
表示Java运行时版本号。
41第3章 Tomcat的启动与关闭
7) java library path
表示系统搜索库文件的路径。
8) java vendor
表示Java运行时环境供应商
9) java ext dirs
表示Java扩展包的目录。
10) user name
表示用户的账户名
package definition
表示Java安全管理器需要检査的包。
12) package. access
表示Java安全管理器需要检查访问权限的包。
13) path separator
表示多个文件路径之间的分隔符。
14) file encoding
表示默认JM编码
15) os version
表示操作系统的版本。
16) catalina. home
配置 Tomcat的安装目录。这个路径变量很重要, Tomcat中常用到。在执行 Tomcat启动
的批处理脚本中会附带 Catalina. home="% CATALINA HOME%",即启动 Tomcat程序时会把
catalina. home作为JVM系统变量。
17) catalina. base
配置 Tomcat的工作目录。这个目录容易与 catalina.home混淆,工作目录与安装目录有什
么区别呢?当我们想要运行多个 Tomcat实例时,就可以创建多个工作目录,而使用同一个安
装目录,达到了多个 Tomcat实例重用 Tomcat程序的目的。在执行 Tomcat启动的批处理脚本
中会附带- Catalina. base="% CATALINA BASE%",即启动 Tomcat程序时会把 catalina. base作
为JVM系统变量。
18) catalina. confi
g
配置 Tomcat配置文件 catalina.properties的路径。
19)org. apache. catalina. startup. EXIT_ ON_ INIT FAILURE
配置启动初始化阶段遇到问题是否退出。
20)tomcat util. scan. DefaultJarScanner jars ToSkip
配置此选项将使 JarScanner扫描时会跳过这些包。
4232 Tomcat中的变量及属性
21)org. apache. catalina. startup. ContextConfig jars ToSkip
配置此选项避免扫描 Servlet3.0插件功能。
22)org.apache. catalina. startup. TldConfig jarsToSkip
配置此选项避免扫描TLD。
23)org. apache. catalina. tribes. dns_ lookups
配置是否在集群中尝试使用DNS査找主机。
24)org. apache. catalina connector CoyoteAdapter. ALLOW BACKSLASH
配置是否允许使用“”符号作为路径分隔符。
25)org.apache tomcat util buf. UDecoderALLOW ENCODED SLASH
配置是否允许使用%2F和%C作为路径分隔符。
26)org. apache. catalina. core Application Context. GET_ RESOURCE- REQUIRE - SLASH
配置是否传入 Servlet Context getResourceO或 Servletcontext: getResource AsStreamO的参数
定要以“/”开头
27)org.apachetomcatutilhttpServercookie.AlloW__eqUalsinValuE
配置 Cookie中的值是否可以包含“=”符号。
28)org. apache. catalina. session. StandardSession ACTIVITY_ CHECK
配置是否跟踪统计活跃的会话数。
29)org. apache. catalina authenticator Constants SSO- SESSION_COOKIE- NAME
配置单点登录的会话 Cookie名字。
30) jvm Route
配置 Engine默认的路由标识。
31)org. apache jasper Constants. SERVICE- METHOD NAME
配置JSP执行时调用的服务方法,默认是 jspService
32)org. apache. jasper Constants. JSP- PACKAGE- NAME
配置编译的JSP页面的包名,默认为 org. apache」jsp
33)org. apache. juli formatter
配置日志框架的格式类。
34) org. apache juli. AsyncMaxRecord Count
配置异步方式下日志在内存中能保存的最大记录数。
35) org. apache juli. AsyncOverflow DropType
配置异步方式下到达日志记录内存限制时所采取的措施。
36)org. apache. coyote. USE_CUSTOM_ STATUS MSG_ IN HEADER
配置是否在HTTP报文头部使用自定义状态。
43第3章 Tomcat的启动与关闭
3.2.3 Tomcat属性
pacKage. access
此属性与Java安全管理器的权限配置有关,用于配置包的访问权限。它的值包含多个包
路径,默认配置为
package. access=sun, org. apache. catalina, org. apache. coyote, org. apache tomcat
org. apache. jasper.
2) package definition
此属性与Java安全管理器的权限配置相关,用于配置包的定义权限。默认配置为
package definition=sun java. org apache. catalina, org. apache. coyote, org. apache tomcat, org. apache
Jasper.
3)common loader
此属性用于配置 Tomcat中用 common loader
类加载器加载的类库。配置的值可以使用特
定的变量,例如${ catalina. base}, Tomcat程序中会对其进行解析替换。默认配置为 com
loader=(catalina. base)/ib, $catalina. base)/ib/*jar, $(catalina. home /lib, $(catalina. home)/ib/*. jar
4)server. loader
此属性用于配置 Tomcat中用 serverloader类加载器加载的类库。默认配置为空。
5)sharedloader
此属性用于配置 Tomcat中用 sharedLoader类加载器加载的类库。默认配置为空。第4章从整体预览 Tomcat
41整体结构及组件介绍
Tomcat发展到今天已经变成一个比较庞大的项目,想深入每个细节是相当耗时耗体力的,
但不管 Tomcat怎么升级,它的主体骨架基本没有改变,良好的模块划分让它拥有很好的可扩
展性。在深入研究 Tomcat之前,先从整体上了解它的各个主要模块将会非常有帮助。本章就
从整体上预览 Tomcat的内部架构,介绍其中包含的各个模块及其作用,从整体上认识 Tomcat
内部的架构层次。
如图41所示,它包含了 Tomcat内部的主要组件,每个组件之间的层次包含关系能够很
清晰地看到,这里不再赘述。如果将 Tomcat内核高度抽象,则它可以看成由连接器( Connector)
组件和容器( Container)组件组成,其中 Connector组件负责在服务器端处理客户端连接,包
括接收客户端连接、接收客户端的消息报文以及消息报文的解析等工作,而 Container组件则
负责对客户端的请求进行逻辑处理,并把结果返回给客户端。图41中的 Connector正是这里
讨论的 Connector组件,它的结构也比较复杂,第5章将会深入讲解,但 Container组件则不
能在图41中直接找到。它其实包括4个级别的容器: Engine组件、Host组件、 Context组件
和 Wrapper组件,容器也是整个 Tomcat的核心,这将会在第7章到第10章中进行深入讲解。
从 Tomcat服务器配置文件 server xml的内容格式看,它所描述的 Tomcat也符合图41的
层级结构,以下便是 server xml简洁的配置节点,所以从 server xml文件也能看出 Tomcat的大
体结构。
<?xml version='1.0 encoding=utf-8 ?>
<Server>
<Listener/>
<GlobalNamingresources>
<Resource/>
</GlobalNamingResources>
<Service>
<Executor/>
<Connector/>
<Engine>第4章从整体预览 Tomcat
<Cluster/>
<Realm>
<Host>
<Context/>
</Host>
</Engine>
</Service>
</Server>
Listener
GlobalNamingResources
Service
Connector
Protocol
Mapp
Endpoint
Executor
Acceptor
EX
xecutor
Processor
ngn
Listener Access
Cluster
Pipeline
Realm
Host
Listene
AccessLogCluster
Pipeline
Realm
Context
Li
Listener
AccessLog
Pipeline
Loader
Manager
NamingResource
MapperRealm
W
rapp
Serve
ServletPool
Pipeline
▲图4.1 Tomcat内部的主要组件
下面将根据图41中的组件大致介绍它们是什么以及它们有什么作用
1. Server组件
Server是最顶级的组件,它代表 Tomcat的运行实例,在一个JVM中只会包含一个 Server
在 Server的整个生命周期中,不同阶段会有不同的事情要完成。为了方便扩展,它引入了监
听器方式,所以它也包含了 Listener组件。另外,为了方便在 Tomcat中集成JNDI,引入了
GlobalNaming Resources组件。同时,还包含了 Service核心组件。
2. Service组件
Service是服务的抽象,它代表请求从接收到处理的所有组件的集合。如图42所示,在设
464.1整体结构及组件介绍
计上 Server组件可以包含多个 Service组件,每个 Service组件都包含了若干用于接收客户端
消息的 Connector组件和处理请求的 Engine组件。其中,不同的 Connector组件使用不同的通
信协议,如HTTP协议和AJP协议,当然还可以有其他的协议A和协议B。若干Connector
组件和一个客户端请求处理组件 Engine组成的集合即为 Service。此外, Service组件还包含了
若干 Executor组件,每个 Executor都是一个线程池,它可以为 Service内所有组件提供线程池
执行任务
Server
Service
Service
Connect
Connector
Connector Connector
Http
AJP
协议A
协议B
Engine
Engine
▲图4.2 Server和 Service组件
3. Connector组件
Connector主要的职责就是接收客户端连接并接收消息报文,消息报文经由它解析后送往
容器中处理。如图43所示,因为存在不同的通信协议,例如HTTP协议、AJP协议等,所以
我们需要不同的Connector组件,每种协议对应一个Connector组件,目前Tomcat包含HTTP
和AJP两种协议的 Connector
上面从协议角度介绍了不同的 Connector组件,而 Connector组件的内部实现也会根据网
络IO的不同方式而不同分为阻塞IO和非阻塞IO。下面以HTTP协议为例,看看阻塞IO
和非阻塞IO的 Connector内部实现模块有什么不同。
在阻塞IO方式下, Connector的结构如图44所示。
Connector
Service
Httpll Protocol
Connector
Connector
Mapper
Http
AJP
(JioEndpoint
Acc
Execute
Httpll Processon
Engine
Coyote Adaptor
▲图4.3 Connector组件
▲图44B0 Connector结构
Http1lprotocol组件,是HTTP协议1.1版本的抽象,它包含接收客户端连接、接收客户端
消息报文、报文解析处理、对客户端响应等整个过程。它主要包含 Jloendpoint组件和
Httpli processor组件。启动时, Jloendpoint组件内部的 Acceptor组件将启动某个端口的监
47第4章从整体预览 Tomcat
听,一个请求到来后将被扔进线程池 Executor,线程池进行任务处理,处理过程中将通过
Httpllprocessor !件对HTIP协议解析并传递到 Engine容器继续处理。
Mapper组件,客户端请求的路由导航组件,通过它能对一个完整的请求地址进行路由,通
俗地说,就是它能通过请求地址找到对应的 Servlet
Coyote Adaptor组件,一个将 Connector和 Container适配起来的适配器
如图45所示,在非阻塞IO方式下, Connector的结构类似阻塞模式, Httpllprotocol组
件改成 HttplinioprotocoL组件, JloEndpoint组件改成 Nioendpoint,, Httpllprocessor组件改成
Htp1 NioProcessor组件,这些类似的组件的功能也都类似。唯独多了一个 Poller组件,它的
职责是在非阻塞IO方式下轮询多个客户端连接,不断检测、处理各种事件,例如不断检测各
个连接是否有可读,对于可读的客户端连接则尝试进行读取并解析消息报文。
Connector
HttplinioprotocOl
Mapper
Nio endpoint
Acceptor Executor Poller Httpi inIopROcessor
Coyote Adapto
▲图4.5 NIO Connector结构
4. Engine组件
Tomcat内部有4个级别的容器,分别是 Engine、Host、 Context和 Wrapper Engine代表
全局 Servlet引擎,每个 Service组件只能包含一个 Engine容器组件,但 Engine组件可以包含
若干Host容器组件。除了Host之外,它还包含如下组件。
> Listener组件:可以在 Tomcat生命周期中完成某些 Engine容器相关工作的监听器。
> AccessLog组件:客户端的访问日志,所有客户端访问都会被记录。
Cluster组件:它提供集群功能,可以将 ngine容器需要共享的数据同步到集群中的其他
Tomcat实例上。
Pipeline组件: Engine容器对请求进行处理的管道。
≯ Realm组件:提供了 Engine容器级别的用户-密码-权限的数据对象,配合资源认证模块
使用。
5.Host组件
Tomcat中Host组件代表虚拟主机,这些虚拟主机可以存放若干Web应用的抽象( Context
容器)。除了 Context组件之外,它还包含如下组件。
Listener组件:可以在 Tomcat生命周期中完成某些Host容器相关工作的监听器。
484.1整体结构及组件介绍
AccessLog组件:客户端的访问日志,对该虚拟主机上所有web应用的访问都会被记录。
≯ Cluster组件:它提供集群功能,可以将Host容器需要共享的数据同步到集群中的其他
Tomcat实例上。
Pipeline组件:Host容器对请求进行处理的管道。
≯ Realm组件:提供了Host容器级别的用户-密码-权限的数据对象,配合资源认证模块使用
6. Context组件
Context组件是web应用的抽象,我们开发的Web应用部署到 Tomcat后运行时就会转化
成 Context对象。它包含了各种静态资源、若干 Servlet( Wrapper容器)以及各种其他动态资
源。它主要包括如下组件。
Listener组件:可以在 Tomcat生命周期中完成某些 Context容器相关工作的监听器。
AccessLog组件:客户端的访问日志,对该Web应用的访问都会被记录。
Pipeline组件: Context容器对请求进行处理的管道。
Realm组件:提供了 Context容器级别的用户-密码-权限的数据对象,配合资源认证模块使用。
Loader组件:Web应用加载器,用于加载Web应用的资源,它要保证不同Web应用之间
的资源隔离。
Manager组件:会话管理器,用于管理对应Web容器的会话,包括维护会话的生成、更新
和销毁
NamingResource组件:命名资源,它负责将 Tomcat配置文件的 server xml和web应用的
context. xml资源和属性映射到内存中。
Mapper组件: Servlet映射器,它属于 Context内部的路由映射器,只负责该 Context容器
的路由导航。
Wrapper组件: Context的子容器
7. Wrapper组件
Wrapper容器是 Tomcat中4个级别的容器中最小的,与之相对应的是 Servlet,一个 Wrapper
对应一个 Servlet它包含如下组件。
Servlet组件: Servlet即web应用开发常用的 Servlet,我们会在 Servlet中编写好请求的逻
辑处理。
> Servletpool组件: Servlet对象池,当Web应用的 Servlet实现了 Single ThreadModel接口时
则会在 Wrapper中产生一个 Servlet对象池线程执行时,需先从对象池中获取到一个 Servlet
对象, Servletpool组件能保证 Servlet对象的线程安全
Pipeline组件: Wrapper容器对请求进行处理的管道。
49第4章从整体预览 Tomcat
42请求处理的整体过程
上一节已经介绍了 Tomcat内部的整体结构,对每个组件的定义及作用也进行了大致的讨
论。接下来,从整体看一下客户端从发起请求到响应的整个过程在 Tomcat内部如何流转。我
们从图4.6开始讲起。
Server
ervice
Connector
Http protOcol
Mapper
JioEndpoint
Acceptor Executor
Httpll Processor
Coyote
Adaptor
Engine
Pipeline
Engine Valve
xxx Valve
Host
Pipeline
x× Valve
Host valve
Context
Pipeline
Context valve
xxxValve
Wrapper
Pipeline
Wrapper Valve
xx× Valve
ApplicationFilterChain
Servlet
▲图4.6 Tomcat的请求流转过程
图4.6是 Tomcat的请求流转过程,为了更简洁明了,去掉了请求过程中一些非主线的组
件。这里假定Tomcat作为专门处理HTTP的Web服务器,而且使用阻塞IO方式接受客户端
的连接。下面介绍请求流转的具体过程。
①当 Tomcat启动后, Connector组件的接收器( Acceptor)将会监听是否有客户端套接
字连接并接收 Socket
504.2请求处理的整体过程
②一旦监听到客户端连接,则将连接交由线程池 Executor处理,开始执行请求响应仼务
③Httpllprocessor组件负责从客户端连接中读取消息报文,然后开始解析HTTP的请求
行、请求头部、请求体。将解析后的报文封装成 Request对象,方便后面处理时通过 Request
对象获取HTTP协议的相关值。
④Mapper组件根据HTTP协议请求行的URL属性值和请求头部的Host属性值匹配由哪
个Host容器、哪个 Context容器、哪个 Wrapper容器处理请求,这个过程其实就是根据请求从
Tomcat中找到对应的 Servlet。然后将路由的结果封装到 Request对象中,方便后面处理时通过
Request对象选择容器。
⑤ Coyote Adaptor组件负责将 Connector组件和 Engine容器连接起来,把前面处理过程中
生成的请求对象 Request和响应对象 Response传递到 Engine容器,调用它的管道。
⑥ Engine容器的管道开始处理请求,管道里包含若干阀门( Valve),每个阀门负责某些
处理逻辑。这里用 xxx Valve代表某阀门,我们可以根据自己的需要往这个管道中添加多个阀
门,首先执行这个 xxx Valve,然后才执行基础阀门 Engine valve,它会负责调用Host容器的
管道。
⑦Host容器的管道开始处理请求,它同样也包含若干阀门,首先执行这些阀门,然后执
行基础阀门 Host valve,它继续往下调用 Context容器的管道。
⑧ Context容器的管道开始处理请求,首先执行若干阀门,然后执行基础阀门
Context Valve,它负责调用 Wrapper容器的管道。
⑨ Wrapper容器的管道开始处理请求,首先执行若干阀门,然后执行基础阀门
Wrapper Valve,它会执行该 Wrapper容器对应的 Servlet对象的处理方法,对请求进行逻辑处理,
并将结果输出到客户端。
以上便是一个客户端请求到达 Tomcat后处理的整体流程。这里,先对其有个整体印象,
后面会深入讨论更多的细节。
51第5章 Server组件与 Service组件
Server组件和 Service组件是 Tomcat核心组件中最外层级的两个组件, Server组件可以看
成 Tomcat的运行实例的抽象,而 Service组件则可以看成 Tomcat内的不同服务的抽象。如图
5.1所示, Server组件包含若干 Listener组件、 GlobalNaming Resources组件及若干 Service组件
Service组件则包含若干 Connector组件和 Executor组件。由于它们的结构相对比较简单且关系
密切,因此将两者放到同一章中进行讲解。
Server
Listener
GlobalNaming Resources
IVI
Connector
Executor
▲图5.1 Server与 Service
51 Server组件
Server组件是代表整个 Tomcat的 Servlet容器,从 server. xm1配置文件也可以看出它属于
最外层组件。它的结构如图52所示,默认配置了6个监听器组件,每个监听器负责各自的监
听任务处理。 GlobalNaming Resources组件通过JND提供统一的命名对象访问接口,它的使用
范围是整个 Server. server Socket组件监听某个端口是否有 SHUTDOWN命令,一旦接收到则
关闭 Server,即关闭 Tomcat. Service组件是另外一个核心组件,它的结构很复杂,也包含了
更多其他的核心组件。
作为 Tomcat最外层的核心组件, Server组件的作用主要有以下几个。
提供了监听器机制,用于在 Tomcat整个生命周期中对不同事件进行处理。
提供了 Tomcat容器全局的命名资源实现。
监听某个端口以接收 SHUTDOWN命令51 Server组件
Server
AprLifecycleListener
ServerSocket
Jasperlistener
JreMemory Leak Prevention Listener
ervice
GlobalResources LifecycleListener
Thread LocalLeak Prevention Listener
GlobalNaming
Naming ContextListener
Resources
图52 Server组件
5.1.1生命周期监听器
Tomcat的整个生命周期存在很多阶段,比如初始化前、初始化中、初始化后、启动前、
启动中、启动后、停止前、停止中、停止后、销毁中、销毁后等。为了在 Server组件的某阶
段执行某些逻辑,于是提供了监听器机制。在 Tomcat中实现一个生命周期监听器很简单,只
要实现 LifecycleListener接口即可,在 lifecycle Event方法中对感兴趣的生命周期事件进行处理。
对于监听器机制及其实现将在第11章进行深入讲解。下面介绍6个监听器。
1. AprLifecyclelistener监听器
有时候, Tomcat会使用APR本地库进行优化,通过JNI方式调用本地库能大幅提高对静
态文件的处理能力。 AprLifecycleListener监听器对初始化前的事件和销毁后的事件感兴趣,在
Tomcat初始化前,该监听器会尝试初始化APR库,假如能初始化成功,则会使用APR接受
客户端的请求并处理请求。在 Tomcat销毁后,该监听器会做APR的清理工作。
2. JasperListener监听器
在 Tomcat初始化前该监听器会初始化 Jasper组件, Jasper是 Tomcat的JsP编译器核心弓
擎,用于在Web应用启动前初始化 Jasper
3. JreMemory LeakPreventionListener监听器
该监听器主要提供解决JRE内存泄漏和锁文件的一种措施,该监听器会在 Tomcat初始化
时使用系统类加载器先加载一些类和设置缓存属性,以避免内存泄漏和锁文件。
先看JRE内存泄漏问题。内存泄漏的根本原因在于当垃圾回收器要回收时无法回收本该被回收
的对象。假如一个待回收对象被另外一个生命周期很长的对象引用,那么这个对象将无法被回收。
其中一种JRE内存泄漏是因为上下文类加载器导致的内存泄漏。在JRE库中某些类在运
行时会以单例对象的形式存在,并且它们会存在很长一段时间,基本上是从Java程序启动到
关闭。JRE库的这些类使用上下文类加载器进行加载,并且保留了上下文类加载器的引用,所
以将导致被引用的类加载器无法被回收,而 Tomcat在重加载一个Web应用时正是通过实例化
53第5章 Server组件与 Service组件
一个新的类加载器来实现的,旧的类加载器无法被垃圾回收器回收,导致内存泄漏。如图5.3
所示,某上下文类加载器为 WebappClassloader的线程加载JRE的 DriverManager类,此过程
将导致 Webapp Classloader被引用,后面该 Webapp Classloader将无法被回收,发生内存泄漏。
JRE
Driver manange
上下文类加载器为 Webappctassloader
的线程加载JRE的某些类
Webappclassloader
线程
▲图5.3JRE内存泄漏
另外一种]RE内存泄漏是因为线程启动另外一个线程并且新线程无止境地执行。在JRE
库中存在某些类,当线程加载它时,它会创建一个新线程并且执行无限循环,新线程的上下文
类加载器会继承父线程的上下文类加载器,所以新线程包含了上下文类加载器的应用,导致该
类加载器无法被回收,最终导致内存泄漏。如图5.4所示,某上下文类加载器为
Webappclassloader的线程加载JRE的 Disposer类,此时该线程会创建一个新的线程,新线程
的上下文类加载器为 Webappclassloader,,随后新线程将进入一个无限循环的执行中,最终该
Webappclassloader将无法被回收,发生内存泄漏。
JRE
Dist
W启动二个线
程无限循环
上下文类加载器为 Webappclassloader
Webappclassloader
的线程加载JRE的某些类
线程
▲图5.4JRE内存泄漏二
可以看到JRE内存泄漏与线程的上下文类加载器有很大的关系。为了解决JRE内存泄漏,尝试
让系统类加载器加载这些特殊的JRE库类。 Tomcat中即使用了 JreMemoryLeak Prevention Listener监
听器来做这些事。主要的代码如下。
5451 Server组件
ClassLoader loader Thread currentThread (. getContextClassLoader (
Thread currentThread(. setContextclassLoader(ClassLoader. getsystemClassload
er());
DriverManager. getDrivers()i
try t
Class forName ("sun java2d Disposer)i
catch (ClassNot FoundException cnfe) t
Thread currentThread(. setContextclassLoader (loader)i
在 Tomcat启动时,先将当前线程的上下文类加载器设置为系统类加载器,再执行
Driver Manager.getDrivers(0和 Class. forName(" sun Java2 d Disposer"),即会加载这些类,此时的线程
上下文为系统类加载器,加载完这些特殊的类后再将上下文类加载器还原。此时,如果
Web应用使用到这些类,由于它们已经加载到系统类加载器中,因此重启Web应用时不会
存在内存泄漏。除了上面两个类之外,JRE还有其他类也存在内存泄漏的可能,如
javax. imageio. ImagelO, java. awt. Toolkit, sun. misc. GC javax. securityauth. Policy, javax.security
auth. login Configuration, java security Security javax. xml parsers Document BuilderFactory,com.sun
jndi. ldap. Ldap poolManager等。
接着讨论锁文件问题。锁文件的情景主要由 URLConnection默认的缓存机制导致,在 Windows
系统下当使用 URLConnection的方式读取本地Jar包里面的资源时,它会将资源内存缓存起来,这
就导致了该Jar包被锁。此时,如果进行重新部署将会失败,因为被锁的文件无法删除。
为了解决锁文件问题,可以将 URLConnection设置成默认不缓存,而这个工作也交由
JreMemory Leak PreventionListener完成。主要的代码如下。
URLurl new URL ("jar: file: //dummy. jar!")i
URLConnection uConn = url. openConnection ()i
uConn. setDe faultUseCaches( false)
在 Tomcat启动时,实例化一个 URLConnection,然后通过 setDefaultUse caches( false)设置
成默认不缓存,这样后面使用 URLConnection将不会因为缓存而锁文件。
JreMemory Leak PreventionListener监听器完成上面的工作即能避免JRE内存泄漏。
4. GlobalResourcesLifecycleListener监听器
该监听器主要负责实例化 Server组件里面JND资源的 MBean,并提交由JMX管理。此
监听器对生命周期内的启动事件和停止事件感兴趣,它会在启动时为D创建 MBean,而在
停止时销毁 MBean
5. ThreadLocalLeak PreventionListener监听器
该监听器主要解决 ThreadLocal的使用可能带来的内存泄漏问题。该监听器会在 Tomcat
55第5章 Server组件与 Service组件
启动后将监听Web应用重加载的监听器注册到每个Web应用上,当Web应用重加载时,该监
听器会将所有工作线程销毁并再创建,以避免 ThreadLocal引起内存泄漏。
Threadlocal引起的内存泄漏问题的根本原因也在于当垃圾回收器要回收时无法回收,因
为使用了 ThreadLocal的对象被一个运行很长时间的线程引用,导致该对象无法被回收。
Thread Local导致内存泄漏的经典场景是Web应用重加载,如图5.5所示。当 Tomcat启动
后,对客户端的请求处理都由专门的工作线程池负责。线程池中线程的生命周期一般都会比较
长,假如Web应用中使用了 ThreadLocal保存AA对象,而且A类由 Webappclassloader加载,
那么它就可以看成线程引用了AA对象。Web应用重加载是通过重新实例化一个
Webappclassloader类加载器来实现的,由于线程一直未销毁,旧的 Webappclassloader也无法
被回收,导致了内存泄漏。
Webappclassloader
AA
ThreadlocalsAA
线程
▲图5.5 Threadloca内存泄漏
解决 Thread Local内存泄漏最彻底的方法就是当Web应用重加载时,把线程池内的所有线
程销毁并重新创建,这样就不会发生线程引用某些对象的问题了。如图5.6所示, Tomcat中处
理 ThreadLocal I内存泄漏的工作其实主要就是销毁线程池原来的线程,然后创建新线程。这分
两步做,第一步先将任务队列堵住,不让新任务进来;第二步将线程池中所有线程停止
线程池
线程
线程1
任任任
务务务
线程
线程2
线程
▲图5.6线程池51 Server组件
ThreadLocalLeak PreventionListener监听器的工作就是实现当Web应用重加载时销毁线程
池的线程并重新创建新线程,以此避免 Threadlocal内存泄漏。
6. Naming ContextListener监听器
该监听器主要负责 Server组件内全局命名资源在不同生命周期的不同操作,在 Tomcat启
动时创建命名资源、绑定命名资源,在 Tomcat停止前解绑命名资源、反注册 MBean
5.1.2全局命名资源
Server组件包含了一个全局命名资源,它提供的命名对象通过 ResourceLink可以给所有
Web应用使用。它可以包含以下对象描述的命名资源。
ContextResources
ContextEjb
ContextEnvironment
ContextLocalEjb
Message DestinationRef
ContextResource EnvRef
ContextResourceLink
ContextService
在 Tomcat启动初始化时,通过 Digester框架将 server.xml的描述映射到对象,在 Server
组件中创建 NamingResources和 Naming ContextListener两个对象。监听器将在启动初始化
时利用 ContextResources里面的属性创建命名上下文,并且组织成树状。
如图5.7所示, Tomcat启动时将 server:xml配置文件里面的 GlobalNaming Resources
节点通过 Digester框架映射到一个 Naming Resources对象。当然,这个对象里面包含了不
同类型的资源对象,同时会创建一个 Naming ContextListener监听器,这个监听器负责在
Tomcat初始化启动期间完成对命名资源的所有创建、组织、绑定等工作,使之符合JND
标准。而创建、组织、绑定等是根据 Naming Resources对象描述的资源属性进行处理的,
绑定的路径由配置文件的 Resource节点的name属性决定,name即为JND对象树的分
支节点,例如,name为“ jdbc/my DB”,那么此对象就可通过“ java: jdbc/myDB”访问,而树
的位置应该是 jdbc/my DB,但在Web应用中是无法直接访问全局命名资源的。因为要访问全
局命名资源,所以这些资源都必须放在 Server组件中。
57第5章 Server组件与 Service组件
InitialContext
Catalina
创建命名上下
Server
监听到Tmm初始化文,绑定资源
Naming Contextlisterner
Naming Context
NamingResources
ContextResources
Contextl
ContextEnvironment
ContextlocalEjb
MessageDestinationRef
ContextResource Env Ref
Context ResourceLink
ContextService
JNDI
框架运行机制
利用 Digester创建
NamingResources实例
<Server>
<Globa NamingResouces>
<Resource/>
<GlobaNamingResouces>
server xml
▲图5.7全局命名资源
5.1.3监听 SHUTDOWN命令
Server会另外开放一个端口用于监听关闭命令,这个端口默认为8005,此端口与接收客
户端请求的端口并非同一个。客户端传输的第一行如果能匹配关闭命令(默认为
SHUTDOWN),则整个 Server将会关闭。
要实现这种关闭其实很简单,如图58所示, Tomcat中有两类线程,一类是主线程,另外
类是 daemon线程。当 Tomcat启动时, Server将被主线程执行,其实就是完成所有的启动工
作,包括启动接收客户端和处理客户端报文的线程,这些线程都是 daemon线程。所有启动工
作完成后,主线程将进入等待 SHUTDOWN命令的环节,它将不断尝试读取客户端发送过来
的消息,一旦匹配 SHUTDOWN命令则跳出循环。主线程继续往下执行 Tomcat的关闭工作。
最后主线程结束,整个 Tomcat停止。
主线程
daemon线程
Ser
等待
启动
SHLITDOWN
停止
主线程
daemon线程
daemon线程
daemon线程
daemon线程
daemon线程
▲图5.8监听 SHUTDOWN命令
5852 Service组件
监听 SHUTDOWN命令的简要代码如下:打开本地8005端口监听客户端,一旦有客户端
连接,就尝试读取客户端的命令,如果客户端发送的命令为 SHUTDOWN,则跳出循环,让整
个主线程执行完毕,也就意味着程序执行完关闭。假如输入的命令并非为 SHUTDOWN,则进
去下一个循环,等待下一个客户端的连接
public class ShutdownCommand
public static void main(String[] args)
ServerSocket serverSocket nulli
try i
serverSocket= new ServerSocket(8005, 1,
InetAddress getByName("localhost));
while (true) i
Socket socket null
StringBuilder command= new StringBuilder()
Inputstream stream nulli
socket serverSocket accept ()i
socket. setsoTimeout(10 1000)i
stream socket. getInputstream ()i
byte[] commands new byte [8l;
stream read( commands)i
for (byte b: commands)
command. append((char)b)i
System. out. println (command. tostring())i
if (command. tostring(). equals("SHUTDOWN")
break
catch (IOException e)
52 Service组件
Service组件是一个简单的组件,如图59所示, Service组件是若干 Connector组件和
Executor组件组合而成的概念。 Connector组件负责监听某端口的客户端请求,不同的端口对
应不同的 Connector。 Executor组件在 Service抽象层面提供了线程池,让 Service下的组件可
以共用线程池。默认情况下,不同的 Connector组件会自己创建线程池来使用,而通过 Service
组件下的 Executor组件则可以实现线程池共享,每个 Connector组件都使用 Service组件下的
线程池。除了 Connector组件之外,其他的组件也可以使用。
既然提及线程池,就来看看 Tomcat中线程池的实现。
“池”技术对我们来说是非常熟悉的一个概念。它的引入是为了在某些场景下提高系统某
59第5章 Server组件与 Service组件
些关键节点的性能和效率,最典型的例子就是数据库连接池。数据库连接的建立和销毁都是很
耗时耗资源的操作。为了査询数据库中某条记录,最原始的一个过程是建立连接,发送査询语
句,返回査询结果,销毁连接。假如仅仅是一个很简单的查询语句,那么建立连接与销毁连接
两个步骤就已经占所有时间消耗的绝大部分,效率显然让人无法接受。于是想到尽可能减少创
建和销毁连接操作,连接相对于査询是无状态的,不必每次査询都重新生成和销毁连接,我们
可以维护这些通道维护以供下一次查询或其他操作使用。维护这些管道的工作就交给了“池”。
Service
Connector
Executor
▲图5.9 Service组件
线程池也是类似于数据库连接池的一种池,而仅仅是把池里的对象换成了线程。线程是为
多任务而引入的概念,每个线程在任意时刻执行一个任务,假如多个任务要并发执行,则要用
到多线程技术。每个线程都有自己的生命周期,以创建为始,以销毁为末。如图5.10所示,
两个线程的运行阶段占整个生命周期的比重不同。第一种情形是运行阶段所占比重小的线程
(见图5.10(a)),可以认为其运行效率低。第二种情形是运行阶段所占比重大的线程(见图
5.10(b),可认为其运行效率高。如果不使用线程池,大多数场景下都比较符合第一和线程
运行模式。为了提高运行效率,引入了线程池,它的核心思想就是把运行阶段尽量拉长,对于
每个任务的到来,不是重复建立、销毁线程,而是重复利用之前建立的线程执行任务。
建立
运行
销毁
建立
运行
销毁
(b)
▲图5.10线程的生命周期
其中一种方案是在系统启动时建立一定数量的线程并做好线程维护工作,一旦有任务到来
即从线程池中取出一条空闲的线程执行任务。原理听起来比较清晰,但现实中对于一条线程,
旦调用 start方法后,就将运行任务直到任务完成,随后JVM将对线程对象进行GC回收,
如此一来线程不就销毁了吗?是的,所以需要换种思维角度,让这些线程启动后通过一个无限
循环来执行指定的任务。下面将重点讲解如何实现线程池。
个线程池的属性起码包含初始化线程数量、线程数组、任务队列。初始化线程数量指线
程池初始化的线程数,线程数组保存了线程池中的所有线程,任务队列指添加到线程池中等待
5052 Service组件
处理的所有任务。如图5.11所示,线程池里有两个线程,池里线程的工作就是不断循环检测
任务队列中是否有需要执行的任务,如果有,则处理并移出任务队列。于是,可以说线程池中
的所有线程的任务就是不断检测任务队列并不断执行队列中的任务。
建立
运行
销毁
00
建立
销毁
图5.11线程池的实现
看一个最简陋的线程池的实现,使用线程池时只须实例化一个对象,构造函数就会创建相
应数量的线程并启动线程,启动的线程无限循环地检测任务队列,执行方法 execute仅仅把任
务添加到任务队列中。需要注意的一点是,所有任务都必须实现 Runnable接口,这是线程池
的任务队列与工作线程的约定,JC工具包作者 Doug Lea当时如此规定,工作线程检测任务
队列并调用队列的runO方法,假如你自己重新写一个线程池,就完全可以自己定义一个不
样的任务接口。一个完善的线程池并不像下面的例子那样简单,它需要提供启动、销毁、增加
工作线程的策略,最大工作线程数,各种状态的获取等操作,而且工作线程也不可能始终做无
用循环,需要对任务队列使用wait、 notify优化,或者将任务队列改用为阻塞队列。
public final class ThreadPool
private final int worker_num
private WorkerThread[] workerThrads
private List<Runnable> taskQueue
new Linkedlist<Runnable>i
private static Threadpool threadpool
public ThreadPool (int worker_num) t
this, worker num worker numi
workerThrads new WorkerThread[worker num]i
for (int i =0; i< worker num; i++)t
workerThrads [i] new WorkerThread o)i
workerThrads [i]. start()i
61------
第5章 Server组件与 Service组件
public void execute(Runnable task)(
synchronized (taskQueue)[
taskQueue. add(task)i
private class Worker Thread extends Thread i
public void run()(
Runnable r= null
while (true) i
synchronized (taskQueue) i
if ( tas kQueue isEmpty())(
r= taskQueue. remove(0)i
r runni
通过上面的讲解,读者已经清楚了线程池的原理,但我们并不提倡重造轮子的行为,因为
线程池处理很容易产生死锁问题,同时线程池内的状态同步操作不当也可能导致意想不到的问
题。除此之外,还有很多其他的并发问题,除非是很有经验的并发程序员才能尽可能减少可能
的错误。建议读者直接使用JDK的JC工具包即可,它是由 Doug Lea编写的优秀并发程序
工具,仅线程池就已经提供了好多种类的线程池,实际开发中可以根据需求选择合适的线程池。
62第6章 Connector组件
Connector(连接器)组件是 Tomcat最核心的两个组件之一,主要的职责是负责接收客户
端连接和客户端请求的处理加工。每个 Connector都将指定一个端口进行监听,分别负责对请
求报文解析和对响应报文组装,解析过程生成 Request对象,而组装过程则涉及 Response对象。
如果将 Tomcat整体比作一个巨大的城堡,那么 Connector组件就是城堡的城门,每个人要进
入城堡就必须通过城门,它为人们进出城堡提供了通道。同时,一个城堡还可能有两个或多个
城门,每个城门代表了不同的通道。本章将深入剖析 Tomcat的 Connector组件。
典型的 Connector组件会有如图6.1所示的结构,其中包含 Protocol组件、 Mapper组件和
CoyoteAdaptor组件。
Connector
Protocol
appe
Endpoint
Acceptor
Executor
Coyote Ada
▲图6.1 Connector组件
Protocol组件是协议的抽象,它将不同通信协议的处理进行了封装,比如HTTP协议和
AJP协议。 Endpoint是接收端的抽象,由于使用了不同的Io模式,因此存在多种类型的
Endpoint,如BO模式的 JloEndpoint NIO模式的 NioEndpoint和本地库IO模式的 AprEndpoint
Acceptor是专门用于接收客户端连接的接收器组件, Executor则是处理客户端请求的线程池,
Connector可能是使用了 Service组件的共享线程池,也可能是 Connector自己私有的线程池。
Processor组件是处理客户端请求的处理器,不同的协议和不同的O模式都有不同的处理方
式,所以存在不同类型的 Processor o
Mapper组件可以称为路由器,它提供了对客户端请求URL的映射功能,即可以通过它将
请求转发到对应的Host组件、 Context组件、 Wrapper组件以进行处理并响应客户端,也就是
我们常说的将某客户端请求发送到某虚拟主机上的某个Web应用的某个 Servlet
CoyoteAdaptor组件是一个适配器,它负责将 Connector组件和 Engine容器适配连接起来。把接
收到的客户端请求报文解析生成的请求对象和响应对象 Response传递到 Engine容器交由容器处理。第6章 Connector组件
目前 Tomcat支持两种 Connector,分别是支持HTP协议与AJP协议的 Connector,用于
接收和发送HTP、AJP协议请求。 Connector组件的不同体现在其协议及IO模式的不同,所
以 Connector包含的 Protocol组件类型为: Httpll protocol、Ht1 NioProtocol、Htpl| AprProtocol
Ajp Protocol, AjpNioProtocol F Ajp AprProtocol
HttpConnector所支持的协议版本为HTTP/1.1和HTTP/1.0,无须显式配置HTTP的版本,
Connector会自动适配版本。每个 Connector实例对应一个端口,在同个 Service实例内可以配
置若干 Connector实例,端口必须不同,但协议可以相同。 Http Connector包含的协议处理组件有
Httpl1protocol( Java blo模式)、Hψpl| NioProtocol( Java nio模式)和 Http l laprprotocoL( APR/native
模式)。 Tomcat启动时根据 server xml的<( Connector>节点配置IO模式,BO模式为 org.apache
coyote.httpl1.Http11protocoL,NioFaRt>org.apache.coyote.http11.htp11niopRotocol,apr/natIve
模式为org.apache.coyotehttpl1.Http11aprprotocoL
AJP Connector组件用于支持AJP协议通信,当我们想将Web应用中包含的静态内容交给
Apache处理时, Apache与 Tomcat之间的通信则使用AJP协议,目前标准协议为AJP/13。AJP
Connector包含的协议处理组件有 AjpProtocol( Java bio模式)、 AjpNioProtocol( Java NIc模
式)和 AjpAprProtocol( APR/native模式)。 Tomcat启动时根据 server xml I的< Connector节点
配置IO模式,BIO模式为 org.apache. coyote.ajp. AjpProtocol,NIO模式为org. apache: coyote.
ajp. AjpNioProtocol, APR/native #Art* org. apache. coyote. ajp. AjpAprProtocol
Connector也在服务器端提供了SSL安全通道的支持,用于客户端以 Https方式访问,
可以通过配置 server x的< Connector>节点 SSLEnabled属性开启。
在BIO模式下,对于每个客户端的请求连接都将消耗线程池里面的一条连接,直到整个
请求响应完毕。此时,如果有很多请求几乎同时到达 Connector,当线程池中的空闲线程用完
后,则会创建新的线程,直到达到线程池最大线程数。但如果此时还有更多请求到来,虽然线
程池已经处理不过来,但操作系统还是会将客户端接收起来放到一个队列里,这个队列的大小
通过 SocketServer设置 backlog而来。如果还是有再多的请求过来,队列已经超过了 SocketServer
的 backlog大小,那么连接将直接被拒绝掉,客户端将收到“ connection refused”报错。
在NIO模式下,则是所有客户端的请求连接先由一个接收线程接收,然后由若干(一般
为CPU个数)线程轮询读写事件,最后将具体的读写操作交由线程池处理。可以看到,以这
种方式,客户端连接不会在整个请求响应过程占用连接池内的连接,它可以同时处理比BO
模式多得多的客户端连接数,此种模式能承受更大的并发,机器资源使用效率高很多。另外,
APr/native模式也是NO模式,它直接用本地代码实现NIO模式。
61HTP阻塞模式协议— Httpllprotocol
Httpllprotocol表示阻塞式的HTTP协议的通信,它包含从套接字连接接收、处理、响应
客户端的整个过程。它主要包含 JloEndpoint组件和 Httpllprocessor组件。启动时, Jloendpoint
6461HTTP阻塞模式协议—Ht1Protocol
组件将启动某个端口的监听,一个请求到来后将被扔进线程池,线程池进行任务处理,处理过
程中将通过协议解析器Httpliprocessor组件对HTTP协议解析,并且通过适配器Adapter匹配
到指定的容器进行处理以及响应客户端。当然,整个过程相对比较复杂,涉及很多组件。下面
会对此更深入地分析,HTTP阻塞模式的协议整体结构如图62所示。
Httpllprotocol
JloEndpoint
Aco创建 Socket
扔进线程池
的任务队列
Executor
CCC
读写
操作系统底层
Httpllprocessor
请求
响应
InternalInput Buffer
InternalOutputBuffer
图6.2HTP阻塞模式的协议结构图
6.1.1套接字接收终端 JloEndpoint
需要一个组件负责启动某端口监听客户端的请求,负责接收套接字连接,负责提供一个线
程池供系统处理接收到的套接字连接,负责对连接数的控制,负责安全与非安全套接字连接的
实现等,这个组件就是 JioEndpoint。它所包含的组件可以用图6.3表示,其中包含连接数控制第6章 Connector组件
器 Limitlatch、 Socket接收器 Acceptor、套接字工厂 ServerSocketFactory任务执行器 Executor、
任务定义器 SocketProcessor。下面将对每个组件的结构与作用进行解析。
Jloendpoint
创建
ceptor
扔进线程池
子队
的任务
列
Executor
Limitlatch
Server SocketFacto
Recv
数据1
读写
数据2
操作系统底层
▲图6.3套接字接收终端
1.连接数控制器— Limitlatch
作为Web服务器, Tomcat对于每个客户端的请求将给予处理响应,但对于一台机器而言,
访问请求的总流量有高峰期且服务器有物理极限。为了保证Web服务器不被冲垮,我们需要
釆取一些保护措施,其中一种有效的方法就是采取流量控制。需要稍微说明的是,此处的流量
更多地是指套接字的连接数,通过控制套接字连接个数来控制流量。如图6.4所示,它就像在
流量的入口增加了一道闸门,闸门的大小决定了流量的大小,一旦达到最大流量,将关闭闸门,
停止接收,直到有空闲通道。
▲图6.4连接数控制器
6661HTTP阻塞模式协议——Htp11Protocol
Tomcat的流量控制器是通过AQS并发框架来实现的,通过AQS实现起来更具灵活性和
定制性。思路是先初始化同步器的最大限制值,然后每接收一个套接字就将计数变量累加1,
每关闭一个套接字将计数变量减1,如此一来,一旦计数变量值大于最大限制值,则AQS机
制将会将接收线程阻塞,而停止对套接字的接收,直到某些套接字处理完关闭后重新唤起接收
线程往下接收套接字。我们把思路拆成两部分,一是使用AQS创建一个支持计数的控制器,
另一个是将此控制器嵌入处理流程中。
)控制同步器,整个过程根据AQS推荐的自定义同步器的做法进行,但并没有使用
AQS自带的状态变量,而是另外引入一个 AtomicLong类型的 count变量用于计数。具体
代码如下。控制器主要通过 countUpOrAwait和 countDown两个方法实现计数器的加减操作,
countUpOrAwait方法中,当计数超过最大限制值时则会阻塞线程, countDown方法则负责
递减数字和唤醒线程。
public class limitLatch
private class Sync extends Abstractqueuedsynchronizer
public Sync()()
oVerride
protected int tryAcquireShared (int ignored) f
long newCount = count. incrementAndGet()i
if (newCount limit)(
count. decrementAndget()
return -1
s else
return 1:
@override
protected boolean tryReleaseShared(int arg)i
count. decrementAndget oi
return true i
private final Sync sync;
private final AtomicLong count;
private volatile long limiti
public LimitLatch(long limit) i
this limit limit
this count new Atomiclong(0)i
this sync= new Sync()i
67第6章 Connector组件
public void countUporAwait() throws InterruptedException
sync. acquireSharedInterruptibly(1)i
public long countDown() t
sync. releaseshared(o)i
long result count get()i
return resulti
2)对于流程嵌入控制器,伪代码如下。其中,首先初始化一个最大限制数为200的
连接数控制器( Limitlatch),然后在接收套接字前尝试累加计数器或进入阻塞状态,接
着接收套接字,对套接字的数据处理则交由线程池中的线程。它处理需要一段时间,假
如这段时间内又有200个请求套接字,则第200个请求会导致线程进入阻塞状态,而不
再执行接收动作,唤醒的条件是线程池中的工作线程处理完其中一个套接字并执行
coυ untDown操作。需要额外说明的是,当到达最大连接数时,操作系统底层还是会继续
接收客户端连接,但用户层已经不再接收,操作系统的接收队列长度默认为100,可以通
过 server xml的< Connector>节点的 acceptCount属性配置。 Tomcat同时接收客户端连接数
的默认大小为200,但可以通过 server. xm1的< Connector>节点的 max Connections属性进行
调节, Tomcat bIc模式下 Limitlatch的限制数与线程池的最大线程数密切相关,它们之间
的比例是1:1。
LimitLatch limitlatch new LimitLatch(200)i
创建 server socket实例;
While(true)
limitLatch. countUpOrAwait()i
Socket socket serverSocket accept()i
socket交由线程池处理,处理完执行1 imitlatch. count Down();
2. Socket接收器— Acceptor
Acceptor主要的职责就是监听是否有客户端套接字连接并接收套接字,再将套接字交由任
务执行器( Executor)执行。它不断从系统底层读取套接字,接着做尽可能少的处理,最后扔
进线程池。由于接收线程默认就只有一条,因此这里强调要做尽可能少的处理,它对每次接收
处理的时间长短可能对整体性能产生影响。
于是接收器所做的工作都是非常少且简单的,仅仅维护了几个状态变量,负责流量控制闸
门的累加操作和 Server Socket的接收操作,设置接收到的套接字的一些属性,将接收到的套接
字放入线程池以及一些异常处理。其他需要较长时间处理的逻辑就交给了线程池,例如对套接
686.1HTTP阻塞模式协议——Htt11Protocol
字底层数据的读取,对HTTP协议报文的解析及响应客户端的一些操作等,这样处理有助于提
升系统处理响应性能。此过程如图6.5所示。
A
(server Socket accept
简单处理后扔进
线程池的任务队列
LimitLatch
线程池
Recv
数据1
「数据2
操作系统底层
▲图6.5套接字接收器
用一段简化的伪代码表示接收器处理的过程:
public class Acceptor implements Runnable t
public void run()t
while(true)(
1 imi latch, countuporAwait();∥流量控制闸门信号量加1
Socketsocket serverSocket accept()i
设置套接字的一些属性;
将接收的套接字扔进线程池;
3.套接字工厂— Server SocketFactory
接收器 Acceptor在接收连接的过程中,根据不同的使用场合可能需要不同的安全级别,
例如安全性较高的场景需要对消息加密后传输,而在另外一些安全性要求较低的场合则无须对
消息加密。反映到应用层则是使用HTTP与Https的问题。
图6.6为 Https的组成层次图,它在应用层添加了一个 SSL/TLS协议,于是组成了 Https
简单来说, SSL/TLS协议为通信提供了以下服务:
①提供验证服务,验证会话内实体身份的合法性;
②提供加密服务,强加密机制能保证通信过程中的消息不会被破译;
③提供防篡改服务,利用Hash算法对消息进行签名,通过验证签名保证通信内容不
9第6章 Connector组件
被篡改。
Http
应用层
TLSISSL
TCP
传输层
网络层
链路协议
链路层
▲图6.6HTPS层次图
Java为开发者提供了方便的手段实现SSL/TLS协议,即安全套接字,它是套接字的安全
版本。Tomcat作为web服务器必须满足不同安全级别的通道,HTTP使用了套接字,而Https
则使用了 SSLSocket,由于接收终端根据不同的安全配置需要产生不同类别的套接字,于是引
入了工厂模式处理套接字,即是 ServerSocket Factory工厂类。另外,不同厂商可自己定制SSL
的实现。
Server SocketFactory是 Tomcat接收端的重要组件。先看看它的运行逻辑。 Tomcat中有两个工
厂类 DefaultServer Socket Factory和 JSSESocketFactory,它们都实现了 ServerSocket Factory接口,
分别对应HTP套接字通道与 Https套接字通道。假如机器的某端口使用加密通道,则由
JSSESocketFactory作为套接字工厂,反之则使用 DefaultServer SocketFactory作为套接字工厂,于
是 Tomcat中存在一个变量 SSLEnabled用于标识是否使用加密通道,通过对此变量的定义就可以
决定使用哪个工厂类, Tomcat提供了外部配置文件供用户自定义。
实际上,我们通过对 server. xm进行配置就可以定义某个端口开放并指出是否使用安全通
道,例如:
①HTTP协议对应的非安全通道的配置如下。
<service>
<conNectorexecutor=tomcatthreadpool"port=8080protocol="http:/1.1
connectionTimeout="20000" redirectPort=8443"/>
</service>
706.1HTTP阻塞模式协议——Htp11Protoco
② Https协议对应的安全通道的配置如下。
<service>
<conNectorport=8443"protocol="http:/1.1"sslenabled="true"maxthreads="150
scheme="https"secure=true"clientauth="false"sslprotocol=tls"7>
</service>
第一种配置告诉Tomcat开放8080端口并使用HTTP1.1协议进行非安全通信。第二种配
置告诉 Tomcat开放8443端口并使用HTP11协议进行安全通信,其中使用的安全协议是TLS
协议。需要注意的是加粗字体的 SSLEnabled="tue",此变量值会在 Tomcat启动初始化时读入
自身程序中,运行时也正是通过此变量判断使用哪个套接字工厂, Default Server SocketFactory
还是 JSSESocket Factory
把 ServerSocketFactory工厂组件引入后,整个结构图如图67所示。
创建
Acceptor
Socket Processor
扔进线程池
的任务队列
LimitLatch
Executor
ServerSocketFactory
Reco
datal
data2
口p
操作系统底层
▲图6.7套接字工厂
4.任务执行器— Executor
上一节提到接收器 Acceptor在接收到套接字后会有一系列简单的处理,其中将套接字放
入进线程池是重要的一步。这里重点讲 Tomcat中用于处理客户端请求的线程池— Executor
为确保整个web服务器的性能,应该在接收到请求后以最快的速度把它转交到其他线程
上去处理。在接收到客户端的请求后这些请求被交给任务执行器 Executor,它是一个拥有最大
最小线程数限制的线程池。之所以称之为任务执行器,是因为可以认为线程池启动了若干线程第6章 Connector组件
不断检测某个任务队列,一旦发现有需要执行的任务则执行。如图6.8所示,每个线程都不断
循环检测任务队列,线程数量不会少于最小线程数也不能大于最大线程数
Executor
▲图6.8任务执行器
任务执行器的实现使用JUC工具包的 Thread PoolExecutor类,它提供了线程池的多种机制,
例如有最大最小线程数限制、多余线程回收时间、超出最大线程数时线程池做出的拒绝动作等。
继承此类并重写一些方法基本就能满足 Tomcat的个性化需求
Connector组件的 Executor分为两种类型:共享 Executor和私有 Executor
所谓共享 Executor则指直接使用 Service组件的线程池,多个 Connector可以共用这些线
程池。可以在 server.xml文件中通过如下配置进行配置,先在< Service>节点下配置一个
< Executor->,它表示该任务执行器的最大线程数为150,最小线程数为4,线程名前缀为
catalina-exec-,并且命名为 tomcat Threadpool。< Connector>节点中指定以 tomcatThreadpool作
为任务执行器,对于多个 Connector,如图69所示,可以同时指向同一个 Executor,以达到共
享的目的。
E
xecutor
Connector
Connector
rotocol
P
Protocol
Endpoint
Endpoint
Acceptor Executor
Acceptor Executor
▲图6.9共享 Executor
<Service>
<Executorname=tomcatThreadPool'namePrefix="catalina-exec-"maxThreads="150
minSpareThreads="4"/>
<coNnectorexecutor=tomcatthreadpool"port=8080protocol="http:/1.1"
connectionTimeout="20000 redirectport=8443"/>
</Service>
726.1HTTP阻塞模式协议—Htp11Protocol
所谓私有 Executor是指< Connector>未使用共享线程池,而是自己创建线程池。如下面
的配置所示,第一个 Connector配置未引用的共享线程池,所以它会为该 Connector创建
个默认的 Executor,它的最小线程数为10,最大线程数为200,线程名字前缀为TP-exec
线程池里面的线程全部为守护线程,线程数超过10时等待60秒,如果还没任务执行将销
毁此线程;第二个 Connector配置未引用的共亨线程池,但它声明了 max Threads和
minSpare Threads属性,表示私有线程池的最小线程数为 minSpare Threads,而最大线程数
为 max Threads。第一个 Connector和第二个 Connector各自使用自己的线程池,这便是私有
Executor。
<Service>
<coNnectorport=8080"protocol="http:/1.1"connectiontimeout=20000redirect
Port="8443"/>
<Connector port=8009"protocol="AJP/1.3"redirectPort=8443"maxThreads=200
minSpare Threads=10/>
</Service>
5.任务定义器— SocketProcessor
将套接字放进线程池前需要定义好任务,而需要进行哪些逻辑处理则由 SocketProcessor
定义,根据线程池的约定,作为任务必须扩展 Runnable。具体操作用如下伪代码表示。
protected class SocketProcessor implements Runnable
public void run ()
对套接字进行处理并输出响应报文;
连接数计数器减一腾出通道;
关闭套接字;
Socket Processor的任务主要分为三个:处理套接字并响应客户端,连接数计数器减1,关
闭套接字。其中对套接字的处理是最重要也是最复杂的,它包括对底层套接字字节流的读取,
HTP协议请求报文的解析(请求行、请求头部、请求体等信息的解析),根据请求行解析得
到的路径去寻找相应虚拟主机上的web项目资源,根据处理的结果组装好HTTP协议响应报
文输出到客户端。此部分是Web容器处理客户端请求的核心,接下来将一一剖析。引入任务
定义器后,整个模块如图6.10所示。
6.1.2HTTP阻塞处理器—Htte1Processor
Httpllprocessor组件提供了对HTTP协议通信的处理,包括对套接字的读写和过滤,对
HTTP协议的解析以及封装成请求对象,HTP协议响应对象的生成等操作。其整体结构如
图6.11所示,其中涉及的更多细节将在下面展开介绍。第6章 Connector组件
创建
Acceptor
SocketProcessor
扔进线程池
的任务队列
Executor
ServerSocketFactory
1到到
Recto
数据
数据2
操作系统底层
▲图6.10任务定义器
Httpll processor
请求
国自目
Cookies
响应
Mimeheaders
MimeHeaderFieldMirmeHeaderField
Action Hook
m 5 oupu
ut Buffe
InternalInputBuffer
InternalOutputBuffer
fiLte
OutputFil
Socket
Socket OutputBut
操作系统底层
操作系统底层
▲图6.11HTTP阻塞处理器6.1HTTP阻塞模式协议—Http1proTocol
1.套接字输入缓冲装置—— InternallnputBuffer
互联网中的信息从一端传向另一端的过程相当复杂,中间可能通过若干个硬件。为了提高
发送和接收效率,在发送端及接收端都将引入缓冲区,所以两端的套接字都拥有各自的缓冲区
当然,这种缓冲区的引入也带来了不确定的延时,在发送端一般先将消息写入缓冲区,直到缓
冲区填满才发送,而接收端则一次只读取最多不超过缓冲区大小的消息。
Tomcat在处理客户端的请求时需要读取客户端的请求数据。它同样需要一个缓冲区,用
于接收字节流,在 Tomcat中称为套接字输入缓冲装置。它主要的责任是提供一种缓冲模式,
以从Socket中读取字节流,提供填充缓冲区的方法,提供解析HTTP协议请求行的方法,提
供解析HTTP协议请求头的方法,以及按照解析的结果组装请求对象Request
套接字输入缓冲装置的工作原理并不会复杂,如图6.12所示, InternalInput Buffer包含以
下几个变量:字节数组butf、整型pos、整型 last valid、整型end。其中buf用于存放缓冲的字
节流,它的大小由程序设定, Tomcat中默认设置为8*1024,即&KB;pos表示读取指针,读
到哪个位置值即为多少; last valid表示从操作系统底层读取数据填充到buf中最后的位置;end
表示缓冲区buf中HTTP协议请求报文头部结束的位置,同时也表示报文体的开始位置。
在图6.12中从上往下看,最开始缓冲区buf是空的。接着读取套接字操作系统底层的若干字
节流读取到buf中,于是状态如②所示,读取到的字节流将buf从头往后进行填充,同时pos
为0, last Valid为此次读取后最后的位置值。然后第二次读取操作系统底层若干字节流,每次
读取多少并不确定,字节流应该接在②中 last valid指定的位置后面而非从头开始,此时pos
及 last valid根据实际情况被赋予新值。假如再读取一次则最终状态为⑤,多出了一个end变量,
它的含义是HTTP请求报文的请求行及请求头部结束的位置。
buf
last Vald
buf
buf
z last Vald
buf
end last Vald
lL
▲图6.12套接字输入缓冲装置的工作原理第6章 Connector组件
为了更好地理解如何从底层读取字节流并进行解析,下面将给出简化的处理过程。首
先需要一个方法提供读取字节流,如下所示。其中 inputStream代表套接字的输入流,通过
socket. getInputstreamo获取,而read方法用于读取字节流,它表示从底层读取最多
( buf length- -last valid长度的字节流,且把这些字节流填入buf数组中,填充的位置从 buflpos
开始, n Read表示实际读取到的字节数。通过对上面这些变量的操作,则可以准确操作缓
冲装置,成功填充并返回true。
public class InternalInputBuffer(
byte[] buf=new byte[8*1024]i
int pos=0;
int lastvalid=0;
public boolean fill(f
int nRead inputstream read(buf, pos, buf length
lastvalid)i
if (nRead >0)t
lastvalid= pos nRead
return (nRead >0)i
有了填充的方法,接下来需要一个解析报文的操作过程,下面以解析请求行的方法及路径
为例子进行说明,其他的解析也按照类似的操作。HTP协议请求报文的格式如图613所示,
请求行一共有3个值需要解析出来:请求方法、请求URL及协议版本,以空格间隔并以回车
换行符结尾。解析方法如下。
请求行
「请求方法空格UR空格协汉版本工
字段名
值
n
请求头部
「字段名值工m
r
请求体
请求体的内容
▲图6.13HTTP请求报文的格式61HTP阻塞模式协议—Htt11 Protocol
public boolean parseRequestLine()(
int start =0:
byte chr =0
boolean space
false
hile ( space)(
if (pos > lastvalid)
fi11();
if (buf [pos]==(byte)')t
space true;
byte[] methodB new byte [pos - start]i
System. arraycopy(buf, start, methodB,0, pos -start)
String method new String(methodB)i
request. setMethod(method)
post+
while (space) i
if (pos > lastvalid)
fi11();
if (buf [pos]==(byte)
pos++i
else
space false
start = pos
while ( space) t
if (pos > lastvalid)
fi11()
if (buf [pos]
te)
space true;
byte[] uriB= new byte [pos-start]i
System. arraycopy(buf, start, uriB ,0, pos-start)i
String uri= new String (uriB)i
request. setUri(uri)i
pos++i
return true
第一个 while循环用于解析方法名,每次操作前必须判断是否需要从底层读取字节流。当
pos大于等于 last Valid时,即需要调用fi方法读取。当字节等于ASCI编码的空格时,就截取-
第6章 Connector组件
start到pos之间的字节数组,它们便是方法名的字节组成,转成 String对象后设置到 request对
象中。第二个 while循环用于跳过方法名与URI之间所有的空格。第三个 while循环用于解析
URI,它的逻辑与前面方法名解析的逻辑差不多,解析到的URI最终也设置到 request对象里中。
至此,整个缓冲装置的工作原理基本搞清楚了。一个完整的过程是从底层字节流的读取到
对这些字节流的解析并组装成一个请求对象 request,方便程序后面使用。由于每次从底层读
取到的字节流的大小都不确定,因此通过对pos、 last valid变量进行控制,以完成对字节流的
准确读取接收。除此之外,输入缓冲装置还提供了解析请求头部的方法。处理逻辑是按照HTP
协议的规定对头部解析,然后依次放入 request对象中。需要额外说明的是, Tomcat实际运行
中并不会在将请求行、请求头部等参数解析后直接转化为 String类型设置到 request中,而是
继续使用ASCI码存放这些值,因为对这些ASC∏l码转码会导致性能问题。其中的思想是只
有到需要使用的时候才进行转码,很多参数没使用到就不进行转码,以此提高处理性能。这方
面的详细内容在6.1.2节的“请求— Request”会涉及。最后附上套接字输入缓冲装置的结构
图,如图6.14所示。
InternalInputBuffer
wi i buf
InputFilter
des Buf
Inputfilte
InputStreamInputBuffer
Recv
数据1
数据2
操作系统底层
▲图6.14套接字输入缓冲装置
消息字节— Message Bytes
上一节提到, Tomcat不会直接将解析出来的HTP协议直接转成Sng类型保存到 request
中,而是保留字节流的形式,在需要时才进行转码工作,以此提高处理性能。 MessageBytes
正是为解决这个问题而提出的一个类。61HTP阻塞模式协议——Htp11 Protocol
消息字节封装了不同的类型用于表示信息,它包含4种类型: T BYTES、 T CHARS、
TSTR、 T NULL,分别表示字节类型、字符类型、字符串类型、空。由于Web服务器使用 ASCII
码通信,对应的是字节,因此这里选取 T BYTES类型作为案例进行说明,其他类型与之类似。
消息字节的使用方法很简单,假如有一个字节数组byte[ buffer,该数组从第3~20下标之间的
字节数组组成的字符表示 Request对象中方法变量的值,那么用以下代码简单表示。
①请求对象类的代码如下。
public class Request i
MessageBytes methodMB= new MessageBytes(
public Me ssageBytes method (
return me thodmB
②设置请求对象属性的代码如下。
Request request= new Request()i
request method(). setBytes(buffer, 3, 18)i
执行上面操作后就完成对字节数组某段的标记操作,方便以后获取指定的一段字节数组。
参照图6.15,你可以用多个消息字节对 buffer标记,例如,对请求变量、协议版本等变量进行
标记,每个消息字节实例标识了一段字节数组,可以通过如下代码获取并转为字符串类型
request method(). tostring()i
消息字节
消息字节
消息字节
消息字节
消息字节
buffer
▲图6.15 MessageBytes类
使用起来很简单,接着介绍实际的实现原理。为了化繁为简,由于 Tomcat底层接收的是字
节流,因此只考虑 T BYTES的情况。可以看到消息字节里面其实由字节块( Byte Chunk)实现,
这里只体现本节相关的操作方法,所以例子中的 Byte Chunk并不包含缓冲的相关操作方法。
① MessageBytes类的代码如下。
public class MessageBytes i
private final Bytechunk btec new Byte Chunk()i
public void setBytes(byte[] b, int off, int len)t
79第6章 Connector组件
byte. setBytes(b, off, len)i
public String tostring()
return btec tostring ()i
② Byte Chunk类的代码如下。
public class Bytechunk i
private byte [ buff;
private int start =0;
private int end;
public void setBytes(byte[] b, int off, int len)
buff bi
start
off
end start len:
public String tostring()(
Charset charset=Charset forName ("ISO 8859 1")
CharBuffer ch= charset decode(ByteBuffer wrap(buff, start,
end start))i
return new string(cbarray(), cb. arrayoffset(), cb length())
前面的示例中, request method. setBytes(buffer,3,18)其实调用了 Byte Chunk的 setBytes方
法,把字节流及始末坐标设置好。后面 request. method to String同样调用了 Byte Chunk的 toString
方法,根据指定编码进行转码,这里是ISO_88591。这样一来就达到了延迟处理模式的效果,
在需要时才根据指定编码转码并获取字符串,如果不需要,则无须转码,处理性能得到提高
Tomcat对于套接字接收的信息都用消息字节表示,好处是实现一种延迟处理模式,提高
性能。实际上, Tomcat还引入了字符串缓存,在转码之前会先从缓存中查找是否有对应的编
码的字符串,如果存在,则不必再执行转码动作,而直接返回对应的字符串,性能进一步得到
优化。为了提高性能,我们必须要多做一些额外的工作,这也是 Tomcat接收到的信息不直接
用字符串保存的原因。
字节块— Byte Chunk
上一节在模拟消息字节的实现时使用了一个没有缓冲的 Byte Chunk,本小节将讲解 Tomcat
真正使用的 Byte Chunk。它是一个很重要的字节数组处理缓冲工具,它封装了字节缓冲器及对字
806.1HTP阻塞模式协议——Ht11 Protocol
节缓冲区的操作,包括对缓冲区的写入、读取、扩展缓冲区大小等。另外,它还提供相应字符编
码的转码操作,使缓冲操作变得更加方便。除了缓冲区之外,它还有两个通道— - Bytelnput( hannel
和 ByteOutput Channel,一个用于输入读取数据,一个用于输出数据,并且会自动判断缓冲区是否
超出规定的缓冲大小,一旦超出,则把缓冲区数据全部输出。
如图6.16所示,缓冲区buf负责存放待输出的字节数组,此区域有初始值及最大值,在
运行时会根据实际进行扩充,一旦到达最大值则马上输出到指定目标。此外,还定义了两个内
部接口— ByteInput Channel和 ByteOutputChannel,一般可以认为,一个用于读取数据,一个
用于输出数据。另外,它还包含 Charset对象,借助它,可以方便转码工作。
ByteChunk
end
Charset
▲图6.16 ByteChunk
下面用一个简化例子说明字节块的工作机制。为使例子简洁,这里省去了很多方法和
Charset对象,只展示缓冲的工作机制。
①字节块 Byte Chunk的简化实现如下所示。其中包含数据读取输出接口、内存分配方法
allocate、缓冲区字节添加方法 append、缓冲区扩容方法 make space及缓冲区刷新方法 flush Buffer
public final class ByteChunk t
public static interface ByteInput channel i
public int realReadBytes(byte cbuf[], int off, int len)
throws IOException;
public static interface ByteOutputchannel t
public void realWriteBytes(byte cbuf[], int off, int len)
throws IOException;
private byte[] buffi
private int start =0;
private int end;
private int limit =-li
81第6章 Connector组件
private ByteInputchannel in = nulli
private ByteOutputChannel out null
public Bytechunk()
public void allocate(int initial, int limit)(
if (buff = null buff. length initial)(
buff new byte[initially
this limit limiti
start 0
end =0
public void setByteInput Channel(ByteInputChannel in)(
this in in:
public void setByteOutput Channel(ByteOutputchannel out
this out out
public void append(byte b)throws IOException
make Space(1)i
if (limit >0 & end > limit)(
flushBuffer();
buff [end++]= bi
public void flushBuffer() throws IOException i
out. realWriteBytes(buff, start, end - start)i
end
start
private void make Space (int count)
byte[] tmp null;
int newSize= buff. length 2
if (limit >0&& newsize limit)(
newSize = limit
tmp new byte [newsize]i
System. arraycopy(buff, start, tmp, 0, end -start)i
buff tm
tmp nulli
end end start:
start =0:
②输出测试类 Output Buffer的实现如下所示。此类使用字节块提供的缓冲机制对D盘的
826.1HTTP阻塞模式协议——Htp11Protocol
hello. txt文件进行写入操作。为更好地说明缓冲区的工作原理,把字节块的缓冲区初始大小设
置为3,最大值为7,我们要把8个字节码写到helo.txt文件中。注意加粗的三行代码,执行
downie方法时因为字节长度为8,已经超过了缓冲区最大值,所以进行了一次真实的写入操作,
接着让程序睡眠10秒,期间你打开 hello, txt文件时只能看到7个字节数组,它们为1~7(以
十六进制形式打开)。10秒后,由于执行了fush(刷新)操作才把剩下的一个字节写入文件中。
public class OutputBuffer implements ByteChunk ByteOutput Channel
private Bytechunk fileBufferi
FileOutputstream fileOutputstream
public outputBuffer ()
fileBuffer new ByteChunk()i
fileBuffer. setByteOutputchannel(this)i
fileBuffer allocate(3,7)i
try i
fileOutputstream new Fileoutputstream("d: hello. txt")
y catch (FileNotFoundException e) i
e printstackTrace()i
public void realWriteBytes(byte cbuf[], int off, int len)
throws IOException t
fileOutputstream write(cbuf, off, len)i
public void flush()throws IOException t
fileBuffer. flushBufferoi
public int dowrite(byte[] bytes) throws IOException i
for (int i =0; 1< byteslength; 1++)
fileBuffer. append(bytes[i])i
return bytes length
public static void main (String[] args) throws InterruptedException t
OutputBuffer outputBuffer new OutputBuffer()i
byte[ bytes
1
3,4,5,6,7,8}
try i
outputBuffer. dowrite(bytes)i
Thread currentThread(). sleep(10*1000)i
outputBuffer. flush()i
y catch (IOException e)
e printstackTrace()i
83第6章 Connector组件
字节块是一个很有用的工具类,它提供了缓冲工具,从而方便我们为某些流添加缓冲
区。类似的工具还有字符块 Char Chunk,顾名思义,它专门用于为字符类型的数据提供缓
冲操作。
套接字输入流— nputstream
输入缓冲装置里面必须要包含读取字符的通道,否则就谈不上缓冲了,这个通道就是
InputStream。它属于JDK的 Java.10包的类,有了它,我们就可以从源头读取字符。它的来源
可以有多种多样,这里主要探讨的是从套接字连接中读取字符。
如图6.17所示, Inputstream充当从操作系统底层读取套接字字节的通道。当客户端与服
务器端建立起连接后,就可以认为存在一条通道供双方传递信息,客户端写入的字符串通过通
道传递到服务器端,应用层则通过 InputStream读取字节流。
Recv
数据1
数据2
操作系统底层
图6.17套接字输入流
应用层接收到的每个消息的最小单位为8位。为方便后续转码处理,我们希望获取到原生
的字节流。用以下简化代码说明客户端传输字节到服务器端的过程。服务器端创建服务以后,
开始等待客户端发起连接,客户端与服务器端建立连接后;通过 OutputStream向服务器端写
入字节数组,而服务器端通过 InputStream将客户端传过来的字节数组读取到 buffer中,接着
就可以往下对 buffer进行其他处理,比如解码操作。套接字输入缓冲装置就是通过lpuSπrean
将字节读取到缓冲装置,并且提供对HTTP协议的请求行、请求头部等的解析方法。其中HTTP
协议请求行及头部规定使用ASCI编码,字节与之对应。
①服务器端的代码如下。
Server Socket server new ServerSocket(8080)i
Socket socket server accept()i
Inputstream in =socket. getInputstream()i
846.1HTTP阻塞模式协议—Htp11Protocol
byte[] buffer new byte[5]i
int i in read (buffer)i
socket. close()
②客户端的代码如下
Socket client= new Socket("127.0.0.l",8080)
Outputstream out client getoutputstream()
byte[] bytes={1,1,1,1,1};
out write(bytes)i
client. close()i
请求体读取器—— nput StreamInputBuffer
前面提到,套接字缓冲装置 InternalInput Buffer用于向操作系统底层读取来自客户端的消
息并提供缓冲机制,把报文以字节数组形式存放到buf中。同时它提供了HTTP协议的请求行
和请求头部的解析方法,当它们都被解析完成后,buf数组中指针指向的位置就是请求体的起
始位。web容器后期可能需要处理HTTP报文的请求体,所以必须提供一个获取的通道。这
个通道就是请求体读取器 InputStreamInputBuffer,它其实是套接字缓冲装置的内部类。它仅有
个 drEad方法用于读取请求体报文,此方法会自行判断缓冲数组buf的已读指针是否已到
达尾部,如果到达尾部,则重新读取操作系统底层的字节,最终读取到目标缓冲区 des Buf上
如图6.18所示, InputstreamInputBuffer包含在套接字缓冲装置中,通过它可以将请求体
读取到目标缓冲区 des Buf上
InternalInput Buffe
E Input StreamInputBuffer
debUt
Recy
数据
操作系统底层
▲图6.18请求体读取器第6章 Connector组件
输入过滤器— InputFilter
一般情况下,我们通过请求体读取器 InputStreamInput Buffer获取的仅仅是源数据,即未
经过任何处理发送方发来的字节。但有些时候在这个读取的过程中希望做一些额外的处理,而
且这些额外的处理可能是根据不同的条件做不同的处理。考虑到程序解耦与扩展,于是引入过
滤器(过滤器模式)—输入过滤器 InputFilter。在读取数据过程中,对于额外的操作,只需
要通过添加不同的过滤器即可实现,例如添加对HTTP1.1协议分块传输的相关操作的过滤器。
如图6.19所示,在套接字输入缓冲装置中,从操作系统底层读取的字节会缓冲在buf中,
请求行和请求头部被解析后,缓冲区buf的指针指向请求体的起始位置,通过请求体读取器
InputStreamInputBuffer可进行读取操作,它会自动判定buf是否已经读完,读完则重新从操
作系统底层读取字节到buf中。当其他组件从套接字输入缓冲装置读取请求体时,装置将判
定其中是否包含过滤器,假设包含,则通过一层层的过滤器完成过滤操作后才能读取到
des Buf。这个过程就像被加入了一道道处理关卡,经过每一道关卡都会执行相应的操作,最
终完成源数据到目的数据的操作。
InternalInputBuffer
buf
InputFilter
des Buf
InputFilter
InputStreamInputBuffer
Reco
数据1
「数据2
操作系统底层
▲图6.19输入过滤器
过滤器是一种设计模式,在Java的各种框架及容器中都频繁地使用以实现更好的扩展性
和逻辑解耦。下面用一个例子看看过滤器如何工作。
866.1HTTP阻塞模式协议—Htt11Protocol
①输入缓冲接口Iηpυ ut Buffer,;提供读取操作。
public interface InputBuffer i
public int doRead(byte[] chunk) throws IOException;
②输入过滤器接口 InputFilter,继承 InputBuffer类,额外提供 setBuffer方法以设置前
个缓冲
public interface InputFilter extends InputBuffer i
public void setBuffer(InputBuffer buffer)i
③输入缓冲装置,模拟通过请求体读取器 InputStreamInputBuffer从操作底层获取请求体
字节数组,并且包含若干个过滤器,缓冲装置在执行读取操作时会自动判断是否有过滤器,如
存在则将读取后的字节再经过层层过滤,得到最终的目的数据。
public class InternalInputBuffer implements InputBuffer i
boolean isEnd false
byte[] buf new byte [4li
protected int lastActiveFilter
1
protected InputFilter[] activeFilters new InputFilter[2]i
InputBuffer inputStreamInputBuffer =(InputBuffer) new InputstreamInput
Buffer(i
public void addActiveFilter(InputFilter filter)(
if (lastActiveFilter
1
filter setBuffer(inputstreamInputBuffer)i
y else t
for (int i =0; i < lastActiveFilteri i++)
if (activeFilters[i]== filter
return
filter setBuffer(activeFilters [lastActiveFilter])
activeFilters [++lastActivefilter]= filter
public int doRead (byte[] chunk) throws IOException
if (lastActiveFilter ==-1
return inputstreamInputBuffer. doRead(chunk)
else
return activeFilters[lastActiveFilter] doRead (chunk)i
87第6章 Connector组件
protected class InputstreamInputBuffer implements InputBuffer
public int doRead(byte[] chunk) throws IOException i
if (isEnd = false) i
buf[o]
buf[1]="b";
uf[2
buf[31
d
System. arraycopy(buf, 0, chunk,0,4)i
isend true
return chunklength
y else i
return -l;
④清理过滤器 Clear Filter,负责将读取的字节数组中的字符a换成f
public class ClearFilter implements InputFilter i
protected InputBuffer buffer
public int doRead (byte[] chunk)throws IOException t
int i buffer. doRead (chunk)i
if(1==-1)
return -1
for (int j=0;3< chunklength; j++)
if (chunk[j]==a)
chunk [j]
f
return li
public InputBuffer getBuffer()
return buffer
public void setBuffer(InputBuffer buffer) t
this buffer buffer;
⑤大写过滤器 UpperFilter,负责将读取的字节数组全部变成大写形式。
public class UpperFilter implements InputFilter t
protected InputBuffer buffer
886.1HTTP阻塞模式协议—Htp1Protoco
public int doRead(byte[] chunk) throws IOException i
int i buffer drEad (chunk
if(i==-1)
return -1
for (int 3=0;3< chunk length; j++)
chunk [j]=(byte)(chunk[j]
A");
return i
public InputBuffer getBuffer((
return buffer
public void setBuffer(InputBuffer buffer)(
this buffer buffer
⑥测试类,创建输入缓冲装置。接着创建清理过滤器和大写过滤器,把它们添加到输入
缓冲装置中。执行读取操作,读取出来的就是经过两个过滤器处理后的数据了,结果为“FBFD”。
如果有其他处理需求,通过实现 InputFilter接口编写过滤器并添加即可。
public class Test
public static void main(String[] args)
InternalInputBuffer internalInputBuffer new InternalInputBuffer()
ClearFilter clearFilter new ClearFilter()i
UpperFilter upperFilter new UpperFilter()
internalInputBuffer. addActiveFilter(clearFilter)i
internalInputBuffer. addActiveFilter(upperFilter)i
byte[] chunk new byte[4]i
try i
int i =0;
while (1 !=-1)(
i internalInputBuffer. doRead (chunk)i
if(i==-1)
break
catch (IOException e)[
e printstackTrace()i
System. out. println(new String(chunk))i
上面的过程基本模拟了 Tomcat输入缓冲的工作流程及原理,但实际使用的过滤器并非上
89第6章 Connector组件
面模拟过程中使用的过滤器。 Tomcat主要包含4个过滤器: IdentityInputFilter、 oidInputFilter
BufferedInputFilter, ChunkedInputFilter
IdentityInputFilter过滤器在HTTP包含content-length头部并且指定的长度大于0时使用,
它将根据指定的长度从底层读取响应长度的字节数组,当读取足够数据后,将直接返回-1,
避免再次执行底层操作。
oidInputFilter过滤器用于拦截读取底层数据的操作,当HTTP不包含content-length头部
时,说明没有请求体,没必要执行读取套接字的底层操作,所以用这个过滤器拦截。
BufferedInputFilter过滤器负责读取请求体并将其缓存起来,后面读取请求体时直接从此缓
冲区读取。
ChunkedInput Filter过滤器专门用于处理分块传输,分块传输是一种数据传输机制,当没有
指定 content-length时可通过分块传输完成通信。
以上就是 Tomcat的套接字缓冲装置中过滤器的机制及其实现方法,同时也介绍了 Tomcat
的输入装置中不同过滤器的功能,过滤器模式能让 Tomcat在后期升级、扩展时更加方便。
2.套接字输出缓冲装置— InternalOutputBuffer
套接字输出缓冲装置就是向客户端提供响应输出的组件,它与套接字输入缓冲装置具有类似
的结构,包含 OutputStream、 OutputStreamOutputBuffer、 Output Filter和 Byte Chunk等元素。其中
OutputStream是套接字的输出通道,通过其将字节写入到操作系统底层; OutputStream OutputBuffer
提供字节流输出的通道,与 OutputFilter组合实现过滤效果; Output Filter即是过滤器组件。这些组
件的结构和作用与前面套接字输入缓存装置的差不多。唯一需要额外说明的是 Byte Chunk组件,
为输出添加了一层缓冲。图6,20为 Internallyψ outBuffer的结构图。
Byte Chunk这个组件大家应该都不陌生了,它的功能就是为某个流添加缓冲功能。添加这个组
件是为了引入缓冲功能, InternalOutput Buffer包含一个变量 use Socket Buffer,用于标识输出是否使用
缓冲(这个缓冲是指Tomc趾t级别的缓冲,不涉及操作系统的缓冲)。如果 useSocketBuffer为tue则
把输出流写入 Byte Chunk里面,再由 Byte Chunk机制写入操作系统底层。如果 useSocketBuffer
为 false,则不经过 Byte Chunk直接通过 OutputStream写入操作系统底层。
3.请求—— -Request
为方便后续处理,同时根据面向对象的思想,我们把每个请求相关的属性及协议字段等抽
象成一个对象— Request
图6.21所示为Request对象的结构。其中包含HTTP请求行相关的字段值,例如请求
方法、请求路径、协议版本。同时,也包含所有的HTTP请求头部,如User-Agent、Content-Type、
Content-Length等,这些头部被封装成 MimeHeaders对象。当然,也包含了我们常用的 Cookies,
它在请求对象中被封装成一个Cookies对象。除此之外,它还包含一些非HTTP协议的属性,
如服务器端口、服务器名称、远程地址、远程端口等。请求对象中的属性值不但可供 Tomcat
906.1HTTP阻塞模式协议——Htt1rotocol
内核处理过程中使用,而且有些属性需要提供给Web应用开发使用。本节将深入介绍请求对
象 Request
InternalOutputBuffer
OutputFilter
OutputBut
ByteChunk
OutputFilter
OutputStream Output Buffer
Sendo
数据1
「数据2
操作系统底层
▲图6.20 nternalOutputBuffer的结构图
Request
MimeHeaders
MimeHeader Field
MimeHeader Field
Cookies
s prev
pre
Server Cook
ServerCooki
ServerCookie
next
i value
a value
maxAge
maxAge
s maxAge
▲图6.21 Request对象的结构
91第6章 Connector组件
请求头部— MimeHeaders
HTTP协议的请求头部像一个键值对,例如Content-Length:123,前面为键,后面为值,
读值表示文本长度为123。对于若干个头部,在请求对象中把它们封装成 Mimeheaders对象,
Mimeheaders对象里面包含了一个链表结构,用于存放头部名和头部值。如图6,2所示,每
个 MimeHeader Field对象指向其前驱节点对象,同时也指向其后继节点对象,采用这种双向链
表结构有利于快速搜索。以 MimeHeader Field作为单位,它代表一个头部,其中包含的name、
value
分别用于保存头部的键-值对。
MimeHeaders
MemeHeader Field
MemeHeader Field
Meme Header Field
prev
prev
prev
next
next
valuename
value name
value name
▲图6.22请求头部
小文本— cookie
HTTP协议的无状态性导致在会话的场景中需要借助其他的机制来弥补。例如,某网站要
实现一段时间内登录过的浏览器客户端自动登录,为实现客户端与服务器之间的会话机制,需
要额外的一些标识,HTTP头部引入的Cookie正是客户端与服务器会话机制的基础。当一个
浏览器通过HTTP协议访问某服务器时,服务器可以将指定的一些键-值对发往客户端。客户
端根据域名保存于本地,下次访问此域名时浏览器会连同这些键-值对发送到服务器端,这样
就实现了服务器与客户端之间的会话机制。
①客户端第一次访问的报文(无 Cookie)如下所示。
Get/Web/Index. jsp Http/1.1
Accept-Language: zh-CN
User-Agent: Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36(KHTML, like Gecko
) Chrome/31.0.1650.63 Safari/537.36
HOST: localhost: 8080
Connection: Keepp-Alive
②服务器响应报文如下所示。
Http/1.1200 Ok
Content-Length: 3000
926.1HTTP阻塞模式协议—Ht1Protoco
Content-Type: text/html; charset=utf-8
Set-Cookie: user=lilei; weight=70kg
Connection: Keep-Alive
③客户端第二次访问的报文(带 Cookie)如下所示。
Get /web/index. jsp Http/1.1
Accept-Language: zh-CN
User-Agent: Mozilla/5.0(Windows NT 6.1)AppleWebkit/537.36(KHTML, like Gecko
) Chrome/31.0.1650.63 Safari/537.36
HOST: localhost: 8080
Connection: Keepp-Alive
Cookie: user=lilei; weight=70kg
第一次访问 localhost:8080/web/ index. jsp时浏览器搜索本地无相关 Cookie,服务器接收报
文后做出响应,通过HTTP协议的Set-Cookie头部把“user-lili;weight=70kg”返回浏览器,
同时浏览器把 Cookie信息保存到本地。第二次访问时,浏览器检査到有相关的 Cookie并发往
服务器,服务器收到信息后知道此浏览器之前由 lilei用户使用,并且他的体重是70kg,服务
器可根据用户信息做一些个性化处理,这就是 Cookie。
Cookie将信息储存在客户端,每次通信都要将这些信息附带在报文里面,这会导致带宽
浪费、敏感数据有安全隐患、对复杂结构数据力不从心等问题。每次访问都把 Cookie发送到
服务器,当 Cookie较大时,明显有带宽浪费问题,假如将用户名、密码存放到客户端,显然
存在安全问题, Cookie对于非键-值对结构的数据显然力不从心。针对这些问题,提出一种解
决方案——服务器会话( Session),它将数据存在服务器中,无须客户端携带,数据安全更加
可控且数据结构可以任意复杂。当然,这种会话的实现也要依赖 Cookie,服务器把一个唯
值 JSESSⅠONID发往客户端,每个唯一值表示一个客户端,客户端与服务器通信时携带此唯
值,服务器根据唯一值寻找属于此客户端的所有数据。
重新回到 Cookie,浏览器将 Cookie发往 Tomcat服务器后, Tomcat需要将这些信息封装
成 Cookies对象。如图623所示, Cookies对象包含了若干个 ServerCookie,而每个 ServerCookie
主要包含了name和 value,即键-值对。当然,还包括其他参数,例如 maxAge表示 Cookie过
期时间,path表示 Cookie存放的路径, domain表示服务器主机名。另外还有其他参数,读者
可自行查阅HTTP协议的Cookie标准,有个参数需要特别说明,secure参数表示是否使用SSL
安全协议发送 Cookie,以避免明文被网络拦截
Request的门面模式
Request使用了门面设计模式,门面模式的使用主要出于数据安全的考虑。系统中多个组
件之间涉及数据交互,如果组件不想把自己内部的数据全部暴露给其组件,就可以使用门面模
式。将某一组件设计成一个门面,把其他组件感兴趣的数据进行封装,通过此门面完成数据访
问。如图6.24所示,其他组件通过一个门面( Facade)访问某组件,门面实现了对数据安全
93第6章 Connector组件
的控制,对于敏感数据不提供任何访问通道,而非敏感数据则暴露,可供访问。
Cooki
Server Cookie
ServerCookie
ServerCookie
value
alue
name
name
name
maxAge
maxAge
maxAge」
th
path
patl
domain
domain
I domain
图6.23Co0kes对象的结构
其他组件
门面
组件
敏感数据
非敏感数据非敏感数据
敏感数据|非敏感数据
图6.24门面模式
下面介绍 Tomcat中的请求对象如何使用门面模式。如图6,25所示, ServletRequest与
HttpservletrEquest都是 Servlet规范标准定义的接口,它们为继承关系,这些接口定义的方法
用于暴露给Web开发者使用。 RequestFacade就是一个门面,它将实现所有 HttpservletrEquest
接口定义的方法,具体的实现依赖于 Connector组件的 Request Connector组件的 Request主
要供 Tomcat内核使用,考虑到安全问题,并不可把所有数据暴露给Web开发人员,所以使用
个请求门面对象。 Connector组件的 Request需要依赖于 coyote包的 Request,该 Request封
装的是最底层的数据,即套接字通信的所有字节数组, Connector组件的 Request是对 coyote
包中 Request的进行一定加工处理后的对象
946.1HTTP阻塞模式协议——Htp1Protocol
aservlet. ServletReqiest
sjava.servlethttpHttpservletrEqiest>
e org. apache. catalina connector. RequestFacac
org. apache. catalina. connector Request
rg.apache. coyote, Requ
图6.25 Request门面
4.响应—— Response
客户端从请求到响应的处理过程中会存在一个响应对象与请求对象相对应,它包含了
HTP协议响应相关的参数,例如响应状态码、内容类型、内容长度、响应编码及响应头部等。
图6.26展示了 Response对象的结构, Response的头部类型与 Request的头部类型一样,都为
Mimeheaders。另外多了一个动作钩子 Action Hook,它为处理过程提供了钩子机制。还有一个
输出缓冲 OutputBuffero
R
MimeHeader Field Mime Header Field
Action Hook
Output Buffe
▲图626 Response对象的结构
95第6章 Connector组件
服务器接收到HTTP请求后,按照HTTP协议规范组织成响应报文,包括响应行、响应头
部和响应体。处理过程需要一个对象封装这些相关的参数值,这个对象就是 Response,它用
于封装响应相关的参数,而且 Response也使用了门面模式。
个请求达到服务器后,经过处理后,将发送如下的响应报文到客户端,包括响应报文协
议及版本、状态码及其描述、响应头部、响应体等。处理过程通过一个响应对象 Response来
保存这些参数值,而响应体会直接通过流输出到客户端。例如下面这段响应报文,在处理过程
中响应行及响应头部的相关属性值将存入 Response对象中,响应体则不保存于 Response中,
而直接写入输出缓冲装置中。
Http/1.1200 ok
Content-Type: text/html; charset=ISO-8859-1
Content-Length: 122
<html>
<head>
<title>Hello</title>
</head>
dv>
</body>
</html>
Response的门面模式
与 Request类似, Response也使用了门面模式实现敏感数据的隔离。如图6.27所示,
ServletRsponse及其子类 HttpservletrEsponse都属于 Servlet规范定义的标准接口,用于暴露给
Web开发者调用。 Responsefacade是一个门面类,它实现所有 Http Servletresponse标准接口并
使用连接器的 Response具体实现。( coyote) Response是最底层的响应对象。
响应钩子— Action Hook
说起钩子(Hok), Windows开发人员比较熟悉,例如鼠标钩子、键盘钩子等。用简单的
语言描述,就是在正常处理流程中安置某个钩子,当执行到安置了钩子的地方时,就将进入指
定的钩子函数进行处理,待处理完再返回原流程继续处理。钩子是消息处理的一个重要机制,
专门用于监控指定的某些事件消息。它的核心思想是在整个复杂的处理流程的所有关键点都触
发相应的事件消息,假如添加了钩子则会调用钩子函数,函数中可根据传递过来的事件消息判
断执行不同的逻辑。它就好像透明地让程序挂上额外的处理。
为什么要使用钩子机制?可以这样认为,在一个庞大的系统内,某些基本的处理流
程是相对固定的,且涉及系统内部逻辑,不应该允许外部人员修改它,但又要考虑到系
统的扩展性,必须预留某些接口让开发者在不改变系统内部基本处理流程的情况下可以
自定义一些额外的处理逻辑,于是引入了钩子机制。按照钩子思想,最后实现的效果相
当于在一个适当的位置嵌入自定义代码,此机制保证了系统内部不被外界修改同时又预
966.1HTTP阻塞模式协议—Htp11Protocol
留足够的扩展空间。
对于Java比较熟悉的就是JM的关闭钩子( Shutdown Hook)了,它提供一种在虚拟机关
闭之前进行额外操作的功能。钩子并不仅是具体的某些功能,它还是一种机制,是一种设计方
法。下面模拟 Tomcat的响应对象如何使用钩子机制。
sjava.servlethttp.HttpServletresponse>
org. apache. catalina connector, Response Facade
org. apache. catalina connector Response
org.apache. coyote. Response
▲图627 Response门面
①定义钩子接口的代码如下。
public interface ActionHook
public void action (Actioncode actionCode, Object param)i
②定义消息状态值的代码如下。为方便理解,假设这里只有两种状态,实际包含了几十
个状态。
public enum ActionCode t
CLOSE, COMMIT
③响应对象的代码如下。它包含了钩子属性
97第6章 Connector组件
public class Response i
public ActionHook hook
public ActionHook getHook()I
return hook
public void setHook(ActionHook hook)
this hook hook
public void action(ActionCode actioncode, Object param)t
hook. action(actioncode, param)i
④钩子处理类的代码如下。它分别对不同的消息状态进行不同的逻辑处理。
public class Httpllprocessor implements Actionhook (
public void action(ActionCode actionCode, Object param)
if (actioncode = Actioncode ClOSE) t
System. out. println("Before closing")i
y else if (actionCode = ActionCode. COMMIT)
System. out. println("Before committing")i
⑤测试类,假设对 response对象的处理流程如下,那么在每个关键节点都通过 action方
法触发钩子,并附带上消息状态,于是每个关键点都能做点额外的事,只要通过修改
Http 11 processor中 action方法即可,根据状态自定义处理逻辑。
public class HookTest
public static void main(String [ args)
Actionhook actionhook-new Httpllprocessor()i
Response response=new Response ()i
response. setHook(actionHook)
response action(Action code. COMMIT, null)i
System. out. println ("commit..)i
response action(ActionCode. CLOSE, null)i
System. out. println ("close..);
Response的缓冲
客户端的请求发送到服务器端后被解析,然后交由容器处理,开始响应客户端。如图6.28
所示,整个处理过程如箭头走势,对于HTTP请求,响应客户端其实就是将相应的HTTP响应
986.1HTTP阻塞模式协议—Htp11Protocol
报文写回给客户端。其中 Response对象中还使用了一定大小的缓冲区,假如某次处理过程有
三次写入缓冲区:第一次是将某部分响应体写入缓冲区;第二次是将另外一部分响应体写入缓
冲区;第三次是将最后剩下的响应体写入缓冲区。如果后面的线程执行发生了异常,这时候会
有两种情况。
发生异常
处理线程
Response
缓冲区
▲图628 Response的缓冲
三次写入的响应体报文总大小没有超过缓冲区大小,所以它不会自动刷新并写入操作系统
缓冲区,即不会发送到客户端。此时可以将响应状态码改成失败,再返回给客户端。
三次写入的响应体报文总大小超过缓冲区大小,假设第二次的时候已经超过缓冲区大小,所以
会自动刷新并写入操作系统缓冲区,而且还会将响应行和响应头也一起写入。而此时响应状态
码为成功,但第三次写入后发生异常,所以整个请求其实算是失败的。然而,由于已经告诉客
户端响应状态码为成功,因此这种情况下响应状态码虽然为成功,但实际处理失败了。
如果缓冲区足够大就不会发生上面的问题,但 Tomcat并没有将所有响应体保存到内存中,
而是选择使用缓冲机制,如果没有缓冲,则当响应体很大时将大量消耗内存。要模拟响应状态
码为成功但实际是失败的场景,可以用下面的一个JSP页面,浏览器能看到输出很多s字母,
但服务器实际处理发生了异常。
<a page contentType="text/html; charset=gb2312" language="java">
<HTML>
<HEAD>
<TITlE>HelloWorld</TITlE>
</HEAD>
<BODY>
<号
for(inti=1;i<20000;i++)
out. print('s)
if(true)
hrow new RuntimeException(Error condition!!!");
号>
</BODY>
</HTML>
99第6章 Connector组件
5.长连接
对于TCP/P协议来说,每次创建连接都会涉及3次握手,而HTTP协议基于TCP/IP协议,
所以HTP协议也会涉及3次握手的过程。如果每个连接只用于一次HTTP通信,那么通信信
道的使用效率就很低。如图6.29所示,比如HTTP1.0下默认的连接都是短连接,每个HTP
请求都需要3次握手才可以创建连接,请求完又4次挥手以结束连接,这种通信信道的使用效
率是相当低下的。
客户端
服务器
SYN
SYN+ACK
ACK
莲接建立
请求
响应
结束响应
FIN
ACK
▲图6.29短连接请求
为了提高HTTP的信道使用效率,HTP1.1默认使用长连接,而如果是HTTP1.0协议,
则通过在HTTP协议头部添加Connection:Ke-Alive来实现长连接。在长连接方式下,如
图630所示,连接经过3次握手后可以进行N次HTTP请求响应,然后才通过4次挥手关闭
连接。如果不想使用长连接,需要在头部显式声明 Connection: Close
接下来,介绍 Tomcat如何实现长连接。先看总的实现思路,如图6.31所示,一个客
户端连接被 Acceptor接来后创建一个 SocketProcessor 1务,然后放到线程池里面,刚刚
定义的 SocketProcessor任务就包含了N次请求响应周期的循环处理。循环步骤为首先读
取客户端请求HTTP报文、解析报文、处理逻辑、响应客户端,然后结束一个请求响应
周期。接着又有一个这样的循环,直到出现某些情况才可能会关闭连接,比如超时或发
生异常。
1006.1HTTP阻塞模式协议—Ht11Protocol
客户端
服务器
SYN+ACK
ACK
连接建立
请求
响应
结東响应
请求
结束响应
结東响应
请求
响应
结東响应
FI
ACK
FIN
ACK
图6.30长连接请求
客户端
服务器
请求
创建
Acceptor
SocketProcessor
响应
扔进线程池
结束响应
的任务队列
请求
Limitlatch
响应
结束响应
请求
ServerSocket Factory
响应
Reco
结束响应
操作系统底层
▲图6.31T0mcat长连接的实现
101第6章 Connector组件
所以这里对长连接的实现放在 Http llprocessor中,它的处理逻辑的伪代码大致如下
所示。
while(true)[
读取客户端HTTP请求报文
解析HTTP报文;
逻辑处理;
响应客户端
判断是否 break循环;
判断是否需要 break循环的条件有以下几种:
超过服务器设置的最大允许长连接数
>超过服务器设置的一次连接最多请求数。
>超过长连接两次请求之间允许的最大超时。
客户端请求头部告知需要关闭连接
响应码包含400、408、411、413、414、500、503、501等需要关闭连接。
62MTP非阻塞模式协议— HttplinioprotocOl
HttplinioprotocOl表示非阻塞模式的HTP协议的通信,它包含从套接字连接接收、处理
请求、响应客户端的整个过程。它主要包含 NioEndpoint组件和 Httpllnioprocessor组件。启动
时 NioEndpoint组件将启动某个端口的监听,一个连接到来后将被注册到 NioChannel队列中,
由 Poller(轮询器)负责检测通道的读写事件,并在创建任务后扔进线程池中,线程池进行任务
处理。处理过程中将通过协议解析器HttplinioprocesSor组件对HTTP协议解析,同时通过适配
器( Adapter)匹配到指定的容器进行处理并响应客户端。整体结构如图6.32所示。
621非阻塞接收终端— - nioEndpoint
NioEndpoint组件是非阻塞JO终端的一个抽象,如图633所示, NioEndpoint组件包含了
很多子组件。其中包括 Limitlatch(连接数控制器)、 Acceptor(套接字接收器)、Polr(轮询
器)、 Poller池、 SocketProcessor(任务定义器)以及 Executor(任务执行器)。
Limitlatch组件负责对连接数的控制, Acceptor组件负责接收套接字连接并注册到通道队
列里面, Poller组件负责轮询检查事件列表, Poller池包含了若干polr组件, SocketProcessor
组件是任务定义器, Executor组件是负责处理套接字的线程池。下面将对每个组件的结构与作
用进行解析。
1.连接数控制器—— -Limitlatch
不管使用BⅠO模式还是NIO模式,作为服务器端的一个服务,不可能无限制地接收客
10262HTTP非阻塞模式协议—Htt11NioProtocol
户端的连接,如果不对客户端的连接数进行限制可能会导致服务器崩溃。 Tomcat中的
Limitlatch就是用于限制连接数的控制器,BIO与NIO都使用这个组件,它是基于AQS
并发框架实现的。
Htt1 1NioProtocol
NioEndpoint
获取
Poller
创建
Poller池
SocketProcessor
扔进线程池
事件列表
的任务队列
注册
Executor
NioChannel
Nio Channel
Limitlatch
Reco
操作系统底层
Httplinioprocessor
R
InternaINioInputBuffer
InternalNioOutputBuffer
InputFilter
OutputFilter k
Inputfilter
Output Filt
SocketlnputBuffer
dsocketoutputBuff
作系统底层
操作系统属腺
▲图6.32HTP非阻塞模式协议的整体结构
103第6章 Connector组件
NioEndpoint
获取
Polle
创建
Poller池
SocketProcessor
轮询
扔进线程池
A
事件列表
的任务队列
注册
Executor
Nio Channel
NioChannel
NioChannel
LimitLatch
读写
数据1
数据2
操作系统底层
▲图6.33非阻塞接收终端
与BIO中的控制器不同的是,控制阀门的大小不相同,BIO模式受本身模式的限制,它
的连接数与线程数比例是1:1的关系,所以当连接数太多时将导致线程数也很多,JVM线程数
过多将导致线程间切换成本很高。默认情况下, Tomcat处理连接池的线程数为200,所以BIO
流量控制阀门大小也默认设置为200。但NIO模式能克服BIO连接数的不足,它能基于事件
同时维护大量的连接,对于事件的遍历只须交给同一个或少量的线程,再把具体的事件执行逻
辑交给线程池。例如, Tomcat把套接字接收工作交给一个线程,而把套接字读写及处理工作
交给N个线程,N一般为CPU核数。对于NO模式, Tomcat默认把流量阀门大小设置为10000
如果你想更改大小,可以通过 server xml中< Connector>节点的 maxConnections属性修改,同
时要注意,连接数到达最大值后,操作系统仍然会接收客户端连接,直到操作系统接收队列被
塞满。队列默认长度为100,可通过 server xml中< Connector点的 acceptCount属性配置
Tomcat连接数控制器的伪代码如下所示。
Limitlatch limitLatch new LimitLatch(10000);
创建阻塞的 Server Socketchanne1对象
While(true)i
limitLatch. countUpOrAwait(; /
这里可能阻塞,达到10000则阻塞,不再接收连接
socket channel socket Channel= ServerSocketChannel accept(
将 socketchanne1对象设为非阻塞并向 Selector注册读写事件;
轮询检测出可读可写连接,并交由连接池读写及处理;
10462HTTP非阻塞模式协议——Ht1|NioProtocol
响应完客户端后执行1 imitlatch. countDown();
2. SocketChannel接收器— Acceptor
Acceptor的主要职责也是监听是否有客户端连接进来并接收连接,这里需要注意的是, accept
操作是阻塞的。为了使操作简洁方便,作为服务器端通道的 ServerSocketChannel并未设置为非阻
塞,而设置为阻塞,如此一来它将在 Acceptor中阻塞直到有客户端连接可被接收,接收操作与
原来的BIO操作类似,只是返回的对象不同,原来返回 Socket对象,现在返回 Socketchannel
对象。
如图6.34所示, Acceptor接收 SocketChannel对象后要把它设置为非阻塞,这是因为后面
对客户端所有的连接都采取非阻塞模式处理。接着设置套接字的一些属性,再封装成非阻塞通
道对象。非阻塞通道可能是NioChannel也可能是SecureChannel,这取决于使用HTTP通
信还是使用HTPS通信。最后将非阻塞通道对象注册到通道队列中并由 Poller负责检测事件。
Acceptor
Poll
注册
轮询
LimitLatch
事件列表
Reco
Niochannel
数据1
NioChannel
「数据2
NioChannel
操作系统底层
▲图6.34 Socketchannel接收器
在封装非阻塞通道对象时使用的一项优化值得我们深入学习。如图6.35所示, NioChannel
属于频繁生成与消除的对象,因为每个客户端连接都需要一个通道与之相对应,频繁地生成和
消除在性能的损耗上也不得不多加考虑,我们需要一种手段规避此处可能带来的性能问题。其
思想就是:当某个客户端使用完 NioChannel对象后,不对其进行回收,而是将它缓存起来,
当新客户端访问到来时,只须替换其中的 Socketchannel对象即可, NioChannel对象包含的其
他属性只须做重置操作即可,如此一来就不必频繁生成与消除 NioChannel对象。具体的做法
105第6章 Connector组件
是使用一个队列,比如 ConcurrentLinkedQueue< NioChannel>,将关闭的通道对应的 NioChannel
对象放到队列中,而封装 Niochannel对象时优先从队列里面取,取到该对象后,做相应的替
换及重置操作,假如队列中获取不到 Nio Channel对象,再通过实例化创建新的 Niochannel对
象。这种优化方式很常见,尤其在频繁生成与消除对象的场景下。
Niochannel
SocketChannel
SocketChannel
▲图6.35优化
3.非阻塞通道— - Nio Channel和 SecureNioChanne
非阻塞通道负责将数据读到缓冲区中,或将数据从缓冲区中写入,它的作用主要是用于屏
蔽非SSL及SSL读写操作细节的不同。非阻塞通道实现了 Byte Channel接口,此接口只有 write
read两个操作字节流的方法,两种非阻塞通道不同的细节屏蔽在这两个操作中。例如,对于非
SSL通信,报文本来就是明文,可直接读取,而对于SSL通信,报文属于加密后的密文,解
密后才是真正需要的报文。同样地,对于非SSL通信,直接写入,而对于SSL通信,应该把
报文加密后再传送到套接字通道。下面是这两种通道的详细解析。
非SSL通道— NioChannel
非SSL通道即常规情况下不加密而直接传输明文的通道,常用的HTP协议使用的就是
此通道,传输过程中它无须加密、解密。 NioChannel组件包含两个重要的部分— Socketchannel
和 Application Handler,如图6.36所示。 Socketchannel对象是真正与操作系统底层 Socket
交互的对象,包括写入读取操作,而 ApplicationBufferHandler接口提供用于操作待写入
Socketchannel的缓冲区和读取 Socketchannel的缓冲区的协助方法
Niochannel
anne
Application BufferHandler
图6.36非SSL通道
10662HTTP非阻塞模式协议——Htp11NioProtocol
SocketChannel属于JDK提供的类,用于使套接字在应用层和操作系统内核之间读写。这
里主要分析 ApplicationBufferHandler接口,它主要包含 getReadBuffer和 get WriteBuffer两个方
法,分别用于获取读缓冲和写缓冲。在分配内存方式上有两种。一种方式是分配操作系统本地
内存,称为直接内存。它不直接由垃圾回收器管理,它能提高性能,因为它不需要反复从Java
堆到 Native堆进行内存复制,直接内存只有在它对应的Java类 DirectByte Buffer类作为垃圾回
收时才会调用释放内存方法,或者程序手动调用对应的方法释放直接内存,否则直接内存不会
释放,所以可能会导致内存泄漏。另一种方式是分配Java堆内存,它由垃圾回收器管理,它
需要在 Native堆内存与Java堆内存之间相互复制。该接口的详细实现如下
public static class NioBufferHandler implements ApplicationBufferHandler f
protected ByteBuffer readbuf null;
protected ByteBuffer writebuf null;
public NioBufferHandler(int readsize, int writesize, boolean direct
if( direct )i
readbuf ByteBuffer allocateDirect(readsize)i
writebuf= ByteBuffer. allocateDirect(writesize)
Felse i
readbuf ByteBuffer allocate (readsize)
writebuf ByteBuffer allocate(writesize);
public ByteBuffer getReadBuffer(freturn readbufi I
public ByteBuffer getWriteBuffer()(return writebuf:
非SSL通道的作用就是,通过它读取来自操作系统底层的套接字数据到直接内存或Java
堆内存,或将直接内存或Java堆内存写入底层套接字。
≯SSL加密非阻塞通道—— SecureNio Channel
当通信的据涉及安全性时,需要使用SSL加密非阻塞通道,常见的 Https使用的就是此
通道,SSL加密通道的实现需要依赖JSE,而JSSE主要的责任是将数据进行加密打包或拆包
解密。如图6.37所示, SecureNioChannel组件继承了非SSL通道 Niochannel的特性,即其中
Socketchannel和 Application Buffer Handler对象的作用都与 Nio Channel相同。另外,还额外包
含一些对象,两个 ByteBuffer对象分别用于存放网络接收到的未经过解密的字节流和经过加密
后待发送的字节流,而 SSLEngine引擎则负责加密解密工作, HandshakeStatus则是SSL协议
握手阶段的状态。
SecureNio channel其实就是在 NioChanne上加了一层,使之拥有SSL协议通信的能力,
而具体的实现则基于JSSE。
107第6章 Connector组件
SecureNioChannel
SocketChannel
Application Buffer Handler
Byte Bufter
Byte Buffer
SSLEngine
HandshakeStatus
图6.37SSL加密非阻塞通道
4.任务定义器— socket processor
与 JloEndpoint组件相似,将任务放到线程池中处理前需要定义好任务的执行逻辑。根据
线程池的约定,它必须扩展 Runnable接口,用如下伪代码表示。
protected class SocketProcessor implements Runnable i
public void run()(
用NO方式读取套接字并进行处理,输出响应报文;
连接数计数器减一腾出通道;
关闭套接字;
因为NO与BO模式有很大不同,其中一个很大不同在于BIO每次返回都肯定能获取若干字
节,而NO无法保证每次读取的字节量,可多可少甚至可能没有,所以对于NO模式,只能“尝
试”处理请求报文。例如,第一次只读取了请求头部的一部分,不足以开始处理,但并不会阻塞,
而是继续往下执行,直到下次循环到来,此时可能请求头部的另外一部分已经被读取,则可以开始
处理请求头部。任务定义器定义的内容主要是使用NO模式读取套接字并对报文解析及处理,然后
用BIO模式对套接字写入响应报文,最后处理完成后要把连接数计数器减1并关闭 Socket
由于任务定义器也是一个需要频繁产生与清除的短暂对象,因此也可以采取一定的优化措
施提高性能,即不让使用过的 SocketProcessor对象进行垃圾回收,而是把它保存在一个
ConcurrentLinkedQueue< SocketProcessor>队列中,下次要用到此对象则从队列中取出,仅仅只
是将其中的某一部分置换掉。如图6.38所示,只置换其中的 NioChannel对象,以此达到重复
利用 SocketProcessor对象的效果。
5.连接轮询器——Po‖er
NIO模型需要同时对很多连接进行管理,管理的方式则是不断遍历事件列表,对相应连接
的相应事件做出处理,而遍历的工作正是交给 Poller负责。 Poller负责的工作可以用图6.39简
1086.2HTTP非阻塞模式协议—Htt11NioProtocol
单表示出来,在Java层面上看,它不断轮询事件列表,一旦发现相应的事件则封装成任务定
义器 SocketProcessor,进而扔进线程池中执行任务。当然,由于 NioEndpoint组件内有一个 Poller
池,因此如果不存在线程池,任务将由 Poller直接执行。
Socket Processor
NioChannel
SocketStatus
NioChannel
图6.38优化
Poller内部依赖JDK的 Selector对象进行轮询, Selector会选择出待处理的事件,每轮询
次就选出若干需要处理的通道,例如从通道中读取字节、将字节写入 Channel等。在NO
模式下,因为每次读取的数据是不确定的,对于HTP协议来说,每次读取的数据可能既包含
了请求行也包含了请求头部,也可能不包含请求头部,所以每次只能尝试去解析报文。若解析
不成功则等待下次轮询读取更多的数据后再尝试解析,若解析报文成功则做一些逻辑处理后对
客户端响应,而这些报文解析、逻辑处理、响应等都是在任务定义器中定义的。
Poller
Socket Processor
轮狗
「事件列表
NioChannel
线程池
NioChannel
NioChannel
▲图6.39 Poller负责的工作
6. Poller池
在NIO模式下,对于客户端连接的管理都是基于事件驱动的,上一节提到 NioEndpoint
组件包含了 Poller组件,Polr负责的工作就是检测事件并处理事件。但假如整个 Tomcat的所第6章 Connector组件
有客户端连接都交给一个线程来处理,那么即使这个线程是不阻塞的,整体处理性能也可能无
法达到最佳或较佳的状态。为了提升处理性能, Tomcat设计成由多个 Poller共同处理所有客
户端连接,所有连接均摊给每个 Poller处理,而这些 Poller便组成了 Poller池。
整个结构如图6.40所示,客户端连接由 Acceptor组件接收后按照一定的算法放到通道队
列上。这里使用的是轮询调度算法,从第1个队列到第N个队列循环分配,假如这里有3个
Polr,则第1个连接分配给第1个 Poller对应的通道列表,第2个连接分配给第2个 Poller
对应的通道列表,以此类推,到第4个连接又分配到第1个 Poller对应的通道列表上。这种算
法基本保证了每个Polr所对应处理的连接数均匀,每个 Poller各自轮询检测自己对应的事件
列表,一旦发现需要处理的连接则对其进行处理。这时如果 NioEndpoint组件包含任务执行器
( Executor)则会将任务处理交给它,但假如没有 Executor组件, Poller则自己处理任务。
线程池
Poller
Poller
Poller
匚事件列表
匚事件列表
事件列表
NioChannel
NioChannel
NioChannel
NioChannel
CocHannel
I CocHannel
NioChannel
NioChannel
NioChannel
Acceptor
▲图6.40 Poller池
11062HTTP非阻塞模式协议——Htp11NioProtocol
Poller池的大小多少比较合适呢? Tomcat使用了一个经典的算法 Math. min(2, Runtime
getruntime(. availableProcessors(,即会根据 Tomcat运行环境决定 Poller组件的数量。所以在
Tomcat中最少会有两个 Poller组件,而如果运行在更多处理器的机器上,则JVM可用处理器
个数等于 Poller组件的个数
7.任务执行器— Executor
对于此组件这里不再做过多介绍, Nioendpoint组件内的任务执行器其实与 JloEndpoint组
件的任务执行器是同一个组件,两者都用来处理请求任务。但 Nioendpoint组件不一定包含任
务执行器,因为在 NioEndpoint中有一个 Poller池,除了轮询事件列表,它同样也可以在遍历
到事件后对事件进行处理,而不必再交到其他线程中。
6.2.2HTTP非阻塞处理器—Ht11NioProcessor
HttplinioprocessoR组件提供了对HTTP协议非阻塞模式的处理,包括对套接字的读写和
过滤,对HTTP协议的解析与封装成请求对象,HTTP协议响应对象的生成等操作。整体结构
如图641所示。
Httpllnioprocessor
Request
sponse
InternalNiolnput Buffer
InternalNioOutput Buffer
OutputFilter
InputFilter
OutputFilter
tBu
操得系统账层
▲图6.41HTTP非阻塞处理器的整体结构
1.非阻塞套接字输入缓冲装置— nternalNiolnputBuffer
在消息传递过程中,为了提高消息从一端传到另一端的效率,一般会引入缓冲区。对于写
入缓冲区,只有在强制刷新或缓冲区被填满后才会真正执行写入操作。 Tomcat在BIO模式中
使用了套接字输入缓冲装置来接收客户端的数据,它会提供一种缓冲模式以从套接字中读取字
l11第6章 Connector组件
节流并解析HTTP协议的请求行和请求头部,最后填充好请求对象Request
在NO模式下,Tomcat同样存在一个类似的缓冲装置用来处理HTTP协议报文,它就是
非阻塞套接字输入缓冲装置( nternalNiolnputBuffer)。它与阻塞套接字输入缓冲装置之间的不
同就在于读取套接字数据时的方式,阻塞方式是会一直阻塞,直到数据返回,而非阻塞则是“尝
试”读取,有没数据都返回。所以它们的基本原理及机制都是相同的,而唯一的差异就在于此。
如果对缓冲装置的工作原理不太清楚,可以参考6.1.2节。
为了更好地理解如何使用NO模式从底层读取字节并进行解析,下面给出一个简化的处
理过程。首先需要一个方法提供读取的字节,代码如下所示,NO模式下读取数据不再使用流
的方式读取,而是通过通道读取,所以这里使用了 NioChannel对象读取,非阻塞并不能保证
定能读到数据,读不到数据时会直接返回-1
public class InternalInputBuffer(
byte[] buf=new byte[8*1024]
int pos=0i
int lastvalid=0
ByteBuffer readbuf =ByteBuffer allocate(8192)
public boolean fill()i
int nRead niochannel read(readbuf)i
if (nRead >0)[
readbuf. get(buf, pos, nRead)i
lastvalid= pos nRead;
return (nRead>0)i
有了填充方法,接下来,需要一个解析报文的操作过程。如图642所示,当 Poller轮
询检测到有可读事件后,开始处理相应的 Nio Channel,非阻塞套接字输入缓冲装置
InternaINioInputBuffer将开始读取NioChannel里面的数据,然后开始尝试解析HTTP请求
行。解析过程中,如果数据不足,则用fll方法尝试读取数据,此时,如果读不到数据,
则直接返回,结束此次处理。当 Poller再次检测到该通道的可读事件后,非阻塞套接字输
入缓冲装置再次从 NioChannel里面读取数据,并接着上一次结束的位置继续处理。但如果
用fil方法尝试读取数据成功,则不必等到Polr第二次轮询。往下继续尝试解析HTTP
请求头部,由于这个过程中同样可能数据不足,因此同样也会使用fi法尝试读取数据。
如果读不到数据,也会直接结束,并需要等到 Poller第二次检査到该通道时,才能继续往
下执行。最后完成整个HTTP请求报文的解析
非阻塞套接字输入缓冲装置与阻塞套接字输入缓冲装置的结构大体相同,如图6.43所示,
NioChannel组件用于读取底层 Socket数据, SocketInputBuffer组件则提供读取请求体的功能,
还有若干 InputFilter组件属于过滤器。
11262HTTP非阻塞模式协议——Htp11NioProtoco
InternalNioInput Buffer
Poller
NioChannel
读数据)
轮
尝试解析HTTP请求行
直接返回,结
束此次处理
数据不足
事件列表
读不到
尝试读数据
尝试解析HTP请求头部
读不到
NioChannel
NioChannel
数据不足
Nio Channel
尝试读数
完成读取与解析)
▲图642非阻塞处理过程
InternalNioOutput Buffer
InputFilter
des Buf
InputFilter
SocketInputBuffer
I Recv
数据I
数据2
操作系统底层
▲图6.43非阻塞套接字输入缓冲装置
2.非阻塞套接字输出缓冲装置— nternalNioOutputBuffer
非阻塞套接字输出缓冲装置是提供NIO模式输出数据到客户端的组件,整体结构如
图644所示,它包含 Nio Channel组件、 SocketOutputBuffer组件和 OutputFilter组件。其
中 Niochannel组件是非阻塞的套接字输出通道,通过它以非阻塞模式将字节写入操作系
统底层; SocketOutput Buffer组件提供字节流输出通道,与 OutputFilter组件组合实现过
滤效果。
113第6章 Connector组件
InternaINioOutput Buffer
Output Filte
output Buf
ketOutput Buffe
数据2
操作系统底层
▲图6.44非阻塞套接字输出缓冲装置
63 HttpApr模式协议— IttpllAprProtocol
Httpllaprprotocol表示使用APR模式的HTTP协议的通信,它包含从套接字连接接收、
处理请求、响应客户端的整个过程。APR模式主要是指由 Native库完成套接字的各种操作,
APR库提供了 sendfile.、epol和 OpenSSL等IO高级功能, Linux和 Windows操作系统都有各
自的实现库, Tomcat中通过JNI方式调用这些 Native库。Htpl| AprProtocol组件主要包含
AprEndpoint组件和Htt1 AprProcessor组件。启动时 AprEndpoint组件将启动某个端口的监
听,一个连接到来后可能会直接被线程池处理,也可能会被放到一个待轮询队列里面由 Poller
负责检测,如果该连接被检测到已准备好,则将由线程池处理。处理过程中将通过协议解析器
Httpllaprprocessor组件对HTTP协议解析,通过适配器(Adapter)匹配到指定的容器进行处
理并响应客户端。 Http apr模式协议的整体结构如图6.45所示。
631APR接收终端— AprEndpoint
AprEndpoint组件是使用APR模式IO的终端抽象。如图6.46所示, AprEndpoint组件包
含了很多子组件。其中包括 Limitlatch(连接控制器)、 Acceptor(套接字接收器)、 SocketProcessor
和 Socket WithOptions Processor两种任务定义器、 Poller(轮询器)以及 Executor(任务执行器)。
Limitlatch组件负责对连接数的控制; Acceptor组件负责接收套接字连接并将其放到
PollSet队列里面或直接创建任务放到线程池里面,但 Acceptor组件不再通过JDK获取套接字
连接,而是通过方式调用APR库接收; SocketProcessor组件和 Socket WithOptionsProcessor
组件是任务定义器; Executor组件是负责处理套接字的线程池; Poller组件负责轮询检测已准
备好的套接字连接
1146.3 Http Apr模式协议—Htp11 AprProtocol
Httpllaprprocessor
AprEndpo
oint
Poller
创建
Socket Processor
Acceptor
创建, Socket WithOptions进程池
Processor
扔进线程池
的任务队列
cutor
Poll
APR
Socket
PollSet
操作系练底层
Httpllaprprocessor
Request
Response
InternaINiolnputBuffer
InternalNioOutputBuffer
OutputFilter
地pe
OutputFilter
SocketInputBufte
ocketOutput Buffe
Socket
APR)
数据2
底层
▲图6.45 Http Apr模式协议的整体结构
AprEndpoint组件其实有两种处理流程。
Acceptor组件通过APR获取到套接字,然后直接创建 Socket WithOptions Processor对象,
最后直接放到线程池中执行套接字的读写和逻辑处理,整个过程都是阻塞的,这也是默认
的处理方式。
115第6章 Connector组件
AprEndpoint
Poller
创建
SocketProcessor
轮狗
创建
Acceptor
Socket WithOptions Processor
扔进线
扔进线程池
程池的
的任务队列
任务队
接
列
Executor
Poll
LimitLatch
(APR)
Socket
读写
(APR)
PollSet
数据
操作系统底层
▲图6.46APR接收终端
Acceptor组件通过APR获取到套接字,然后将套接字放到待轮询队列 PollSet中,而 Poller
则不断通过APR检测已准备好的套接字,接着创建 Socket Processor对象,最后放入线程
池中执行,接下来的整个过程也是阻塞的。
第一种方式之所以在 Acceptor接收到套接字后将套接字直接放入线程池处理,是因为
Tomcat的 AprEndpoint组件默认使用了TCP的 TCP DEFER ACCEPT参数来优化网络IO。
在没有 TCP DEFER ACCEPT参数的情况下,如图6.47所示,TCP三次握手成功后连接即被
接收,但此时离客户端真正发送数据可能还有一段时间,这段时间将会导致阻塞。所以在没有
使用 TCP DEFER ACCEPT参数的情况下IO效率较低。
当使用 TCP DEFER ACCEPT参数优化后的情况又是怎样的呢?如图648所示,同样的
11663 Http Apr模式协议——Ht1 AprProtocol
三次握手,但在最后一次ACK后连接并不会被接收,而是当客户端数据发送到来时才会被接
收,这样一来,连接只要被接收就肯定有数据。在使用了 TCP DEFER ACCEPT参数的情况
下,1O效率得到提升。所以有了这种优化方式, Acceptor组件一旦接收到连接,就直接放进
线程中进行处理了。但 TCP DEFER ACCEPT优化并不是所有操作系统都支持,而且JDK也
没有提供这个参数的优化接口,只能在支持的操作系统中,通过APR这种本地方式来优化,
Java通过JI调用这些本地库。
客户端
服务器
SYN
SYN+ACK
ACK
接
ESTABLISHED
等待
数据
数据
数据
▲图6.47默认接收方式
客户端
服务器
SYN
SYN+ACK
ACK
¨" ESTABLISHED
数据
接收
数据
数据
图6.48 TCP DEFER ACCEPT参数的优化
第二种方式是在不支持TCP的 TCP DEFER ACCEPT参数优化情况下的处理方式,
Acceptor接收连接并放到待轮询队列中, Poller将检査已准备好的连接,然后放到线程池中进
行处理。因为引入了轮询器,所以在三次握手后接收连接不会存在阻塞的问题
117第6章 Connector组件
1. Socket接收器— Acceptor
在使用了APR本地库进行网络IO操作后,对于套接字的接收时机会根据TCP的
TCP_ DEFER ACCEPT参数不同而不同。一种是完成三次握手后就接收连接,另外一种
是完成三次握手后并且等到数据到来后才接收连接。所以对套接字连接的接收存在两种
逻辑。
Acceptor组件主要负责通过APR本地库获取套接字。如图649所示, Acceptor获取到套
接字连接后会判断运行环境是否使用了TCP的 TCP DEFER ACCEPT参数优化机制,如果使
用了,则直接创建任务并直接放进线程池中处理,而如果没有使用,则将套接字连接放入待轮
询队列 PollSet中。
Acceptor
创建
Socket WithOptions Processor
扔进线程池
接收
的任务队列
Executor
Limitlatch
Socket
读写
(APR
PolISet
数
2
操作系统底层
▲图6.49 Socket接收器
2.连接轮询器—— Poller
Acceptor组件将连接放入待轮询队列 Pollset后,剩下的事情就由 Poller来完成了。如图
6.50所示, Poller组件通过APR本地库轮询检测出已准备好的连接,然后创建任务并放进线
程池中处理。Polr数量默认一般只有一个,即一个线程专门做轮询工作。但在 Windows32
和 Windows64操作系统下,每个 Poller只负责处理不超过1024个连接,所以此时 Poller的数
量为 max Connections/1024。
11863 Http Apr模式协议——Ht11 AprProtoco
Poller
创建
SocketProcessor
扔进线程池
轮询
的任务队列
Executor
Poll
(APR)
Socket
读写
(APR)
PolISet
操作系统底层
▲图6.50连接轮询器
632 Http Apr处理器—Ht11 AprProcessor
Htpl|AprProcessor组件提供了对HTTP协议APR模式的处理,包括对套接字的读写和过
滤,对HTTP协议的解析与封装成请求对象,HTP协议响应对象的生成等操作。HttpApr
处理器的整体结构如图6.51所示。
1.APR套接字输入缓冲装置— InternalAprInputBuffer
InternalAprlnputBuffer g组件是 Tomcat在APR模式中使用的套接字输入缓冲装置,它会提
供一种缓冲模式并通过APR本地库读取套接字消息,同时解析HTTP协议的请求行和请求头
部。默认情况下,APR模式与Java阻塞模式比较相似,它们在读取消息的过程都是阻塞的,
只有当接收到数据或超时才会返回。
如果不熟悉输入缓冲装置的机制,可以参考6.1.2。唯一不同的地方在于读取套接字的方
式,APR模式是通过APR本地库获取的,即在Java中使用JN调用完成套接字报文的读取。
APR套接字输入缓冲装置的整体结构如图6.52所示,本地库的 Socket组件用于读取底层 Socket
数据, SocketInput Buffer组件则提供读取请求体的功能,还有若干 InputFilter组件属于过滤器。
119第6章 Connector组件
Httpll aprprocessor
Request
Response
InternalNiolnputBuffer
InternalNioOutputBuffer
OutputFilter
outputBuf
Inpi
InputFilte
OutputFilter
ffe
SocketOutputBuffer
(APR)
≌△PR)
RevaL
数据
「数据2
数据2
操作系
▲图6.51 Http Apr处理器的整体结构
Internal Aprlnput Buffer
but
Input
desB
Inputfilter
SocketInput Buffe
Socket
ARR
Recv
数据1
数据2
操作系统底层
▲图6.52APR套接字翰入缓冲装置
2.APR套接字输出缓冲装置— Internal/ AprOutputBuffer
APR套接字输出缓冲装置是提供APR模式输出数据到客户端的组件,其整体结构如图6.53所
示,它包含本地库 Socket组件、 SocketOutput Buffer组件和 OutputFilter组件。其中本地库 Socket组
1206.4 AJP Connector
件是套接字输出通道,通过它以APR模式将字节写入操作系统底层; SocketOutput Buffer组件提供
字节流输出通道,与 Output Filter组件组合实现过滤效果。
InternalAprOutput Buffer
OutputFilter
outputBut
OutputFilter
ketOutput Buffer
(ARR)
Reco
数据口
数据2
操作系统底层
图6.53APR套接字输出缓冲装置
6.4 AJP Connector
一般会将静态资源交由 Apache Server处理,而把动态资源交给 Tomcat处理,以提升Web
处理的整体性能。 AJP Connector组件即提供了与 Apache Server通信的支持。 Apache Server
与 Tomcat整合后的整体结构如图6.54所示。第一种情况是客户端请求静态资源,这时将由
Apache Server直接将静态资源输出给客户端。而第二种情况是客户端请求动态资源,此时
Apache Server并没有匹配上静态资源,而是将请求封装成AJP协议发送到后端 Tomcat中,
Tomcat的 AJP Connector专门负责接收AJP协议报文并处理,然后使用AJP协议返回报文给
Apache Server,最后返回给客户端。
Apache Server
Tomcat
请求
AJP
动态
AJP Connector
响应
AJP
(8009)
请求
HTML、Js、Css、JPG
响应
等静态资源
Container
▲图6.54 AJP Connector
121第6章 Connector组件
AJP Connector是 Tomcat除了 Http Connector之外的另外一类 Connector,用于与 Apache
Server之间的AJP协议通信。同样,对于不同的IO模式也有不同的处理,BIO、NIO、APR
三种IO模式分别对应 AjpProtocol、 AjpNioProtocol和 AjpAprProtocol
下面简要介绍AJP协议。
AP协议是Web服务器和Web容器之间通信的一种协议,全称为 Apache JServ Protocol
AJP是一种面向数据包的协议,并且使用二进制格式取代文本格式,这样有助于提高性能。
AP协议建立在TCP连接之上,一般Web容器会维护一个到 Tomcat的套接字连接池,长连接
的使用大大减少了创建套接字的次数,重复利用了连接池的连接。每个连接通道只能同时由
个请求使用,某连接一旦被占用则必须要等到该连接空闲出来后才能继续使用。
AJP协议中有4种数据类型:Byte、 Boolean、 Integer和 String。
Byte表示字节。
> Boolean用1个字节表示布尔类型,1为true,0为 false
Integer用2个字节表示,范围从0~2~16
String表示可变字符串,字符串前面存在一个 nteger用于表示字符串长度,最大长度为
2^16,字符串以“10”作为终结符,并且终结符不计入字符串长度。
从 Apache Server到 Tomcat的协议包都以0x1234开头,而从 Tomcat到 Apache Server的
协议包则以AB开头,接着的一个 Integer(2字节)表示数据的长度,该长度最大值为8KB,
接下来的就是数据了。协议包的说明如表61所示。
表61协议包的说明
协议包流向
0
2
3
4.(n+3)
Apache Server→ Tomcat
0x12
0x34
数据长度
数据
Tomcat→ Apache Server
A
B
数据长度
数据
数据部分会包含各种类型的数据包,除了从 Apache Server发送到 Tomcat的请求体数据包
之外,其他数据包的第一个字节都代表消息的类型,消息类型详细说明如表6,2所示。
表62消息类型详细说明
协议包流向
代码
包类型
描述
Forward request
Apache Server转发的请求
Apache Server→ Tomcat
Shutdown
Apache Server让 Tomcat关闭
ing
发起Ping请求,用于安全登录阶段
Apache Server→ Tomcat
Ping
发起 PIng请求
lone
Data
数据长度及数据
1226.4 AJP Connector
续表
协议包流向
代码
包类型
描述
Send body chunk
发送响应体到 Apache Server
Send headers
发送响应头部到 Apache Server
Tomcat→ Apache Server
End Response
响应结束包
Get body Chunk
获取还未发送的请求
CPong Reply
PIng的响应
比如,当一个请求由 Apache Server转发到 Tomcat时,其数据包的代码即为0x02,还会
包含请求方法、请求协议、请求URI、远程主机、服务端口、请求头部等,各种数据包都要遵
循协议中规定的格式。更详细的协议说明可以参考htp:/ tomcat. apache. org/connectors
doc/ajp/ajpv ahtml
64.1AJP阻塞模式协议— AjpProtocol
AjpProtocol表示阻塞式的AP协议的通信,它包含接收套接字连接、处理请求、响
应客户端的整个过程。它主要包含 Jloendpoint组件和 AjpProcessor组件。启动时,
JIoEndpoint组件将对某端口(默认是8009端口)监听,当接收到 Apache Server转发过
来的请求时,则将其放入到线程池中执行,对AJP协议的读取及解析在 AjpProcessor组
件中完成。注意,这里不再使用缓冲,而是直接以阻塞方式从套接字中读取。整体结构
如图6.55所示。
AjpNioProtocol表示非阻塞模式的AP协议的通信,它包含接收套接字连接、处理请
求、响应客户端的整个过程。它主要包含 NioEndpoint组件和 AjpNioProcessor组件。启动
时, NioEndpoint组件将监听某个端口(默认为8009端口),一个连接到来后将被注册到
Nio channel队列中,由polr负责检测通道的读写事件,并在创建任务后扔进线程池。线
程池进行任务处理,处理过程中将通过协议解析器 AjpNioProcessor组件对AJP协议解析,
同时通过 Adapter匹配到指定的容器进行处理并响应客户端。AJP非阻塞模式协议的整体
结构如图656所示
123第6章 Connector组件
AipProtocol
Jloendpoint
创建
Socket
扔进线程池
的任务队列
Limitlatch
Server SocketFactor
Reaud
数据
读写
数
操作系统底层
“”””x-
AjpProcessor
Request
Response
目国
recv
ecv
数掘1
匚数据I
数据2
数据
操作系统底层
操作系统底层
▲图6.55AP阻塞模式协议整体结构
1246.4 AJP Connector
Nio Endpoint
AjpNioProcessor
获取
创建
Poller池
Socket Processor
Realest
ponse
扔进线程池
Ap人注册
事件列表
的任务队列
Executor
NiChan
读写
檬作系底层
操
▲图6.56AP非阻塞模式协议的整体结构
6.4.2 AJP APR模式协议— AjpApr Protocol
AjpAprProtocol表示使用APR模式的AP协议的通信,它包含接收套接字连接、处理请求、
响应客户端的整个过程。 AjpAprProtocol组件主要包含 AprEndpoint组件和 AjpAprProcessor组件
启动时, AprEndpoint组件将启动某个端口的监听,一个连接到来后可能会直接被线程池处理,也
可能会被放到一个待轮询队列里面由 Poller负责检测,而且在被检测到已准备好后将由线程池处
理。处理过程中将通过协议解析器 AjpAprProcessor组件对AP协议解析,同时通过 Adapter匹配
到指定的容器进行处理并响应客户端。 AJP APR模式协议的整体结构如图6.57所示。
AjpAprProtocol
Apr Endpoint
AjpAprProcessor
Pole创建
SocketProcessor
Accepto
创建
SocketWith
Optionsprocessor
扔进线程池
扔进线程池
的任务队列
的任务队列
Executor
□Pon
(API
ocke
rocket
(APR
(APR)
Socket
(APR)
数据1
数据2
下数据2
Pullet
三
作系统
▲图6.57 AJP APR模式协议的整体结构
125第6章 Connector组件
65HTP三种模式的 connector
HTTP协议有三种不同的IO模式,表6.3描述了BIO、NIO和APR三者之间的差异。
可以看到尽管 NIO Connector属于非阻塞的,但其实它的有些操作也是阻塞的。尽管底层Io
接口为非阻塞模式,但仍然可以在Jaa层使用循环来实现阻塞模式。另外,在SSL的实现
方式上,由于BIO和NO都基于JDK实现,因此SSL基于JSSE实现,而APR则基于 OpenSSL
实现。
表6.3HTTP三种模式的Connector
描述项
BIO Connector
NIO Connector
APR Connector
是否支持轮询
不支持
支持
支持
轮询最大数
无
max Connections
max Connections
读取请求头部
阻塞
非阻塞
阻塞
读取请求体
阻塞
阻塞
阻塞
写入响应报文
阻塞
阻塞
阻塞
最大连接数
max Connections
max connections
max Connections
SSL握手
阻塞
非阻塞
阻塞
SSL的实现
USSE
JSSE
OpenSSL
66MP三种模式的neor
AJP协议有三种不同的IO模式,表6.4描述了BIO、NIO和APR三者之间的差异。读写
都是阻塞的,这主要是因为 Apache Server与 Tomcat之间的通信一般都在局域网中,传输速度
较快,所以阻塞读写方式已经足够了。
表64AJP三种模式的 Connector
描述项
BIO Connector
NIO Connector
APR Connector
是否支持轮询
不支持
支持
支持
轮询最大数
无
max Connections
max Connections
读取请求头部
阻塞
阻塞
阻塞
读取请求体
阻塞
阻塞
阻塞
写入响应报文
阻塞
阻塞
阻塞
最大连接数
maxConnections
maxConnections
max Connections
126第7章 Engine容器
Engine即为全局引擎容器,它的标准实现是 StandardEngine。图7.1为它的结构图,它包
含的主要组件有Host组件、 AccessLog组件、 Pipeline组件、 Cluster组件、 Realm组件、
ifecycleListener组件和Log组件。
E
ngine
AccessLog
Pipeline
Host
Cluster
Realm
LifecycleListener
Log
▲图7.1 Engine容器结构图
虚拟主机—Host
Host组件是 engine容器的子容器,它表示一个虚拟主机,就好比访问一个网址htt:/ tomcat
apache. org/ index. html,根据URL地址建模,在 Tomcat内部,网址中的 tomcat. apache.org部分
被抽象成一个虚拟主机Host。Host容器也包含了很多其他的组件,关于Host的详细内容将在
第8章讲解。
访问日志— AccessLog
Engine容器里的 AccessLog组件负责客户端请求访问日志的记录。因为 Engine容器是一
个全局的 Servlet容器,所以这里的访问日志作用的范围是所有客户端的请求访问,不管访问
哪个虚拟主机都会被该日志组件记录。关于 Accesslog的详细内容可参考第12章。
管道— Pipeline
Pipeline其实属于一种设计模式,在 Tomcat中可以认为它是将不同容器级别串联起来的通
道,当请求进来时就可以通过管道进行流转处理。 Tomcat中有4个级别的容器,每个容器都
会有一个属于自己的 Pipeline。关于 Pipeline的原理及其在 Tomcat的使用可参考第19章。第7章 Engine容器
不同级别容器的 Pipeline完成的工作都不一样,每个 Pipeline要搭配阀门( Valve)才能工
作, Engine容器的 Pipeline默认由 StandardEngine Valve作为基础阀门,这个阀门主要的处理逻
辑很简单,仅仅是通过请求找到对应的Host容器并调用该子容器的管道。如果有其他逻辑需
要在ε ngine容器级别处理,可以往该管道中添加包含了逻辑的阀门,当 Engine管道被调用和
执行时会执行该阀门的逻辑。
> Engine集群— -Cluster
Tomcat中有 Engine和Host两个级别的集群,而这里的集群组件正是属于全局引擎容器。
它主要把不同JVM上的全局引擎容器内的所有应用都抽象成集群,让它们能在不同的JVM之
间互相通信,使会话同步、集群部署得以实现。关于集群的相关机制及 Tomcat中集群的实现,
请参阅第20章
> Engine域— Realm
Realm对象其实就是一个存储了用户、密码及权限等的数据对象,它的存储方式可能是内
存、xm文件或数据库等。它的作用主要是配合 Tomcat实现资源认证模块,详细工作原理可
参考第17章。
Tomcat中有很多级别的 Realm域,这里的 Realm属于 Engine容器级别,它的作用范围是
整个 Engine容器。在配置文件的< ngine>节点下配置 Realm,则在启动时对应的域会添加到
Engine容器中。
生命周期监听器 Life CycleListener
Engine容器内的生命周期监听器是为了监听 Tomcat从启动到关闭整个过程的某些事件
然后根据这些事件做不同的逻辑处理。例如,监听 Tomcat的启动事件,在启动时输出日志。
实际上, Engine容器的生命周期监听器默认为 Engine Config,它负责的事情很简单,分别
在 Tomcat启动和关闭时输出 ngine相关的日志。关于 Life CycleListener实现的原理,请
参阅第11章
日志—Log
日志组件负责的事情就是不同级别的日志输出,几乎所有系统都有日志组件,关于 Tomcat
日志组件的实现,请参阅第12章。
128第8章Host容器
在整个 Servlet引擎中抽象出Host容器用于表示虚拟主机,它是根据URL地址中的主机
部分抽象的,一个 Servlet引擎可以包含若干个Host容器,而一个Host容器可以包含若干个
Context容器。在 Tomcat中Host的标准实现是 Standardhost,它从虚拟主机级别对请求和响应
进行处理。下面将对 StandardHost内部结构进行剖析。
如图8.1所示,Host容器包含了若干 Context容器、 AccessLog组件、 Pipeline组件、 Cluster
组件、 Realm组件、 Host Config组件和Log组件。
Host
AccessLog
Pipeline
Context
Cluster
Realm
HostConfi
▲图8.1Host容器
81Weh应用—0met
每个Host容器包含若干个Web应用( Context)。对于Web项目来说,其结构相对比较复
杂,而且包含很多机制, Tomcat需要对它的结构进行解析,同时还要具体实现各种功能和机
制,这些复杂的工作就交给了 Context容器。 Context容器对应实现了Web应用包含的语义
实现了 Servlet和JSP的规范。
Context容器是比较大的一块,包含了各种各样的组件,这里把它单独放到第9章深入
探讨第8章Host容器
82访问日志一 Access0
Host容器里的 AccessLog组件负责客户端请求访问日志的记录。Host容器的访问日志
作用的范围是该虚拟主机的所有客户端的请求访问,不管访问哪个应用都会被该日志组件
记录。
关于 AccessLog的详细内容,请参阅第12章。
83管道— - pipeline
管道( Pipeline)其实属于一种设计模式,在 Tomcat中,它是将不同容器级别串联起
来的通道,当请求进来时就可以通过管道进行流转处理。 Tomcat中会有4个级别的容器,
每个容器都会有一个属于自己的管道。关于管道的详细原理及其在 Tomcat的使用可参考
第19章。
不同级别容器的管道完成的工作都不一样,每个管道要搭配阀门( Valve)才能工作。Host
容器的 Pipeline默认以 StandardHost valve作为基础阀门,这个阀门主要的处理逻辑是先将当前
线程上下文类加载器设置成 Context容器的类加载器,让后面 Context容器处理时使用该类加
载器,然后调用子容器 Context的管道。
如果有其他逻辑需要在Host容器级别处理,可以往该管道添加包含了逻辑的阀门,当Host
管道被调用时会执行该阀门的逻辑。
84H0s集群Gser
这里的集群组件属于虚拟主机容器,它提供Host级别的集群会话及集群部署。关于集群
的详细机制及 Tomcat中集群的实现,请参阅第20章。
85H0s域Bam
Realm对象其实就是一个存储了用户、密码及权限等的数据对象,它的存储方式可能是内
存、xml文件或数据库等。它的作用主要是配合 Tomcat实现资源认证模块,详细工作原理可
参考第17章。
Tomcat中有很多级别的域( Realm),这里的域属于Host容器级别,它的作用范围是某个
Host容器内包含的所有Web应用。在配置文件的<ost>节点下配置域则在启动时对应的域会
添加到Host容器中。
13086生命周期监听器— HostConfig
86生命周期监听器— HostConfig
Host作为虚拟主机容器用于放置 Context级别容器,而 Context其实对应的就是Web应用,
实际上每个虚拟主机可能会对应部署多个应用,每个应用都有自己的属性。当 Tomcat启动时,
必须把对应Web应用的属性设置到对应的 Context中,根据Web项目生成 Context,并将 Context
添加到Host容器中。另外,当我们把这些Web应用程序复制到指定目录后,还有一个重要的
步骤就是加载,把Web项目加载到对应的Host容器内。
在 Tomcat启动时,有两个阶段可以将 Context添加到Host中。第一种方式是用 Digester
框架解析 server xml文件时将生成的 Context添加到Host中,这种方式需要你先将 Context节
点配置到 server:xml的Host节点下。这样做的缺点是不但把应用配置与Web服务器耦合在
块,而且对 server xml配置的修改不会立即生效,除非重启 Tomcat。另外一种方式就是在
server:xml加载解析完后再在特定时刻寻找指定的 Context配置文件。这时已经将应用配置解
耦出Web服务器,配置文件可能为Web应用的META-NF/ ontext. xml文件,也可能是
%CATALINA HOME%/conf/[ EngineName]/HostName]/[WebName].xml
第一种方式在 server xml解析时会自动组织好Host与 Context的关系,它不是本章的重点。
我们重点讨论第二种方式。由于 Tomcat有完整的一套生命周期管理,因此第二种方式交给监
听器去做很合适,相应的监听器只有在 Tomcat中才可以访问。当 Tomcat启动时,它必须把所
有Web项目都加载到对应的Host容器内,完成这些任务的就是 HostConfig监听器。 Host Config
实现了 Lifecycle接口,当 START EⅤENT事件发生时则会执行Web应用部署加载动作。Web
应用有三种部署类型: Descriptor描述符、WAR包以及目录。所以部署时也要根据不同的类型
做不同的处理。
下面看看 HostConfig分别如何部署不同类型的Web应用。
86.1 Descriptor描述符类型
Descriptor描述符的部署是通过对指定部署文件解析后进行部署的,部署文件会按照一定
规则放置,一般为% CATALINA HOME%/ conf/[Engine Name]/[HostName]/My Tomcat.xml其中,
My Tomcat. xml中的 My Tomcat为Web项目名,此文件的内容大致为< Context doc Base=
D: My Tomcat" reloadable="tue">。其中, docBase指定了Web应用的绝对路径, reloadable为true
表示WEB- INF/classes/和/ WEB-INF/ib改变时会自动重加载。另外,如果一个Host包含多个
Context则可以配置多个xml描述文件,如 My Tomcat. xml、 MyTomcatl. xml、 My Tomcat.2xml等。
部署和加载的工作相对比较耗时,而且存在多个应用一起部署加载的情况。如果由 Tomcat
主线程一个一个部署,可能会导致整体的启动时间过长。为了优化多应用部署耗时问题,
Host Config监听器引入了线程池进行多应用同时部署,使用 Future进行线程协调。如图8.2所
示,最上面是主线程,到达①处时表示开始对多个应用进行部署,为每个应用分别创建一个任
l31第8章Host容器
务并交给线程池执行,只有当所有任务都执行完毕时(达到②处),主线程才会继续往下执行。
主线程—
任务1
任务2
任务3
任务4
线程池
,,,,,,,,,,,,,,,,,,,,,,,,,,
▲图8.2生命周期监听器 HostConfig
部署任务主要做的事情如下。
①通过 Digester框架解析指定的 Context配置文件,例如这里是 My Tomcat.xm,根据配
置文件配置的属性,生成 Context对象。
②2通过反射生成 ContextConfig,并作为监听器添加进第①步生成的 Context对象中。
③设置 Context对象的其他属性,如 Context配置文件路径、Name属性、Path属性和版
本属性。
④ Context对象的 doc Base属性用于表示整个web项目工程的路径。将 Context配置文件
路径和 doc Base放到重部署监听列表中,即 Tomcat会有专门的后台线程检查这些文件是否有
改动。如果有改动,则要重新执行部署动作。部署指的是重新组织Host与 Context的关系并且
加载 Context
⑤调用Host的 addchild方法将上面生成的 Context对象添加到Host容器中,此时会触
发 Context启动,启动动作相当繁杂,这将在第9章深入讨论。
⑥将 Context对象中的 WatchedResource添加到重加载监听列表中, Tomcat会有专门的
后台线程检测这些文件是否改动。如果有改动,则会重新执行加载。加载指的是不会重新组织
Hlst与 Context的关系,而是只根据更新后的Web项目更改 Context内容。
至此,完成 Descriptor描述符的部署工作。
8.6.2WAR包类型
WAR包类型的部署是直接读取% CATALⅠ NA HOME% webapps目录下所有以war包形式
打包的Web项目,然后根据war包的内容生成 Tomcat内部需要的各种对象。同样,由于部署
和加载的工作比较耗时,为了优化多个应用项目部署时间,使用了线程池和 Future机制。
部署WAR包类型时,主要的任务如下。
①尝试读取war包里面的/META-INF/ context. xm1文件。
②通过 Digester框架解析 context.xml文件,根据配置属性生成 Context对象
③通过反射生成 ContextConfig,并作为监听器添加到 Context对象中。
④设置 Context对象的其他属性,如 ContextName属性、Path属性、 Doc Base属性和版
13286生命周期监听器— HostConfig
本属性。
⑤调用Host的 add child方法将 Context对象添加到Host中,此时会触发 Context启动,
启动动作相当繁杂,这将在第9章深入讨论。
⑥将 Context对象中的 WatchedResource添加到重加载监听列表中, Tomcat会有专门的
后台线程检测这些文件是否改动。如果有改动,则会重新执行加载。加载指的是不会重新组织
Host与 Context的关系,而是只根据更新后的Web项目更改 Context内容。
至此,完成WAR包的部署工作。
8.63目录类型
目录类型的部署是直接读取% CATALINA HOME% webapps目录下所有目录形式的Web
项目。与前面两种类型一样,使用线程池和 Future优化部署耗时。
部署目录类型时主要的任务如下。
①读取目录里面的META-NF/ context.xm文件。
②通过 Digester框架解析 context. xm文件,根据配置属性生成 Context对象。
③通过反射生成 Context Config,并作为监听器添加到 Context对象中
④设置 Context对象的其他属性,如 ContextName属性、Path属性、 DocBase属性和版
本属性。
⑤调用Host的 addChild方法将 Context对象添加到Host中,此时会触发 Context启动,
启动动作相当繁杂,这将在第9章深入讨论。
⑥将 Context对象中的 WatchedResource添加到重加载监听列表中, Tomcat会有专门的
后台线程检测这些文件是否改动。如果有改动,则会重新执行加载。加载指的是不会重新组织
Host与 Context的关系,而是只根据更新后的Web项目更改 Context内容。
至此,完成目录类型的部署工作。
133第9章 Context容器
Tomcat中有4个级别的容器,本章将对 Context容器及其包含的组件进行分析。一个
Context对应一个Web应用程序,但Web项目的组成比较复杂,它包含很多组件。对于Web
容器,需要将Web应用程序包含的组件转换成容器的组件。
如图91所示, Context容器包含若干 Wrapper组件、Relm组件、 Accesslog组件、 ErrorPage
组件、 Manager组件、 DirContext组件、安全认证组件、 JarScanner组件、过滤器组件、
NamingResource组件、 Mapper组件、 Pipeline组件、 WebappLoader组件、 Application Context
组件、 Instance Manager组件、 ServletcontainerInitializer组件及 Listeners(监听器)组件。下面
将对每个组件进行深入解析。
Context
Realm
AccessLog
ErrorPage
Listeners
ContextConfig
安全认证
W
rapper
TIdConfi
Manager
DirContext
Jarscanner
Naming ContextListener
过滤器
NamingResource
Mapper
Pipeline
Memory Leak TrackingListener
WebappLoader
ApplicationContext
Instance Manager
ServletcontainerInitializer
▲图9.1 Context容器
91c0net容器的配置文件
用于配置 Context容器的配置文件有很多个。这些配置文件用于配置 Context对象的某些属性,
它们直接影响着创建 Context对象。在深入讨论 Context之前,先介绍这些 Context相关的配置文件。
① Tomcat的 server. xm配置文件中的< Context节点可用于配置 Context,它直接在 Tomcat
解析 server. xm1时就完成 Context对象的创建,而不用交给 HostConfig监听器创建。9.5错误页面— ErrorPage
②Web应用的 META-INF/ context. xml文件可用于配置 Context,此配置文件用于配置该
Web应用对应的 Context属性。
③可用% CATALINA HOME%con[ EngineName//[HostName//[WebName]xml文件声明
创建一个 Context
④ Tomcat全局配置为 conf/context. xml,此文件配置的属性会设置到所有 Context中。
件,它配置的属性会设置到某Host下面的所有 Context hostName]/ ontext
⑤ Tomcat的Host级别配置文件为/conf[ EngineName]/ HostName] ontext.xml. default文
92包装器— Wrapper
般来说, Context容器会包含若干个子容器,这些子容器就叫 Wrapper容器。它属于
Tomcat中最小级别的容器,它不能再包含其他子容器,而且它的父容器必须为 Context容器。
每个 Wrapper其实就对应一个 Servlet, Servlet的各种定义在 Tomcat I中就 Wrapper的形式存在。
Wrapper属于核心类,它的构造比较复杂,会在第10章深入探讨。
93cnet域—Ream
域( Realm)对象其实就是一个存储用户、密码及权限等的数据对象,它的存储方式可能
是内存、xml文件或数据库等。它的作用主要是配合 Tomcat实现资源认证模块,详细工作原
理可参考第17章。
Tomcat中有很多级别的 Realm域,这里的 Realm属于 Context容器级别,它的作用范围
也只是相对于某个Web应用。在配置文件的< Context节点下配置 Realm,则在启动时对应的
域会添加到 Context容器中。
94访问日志—ce0
访问日志组件用于记录客户端的访问,主要可以记录请求的一些信息,包括请求P地址、
请求时间、请求资源、响应状态、请求处理时间等。每个 Context容器可以有自己的访问日志
组件,关于 AccessLog的详细内容,请参阅第12章。
95错误页面— ErrorPage
每个 Context容器都拥有各自的错误页面对象,它用于定义在web容器处理过程中出现问
题后向客户端展示错误信息的页面,这也是 Servlet规范中规定的内容。它可以在Web部署描
述文件中配置,例如:
135第9章 Context容器
<error-page>
<error-code>404</error-code>
<location>/web-inf/404. html</location>
</error-page>
或
<error-page>
<exception-type>java. lang NullPointerException</exception-type>
<location>/WEB-INF/nullPointerException. html</location>
</error-page>
第一个配置表示,web容器处理过程中,当错误编码为404时,向客户端展示
WEB-INF404htm页面。第二个配置表示,处理过程中,当发生 NullPointer Exception异常时,
向客户端展示/ WEB-INF/ nullPointer Exception. html页面。
在Wb应用启动过程中,会将 web. xm中配置的这些 error-page元素读取到 Context容器
中,并以 ErrorPage对象形式存在。 ErrorPage类包含三个属性: error Code、 exceptionType和
location,刚好对应 web.xm中的eror-page元素。
如图92所示,实际上 Tomcat对整个请求的处理过程都在不同级别的管道中流转。而对
错误页面的处理其实是在 StandardHost Valve阀门中,它调用对应 Context容器对请求处理后,
根据请求对象的响应码,判断是否需要返回对应的错误页面,同时它还根据处理过程中发生的
异常寻找对应的错误页面,这样就实现了 Servlet规范中错误页面的功能。
Standardengine
Standard Context
StandardEngine Valve
StandContext Valve
StandardHost
StandardWrapper
StandardHost Valve
StandardWrapper valve
▲图9.2请求在管道流转
1369.7目录上下文— Dir Context
96会话管理器— Manager
Context容器的会话管理器用于管理对应Web容器的会话,维护会话的生成、更新和销毁。
每个 Context都会有自己的会话管理器,如果显式在配置文件中配置了会话管理器,则 Context
容器会使用该会话管理器;否则, Tomcat会分配默认的标准会话管理器( StandardManager)。
同时,如果在集群环境下会使用集群会话管理器,可能是 Deltamanager或 Backup Manager
关于会话管理器的工作原理及设计,请参阅第20章。
97目录上下文— Dircontext
Di( Context接口其实是属于JND的标准接口,实现此接口即可实现目录对象相关属性的
操作。对于 Tomcat,具体来说,就是 Context容器需要支持一种便捷的方式去访问整个Web
应用包含的文件。例如,通过一个字符串路径就能找到对应的文件资源。整个Web应用就像
棵树,如图9.3所示。 Webroot是应用的根目录,它下面包含了很多文件目录和文件,例如
css、wEB-INF、META-INF、 index. jsp等,而WEB-INF又包含了web,xml、 classes、lib,这
些文件目录和文件呈树状结构。所以通过“ META-INF/ context. xm”获取到 context.xml的文
件内容将是一个很便捷的方式。
WebRoot
WEB-INF
META-INF
CSS
Index.Jsp
context xml
classes
web . xml
com
My Test. cl
图9.3目录上下文
DirContext接口要完成的事情就是通过某些字符串便捷地获取对应的内容,于是 Context
容器需要依赖这个接口,为后面处理提供便捷的访问方式。而Web应用项目有两种形式的包,
137第9章 Context容器
般我们可能将Web打包成war或者一个Web目录,所以 Context容器要同时支持这两种格
式的文件格式,不管哪种格式,应该都可以通过路径形式的字符串准确获取到相应的文件内容。
这两种格式对应的 DirContext实现类为 WARDirContext和 FiledirContext。与 WARDirContext
处理不同的是, FileDirContext需要对war包进行解压,然后才能获取到对应的文件内容,而
FileDirContext则可以直接获取文件内容。
98安全认证
对于Web安全认证方面,一般的用法是需要在web部署描述文件中进行配置,具体的配
置及其工作原理可以查看第17章。在 web.xm中涉及安全认证的元素有< <security-constraint和
login-config>元素,通过它们可以实现对 Context容器中资源访问的约束。< ecurity-constraint元
素指定了哪些URL需要哪些角色才能访问,而< ogin-config>元素则指定了使用哪种认证登录
方式。
Tomcat启动时要将 web.xm的这些元素转成Java形态,即 Security Constraint和 Login Config
对象。它们都属于 Context容器内部的属性,而且它们的结构也非常简单,就是web.xml中
security-constraint>和< ogin-config>元素的映射。
99ar扫描器 Jarscanne
从 JarScanner的名字上已经知道它的作用了,它一般包含在 Context容器中,专门用于扫描
Context对应的web应用的Jar包。每个Web应用初始化时,在对TLD文件和 web-fragment. xml
文件处理时都需要对该Web应用下的Jar包进行扫描,因为Jar包可能包含这些配置文件,Web
容器需要对它们进行处理。
Tomcat中 JarScanner的标准实现为 StandardJarScanner。它将对wWeb应用的
WEB- INF/lib目录的Jar包进行扫描,它支持声明忽略某些Jar包,同时它还支持对 classpath
下的Jar包进行扫描。然而,如果 classpath下的Jar包与WEB- INF/lib目录下的Jar包相
同,则会被忽略。
JarScanner在设计上釆用了回调机制,每扫描到一个Jar包时都会调用回调对象进行处理。
回调对象需要实现 JarScannerCallback接口。此接口包含了scan( JarURLConnection urIConn)和
scan( File file)两个方法,我们只需要将对Jar包处理的逻辑写入这两个方法中即可。 JarScanner
在扫描到每个Jar包后都会调用一次此方法,执行对该Jar包的逻辑处理。
Jar扫描器为 Context容器的启动过程提供了方便地扫描Jar包的功能,它让开发过程不必
关注Web应用Jar包的搜索,而是专注于编写对Ja包中TLD文件和web- fragment. xml文件的
逻辑处理。
1389.10过滤器
910过滤器
过滤器提供了为某个web应用的所有请求和响应做统一逻辑处理的功能,如图9.4所示,
客户端发起请求后,服务器将请求转到对应的Web应用webl上,过滤器 filter1和 filter2对请
求和响应进行处理后返回响应给客户端。
服务器
响应
webI
web2
客户端
过滤器
filter
filter
filter
filter
响应
▲图9.4过滤器
Servlet规范中规定需提供过滤器功能,允许web容器对请求和响应做统一处理。因为每
个 Context容器对应一个Web应用,所以 Tomcat中的过滤器及其相关配置保存在 Context容
器中是最适合的。也就是说,每个 Context可能包含若干个过滤器。一个简单的典型 Filter配
置如下。
<filter>
<filter-name>EcodingFilter</filter-name>
<filter-class>com. test. EncodeFilter</filter-class>
<init-param>
<param-nameEncode Coding</param-name>
<param-value>UTF-8</param-value>
</init-param>
</filter>
<filter-mapping>
<filter-name>EcodingFilter</filter-name>
<url-pattern>*</url-pattern>
</filter-mapping>
配置主要就是配置过滤器类名称、过滤器类、初始化参数以及过滤器的映射路径。下面介
绍 Context容器如何实现过滤器的。
FilterDef
Filter Def用于描述过滤器的定义,它其实对应web部署描述符配置的 Filter元素,如
Filter Def对象包含 filter Class、 filterName、 parameters等属性,它们的值对应 web, xm文件中
Filter元素的< filter-name>、< filter-cass、< <init-param>子元素中的值。Web应用启动解析 web. xml
时,将 Filter元素转换成 FilterDef实体对象
139第9章 Context容器
ContextFilterMaps
ContextFilterMaps用于保存过滤器映射关系,它对应Web部署描述符配置的 filter-mapping
元素。它其实就是一个Ma数据结构对象,将 web. xml文件中 filter-mapping的子元素 filter-name
和 url-pattern对应的值保存起来,方便后面进行URL匹配。
Application Filter Config
Servlet规范提供一个 Filter Config接口访问 Filter的名称、初始化参数以及 Servlet上下文。
Application Filter Config是 ilter Config接口的具体实现,它的实现具体依赖 Context容器。而当
初始化每个 Filter时, Application Filter Config对象都会作为 Filter的init方法的参数,所以我
们在自定义 Filter时可以在初始化方法中直接使用 Filter Config接口。
Context容器的过滤器模块的主要对象就是包含了以上三个对象: FilterDef、 ontextFilterMaps
和 Application Filter Config。而调用这些过滤器进行过滤的工作则由 Wrapper容器中的管道负责。
911命名资源— NamingResource
Naming Resource组件其实是一个很简单的组件,它负责的工作就是将配置文件中声明的
不同的资源及其属性映射到内存中,这些映射统一由 Naming Resource对象封装。如图9.5所
示,命名资源的配置有两个地方,分别为 Tomcat容器的 server xml文件和每个Web项目的
context. xml文件。它们通过 Digester框架读取配置文件中对应的属性并设置到 Naming Resource
的属性中, NamingResource组件便充当这么一个功能。
Context
监听到web
应用初始化
创建命名上下
Naming Contextlisterner
文,绑定资源
Naming Context
Naming Resources
ContextResources
Contexte
☆☆☆
ContextEnvironment
Me
DestinationRef
Context Resource EnvRe
ContextResourceLink
JNDI框架运行机制
<Server>
<Service>
利用 Digester创建
NamingResources实例
<Host
<Context
Resource/>
server xml
META-INI
<Context>
<Resource/>
</Context>
server xml
</Context>
ENgine
</Service>
</Server>
9.5命名资源
1409.13管道—— -Pipeline
实际上, Tomcat要完成命名目录接口需要另外一个 Naming ContextListener监听器组件协
同,这两个组件都属于 Context容器。当Web应用初始化时,此监听器会创建JNDI的命名上
下文及其资源绑定,以此完成 Tomcat对JNDI的支持
91 Servlet映射器— Mapper
Context容器包含了一个请求路由映射器( Mapper)组件,它属于局部路由映射器,它只
能负责本 Context容器内的路由导航。即每个web应用包含若干 Servlet,而当对请求使用请求
分发器 RequestDispatcher以分发到不同的 Servlet上处理时,就用了此映射器。
关于 Mapper的详细实现原理及映射规则,可以参考第15章。
9#3管道— Pipelin
Context容器的管道负责对请求进行 Context级别的处理,管道中包含了若干个不同逻辑处理的
阀门。其中有一个基础阀门,它的主要处理逻辑是找到对应的 Servlet并将请求传递给它进行处理。
如图9.6所示, Tomcat中4种容器级别都包含了各自的管道对象。而 Context容器的管道
即为图9.6中的 StandardContext包含的管道, Context容器的管道默认以 Standard Context Valve
作为基础阀门。这个阀门主要的处理逻辑是判断请求是否访问了禁止目录,如WEB-ⅠNF或
META-INF目录,并向客户端发送通知报文“HTP/1.100 Continue”,最后调用子容器 wrapper
管道。请求就在这些不同的管道中流转,直至最后完成整个请求处理。每个容器的管道完成的
工作都不一样,每个管道都要搭配阀门才能工作。
StandardEngine
Standardcontext
StandardEngine valve
tand Context Val
andardHost
Standard wrapper s
Standard Host Valve
StandardWrapper Valve
图9.6管道
141第9章 Context容器
914W应用载入器 Webauploader
每个Web应用都有各自的 Class类和Jar包。一般来说,在 Tomcat启动时要准备好相应
的类加载器,包括加载策略及 Class文件的査找,方便后面对web应用实例化 Servlet对象时
通过类加载器加载相关类。因为每个Web应用不仅要达到资源的互相隔离,还要能支持重加
载,所以这里需要为每个Web应用安排不同的类加载器对象加载,重加载时可直接将旧的类
加载器对象丢弃而使用新的。
Standard Context使用一个继承了 Loader接口的 WebappLoader作为Web应用的类加载器。
作为 Tomcat的Web应用的类加载器的实现,它能检测是否有web项目的 Class被更改,然后
自动重加载。每个Web应用对应一个 Webapploader,每个 Webapploader互相隔离,各自包
含的类互相不可见。
如图97所示, WebappLoader的核心工作其实交给其内部的 Webapp ClassLoader,它才是
真正完成类加载工作的加载器,它是一个自定义的类加载器。 WebappClassLoader继承了
URLClassloader,只需要把WEB-INF/ib和/WEB-INF/lase录下的类和Jar包以URL形式
添加到 URLClassloader中即可,后面就可以用该类加载器对类进行加载
Webapp Loader
Webapp ClassLoade
/WEB-INF/lib /WEB-INF/classes
▲图9.7Web应用载入器
Webapp ClassLoader类加载器是如何达到互相隔离和实现重加载的呢?
Webapp! Class loader并没有遵循双亲委派机制,而是按自己的策略顺序加载类。根据委托
标识,加载分为两种方式。
①当委托标识 delegate为 false时, Webapp ClassLoader类加载器首先先尝试从本地缓存
中查找加载该类,然后用 System类加载器尝试加载类,接着由自己尝试加载类,最后才由父
类加载( Common)器尝试加载。所以此时它搜索的目录顺序是< JAVA HOME>jre/ib→<AVA
HOME> /jre/lib/ext→ CLASSPATH→WEB-NF/ classes→/WEBⅠ NF/ib→ SCATALINA BASE/ib和
SCATALINA HOME/ib
②2当委托标识 delegate为true时, Webapp ClassLoader类加载器首先先尝试从本地缓存中
1429.15 Servletcontext的实现—— ApplicationContext
查找加载该类,然后用 System类加载器尝试加载类,接着由父类加载器( Common)尝试加
载类,最后才由自己尝试加载。所以此时它的搜索的目录顺序是< JAVA HOME> jre/lib→<JAA
HOME>jre/ lib/ext→ CLASSPATH→ SCATALINA BASE/ib和$ CATALINA HOME/ib→
/WEB-INF/ classes→/WEB-NF/lib。
图98是 WebappClassLoader和其他类加载器的关系结构图。可以看出,对于公共资源可
以共享,而属于Web应用的资源则通过类加载器进行了隔离。对于重加载的实现,也比较清
晰,只需要重新实例化一个 Webapp ClassLoader对象并把原来 WebappLoader中旧的置换掉即
可完成重加载功能,置换掉的将被GC回收。
Boostrap ClassLoader
Extension Classloader
System Classloade
Common classloader
Webapp Class
WebappClass
WebappS
oader
Loade
WEB
/EB-
/EB
WEB
AWEB
/EB-
INF/ib
INF/classes
INF/ib
INF/classes
ⅠNF/ib
ⅠNF/ classes
▲图9.8类加载器关系
915 Servletcontext的实现— ApplicationContext
在 Servlet的规范中规定了一个 Servletcontext接口,它提供了Web应用所有 Servlet的视
图,通过它可以对某个Web应用的各种资源和功能进行访问。
Servletcontext接口包含的主要常见方法如下。
addFilter,往 Servlet上下文中添加 Filter
addListener,往 Servlet上下文中添加 Listener
addServlet,往 Servlet上下文中添加 servlet
getAttribute,从 Servlet上下文中获取某属性值。
setAttribute,设置 Servlet上下文中某属性的值。
remove Attribute,从 Servlet上下文中删除某属性。
setInitParameter,设置web应用配置的初始值。
143第9章 Context容器
getInitParameter,获取web应用配置的初始化。
getResourceAsStream,从 Servlet上下文中获取某资源的流。
对于 Tomcat容器, Conteαt容器才是其运行时真正的环境。为了满足 Servlet规范,它必
须要包含一个 ServletContext接口的实现,这个实现就是 Application Context Application Context
是 Servletcontext的标准实现,用它表示某个web应用的运行环境,每个 Tomcat的 Context
容器都会包含一个 Application Context
Application Context对 Servletcontext接口的所有方法都进行了实现,所以Web开发人员可
以在 Servlet中通过 getServletContextO方法获得该上下文,进而再对上下文进行操作或获取上
下文中的各种资源。但实际上 getServlet Context()获取到的并非A
pplication Context
对象,而是
个 Application Context的门面对象 Application ContextFacade。门面模式的作用就是提供一个
类似代理的访问模式,把 Application Context里面不该暴露的方法和属性屏蔽掉,不让Web开
发人员访问
如图99所示, Application Context提供了一个 Application ContextFacade门面对象,Web开发
人员编写 Servlet逻辑时只能获取到该门面对象。该门面对象只提供了对 Application Context可暴露
的方法和属性的访问,而对于一些运行的重要属性和内部方法则不能暴露给Web开发人员,以
免影响整个Web应用的运行。
servlet
Application ContextFacade
不可暴露
可暴露
可暴露
不可暴露
可暴露
ApplicationContext
图9.9 ApplicationContext门面
Application Context的实现很大程度上依赖于 Tomcat的 Context容器,它需要从 Context
容器中获取各种资源,如 Servlet信息、 Filter信息等,而且像 getResourceAsStream方法其实
也获取 Context容器里面的某资源然后返回流。
所以总的来说, Application Context就是为了满足 Servlet标准的 ServletContext接口而实现
的一个类,它按 Servlet的规范要求提供了各种实现方法。
144917 ServletcontainerInitializer初始化器
916实例管理器 InstanceManager
Context容器中包含了一个实例管理器,它主要的作用就是实现对 Context容器中监听器、
过滤器以及 Servlet等实例的管理。其中包括根据监听器 Class对其进行实例化,对它们的
Class的注解进行解析并处理,对它们的 Class实例化的访问权限的限制,销毁前统一调用
preDestroy方法等。
实例管理器的实现其实很简单,其中就使用了一些反射机制实例化出对象,但这里面需要
注意的地方是, InstanceManager包含了两个类加载器,一个是属于 Tomcat容器内部的类加载
器,而另外一个是Web应用的类加载器。 Tomcat容器类加载器是web应用类加载器的父类加
载器,且 Tomcat容器类加载器在 Tomcat的整个生命周期中都存在,而Web应用类加载器则
不同,它可能在重启后则被丢弃,最终被GC回收。
所以,由不同类加载器加载的类也会有不同的生命周期。于是,实例管理器中的 loadclass
方法中会有类似如下的判断。
protected Class<?> loadclass(String className, ClassLoader classloader)thr
ows ClassNotFoundException t
f (className startswith("org. apache. catalina"))t
return containerclassLoader loadClass(className )i
3 else
return webClassLoader loadclass(className)i
判断需要实例化的 Class是否属于 org. apache. catalina包下的类,如果属于则使用 Tomcat
容器类加载器加载,这个类会在 Tomcat的整个生命周期中存在内存中,否则会使用Web类加
载器加载。
9们 Servletcontainerinitializer初始化器
在web容器启动时为让第三方组件机做一些初始化工作,例如注册 Servlet或者 Filters等, Servlet
规范中通过 ServletcontainerInitializer实现此功能。每个框架要使用 Servletcontainerinitializer就必
须在对应的Jar包的 META-INF/ services目录中创建一个名为 javax. servlet Servlet ContainerInitializer
的文件。文件内容指定具体的 ServletcontainerInitializer实现类,于是,当Web容器启动时,就会
运行这个初始化器做一些组件内的初始化工作。
一般伴随着 Servlet containerlnitializer起使用的还有 Handles Types注解,通过 Handles Types
可以将感兴趣的一些类注入 Servletcontainerlnitializer的 on Startup方法中作为参数传入。
145第9章 Context容器
Tomcat容器的 ServletcontainerInitializer机制,主要交由 Context容器和 ContextConfig监
听器共同实现。 ContextConfig监听器首先负责在容器启动时读取每个Web应用的wEB-INF/
ib目录下包含的Jar包的 META-INF/ services/javax. servlet. ServletContainerInitializer,以及Web根目
录下的 META-INF/ services/javax. servlet. ServletContainerInitializer,通过反射完成这些 Servlet
ContainerInitializer的实例化,然后再设置到 Context容器中。最后, Context容器启动时就会
分别调用每个 ServletcontainerInitializer的 on Startup方法,并将感兴趣的类作为参数传入。
基本的实现机制如图9.10所示。首先,通过 ContextConfig监听器遍历每个Jar包或web
根目录中的 META-INF/ services/javax. servlet Servlet ContainerInitializer文件,根据读到的类路径
实例化每个 Servlet containerInitializer。然后,再分别将实例化的 Servletcontainerlnitializer设
置进 Context容器中。最后, Context容器启动时分别调用所有 Servletcontainerlnitializer对象
的 on Startup方法。
r
Context
ContextConf
ontic
Initializers
jaI
stArtup(
▲图9.10 Servletcontainer initializer的实现机制
假如读出来的内容为 com.seaboat. mytomcat CustomServletContainerInitializer,则通过反射
实例化一个 Custom ServletContainerInitializer对象。这里涉及一个@ Handles Types注解的处理
被它标明的类需要作为参数值传入 on Startup方法中,如下例所示。
dhaNdlestypes(i Httpservlet. class Filter class ))
public class CustomServletContainerInitializer implements
ServletContainerInitializer
public void onstartup(Set<class<?>> classes, ServletContext servletContext)
throws ServletException t
for(Class c: classes
System. out. println(c getName ())i
其中@ HandlesTypes标明的 Http servlet和 Filter两个Cas被注入 on Startup方法中。所以
这个注解也需要在 ContextConfig监听器中处理。前面已经介绍了注解的实现原理,由于有了
编译器的协助,因此我们可以方便地通过 ServletcontainerInitializer的 Class对象获取到
HandlesTypes对象,进而再获取到注解声明的类数组,如以下代码所示。
146918 Context容器的监听器
HandlesTypes ht =servletContainerInitializer. getclass(). getAnnotation(Handl
esTypes class)i
Class<?>[] types =ht value()i
获取到 Http Servlet和 Filter的 Class对象数组,后面 Context容器调用 Custom Servlet
ContainerInitializer对象的 on Startup方法时作为参数传入。至此,即完成了 Servlet规范的
ServletcontainerInitializer初始化器机制。
918cnte容器的监听器
Context容器的生命周期伴随着 Tomcat的整个生命周期,在 Tomcat生命周期的不同阶段
Context需要做很多不同的操作。为了更好地将这些操作从 Tomcat中解耦出来,提供一种类似
可插拔可扩展的能力,这里使用了监听器模式。把不同类型的工作交给不同的监听器,监听器
对 Tomcat生命周期不同阶段的事件做出响应。
实际上, Tomcat启动过程中一般默认会在 Context容器中添加4个监听器,分别为
Context Config、 TldConfig、 Naming ContextListener以及 Memory LeakTracking Listener如图911
所示,每个监听器负责各自的工作,从名字可以大概看出各自的功能。 ContextConfig监听器
主要负责在适当的阶段对Web项目的配置文件进行相关处理; TldConfig监听器主要负责对
TLD标签配置文件的相关处理; Naming ContextListener监听器主要负责对命名资源的创建、
组织、绑定等相关的处理工作,使之符合JND标准; Memory LeakTracking Listener监听器主
要用于跟踪重加载可能导致内存泄漏的相关处理。
Context
listeners
Contextconfi
TIdConfig
NamingContextListener
Memory Leak Tracking Listener
▲图9.11 Context容器的监听器
另外,这些监听器添加到 Context中的时期也是不一样的。 Context Config监听器可能是在
Digester框架解析 server xml文件生成 Context对象时添加的,也可能是由 Host Config监听器
添加的; TldConfig监听器则是在 Context容器初始化( initlnternal方法)时添加的;
147第9章 Context容器
Naming ContextListener监听器是在 Context容器启动( startInternal方法)时添加的
Memory LeakTracking Listener监听器则是在 HostConfig监听器调用 add Child方法把 Context容
器添加到Host容器时添加的。每个监听器负责的详细工作分别又有哪些?在 Tomcat启动时它
们都执行了什么操作?下面对每个监听器进行详细分析。
9.18.1 Context Config监听器
ContextConfig监听器感兴趣的几个事件为: AFTER INIT EVENT、 BEFORE START EVENT、
CONFIGURE START EVENT、 AFTER START EVENT、 CONFIGURE STOP EVENT和
AFTER DESTROY EVENT等。按照 Tomcat的生命周期,这些事件的顺序为 AFTER
INIT EVENT→ BEFORE START EVENT→ CONFIGURE START EVENT→ AFTER START
EVENT→ CONFIGURE STOP EVENT→ AFTER DESTROY EVENT。根据不同的响应事件,
ContextConfig监听器都做不同的事情
1)当 AFTER INIT EVENT事件发生时,会调用 Context Config监听器的init方法,init
主要的工作如下。
①创建 Digester对象,指定解析规则,因为在 HostConfig监听器中只是根据< Context>
节点属性创建了一个 Context对象,但其实< Context>节点还有很多子节点需要解析并设置到
Context对象中。另外, Tomcat中还有两个默认的 Context配置文件需要设置到 Context对象作
为默认属性,一个为 conf/context. xml文件,另一个为conf[ EngineName]/ Hostname]
context. xml. default文件。所以 Digester的解析工作分为两部分,一部分是解析默认配置文件,
二部分是解析< Context>子节点。子节点包括 Instancelistener、 Listener、 Loader、 Manager、 Store、
Parameter、 Realm、 Resources、 ResourceLink、 Valve、 WatchedResource、 WrapperLifecycle、
Wrapperlistener、 JarScanner、Fjb、 Environment、 LocalEjb、 Resource、 ResourceEny Ref、 ServiceRef、
Transaction等元素
②用第①步创建的 Digester对象按顺序解析 conf/context.xml、coni[ EngineName
[HostName//context. xml. default、META- INF/ context. xml等文件。必须按这个顺序,先用全局
配置设置默认属性,再用Host级别配置设置属性,最后用 Context级别配置设置属性。这种顺
序保证了特定属性值可以覆盖默认的属性值,例如对于相同的属性 reloadable, Context级别配
置文件设为true,而全局配置文件设为 false,于是 Context的 reloadable属性最终的值为true。
③创建用于解析 web. xml文件的 Digester对象
④根据 Context对象的 doc Base属性做一些调整工作,例如,默认把WAR包解压成相应
目录形式,对于不解压的WAR包则要检验WAR包的合法性
2)当 BEFORE START EVENT事件发生时,会调用 Context Config监听器的 before Start
方法, beforeStart主要的工作如下。
根据配置属性做一些预防Jar包被锁定的工作,由于 Windows系统可能会将某些Jar包锁
定,从而导致重加载失败。这是因为重加载需要在把原来的Web应用完全删除后,再把新Web
l489.18 Context容器的监听器
应用重新加载进来,但假如某些Jar包被锁定了,就不能删除,除非把整个 Tomcat停止了。这里
解决的思路是:将Web应用项目根据部署次数重命名并复制到% CATALINA HOME%temp临时
目录下(例如第一次部署就是1- my Tomcat.war),并把 Context对象的 docBase指向临时目录下的
Web项目,这样每次重新热部署都有一个新的应用名,就算原来应用的某些Jar包被锁定了也
不会导致部署失败。
3)当 CONFIGURE START EVENT事件发生时,会调用 ContextConfig监听器的 configure Start
方法。 configureStart主要的工作为扫描web应用部署描述文件web,xm,并且使用规范将它们合并
起来,定义范围比较大的配置会被范围比较小的配置覆盖,例如Web容器的全局配置文件
web. xml会被Host级别或Web应用级别的 web. xm覆盖。详细的步骤如下。
①将 Context级别的 web, xml解析复制到 Web Xml对象中。
②扫描Web应用/WEB- INF/ib目录下的所有Jar包里面的 META-INF/web- fragment. xml
文件生成多个 Web Fragment, Web Fragment本质上还是 Web Xml对象。
③将这些 Web Fragment根据 Servlet规范进行排序,主要是根据绝对顺序和相对顺序。
④根据 Web Fragment扫描每个Jar包中的 Servletcontainerinitializer,,把它们添加到
Context容器的一个Map中,方便 Context容器初始化时调用它们
⑤解析Web应用/wEB-INF/ classes目录下被注解的 Servlet、 Filter或 Listener,对应的注
解符为@ Web Servlet、@ Web Filter和@ Weblistener o
⑥解析Web应用相关Jar包里面的注解,其中同样包含了 Servlet、 Filter和 Listener
⑦合并 Web Fragment到总的 Web Xml对象中。
⑧合并默认 web. xml对应的 EbxMl对象到总的 Web Xml对象中,默认的 web, xml包括
Web容器全局 web. xml、Host容器级别的 web. xml,路径分别为 Tomcat根目录中的/conf/ web. xml
文件和 conf/engine' s name/hosts name/web. xml. default文件。
⑨将有些使用了<jsp-fle>元素定义的 Servlet转化成 JspServlet模式。
⑩将 Web Xml对象中的上下文参数、EJB、环境变量、错误页面、 Filter、监听器、安全
认证、会话配置、标签、欢迎页、JSP属性组等设置到 Context容器中。而 Servlet则转换成
Wrapper放到 Context中。
①把合并后的 Web Xml的字符串格式以 org.apache. tomcat. util. scan. Constants. MERGED
WEB XML作为属性键存放到 Context属性中。
①②扫描每个Jar包的META- INF/resources/目录,将此目录下的静态资源添加到 Context
容器中。
①3将 ServletcontainerInitializer添加到 Context容器中。
⑩处理 Servlet、 Filter或 Listener类中的注解,有三种注解,分别为类注解、字段注解、
方法注解,分别把它们转化成对应的资源放到 Context容器中,实例化这些对象时要将注解注
入对象中。
4)当 AFTER START EVENT事件发生时处理的逻辑比较简单,只是把 Context容器的
149第9章 Context容器
doc Base指向另外一个目录上,为了解决重新部署时可能导致的锁问题,而把项目复制到另外
个目录上,而 docBase要指向它。
5)当 CONFIGURE STOP EVENT事件发生时,会调用 Context Config监听器的 configureStop
方法, configure Stop主要的工作是在停止前将相关属性从( Context容器中移除掉,包括 Servlet、
Listener、 Filter、欢迎页、认证配置等。
6)当 AFTER DESTROY EVENT事件发生时,会调用 ContextConfig监听器的 destroy
方法, destroy方法主要用于删除工作目录。
至此, ContextConfig监听器分析完毕,它其实负责了很多事情,主要就是根据各种配置
设置 Context容器的属性。下面分析 Context Config监听器在处理各种元素过程中使用的一些
工具及其原理。
≯ web. xml的映射 EbxMl
Web应用部署描述文件用于描述Web组件,Web容器会使用部署描述文件初始化Web应
用组件,一般包括 web. xml和web- fragment. xml文件。Web容器为方便使用需要把配置文
件转化成内存数据格式,在 Tomcat中使用了 Digester框架将xml转化成类对象,而这个类
就是 EbxMl。
≯ Servlet注解的处理
为了提供声明式的支持, Servlet规范中规定了一些注解,主要有@ WebServlet、@ WebFilter
和@ Weblistener,通过对某些类进行注解可以往Web项目中添加 Servlet、 Filter和 Listener.
而为了支持这些声明式,处理的工作要在Web容器中完成。下面讨论 Tomcat是如何在
Context Config监听器中实现对规范中注解的支持的。
在一个Web项目中,包含了注解的地方主要在Web项目的/EB-INF/ classes目录下的所
有 class文件和 WEB-INF/lib目录下Jar包中的 Class x件中。因为我们不知道这些包含了注解
的类的名字,所以无法在Java程序中直接通过反射获取注解的相关信息,唯一的解决办法就
是一个个读取 Class文件,并按照JVM规范中的Cass文件规定解析 Class文件,然后提取需
要的相关信息进行处理。实现过程中涉及两个辅助类 Javaclass和 Class Parser
Javaclass
Clas文件严格遵循JVM规范规定的格式。为了方便对 Class文件的操作,把 Class文件保存
成一个Java类实例,用来保存 Class文件结构属性的类就是 JavaClass Class文件的属性可以对应
保存到 Javaclass对象中。例如, Class的版本信息、 Class的常量池、Clas的注解集等。
ClassParser
对αlas文件的解析则交由 Class Parser类,它会根据规范解析 Class文件,并把对应的值
设置到 Javaclass对象中。例如,读取 Class y件的版本信息并设置到 JavaClass对象的版本属
性中,读取注解集并保存到 Javaclass对象中。
如何处理
有了上面两个辅助类,对 Servlet规范注解的处理就简单多了,方法是遍历所有可能包含
150918 Context容器的监听器
注解的 class 7和jar文件,每个cass件通过 Class Parser解析并生成 Javaclass对象, JavaClass
对象包含了该类的所有注解集
Cas件中规定不同类型要用不同的表示字符,例如B标识byte类型,而对象类型则要
用L开头,即Sing类型标识则为 Ljava/lang/String;"。所以对于@ WebServlet、@ Web Filter和
Weblistener注解的类型标识分别为"I
Ljavax/servlet/annotation/Web Servlet; ","Ljavax/servlet
annotation/Web Filter;"" javax/servlet/annotation/ WebListener;根据这些类型标识就可以在运
行时动态实例化 Servlet、 Web Filter和 WebListener等,并将对象添加到 Context容器中。例如,
对于注解@ Web servlet(name=" My Servlet'", urlPatterns={"test"}),name和 urlPatterns属性都会
解析并保存在 JavaClass对象的注解集中, Servlet需要的属性全都有了。
综上所述,有了 JavaClass对象就完成了注解的处理。
9.18.2 TIdConfig监听器
JSP规范规定了标签,每个标签都需要在TLD文件中声明。而TLD文件其实就是一个
ⅹML格式的文件,所以 Tomcat在处理 Context容器的过程中要解析这些XML文件。使用
Digester框架解析TLD文件。TLD文件的根节点为< taglib>,它同时包含很多子节点
要确定TLD文件的位置有几种方式。
①在 web. xm中声明TLD文件的路径
②直接扫描WEB-NF/目录下是否存在TLD文件,但不包含WEBⅠNF/ib目录和
/WEB-ⅠNF/ classes目录。
③扫描/WEB-ⅠNFib目录下Jar包的META-INF目录下的TLD文件
④扫描 classpath下的Jar包的 META-INF目录下的TLD文件。
TIdConfig监听器主要的工作职责就是寻找可能存在TLD文件的位置,并解析找到的TLD
文件,以一定的结构保存到内存中。
9.183 Naming ContextListener监听器
Tomcat中需要支持JNDI,而JND1分为全局和局部两种, Context容器对应的即为局部
这里的 Naming ContextListener监听器用于创建命名上下文,并将资源组织成树状。监听器在
接收到事件后完成对命名资源的创建、组织、绑定等工作,使之符合JD标准。
9.184 Memory LeakTrackingListener监听器
Memory LeakTracking Listener监听器主要辅助完成关于内存泄漏跟踪的工作。一般情况下,
如果我们通过重启 Tomcat重启web应用,则不存在内存泄漏问题。但如果不重启 Tomcat而
对Web应用进行重加载,则可能会导致内存泄漏,因为重加载后有可能会导致原来的某些内
存无法被GC回收。例如,当web应用使用了JDBC时,驱动程序会进行注册,当Web应用
停止时,没有反注册就会导致内存泄漏。
151第9章 Context容器
看看是什么原因导致 Tomcat内存泄漏的。这个要从热部署开始说起,因为 Tomcat提供了
不必重启容器而只须重启Web应用以达到热部署的功能,其实现是通过定义一个
Webapp ClassLoader类加载器,当热部署时,就将原来的类加载器废弃并重新实例化一个
Webapp ClassLoader类加载器。但这种方式可能存在内存泄漏问题,因为类加载器是一个结构复杂
的对象,导致它不能被GC回收的可能性比较多。除了对类加载器对象有引用可能导致其无法回
收之外,对其加载的元数据(方法、类、字段等)有引用也可能会导致它无法被GC回收。
如图9.12所示, Tomcat的类加载器之间有父子关系。这里只看启动类加载器 Bootstrap
Classloader和Web应用类加载器 Webapp ClassLoader在JVM中, Bootstrap ClassLoader负责加载
rt. jar包的 java.sql DriverManager,而 WebappClassLoader负责加载Wb应用中的 Mysql驱动包。其
中有一个很重要的步骤是Mysq的驱动类需要注册到 DriverManager中,即 DriverManager register
Driver(new DriverO),它由Mysq驱动包自动完成。这样一来,当Web应用进行热部署操作时,如
果没有将 Mysql的 Driver从 DriverManager中反注册掉,则会导致整个 WebappClassLoader无法回
收,造成内存泄漏。
JAVA HOMEljre
Aib/rt jar
java.sql Driver Manager
load
Bootstrap
Classloader
DroverManager register Driver
(new DriverO)
WebappClassLoader
load
WEB-INF/lib/mysql
connector.Jar
com. mysql jdbc Driver
▲图9.12 MemoryLeakTrackingListener监听器
接着讨论 Tomcat如何对此内存泄漏进行监控,要判断 Webapp ClassLoader会不会导致内
存泄漏,只须判断 Webapp class Loader有没有被GC回收即可。在Java中有一种引用叫弱
引用,它能很好地判断 Webapp ClassLoader有没有被GC回收,被弱引用关联的对象只能生
存到下一次垃圾回收发生之前。即如果某 Webapp ClassLoader对象只被某弱引用关联,则
它会在下次垃圾回收时被回收,但如果 WebappClass Loader对象除了被弱引用关联外还被其他
对象强引用,那么 Webapp ClassLoader对象是不会被回收的,根据这些条件就可以判断是否有
152918 Context容器的监听器
WebappClassLoader发生内存泄漏了
Tomcat的实现是通过 WeakHashMap来实现弱引用的,只须将 WebappClassLoader对象放
到 Weak HashMap中,例如 weakMap pu“ Loader” Webapp ClassLoader)。当 Webapp ClassLoader
及其包含的元素没有被其他任何类加载器中的元素引用到时,JVM发生垃圾回收时则会把
Webapp ClassLoader对象回收。
实现代码的思路大致如下。
public class MemoryLeakTesti
private Map<classLoader, String> childclassLoaders new WeakHashMap<classL
oader, String>()i
public String[] findReloadedContextMemoryLeaks()f
System. gc(i
List<string> result= new ArrayList<string>()i
for (Map Entry<classLoader, String> entry childclassloadersentry
Seto)i
ClassLoader cl entry getKey ()i
if (!((WebappclassLoader) cl).isstarted())i
result. add(entry getvalue())i
return result. toArray(new String [result size()])i
使用一个 Weak HashMap跟踪 Webapp ClassLoader,在査找内存泄漏之前会先强制调用
System,gc进行一次垃圾回收,保证没问题的 Webapp ClassLoader都被回收。这时如果还有
Webapp ClassLoader的状态是非 Started(正常启动的都为 Started,关闭的则为非 Started)的,
则它是未被垃圾回收的 Webapp ClassLoader,发生了内存泄漏。
在 Tomcat中每个Host容器都会对应若干个应用。为了跟踪这些应用是否有内存泄漏,需
要将对应 Context容器注册到Host容器中的 WeakHashMap中,而这里讨论的监听器
Memory Listener就负责 Context对应的 Webapp ClassLoader的注册工作。
153第10章 Wrapper容器
Wrapper
属于 Tomcat中4个级别容器中最小级别的容器,与之相对应的是 Servlet. Servlet
的概念对于我们来说非常熟悉,我们会在它的 doGet和 dopost等方法上编写逻辑处理代码,
而 Wrapper则负责调用这些方法的逻辑。一般来说,一个 Wrapper对应一个 Servlet对象,也
就是说,所有处理线程都共用同一个 Servlet对象。但按照规范,实现了 Single ThreadModel
接口的 Servlet也允许多个对象存在。如图10.1所示, Wrapper容器可能对应一个 Servlet对象,
也可能对应一个 Servlet对象池。本章将深入讨论 Servlet相关机制及实现。
Wrapper
Servlet Pool
Servlet
▲图10.1 Wrapper结构
11eret工作机制
在研究 Servlet在 Tomcat中的工作机制前,必须先看看 Servlet规范的一些重要规定,该规范
提供了一个 Servlet接口,接口中包含的重要方法是init、 service、 destroy等方法。 Servlet在初始
化时要调用iit方法,在销毁时要调用 destroy方法,而对客户端请求处理时则调用 service方法。
对于这些机制,都必须由 Tomcat在内部提供支持,具体则由 Wrapper容器提供支持。
对于 Tomcat中消息流的流转机制,我们都已经比较清楚了,4个不同级别的容器是通过管道
机制进行流转的,对于每个请求都是一层一层处理的。如图10.2所示,当客户端请求到达服务端
后,请求被抽象成 Request对象后向4个容器进行传递,首先经过 Engine容器的管道通过若干阀
门,最后通过 StandardEngine Valve阀门流转到Host容器的管道,处理后继续往下流转,通过
StandardHost valve阀门流转到 Context容器的管道,继续往下流转,通过 StandardContext valve阀
门流转到 Wrapper容器的管道,而对 Servlet的核心处理也正是在 Standard Wrapper Valve阀门中。
Standard Wrapper Valve阀门先由 Application Filter Chain组件执行过滤器然后调用 Servlet的 service10.1 Servlet工作机制
方法对请求进行处理,然后对客户端响应。
Engine
Pipeline
He
ost
请求
xxx Valv
Pipeline
Context
( Standard
Pipeline
Wrapper
engine Valve
Pipeline
Standard
xxx Valve
Host Valve
e
Servlet
Standard
Contextvalve
Standard Wrapper Valve
ApplicationFilter Chain
响应
▲图10.2请求流转
下面更深入地讨论 Standard Wrapper Valve阀门调用 Servlet F过程。Web应用的 Servlet类
都依据 Servlet接口,例如一般我们在写业务处理 Servlet类时都会继承 Http Servlet类,为了遵
循Servlet规范,它其实最终也实现了Servlet接口,只是HttpServlet定义了HTTP协议的Servlet
将协议共性的东西抽离出来复用。 Servlet处理客户端请求的核心方法为 service方法,所以对
于 Http servlet来说,它需要针对HTP协议的GET、POST、PUT、 DELETE、HEAD、 OPTIONS、
TRACE等请求方法做出不同的分发处理。为方便理解,下面用个简化的代码进行展示。
public abstract class Httpservlet extends Servlet
public void service(ServletRequest reg, ServletResponse res) throws ser
letException, IOException t
HttpservletrequeStrequest=(httpservletrequest)req;
HttpservletresponSeresponse=(httpservleTresponse)resi
String method reg. getMethodo)i
if (method equals(" GET"))i
doGet(request, response)i
else if (method equals("POST"))I
doPost(request, response)i
Else if (method equals(" HEAD"))t
doHead(request, response)
protected void dohead(hTtpservletrequest reg HttpservletresponSe resp)
throws ServletException, IOException(
protected void doget(httPservletrequest reg HttpservletresponsE resp)
throws ServletException, IOException( j
protected void dopost(hTtpservletrequest reg HttpservletrespONse resp)
155第10章 Wrapper容器
throws ServletException, IOException
service方法将请求对象和响应对象转换成 HttpservletrEquest和 HttpservletrEsponse,然
后获取请求方法,根据请求方法调用不同的处理方法,例如,如果为GET方法则调用 doget
方法,那么继承了 Httpservlet类的 Servlet只需重写 doGet或 doPost方法完成业务逻辑处理,
这就是我们熟悉的 Servlet了。
这样一来, Standard Wrapper valve阀门调用 Servlet的工作其实就是通过反射机制实现对
Servlet对象的控制。例如,在不配置load-on- startup的情况下,客户端首次访问该 Servlet时由
于还不存在该 Servlet对象,需要通过反射机制实例化出该 Servlet对象,并且调用初始化方法,
这也是第一次访问某个 Servlet时会比较耗时的原因,后面客户端再对该 Servlet访问时都会使
用该 Servlet对象,无须再做实例化和初始化操作。有了 Servlet对象后,调用其 service方法即
完成了对客户端请求的处理
实际上,通过反射机制实例化 Servlet对象是一个比较复杂的过程,它除了完成实例化和
初始化工作外还要解析该 Servlet类包含的各种注解并进行处理,另外,对于实现了
Single ThreadModel接口的 Servlet类,它还要维护一个 Servlet对象池。
综上所述, Servlet工作机制的大致流程是: Request→ Standard Engine Valve→ StandardHost valve
Standard Context valve→ Standard Wrapper Valve→实例化并初始化 Servlet对象→由过滤器链执行过
滤操作→调用该 Servlet对象的 service方法→ Response
102 Servlet对象池
Servlet在不实现 Single ThreadModel的情况下以单个实例模式运行,如图103所示。这种
情况下, Wrapper容器只会通过反射实例化一个 Servlet对象,对应此 Servlet的所有客户端请
求都会共用此 Servlet对象。而对于多个客户端请求 Tomcat会使用多线程处理,所以要注意保
证此 Servlet对象的线程安全,多个线程不管执行顺序如何都能保证执行结果的正确性。关于
线程安全的问题,这里举一个刚做Web应用开发时可能会犯的错误:在某个 Servlet中使用成
员变量累加去统计访问次数,这就存在线程安全问题
Wrapper
线程
线程1
线程
Servlet
线程2
线程3
线程3
▲图10.3单例 Wrapper
15610.3过滤器链
为了支持一个 Servlet对象对应一个线程, Servlet规范提出了一个Sing! e ThreadModel接口,
Tomcat容器必须要完成的机制是:如果某个 Servlet类实现了 Single ThreadModel接口,则要
保证一个线程独占一个 Servlet对象。假如线程1正在使用 Servlet对象,则线程2不能再使
用 Servlet 1对象,只能用 Servlet2对象。
针对 Single ThreadModel模式, Tomcat的 Wrapper容器使用了对象池策略, Wrapper容器
会有一个 Servlet堆,负责保存若干个 Servlet对象,当需要 Servlet对象时从堆中pop出一个对
象,而当用完后则push回堆中。 Wrapper容器中最多可以有20个某 Servlet类对象,例如
XXX Servlet类的对象池,已经有20个线程占用了20个对象,于是在第21个线程执行时就会
因为阻塞而等待,直到对象池中有可用的对象才继续执行
整个流程如图10.4所示,某个线程处理客户端请求时,它首先尝试从 Servlet对象池中获
取 Servlet对象,此时如果对象池有可用对象则直接返回一个对象,如果不够使用则继续实例
化 Servlet对象并push到对象池,但 Servlet对象的总数量必须保证在20个以内。如果20个
Servlet对象都被其他线程使用了,那么就必须要等到其他线程用完放回后才能获取,此时该
线程会一直等待。从对象池中获取到 Servlet对象后则调用 Servlet对象的 service方法对客户端
请求进行处理,处理完后再将 Servlet对象放回对象池中
Wra
servlet, service
allocate
deallocate
ServletPool
压入
Servlet
▲图10.4 Servlet对象池
本节介绍了 Servlet对象池,它是为了支持 Servlet规范 Single ThreadModel接口而引入的,
它就是一个栈结构,需要时就pop出一个对象,使用完就push回去。
103过滤器链
Context容器的过滤器模块包含了过滤器的相关信息,本节将讨论如何使这些过滤器起作
用,即过滤器链的调用。
过滤器链的调用思路其实很简单。如图10.5所示,请求通过管道流转到 Wrapper容器的
管道,经过若干阀门后到达基础阀门 Standard Wrapper Valve,它将创建一个过滤器链 Application
157第10章 Wrapper容器
Filter Chain对象,创建时过滤器链对象做了如下逻辑处理。
①从 Context容器中获取所有过滤器的相关信息。
②通过URL匹配过滤器,匹配的加入到过滤器链中。
③通过 Servlet名称匹配过滤器,匹配的加入到过滤器链中。
W
rapp
Pipeline
xxX Valve
Servlet
Standard Wrapper Valve
Application Filter Chain
过滤器
过滤器
过滤器
▲图10.5过滤器链
创建 Application Filter Chain对象后, Standard Wrapper Valve将调用它的 dofilter方法,
它就会开始一个一个调用过滤器,请求被一层层处理,最后才调 Servlet处理。至此,针对
某个请求,过滤器链将 Context中所有过滤器中对应该请求的过滤器串联起来,实现过滤
器功能。
104Srt种类
根据请求资源的不同种类,可以把 Servlet分成三种类别,比如请求可能访问一个普通的
Servlet,也可能访问一个JSP页面,也可能访问一个静态资源。根据对这些不同类别的处理方
式,可以分成三种 Servlet.如图10.所示,一个请求到达 Tomcat后将由URI映射器根据请求
URI进行建模,它会计算出该请求该发往哪个Host容器的哪个 Context容器的哪个 Wrapper
处理,在路由到 Wrapper容器时会通过一定的算法选择不同的 Servlet进行处理。比如,普通
Servlet请求则路由到普通 Servlet,JsP页面则路由到 Jsp servlet,而静态资源则路由到
DefaultServlet。
158104 Servlet种类
普通 Servlet
请求
Mapper
JspServlet
Default Servlet
▲图10.6 Servlet种类
Servlet路径的匹配规则如下。
首先,尝试使用精确匹配法匹配精确类型 Servlet的路径
然后,尝试使用前缀匹配通配符类型 Servlet o
接着,尝试使用扩展名匹配通配符类型 Servlet o
最后,匹配默认 Servlet
如果一个请求到来,则通过以上规则匹配对应的 Servlet.,例如请求ht: localhost:8080test
精确匹配<url- pattern>test</url- pattern的 Servlet,而htp: localhost:8080 test. jsp则会匹配
<ur- attern>*jsp< url-pattern>的 Jsp Servlet。下面分别讨论三种不同的 Servlet o
普通 Servlet
普通 Servlet就是我们最常见的 Servlet,做web开发都会涉及 Servlet,要处理业务逻辑就
会自己定义 Servlet进行处理,这就是普通的 Servlet。编写好后的 Servlet通过配置web.xml文
件即可完成部署,配置格式类似如下。
<servlet>
<servlet-name>test</servlet-name>
<servlet-class>com. seaboat Test</servlet-class>
</servlet>
<servlet-mapping>
<servlet-name>test</servlet-name>
<url-pattern>/test</url-pattern>
</servlet-mapping>
JspServlet
web应用开发人员一般对这个 Servlet比较陌生,因为他们不会直接与它打交道。既然是
Servlet,那么肯定要声明后才会被部署使用,它被部署到 Tomcat安装目录下conf目录下的
web. xml文件中,这里的 web. xm文件是 Tomcat的全局Web描述文件。 JspServlet的配置如下。
<servlet>
<servlet-name>jsp</servlet-name>
<servlet-class>org. apache. jasper servlet JspServlet</servlet-class>
<init-param>
<param-name>fork</param-name>
159第10章 Wrapper容器
<param-value>false</param-value>
</init-param>
<init-param>
<param-name>xpoweredBy</param-name>
<param-value>false</param-value>
</init-param>
<load-on-startup>3</load-on-startup>
</servlet>
<servlet-mapping
<servlet-name>jsp</servlet-name>
<url-pattern>*.jsp</url-pattern>
<url-pattern>*.jspx</url-pattern>
</servlet-mapping>
可以看到,所有以jp和jspx结尾的请求都会被 Jsp servlet处理,它包揽了所有JSP页面
的处理,我们知道JSP页面最终也是会被 Tomcat编译成相应的 Servlet(详细的编译过程和原
理可以参考第16章),而这些 Servlet的处理都交给 Jspservlet完成。
Jspservlet处理逻辑大致如下
①判断是不是第一次访问JSP,如果是,则会先编译JsP页面,按一定包和类命名规则
生成对应的 Servlet类。
②加载刚刚编译好的 JSP Servlet类,并初始化它们。
③调用刚刚加载好的 JSP Servlet的 service方法,处理请求。
至此完成了JSP页面请求处理。
下面介绍 Defaultservlet
同样是 Tomcat内部使用的一个 Servlet, DefaultServlet是 Tomcat专门用于处理静态资源
的 Servlet。它同样被部署到 Tomcat安装目录下的conf目录下的 web. xml文件中, Defaultservlet
的配置如下。
<servlet>
<servlet-name>default</servlet-name>
Kservlet-class>org. apache. catalina. servlets. DefaultServlet</servlet-class>
<init-param>
<param-name>debug</param-name>
<param-value>0</param-value>
</init-param>
<init-param>
<param-name>listings</param-name>
<param-value>false</param-value>
</init-param>
<load-on-startup>l</load-on-startup>
</servlet>
<servlet-mapping>
<servlet-name>default</servlet-name>
16010.5 Comet模式的支持
<url-pattern>/</url-pattern>
</servlet-mapping>
可以看到所有的URI请求都会被它匹配,但由于 Mapper组件匹配 Servlet时将
Defaultservlet放到最后才匹配,所以它并不会把所有请求都拦截下来。只有那些经过精确匹
配、前缀匹配、扩展名匹配等还没匹配上的,才会留给 DefaultServlet. DefaultServlet通过JNDI
根据URI在 Tomcat内部査找资源,然后以该资源响应客户端。
105c0mat模式的支持
Comet模式是一种服务器端推技术,它的核心思想提供一种能让当服务器端往客户端发送
数据的方式。 Comet模式为什么会出现?刚开始人们在客户端通过不断自动刷新整个页面来更
新数据,后来觉得体验不好,又使用了AJAX不断从客户端轮询服务器以更新数据,然后使用
Comet模式由服务器端通过长连接推数据。 Comet模式能大大减少发送到服务器端的请求,从
而避免了很多开销,而且它还具备更好的实时性。
如图10.7所示,客户端发送一个请求到服务器,服务器接收了连接后,一直保持连接不
关闭。接着,客户端发送一个操作报文告诉服务器需要做什么操作,服务器处理完事件1后会
给客户端响应。然后,处理完事件2后又会给客户端响应。接着,客户端继续发送操作报文给
服务器,服务器再进行响应
客户端
服务器
请求
接收并保持
操作报文连接不关闭
响应
事件
响应事件2
操作报文
响应
▲图10.7 Comet模式
般 Comet模式需要NO配合,而在BIO中无法使用 Comet模式。在 Tomcat内部集成
Comet模式的思路也比较清晰,引入了一个 Comet Processor接口,此接口只有一个 event方法,
具体的接口代码如下。
public interface CometProcessor extends Servlet t
public void event( CometEvent event)
throws IOException, ServletException;
161第10章 Wrapper容器
而 CometEvent则表示 Comet相关的事件,它包含BEGN、READ、END、 ERROR四个
事件,其含义分别如下。
≯ BEGIN,表示请求开始,此时客户端连接已被接收。
≯READ,表示客户端连接已建立,可以读取数据了,读取的过程不会阻塞。
END,表示请求结束,此时客户端连接将断开。
ERROR,表示发生了IO异常,一般将会结束此次请求并且连接会断开。
下面看一个简单的例子。
public class Cometservlet extends Httpservlet implements Cometprocessor
protected ArrayList connections new ArrayList()i
public void event(CometEvent event) throws IOException, ServletException
HttpservletrequeStrequest=event.gethttpservlEtrequest()i
HttpservletresponSeresponse=event.gethttpservlEtresponse()i
f (event. getEventrype()==CometEvent EventType BEGIN)t
synchronized (connections) t
connections. add (response)i
y else if (event. getEventType ()== CometEvent EventType ERROR)
synchronized (connections)I
connections. remove(response)
Else if (event. getEventType()==CometEvent EventType END)
synchronized (connections) t
connections. remove(response)i
y else if (event. getEventType()== CometEvent EventType READ) I
Inputstream is request. getInputstream()i
byte[] buf = new byte[512]
do i
int n is read (buf)i
if(n>0){
System. out. printin(new String(buf, 0, n))i
y else if(n<o)i
returni
while (is available(>o)i
16210.6 Web Socket协议的支持
这个例子中只是简单地接收客户端连接而不做任何处理,并将客户端发送过来的数据输
出。很容易理解,在 BEGIN事件中接收连接并把响应对象放入列表中,发生 ERROR或END
事件时则将响应对象移除,当发生READ事件时则读取数据并输出。
有了 CometProcessor接口后, Tomcat内部就可以识别 Comet模式的 Servlet了。我们知道
Tomcat对请求的处理是管道模式的,所以在 Wrapper容器的管道中判断加载的 Servlet是否继
承了 Comet Processor,如果继承则说明是 Comet模式,并使用 Comet方式处理。它的处理过
程如图10.8所示,当一个客户端连接到来时,被接收器接收后注册到 NioChannel队列中, Poller
组件不断轮询是否有 NioChannel需要处理,如有,则调用前面实例化的 Comet模式 Servlet
这里主要用到 CometProcessor接口的 event方法, Poller会将对应的请求对象、响应对象和事
件封装成 CometEvent对象并传λ event方法。此时即执行 event方法的逻辑,完成对不同事件
的处理,从而实现了 Comet模式。
Accepto
注册
触发 BEGIN事件
接收
Niochannel
NioChannel
NioChannel
y触发BEAD事件
LimitLatch
Poller
Comet Processor
着
触发END事件
Recv
触发 ERROR事件
操作系统底层
▲图10.8集成 Comet
106 Websocket协议的支持
WebSocket协议属于HTML5标准,越来越多的浏览器已经原生地支持 Web Socket,它能
让客户端和服务器端实现双向通信。在客户端和服务器端建立一条 Web Socket连接后,服务器
端消息可直接发送到客户端,从而打破传统的请求响应模式,避免了无意义的请求。比如,传
统的方式可能会使用AJAX不断请求服务器端,而 Web Socket则可以直接发送数据到客户端
且客户端不必请求。同时,由于有了浏览器的原生支持,编写客户端应用程序也变得更加便捷
且不必依赖第三方插件。另外,WebSocket协议摒弃了HTTP协议烦琐的请求头部,而是以数
据帧的方式进行传输,效率更高。
图10.9为 WebSocket协议通信的过程。首先,客户端会发送一个握手包告诉服务器端它
想升级成 WebSocket,不知道服务器端是否同意。这时,如果服务器端支持 WebSocket协议,
则会返回一个握手包告诉客户端没问题,升级已确认。然后,就成功建立起了一条 WebSocket
连接,该连接支持双向通信,并且使用 WebSocket协议的数据帧格式发送消息。
163第10章 Wrappe容器
握手
Web Socket协议升级
客户端
握手
升级确认
服务器端
双向通信的 WebSocke连接
▲图10.9 WebSocket协议
握手过程需要说明。为了让WebSocket协议能和现有HTTP协议web架构互相兼容,
WebSocket协议的握手要基于HTTP协议,比如客户端会发送类似如下的HTTP报文到服务器
端,请求升级为 Web Socket协议,其中包含的 Upgrade: websocket就告诉服务器端客户端想
升级协议:
Get ws: //localhost: 8080/hello Http/1.1
Originhttp://localhost:8080
Connection: Upgrade
Host: localhost: 8080
Sec-WebSocket-Key: uROvSCZiNol/umbTt 5uKmw==
Upgrade: websocket
Sec-Websocket-Version: 13
此时,如果服务器端支持 WebSocket协议,则它会发送一个同意客户端升级协议的报文,
具体报文类似如下,其中 Upgrade: websocket就告诉客户端服务器同意客户端的升级协议。
Http/1.1 101 Websocket protocol handshake
Date: Fri 10 Feb 201617:38: 18 GMT
Connection: Upgrade
Server: Kaazing Gateway
Upgrade: WebSocket
Sec-WebSocket-Accept: rLHCkW/SKsO9GAH/ZSFhBATDKrU=
完成以上握手后,HTTP协议连接就被打破。接下来,则开始使用WebSocket协议进行双
方通信,这条连接还是原来的那条TCPP连接,端口也还是原来的80或443。
下面举一个在 Tomcat中编写 WebSocket的简单例子。
public class HelloWebSocketServlet extends WebSocketservlet
private static List<MessageInbound> socketList
new Arraylist<MessageInbound>()i
protected streamInbound createWebSocketInbound (String subProtocol,
Httpservletrequest request
return new WebSocketMessageInbound(
16410.6 Web socket协议的支持
public class WebSocketMessageInbound extends MessageInbound(
protected void onClose (int status)I
super onClose(status)i
socketlist remove(this)i
protected void onopen(WsOutbound outbound)i
super. onOpen(outbound)i
socketList add (this)i
@override
protected void onBinaryMessage(ByteBuffer message)throws IOException
@override
protected void onTextMessage(CharBuffer message) throws IOException
for(MessageInbound messageInbound socketList)(
CharBuffer buffer CharBuffer wrap(message)i
WsOutbound outbound messageInbound. getWsoutbound ()i
outbound. writeTextMessage(buffer)i
outbound flush(
这个 Servlet必须要继承 Web SocketServlet,接着创建一个继承 Messagelnbound的
WebSocketMessageInbound类,在该类中填充 on Close、 onOpen、 on Binary Message和
on TextMessage等方法即可完成各个事件的逻辑。其中, onOpen会在一个 WebSocket连接建立
时调用, on Close会在一个 WebSocket关闭时调用, on Binary Message则在 Binary方式下接收
到客户端数据时调用, on TextMessage则在Text方式下接收到客户端数据时调用。上面一段代
码实现了一个广播的效果。
按照上面的处理逻辑, Tomcat对 WebSocket的集成就不会太难了,就是在处理请求时,如果
遇到 WebSocket协议请求,则做特殊处理,保持住连接并在适当的时机调用 WebSocketServlet的
MessageInbound的 on Close、 onOpen、 on BinaryMessage和 on TextMessage等方法。因为 Web Socket
般建议在NO模式下使用,所以看看以NIO模式集成 WebSocket协议。
如图10.10所示, WebSocket的客户端连接被接收器接收后注册到 NioChannel队列中, Poller
组件不断轮询是否有 Niochannel需要处理,如果有,则经过处理管道后进入到继承了 WebSocketServlet
的 Servlet上, WebSocketServlet的 doGet方法会处理 WebSocket握手,告诉客户端同意升级协议。往
后 Poller继续不断轮询相关 NioChannel,一旦发现使用 Web Socket协议的管道,则会调用
MessageInbound的相关方法,完成不同事件的处理,从而实现对 WebSocket协议的支持。
165第10章 Wrapper容器
A
接收
NioChannel
LimitLatch
NioChannel
中
Poller
Web Socket Servlet
WebSocket
握手处理
操作系统底层
r onOpen
sageInbound
onBinary Message
Y on TextMessage
图10.10集成 WebSocket
107异步 Servlet
有时 Servlet在生成响应报文前必须等待某些耗时的操作,比如,等待一个可用的JDBC
连接或等待一个远程web服务的响应。对于这种情况, servlet规范中定义了异步处理方式
由于 Servlet中等待阻塞会导致web容器整体的处理能力低下,因此对于比较耗时的操作,可
以把它放置到另外一个线程中进行处理,此过程保留连接的请求和响应对象,在处理完成之后,
可以把处理的结果通知到客户端。
Servlet在同步情况下的处理过程,如图10.11所示。 Tomcat的客户端请求由管道处理,最
后会通过 Wrapper容器的管道,这时它会调用 Servlet实例的 service方法进行逻辑处理,处理完
后响应客户端。整个处理由 Tomcat的 Executor线程池的线程处理,而线程池的最大线程数是有
限制的,所以这个处理过程越短,就能越快地将线程释放回线程池。但如果 Servlet中的处理逻
辑耗时越长,就会导致长期地占用 Tomcat的处理线程池,影响 Tomcat的整体处理能力。
Execute
线程池
Wrapper
占用线程
Pipeline
Servlet
≯处理逻辑
响应客户端
释放线程
完成处理
图10.11 Servlet同步处理
166107异步 Servlet
为了解决上面的问题,引入了支持异步的 Servlet.,如图10.12所示。同样,当客户端请求
到来时,首先通过管道,然后进入到 Wrapper容器的管道,调用 Servlet实例的 service后,创
建一个异步上下文将耗时的逻辑操作封装起来,交给用户自己定义的线程池。这时, Tomcat
的处理线程就能马上回到 Executor线程池,而不用等待耗时的操作完成才释放线程,从而提
升了 Tomcat的整体处理能力。这里要注意的是,由于后面做完耗时的操作后还需要对客户端
响应,因此需要保持住 Request和 Response对象,以便输出响应报文到客户端。
ector
Wrapper
线程池
Runnable
Pipeli
Servlet
Async Context
占用线程
Request
创建异步上
下文并放到
Response
用户自定义
线程上
响应客户端
释放线程
用户定义线程池
▲图10.12 Servlet异步处理
再结合一段简单的异步代码来看 Tomcat对 Servlet异步处理的实现
public class Asyncservlet extends Httpservlet
ScheduledThreadPoolExecutor userExecutor
new ScheduledThreadPoolExecutor(5)i
public void doget(htTpservletrequest reg HttpservletresponsE res)(
AsyncContext aCtx = reg. startAsync(req, res);
userExecutor. execute(new AsyncHandler(actx))i
public class AsyncHandler implements Runnable i
private AsyncContext cti
public AsyncHandler(AsyncContext ctx)t
this ctx ctx
167第10章 Wrapper容器
@override
public void run()(
∥耗时操作
Printwriter pw
try i
pw= ctx getResponse().getwriter()i
pw.print("done!)i
pw. flush()i
pw. close(i
s catch (IOException e)(
e printstackTrace()i
ctx. complete()i
我们创建一个 AsyncServlet,它定义了一个 user Executor线程池专门用于处理该 Servlet的
所有请求中耗时的逻辑操作。这样就不会占用 Tomcat内部的 Executor线程池影响到对其他
Servlet
的处理。这种思想有点像资源隔离,耗时的操作统一由指定的线程池处理,而不会影
响其他耗时少的请求处理。
Servlet的异步实现就很好理解了, startAsync方法其实就创建了一个异步上下文 Async Context
对象,该对象封装了请求和响应对象。然后创建一个任务用于处理耗时逻辑,后面通过
Async Context对象获得响应对象并对客户端响应,输出“done!”。完成后,要通过 complete
方法告诉 Tomcat内部它已经处理完, Tomcat就会对请求对象和响应对象进行回收处理或关
闭连接。
168第11章生命周期管理
像 Tomcat这么大的系统,必然需要对生命周期进行统一管理。那么 Tomcat是怎样管理自
己的生命周期的呢?本章将对 Tomcat的生命周期进行介绍。
11生命周期统一接口→Lie
Tomcat的架构设计是清晰的、模块化的,它拥有很多组件,假如在启动 Tomcat时一个
个组件启动,这不仅麻烦而且容易遗漏组件,还会对后面的动态组件扩展带来麻烦。对于这个
问题, Tomcat的设计者提供了一个解决方案:用 Lifecycle管理启动、停止、关闭。
Tomcat内部架构中各个核心组件有包含与被包含的关系,例如, Server包含 Service, Service
包含 Container和 Connector,往下再一层层包含。 Tomcat就是以容器的方式来组织整个系统
架构的,就像数据结构的树,树的根节点没有父节点,其他节点有且仅有一个父节点,每个父
节点有零个或多个子节点。鉴于此,可以通过父容器启动它的子容器,这样只要启动根容器,
即可把其他所有容器都启动,达到统一启动、停止、关闭的效果。
作为统一的接口, Lifecycle把所有的启动、停止、关闭、生命周期相关的方法都组
织到一起,就可以很方便地管理 Tomcat各个容器组件的生命周期。下面是 Lifecycle接口
详细的定义。
public interface Lifecycle t
public static final String BEFORE_INIT_ EVENT ="before_init";
public static final String AFTER_ INIT_EVENT =after_init",
public static final String START_ EVENT ="start"
public static final String BEFORE_START_EVENT =before_";
public static final String AFTER_ START_ EVENT ="after start";
public static final String STOP__EVENT =stop"i
public static final String BEFORE_STOP__EVENT ="before_stop";
public static final String AFTER_ STOP_EVENT =after_stop";
public static final String AFTER_ DESTROY_EVENT ="after destroy"i
public static final String BEFORE_ DESTROY_EVENT ="before_destroy
public static final String PERIODIC_ EVENT
periodic"i
public static final String CONFIGURE_- START_EVENT ="configure_start";第11章生命周期管理
public static final String CONFIGURE STOP EVENT
"configure_stop"
public void addLifecycleListener(LifecycleListener listener)i
public LifecycleListener[] findlifecycleListeners();
public void removeLifecycleListener (LifecycleListener listener)
public void init()throws LifecycleException;
public void start() throws LifecycleException;
public void stop() throws LifecycleException;
public LifecycleState getstate(
public String getstateName();
从上面可以看出, Lifecycle其实就定义了一些状态常量和几个方法,这里主要看 init start、
stop三个方法,所有需要被生命周期管理的容器都要实现这个接口,并且各自被父容器的相应
方法调用。例如,在初始化阶段,根容器 Server组件会调用init方法,而在init方法里会调用
它的子容器 Service组件的init方法,以此类推。
比如, Tomcat的 Server组件的init负责遍历调用其包含的所有 Service组件的init
方法。
ublic final synchronized void init( throws life
for (int i=0; i <services. length; i++)I
services [i].init()
同样,启动和停止步骤也是通过类似的调用机制实现统一启动、统一关闭。至此,我们对
Tomcat生命周期的统一初始化、启动、关闭机制有了比较清晰的认识。
112生命周期的状态转化
Tomcat从初始化到结束,期间必定会经历很多其他的状态,每一个状态都标志着 Tomcat
现在处于什么阶段。另外,事件的触发也是通过这些状态来进行判定的。
Lifecycle有个返回状态的方法 gestated,返回的是 LifecycleState枚举类型,此枚举
包含了生命周期所有的状态,供组件状态之间转换使用。 LifecycleState类型的详细定义
l7012生命周期的状态转化
public enum Lifecyclestate i
NEW(false, null)r
INITIALIZING(false, Lifecycle. BEFORE_INIT_EVENT
INITIALIZED(false, Lifecycle. AFTER INIT_ EVENTI/
STARTING PREP(false, Lifecycle. BEFORE START_ EVENT),
STARTING(true, Lifecycle. START_EVENT)
STARTED(true, Lifecycle. AFTER_ START_ EVENT),
STOPPING PREP(true, Lifecycle. BEFORE_STOP_EVENT),
STOPPING(false, Lifecycle. STOP_EVENT)
STOPPED(false, Lifecycle. AFTER_STOP_EVENT),
DESTROYING(false, Lifecycle. BEFORE_DESTROY- EVENT),
DESTROYED(false, Lifecycle. AFTER_DESTROY_ EVENT )I
FAILED(false, null
MUST STOP(true, null),
MUST DESTROY (false, null)i
private final boolean available;
private final String lifecycleEvent;
private LifecycleState(boolean available, String lifecycleEvent)
this available available
this lifecycleEvent = lifecycleEvent;
public boolean isAvailable() i
return available;
public String getLifecycleEvent(
return lifecycleeventi
上述常量从NEW到 DESTROYED中间经历了生命周期的各个状态,这样就可以把整个
生命周期划分为多个阶段,每个阶段完成每个阶段的任务。假如一个容器调用init0后,状态
的转化是NEW→ INITIALIZⅠNG→ INITIALIZED,其中从 INITIALIZING到 INITIALIZED是
自动变化的,并不需要人为操作。接着调用 start((,状态则变化为 INITIALIZED→ STARTING
PREP→ STARTING→ STARTED,这个过程全部自动完成。接下来,如果调用 stopE,状态变
化就为 STARTED→ STOPPING PREP→ STOPPING→ STOPPED。如果在生命周期的某个阶段
发生意外,则可能经历xx→ DESTROYING→ DESTROYED。整个生命周期内状态的转化相对
较复杂,更多详细的转换情况如图1.1所示。
171第11章生命周期管理
start
NEW一 INITLALIZING
auto
start
auto
auto
topo
INITIALIZED
STARTING PREP一 STARTING→> STARTED
destroyo
auto
auto
start
STOPPING PREP—) STOPPING—) STOPPED
stop
destroyo
destroyO
FAILED
DESTROYING
destroyo
auto
DESTROYED
topo
▲图11.1生命周期的状态转化
113生命周期事件监听机制
如果我们面对这么多状态之间的转换,我们肯定会有这样的需求:我希望在某某状态事情
发生之前之后做点什么。 Tomcat在这里使用了事件监听器模式来实现这样的功能。一般来说,
事件监听器需要三个参与者。
事件对象,用于封装事件的信息,在事件监听器接口的统一方法中作为参数使用,一般继
承 java. util. EventObject类。
>事件源,触发事件的源头,不同的事件源会触发不同的事件类型。
事件监听器,负责监听事件源发出的事件,更确切地说,应该是每当发生事件时,事件源
就会调用监听器的统一方法去处理,监听器一般实现java. util. Eventlistener接口。
事件源提供注册事件监听器的方法,维护多个事件监器听对象,同时可以向事件监听器对
象发送事件对象。伴随着事件的发生,相应的状态信息都封装在事件对象中,事件源将事件对
象发给已经注册的所有事件监听器,这里其实是调用事件监听器的统一方法,把事件对象作为
参数传过去。接着会在这个统一方法里根据事件对象做出相应处理。
17211.3生命周期事件监听机制
Tomcat中的事件监听器也类似。如图11.2所示, Lifecycle Event类就是事件对象,继承了
EventObject类; LifecycleListener为事件监听器接口,里面只定义了一个方法 lifecycleEvent
Lifecycle Event event)。很明显, LifecycleEvent作为这个方法的参数。最后缺一个事件源,
般来说,组件和容器就是事件源。 Tomcat提供了一个辅助类 Lifecycle Support,用于帮助管理
该组件或容器上的监听器,里面维护了一个监听器数组,并提供了注册、移除、触发监听器等
方法,这样整个监听器框架就完成了。假如想要实现一个监听器功能,比如
XXXLifecycleListener,只要扩展 Lifecyclelistener接口并重写里面的 Lifecycle Event方法,然后
调用 LifecycleSupport的 addLifecycleListener方法注册即可。后面,当发生某些事件时,就可
以监听了
<<Interface>>
LifecycleSupport
LifecycleListener
a lifecycle Lifecycle
o lifecycleEvent(in event LiFecycle Event): void
a listeners LifecycleListener[
△
a listenersLock Object
e <create>> Lifecycle Support (in lifecycle LiFecycle)
o addLifecycleListenerO: void
KxNLifecycleList
o fndLifecycleListeners O: LifecycleListener[]
e freLifecycleEvent(in type String in data Object): void
e removeLifecycleListenerO: void
o lifecycle Event(in event t Lifecycle Event): void
Lifecycle
Eventobje6jdk〕
a seriallersionUID long
a serialversionUID i long
o source object
a data Object
e <create>> Eventobject (in source: object)
a type String
e<<create>> Lifecycle Event(in type String, in data: Object)
e tostring: String
o getDataO: Object
o getLiFecycleo
● getTypeO: String
▲图11.2监听器类图
我们详细看看 Tomcat中监听器的实现。
①事件对象 LifecycleEvent继承 Eventobject,里面都是一些属性。
public finalclass LifecycleEvent extends Eventobject
public LifecycleEvent(Lifecycle lifecycle, string type, Object data)f
super(1 lifecycle)氵
this type
typei
this data datai
private Object data= null;
private string type nulli
public object getData()i
173第11章生命周期管理
return (this data)i
public Lifecycle getLifecycle() i
return (Lifecycle) getSource()i
public string getType()
return (this type)i
②2事件监听器接口,只声明一个 lifecycleEvent方法,事件发生后,就通过调用这个方法
进行逻辑处理。
public interface Lifecyclelistener
public void lifecycleEvent(LifecycleEvent event);
③事件监听器实现类,一个实现类就是一个监听器,通过实现 LifecycleListener接口可以
自定义监听器,在 lifecycleEvent方法中编写事情的逻辑处理。下面这个监听器其实就在初始
化之前对 JspRuntime Context这个类进行类装载。
public class JasperListener implements Lifecyclelistener
override
public void lifecycleEvent(LifecycleEvent event)
if (Lifecycle. BEFORE INIT_ EVENT. equals(event. getType()))t
try i
Class forName("org. apache. jasper. compiler. JspRuntime Context",true, this ge
tClass(). getclassLoader())i
1 catch (Throwable t)(
ExceptionUtils. handleThrowable(t)i
logwarn("Couldn't initialize Jasper",t)i
④事件监听辅助类 LifecycleSupport,主要用于帮助管理该组件或容器上的监听器,它维
护一个了监听器数组,并提供添加、移除、触发监听器等的方法。
public final class LifecycleSupport
public LifecycleSupport(Lifecycle lifecycle)(
super()
this lifecycle = lifecycle;
private Lifecycle lifecycle = null;
private Lifecyclelistener listeners [] new LifecycleListener[0];
17411.3生命周期事件监听机制
public void addLifecycleListener(Lifecyclelistener listener)
synchronized (listenerslock)
Lifecyclelistener results[
new LifecycleListener[listeners.length 1]
for (int i =0: i <listeners. length; i++)
results[i] listeners[ii
results[listeners. length]= listener
listeners results
public Lifecyclelistener[] findLifecycleListeners ()
return listeners:
public void fireLifecycleEvent(string type, Object data)
LifecycleEvent event new LifecycleEvent (lifecycle, type, data)
Lifecyclelistener interested[]= listeners;
for (int
0; i< interested length; 1++)
interested[i]. lifecycleEvent(event)i
public void removeLifecycleListener(LifecycleListener listener)(
∥此处省略删除监听器的操作
⑤事件源,一般组件或容器类就是事件源,例如 StandardServer类。如果要触发 STARTING
事件并让相关监听器进行处理,可以这样。
public final class StandardServer implements Lifecycle
private LifecycleSupport lifecycle new LifecycleSupport(this)i
public void addLifecycleListener (LifecycleListener listener)t
lifecycle. addLifecyclelistener(listener)i
protected void startInternal() throws LifecycleException
LifecycleState state=LifecycleState STARTINGi
String lifecycleEvent =state. getLifecycleEvent()i
if (lifecycleEvent ! null)
lifecycle. fireLifecycleEvent (lifecycleEvent, null)i
175第11章生命周期管理
StandardServer类实现了 Lifecycle接口,并将自己传入 LifecycleSupport对象,两者建立
起了关联。所有监听器通过 addLifecycleListener方法交给 Lifecycle Support对象维护,于是通
过调用 LifecycleSupport对象的 fireLifecycle Event方法遍历所有的监听器,一个一个发送事件,
就可以达到触发事件的效果。
至此, Tomcat的整个生命周期事件监听机制就建立起来了。
176第12章日志框架及其国际化
121系统内日志
日志对每一个系统来说都是必不可少的一部分,它可以记录运行时报错信息,也可以在调
试时使用,使用好日志对我们后期的系统维护是相当重要的。像 Tomcat这么大的系统,对日
志的处理更是非常重要, Tomcat中提供了统一的日志接口Log供系统使用。这个接口只提供
使用的方法,而不管具体使用什么方法实现日志的记录。接口中提供了多种方法来记录日志,
每种方法代表不一样的日志级别,实际使用中根据不同级别使用不同的方法。
public interface Log t
public boolean isDebugEnabled()i
public boolean iserrorEnabled()i
public boolean 'isFatalEnabled(
public boolean isInfoEnabled()i
public boolean isTraceEnabled()i
public boolean isWarnEnabled(
public void trace(Object message)i
public void trace(object message, Throwable t)i
public void debug(object message)i
public void debug (Object message, Throwable t)i
public void info(object message)i
public void info(Object message, Throwable t)i
public void warn(Object message)i
public void warn(Object message, Throwable t)i
public void error(object message)i
public void error(object message, Throwable t)
public void fatal(object message)i
public void fatal(Object message, Throwable t)i
Tomcat中使用的日志实现类是 DirectJDKLog,从名字上来看,就大概知道该类使用JDK
自带的日志工具,实际上,它是在JDK的 java util. logging日志包基础上进行封装的。日志架
构使用了工厂模式进行设计, LogFactory日志工厂类专门提供一个获取扩展的Log接口的类实例第12章日志框架及其国际化
的方法,方便日志的使用。图12.1是日志的类图, DirectJDKLog实现了Log接口, Log Factory
则通过 getLog方法返回 DirectJDKLog对象。这样,以后如果要改用别的日志包,只须另外添
加一个实现Log接口的 XXXLog类,然后通过 getLog方法返回即可。
Io LogFactory
<I
Interface>
Log
o getLog(in class: Class): Log
O info(in message: Object): void
DirectJDKLog
o info(in message: Object): void
▲图12.1日志工厂
Tomcat米用JDK的日志工具可以不用引入第三方Jar包和配置,可以与JDK更紧密地结
合。日志的使用简单方便,通过配置 logging properties即可满足大多要求,此配置文件路径为
JJAVA HOMES% jrellib logging properties,该配置文件的逻辑判断如下。
String fname System getProperty(java util. logging. config file")i
if ( fname = null
fname= System. getProperty("java. home");
if (fname = null)(
throw new Error ("Can't find java. home ??)i
File f= new File(fname, lib")i
new File(f,logging properties")
fname f. getCanonicalPath()i
先从 System获取 java. util. logging. config,fle属性值,如果存在,则直接作为配置文件路径;
否则,获取 System的 java. home属性。这个属性的值为% DJAVA HOME%jre。最后组成JDK
自带的日志工具的默认配置文件路径。
在实际运行时, Tomcat并没有直接使用默认的配置,从启动批处理文件 catalina.bat可以
看到下面两行代码。
-Djava util. logging. config file=%CATALINA_ BASE\conf\logging properties
Djava util. logging. manager=org. apache. juli. ClassLoaderLogManager
178122日志的国际化
Tomcat把 logging properties配置文件放到% CATALINA BASE%conf下,并且把
java. util. logging.manager属性配置成org. apache. juli. ClassLoaderLogManager,即重写一个
og Manager
理解了以上几点, Tomcat的日志框架就基本明朗了。 Tomcat采用工厂模式生成日志对象,
底层使用JDK自带的日志工具,而没有用第三方日志工具,以减少包的引入。没有采用JDK
日志工具的默认配置,而是通过配置系统变量和重写某些类达到特定效果。
12日志的国际化
既然 Tomcat是一个全世界流行的软件,并且面向多个国家的用户,日志的国际化就是十
分重要的一部分,这样才能提供多种语言的日志输出,方便开发调试人员查找错误或者根据这
些信息进行性能调整。
对于很多其他应用来说, Tomcat可以说是比较大型的应用软件,需要关注的要点很多。
在这些关键点进行报错有如下三点好处。
对于 Tomcat夲身程序的开发人员来说,这些关键点的报错能帮助他们开发、调试程序,快
速定位Bug位置并找到错误的原因。
对于开发Web应用的开发人员,更关注的是 Servlet和JsP的报错,这些报错信息同样能
帮助他们迅速找到问题的所在。
对于系统运维人员来说, Tomcat级别的报错或异常,能帮助他们根据实际情况对一些性能
参数进行调整。
总的来说,整个 Tomcat内部有相当多的错误和异常信息需要处理,这些信息对不同人群
都有作用。而对于使用不同文字的人群, Tomcat有提供了多种语言的报错信息,它一共提供
了4种语言,分别是英语、法语、日语和西班牙语。
同一种错误信息需要保存多种语言的版本, Tomcat把错误信息保存在 Properties文件里面。
对于多语言是这样处理的,一般每个Java包下面会存在 LocalStrings properties、 LocalStrings
fr properties、 LocalStrings_ ja properties、 LocalStrings_es. properties这4个属性文件,它们分别
代表四种不同语言的信息版本。程序根据本地语言寻址对应的属性文件,获取对应的错误信息。
用这种配置文件的形式来存储,可以十分方便地修改这些信息。但整个 Tomcat应用这么大,
假如所有日志输出信息都由这4个语言属性文件存储,那么会带来维护的问题,这么多的消息
放在 Properties文件中,对查找修改信息都是一个噩梦。于是,设计者提出了一个思想,在每个
Java包下都存放这4个不同语言的 Properties文件,这些文件负责存储这个Java包下的所有类,
每个类如果需要查找消息,都到对应Java包下的 Properties文件中查找。例如,在 org. apache.
catalina. startup包中,存在4种语言的 Properties文件,如果 org. apache. catalina. startup. Bootstrap
类要记录错误日志,它就会从 Bootstrap类所在包下的 Properties文件中查找对应语言的错
误描述。
79第12章日志框架及其国际化
那么 Properties文件是如何配置的呢?其实它里面是以键-值对保存的,程序通过键查找,
例如, defaulterror= Error processed default web. xml named{0}at{l},通过 defaulterror获取对
应的值。值得注意的是,这个值里面包含了{0}、{1}这两项,它们主要的作用类似于变量值,
在输出的时候用参数的值按顺序替换。 Tomcat中用 MessageFormat类完成这些参数的替换,
MessageFormat使用以下三种模式来使占位符格式化模式字符串。
只声明参数索引{参数索引}
声明参数索引及格式类型{参数索引,格式类型}。
声明参数索引、格式类型及格式样式{参数索引,格式类型,格式样式}
看如下例子。
string message="{0}的第(1, number}个大版本是在{2,date, short}发布的";
MessageFormat messageFormat =new Me ssageFormat (message);
Object [] objs=I"Tomcat",7, new Date(2010-06-29"))
System. out.println(messageFormat format(objs))i
上述程序通过格式化后的输出为“ Tomcat的第7个大版本是在2010-06-29发布的”。如此
确实给我们带来了很多方便,只须把要变化的部分抽取出来,然后通过修改参数值即可达到变
换语义的效果。这在 Tomcat日志部分中大量使用,简单实用,给日志处理及国际化带来很大
便利与好处。
已经介绍了日志的格式化,但怎么才能找到正确的配置文件也是十分重要的。前面说过,
日志的国际化会根据不同国家的语言读取不同语言的属性文件,这具体通过 Resource Bundle
类来实现, Tomcat根据JVM实例当前默认语言环境 Locale获取不同的 Properties文件。假如
要读取中文属性文件 resource_zh. properties, Resource Bundle类通过以下几步即可实现。
Locale locale new Locale("zh")i
ResourceBundle resb= ResourceBundle. getBundle("resource", locale)
System. out. printIn(resb getstring("name"))i
最后输出的是 resource zh, properties中键为name的值。类似地,其他语言只要实例化
个对应国家的 Locale作为参数传进 Resource Bundle,就可以确定用哪个语言的属性文件。
通过以上描述,我们知道日志的国际化通过 MessageFormat、 Locale、 Resource Bundle这
三个类进行操作管理。日志的操作频繁而且类似,我们需要一个更高层的类对这些类进行封装,
从而更加方便使用。 Tomcat中用 String Manager类对其进行封装,它提供了两个 getString方法,
我们一般只会用到这两个方法。通过这两个方法即可根据JVM默认语言获取对应语言属性文
件里面键为key的值。当一个类里面要使用国际化日志时,只需如下代码。
StringManager sm= StringManager, getManager(“包路径”)
sm getstring("key")i
String Manager的使用非常简单,但它的设计比较独特。我们知道在每个Java包里都有对
180123客户端访问日志
应不同语言的 Properties文件,每个包下的Java类的日志信息只需要到对应包下的 Properties
文件查找中就可以。当一个类要获取属性文件的一个错误信息时,如果要通过 String Manager
的方法获取,那么它必须实例化一个 String Manager对象。于是问题来了,整个 Tomcat的应用
这么多类,如果每个类都实例化一个 String Manager对象,那么必然造成资源浪费。从设计模
式考虑,我们马上想到用单例模式,这样就可以解决重复实例化、浪费资源的问题。但如果整
个 Tomcat的所有类都共用一个 String Manager对象,那么又会存在另外一个问题,一个对象处
理这么多的信息,且对象里面有同步操作,多线程执行下导致性能较低。 Tomcat设计者采取
了折中的巧妙处理,既不只用一个对象,也不用太多对象,而是为每一个Java包提供一个
String Manager对象,相当于一个Java包一个单例,这个单例在包内被所有的类共享,各自的
String Manager对象管理各自包下的 Properties文件。实现这种以Java包为单位的单例模式的
主要代码如下。
Public static final synchronized StringManager getManager(
String packageName, Locale locale) t
Map<locale, StringManager> map= managers get(packageName)i
if (map = null)t
map new Hashtable<locale, stringManager>()i
managersput(packageName, map)i
StringManager mgr map get(locale)
if (mgr = null)(
mgr= new StringManager(packageName, locale)i
lap. put(locale, mgr)i
return mari
类中维护了一个静态变量 managers,每个 String Manager实例存储在一个以包名为键的
Map中。当要获取 String Manager实例时,先根据包名査找内存是否已经存在包名对应的
String Manager对象,如果不存在,则实例化一个 String Manager,并且放到内存中,供下次直
接读取内存。至此,一个以包为单位的单例模式得以实现。
本节主要讨论日志中国际化的实现,其中使用了JDK里面的三个类: MessageFormat、
Locale、 Resource Bundle,而 Tomcat中利用 String Manager类把这三个类封装起来,方便操作。
而 String Manager类的设计展示了 Tomcat设计人员的优秀思想,每一个Java包对应一个
String Manager对象,折中的考虑使性能与资源得以同时兼顾。
123客户端访问日志
对任何一个系统,一个强大的日志记录功能是相当重要且必要的,根据日志的记录可以及
181第12章日志框架及其国际化
时掌握系统运行时的健康状态及故障定位。然而,作为Web容器存在另外一种日志—一访问
日志。访问日志一般会记录客户端的访问相关信息,包括客户端IP、请求时间、请求协议、
请求方法、请求字节数、响应码、会话I、处理时间等。通过访问日志可以统计用户访问数
量、访问时间分布等规律及个人爱好等,而这些数据可以帮助公司在运营策略上做出抉择。这
节主要就探究 Tomcat的访问日志组件。
12.3.1访问日志组件的设计
如果让你来设计一个访问日志的组件,你会如何来设计?你应该很快就会想到访问日志的
核心功能就是将信息记录下来,至于要记录到哪里、以哪种形式来记录,我们先不管,于是很
快想到以面向接口编程的方式定义一个接口 Accesslog。方法名命名为log,需要传递参数包
含请求对象和响应对象,代码如下。
public interface AccessLog i
public void log (request request, Response response)i
定义一个好的接口是一个良好的开始,接下来要考虑的事是需要哪些类型的组件。针对前
面的记录到哪里、以哪种形式记录,我们最熟悉也最先想到的肯定就是以文件形式记录到磁盘
里,于是我们实现一个文件记录的日志访问组件。
public class FileAccesslog implements Accesslog t
public void log(Request request, Response response)t
String message= request与 response中的值拼组成你需要的字符串
try i
Charset charset Charset defaultcharseto)i
Printwriter writer new Printwriter(new Bufferedwriter(new
Outputstreamwriter(
new FileOutputstream("c: /accesslog log", true), charset),
128000), false);
writer.println(message)
writer. flush(i
3 catch (IOException e) I
看起来这是一个简单且不错的文件记录访问日志组件的实现,其中的代码简单明了。采用
Print writer对象用于写入操作,而且使用了 Buffered Writer对象实现缓冲,之所以把缓冲器大
小设置为12800是根据经验得出来的一个适合值。 OutputStream Writer则可以对字符进行编码,
此处使用 Charset工具提供的默认编码。 FileOutputStream则指定写入的文件路径及文件名,而
true表明追加日志而非覆盖。
182123客户端访问日志
假如你觉得用SQL语言来统计日志的信息让你更加得心应手,那么写到文件就不符合你
的需求,我们需要另外一个实现,通过JDBC将日志记录到数据库中。于是你必须另外创建
个 JDBCAccessLog类并重新实现log方法,使用JDBC操作数据库大家是最熟悉不过的了,
受篇幅限制,这里不详细写实现细节,但有一个前提是你必须告诉数据库创建一张特定的表且
表的结构要根据访问信息定义好。
public class JDBCAccessLog implements AccessLog i
public void log(Request request, Response response)(
通过JDBC把 request和 response包含的访问信息组成一个SQL语句插入数据库中
你还可以根据自己的需求定制各种各样的访问日志组件,只须实现 Accesslog接口。但有
时可能你会使用多个访问日志组件,例如又写入文件又持久化到数据库中,这时我们还可以提
供一个适配器给它。
public class AccessLogAdapter implements AccessLog t
private AccessLog [] logs;
public AccessLogAdapter(AccessLog log)
logs new AccessLog[]i log i
public void add(AccessLog log)(
AccessLog newArray[] Arrays copyof (logs, logs. length 1)i
newArray [newArray length -1]=logi
logs = newArray
public void log(request request, Response response
for (Accesslog log: logs)
loglog(request, response)i
经过适配器的适配,log方法已经变成了遍历调用多个访问日志组件的log方法,而适配
器对外提供的接口仍然是一个log方法,编写如下测试类log的调用将会分别向文件及数据库
记录下“ hello tomcat
public class Test i
public static void main(String[] args)i
AccessLog accesslog= new AccessLogAdapter(new FileAccesslog ())i
accessLog. add(new JDBCAccessLog())i
accessLog. log(new Request("hello tomcat"), new Response())i
183第12章日志框架及其国际化
经过以上的设计一个良好的访问日志组件就已经成型,而这也是 Tomcat的访问日志组件
的设计思路。另外, Tomcat考虑到模块化和可配置扩展,它把访问日志组件作为一个管道中
的一个阀门,这样就可以通过 Tomcat的服务器配置文件配置实现访问日志记录功能,这可以
在任意容器中进行配置。
12.3.2访问日志格式的自定义
经过几步设计后,一个访问日志组件已成型,但为了增加用户自定义能力我们还是要继续
做点事。对于用户自定义的实现,最经典的做法就是引入变量表示,例如,定义%a表示远程
主机IP,%A表示本机IP,等等,然后在写入之前用相应逻辑把变量替换成相应的值写入日
志。本节实现日志格式的自定义支持
整个过程其实是先自定义变量组,再逐个把变量替换成相应值,最后把替换后的值写入文
件。因为需要实现很多不同的变量,所以定义一个接口用于约束所有变量添加操作的定义,定
义一个 addElement方法,通过从 Request和 Response获取相应的变量值后添加到字符串buf中。
public interface AccessLogElement t
public void addElement (StringBuilder buf, Request request
Responseresponse)i
接着定义两个元素分别用于添加响应状态码和远程地址,使用时直接调用它们的
addElement即可把状态码和远程地址添加到字符串中,
public class Status CodelElement implements AccessLogElement t
public void addElement (StringBuilder buf, Request request
Response response)
buf append (response. getstatus())i
public class RemoteAddrElement implements AccesslogElement t
public void addElement (StringBuilder buf, Request request
Response response) i
buf append(request. getRemoteAddr())i
现在还缺一个映射器用于解析变量到各自 AccessLogElement的映射,如下 ElementMapping
提供一个map方法把自定义的 Pattern解析成对应的访问日志元素并用对应的值替换原来的
变量
public class ElementMapping
Responseresponse;
184123客户端访问日志
Request regeust
public ElementMapping(Request request, Response response)(
this. regeust-requesti
this response=response;
public StringBuilder map(String pattern) i
StringBuilder buf new StringBuilder()i
for (int i =0; i< pattern length(); i++)i
char ch pattern charAt(i)i
if(ch
ch pattern charAt(++i)i
addElement(ch, buf)i
e⊥se
buf append (ch)i
return buf;
private void addElement(char ch, StringBuilder buf
switch (ch) i
case i a'
new RemoteAddrElement(). addElement(buf, request, response
break;
cases.
new Status CodeElement(). addElement(buf, request, response)i
breaki
引入变量使你的日志访问组件拥有自定义格式的功能,并且使用了一个简单的案例说明。
如果你想拥有更强大的自定义能力可以在此基础上实现,例如,可以把常用的变量组合简化为
个字符串表示, common字符串用于表示%h%%u%t"%r"%%b常用的变量组合。当然,
要实现这样的支持,你必须在映射器中做对应的处理。
185第13章公共与隔离的类加载器
131类加载器
Java的设计初衷是主要面向嵌入式领域,对于自定义的一些类,考虑使用按需加载的原则,
即在程序使用到时才加载类,节省内存消耗,这时即可通过类加载器来动态加载。
如果平时只是做web开发,那应该很少会跟类加载器打交道,但如果想深入学习 Tomcat
的架构,那它是必不可少的。所谓类加载器,就是用于加载Java类到Java虚拟机中的组件,
它负责读取Java字节码,并转换成 java. lang Class类的一个实例,使字节码, class文件得以运
行。一般类加载器负责根据一个指定的类找到对应的字节码,然后根据这些字节码定义一个
Java类。另外,它还可以加载资源,包括图像文件和配置文件。
类加载器在实际使用中给我们带来的好处是,它可以使Java类动态地加载到JVM中并运
行,即可在程序运行时再加载类,提供了很灵活的动态加载方式。例如 applet,从远程服务器
下载字节码到客户端再动态加载到JVM中便可以运行。
在Java体系中,可以将系统分为以下三种类加载器。
启动类加载器( Bootstrap ClassLoader):加载对象是Java核心库,把一些核心的Java类加
载进JVM中,这个加载器使用原生代码(CC+)实现,并不是继承 java. lang, Classloader,
它是所有其他类加载器的最终父加载器,负责加载< JAVA HOME> /jre/ib目录下JVM指定
的类库。其实它属于JVM整体的一部分,JVM一启动就将这些指定的类加载到内存
中,避免以后过多的IO操作,提高系统的运行效率。启动类加载器无法被Java程序
直接使用。
扩展类加载器( Extension Class loader):加载的对象为Java的扩展库,即加载
< JAVA HOME>jre/ ib/ext目录里面的类。这个类由启动类加载器加载,但因为启动类加载
器并非用Jaa实现,已经脱离了Java体系,所以如果尝试调用扩展类加载器的 getParentO
方法获取父加载器会得到null然而,它的父类加载器是启动类加载器。
>应用程序类加载器( Application ClassLoader):亦叫系统类加载器( System ClassLoader),
它负责加载用户类路径( CLASSPATH)指定的类库,如果程序没有自己定义类加载器,131类加载器
就默认使用应用程序类加载器。它也由启动类加载器加载,但它的父加载类被设置成了扩
展类加载器。如果要使用这个加载器,可通过 ClassLoader. getSystem ClassLoaderO获取
假如想自己写一个类加载器,那么只需要继承 java. lang ClassLoader类即可。可以用图13.1
来清晰表示出各种类加载器的关系,启动类加载器是最根本的类加载器,其不存在父类加载器,
扩展类加载器由启动类加载器加载,所以它的父类加载器是启动类加载器,应用程序类加载器
也由启动类加载器加载,但它的父加载器指向扩展类加载器,而其他用户自定义的类加载器由
应用程序类加载器加载。
启动类加载器
在M中唯
扩展类加载器
在VM中唯
应用程序类加载器
在JVM中唯一
用户定义的类加载器
用户定义的类加载器
N个
▲图131类加载器关系
由此可以看出,越重要的类加载器就越早被JVM载入,这是考虑到安全性,因为先加载
的类加载器会充当下一个类加载器的父加载器,在双亲委派模型杋制下,就能确保安全性。双
亲委派模型会在类加载器加载类时首先委托给父类加载器加载,除非父类加载器不能加载才自
己加载。
这种模型要求,除了顶层的启动类加载器外,其他的类加载器都要有自己的父类加
载器。假如有一个类要加载进来,一个类加载器并不会马上尝试自己将其加载,而是委
派给父类加载器,父类加载器收到后又尝试委派给其父类加载器,以此类推,直到委派
给启动类加载器,这样一层一层往上委派。只有当父类加载器反馈自己没法完成这个加
载时,子加载器才会尝试自己加载。通过这个机制,保证了Java应用所使用的都是同
个版本的Java核心库的类,同时这个机制也保证了安全性。设想如果应用程序类加载器
想要加载一个有破坏性的 java. lang. System类,双亲委派模型会一层层向上委派,最终委
派给启动类加载器,而启动类加载器检查到缓存中已经有了这个类,并不会再加载这个
有破坏性的 System类。
另外,类加载器还拥有全盘负责机制,即当一个类加载器加载一个类时,这个类所依
187第13章公共与隔离的类加载器
赖的、引用的其他所有类都由这个类加载器加载,除非在程序中显式地指定另外一个类加
载器加载。
在Java中,我们用完全匹配类名来标识一个类,即用包名和类名。而在JM中,一个类
由完全匹配类名和一个类加载器的实例D作为唯一标识。也就是说,同一个虚拟机可以有两
个包名、类名都相同的类,只要它们由两个不同的类加载器加载。当我们在Java中说两个类
是否相等时,必须在针对同一个类加载器加载的前提下才有意义,否则,就算是同样的字节码,
由不同的类加载器加载,这两个类也不是相等的。这种特征为我们提供了隔离机制,在 Tomcat
服务器中它是十分有用的。
了解了JVM的类加载器的各种机制后,看看一个类是怎样被类加载器载入进来的。如
图13.2所示,要加载一个类,类加载器先判断此类是否已经加载过(加载过的类会缓存在内
存中),如果缓存中存在此类,则直接返回这个类。否则,获取父类加载器,如果父类加载器
为null,则由启动类加载器载入并返回 Class如果父类加载器不为nul,则由父类加载器载入,
载入成功就返回Clas,载入失败则根据类路径査找 Class文件,找到就加载此 Class文件并返
回Clas,找不到就抛出 ClassNotFoundException异常
加载类
否
缓存中是否存
是
在此 Class
父类加载器是
是否为null
由启动类加载器载入
返回 Class
否
由父类加
载入是
是
载器载入
否成功
否
根据类路径查找
Class x件
是否找到是J载入找到
的 Class
否
抛出 ClassNotFoundException异常
▲图13.2类加载过程
类加载器属于JVM级别的设计,我们很多时候基本不会与它打交道。假如你想深入了解
Tomcat内核或设计开发自己的框架和中间件,那么你必须熟悉类加载器的相关机制,在现实
18813.2自定义类加载器
的设计中,根据实际情况利用类加载器可以提供类库的隔离及共享,保证软件不同级别的逻辑
分割程序不会互相影响,提供更好的安全性。
12自定义类加载器
般的场景中使用Java默认的类加载器即可,但有时为了达到某种目的,又不得不实现
自己的类加载器,例如为了使类库互相隔离,为了实现热部署重加载功能。这时就需要自己定
义类加载器,每个类加载器加载各自的资源,以此达到资源隔离效果。在对资源的加载上可以
沿用双亲委派机制,也可以打破双亲委派机制。
1)沿用双亲委派机制自定义类加载器很简单,只须继承 Classloader类并重写 findclass
方法即可。下面给出一个例子
①先定义一个待加载的类Test,它很简单,只是在构建函数中输出由哪个类加载器加载。
public class Test
public Test(t
System. out. println(this getClass(). getclassLoader(). tostring())i
②定义一个 Tomcat classloader类(它继承 Class Loader),重写 findclass方法,此方法要
做的事情是读取Test. class字节流并传入父类的 define class方法。然后,就可以通过自定义类
加载器 Tomcatclass Loader对 Test class进行加载,完成加载后会输出“To
omcatloader。
public class TomcatClassLoader extends ClassLoader
private string name;
public TomcatclassLoader(Classloader parent, String name)
super (parent)i
this name name i
@override
public String tostring ()
return this name
@Override
public Class<?> findclass(String name )t
Inputstream is= null
byte[] data nulli
ByteArrayoutputstream baos new ByteArrayoutputstream()i
try i
is= new FileInputStream(new File("d: /Test class"))i
int c= 0
while (-1 !=(c= is read()))i
189第13章公共与隔离的类加载器
baos write(c)
data
baos. toByteArray
catch (Exception e)(
e printstackTrace()i
finally
try
is. close()i
baos close()i
A catch (IOException e)
e. printstackfrace()i
return this. defineclass(name, data, 0, data length)i
public static void main(String[] args)(
Tomcatclassloader loader new Tomcatclassloader
TomcatclassLoader. class. getclassLoader(),"Tomcatloader")i
Class clazz;
try i
clazz loader loadclass("test. classloader Test")
Object object clazz newInstance()i
y catch (Exception e) i
e printstackTrace()i
2)打破双亲委派机制则不仅要继承 ClassLoader类,还要重写 loadclass和 findclass方法,
下面给出一个例子。
①定义Test类。
public class Test i
public Test()i
System. out. println (this getclass().getClassLoader().tostring())i
②重新定义一个继承 ClassLoader的 Tomcat classLoader类,这个类与前面的
Tomcatclassloader类很相似,但它除了重写 findclass方法外,还重写了 load Class方法。默认
的 loadclass方法实现了双亲委派机制的逻辑,即会先让父类加载器加载,当无法加载时,才
由自己加载。这里为了破坏双亲委派机制必须重写 loadclass方法,即这里先尝试交由 System
类加载器加载,加载失败时才会由自己加载。它并没有优先交给父类加载器,这就打破了双亲
委派机制。
l90132自定义类加载器
public class TomcatClassLoaderN extends ClassLoader i
private String name;
public TomcatClassLoaderN (ClassLoader parent, String name)
super(parent)i
this name name;
@Override
public String toString()
return this name;
@override
public Class<?> loadclass(String name) throws ClassNotFoundException f
Class<?> clazz null;
ClassLoader system getsystemClassloader ()i
try i
clazz= system. loadclass(name)i
y catch (Exception e)t
∥忽略
if (clazz ! null)
return clazz
clazz= findclass(name)
return clazz
@Override
public Class<?> findclass(String name
Inputstream is= nulli
byte[] data null;
ByteArrayoutputstream baos new ByteArrayOutputstream ()i
try
is= new FileInputstream(new File("d: /Test class"))i
int
0
while (-1 !=(c= is read())
baos write(c)
data baos. toByteArray()i
y catch (Exception e)t
e printstackTrace
y finally
try
is close()i
baos close()i
3 catch (IOException e) i
e printstackTrace()i
191第13章公共与隔离的类加载器
return this. defineClass(name, data, 0, data length)i
public static void main(string[] args
TomcatclassloaderN loader new TomcatclassloaderN(
TomcatclassLoaderN. class. getClassLoader(),"TomcatLoaderN")
Class clazz
try i
clazz loader loadclass("test. classloader. Test")
Object object clazz newInstance()
3 catch (Exception e)i
e printstackTrace(
133 Tomcat中的类加载器
Tomcat拥有不同的自定义类加载器,以实现对各种资源库的控制。一般来说, Tomcat主
要用类加载器解决以下4个问题。
同一个Web服务器里,各个Web项目之间各自使用的Java类库要互相隔离。
同一个Web服务器里,各个Web项目之间可以提供共享的Java类库。
为了使服务器不受Web项目的影响,应该使服务器的类库与应用程序的类库互相
独立。
对于支持JSP的web服务器,应该支持热插拔( HotS wap)功能。
对于以上几个问题,如果单独使用一个类加载器明显是达不到效果的,必须根据具体情况
使用若干个自定义类加载器。
下面看看 Tomcat的类加载器是怎样定义的。如图133所示,启动类加载器、扩展类加载
器、应用程序类加载器这三个类加载器属于JDK级别的加载器,它们是唯一的,我们一般不
会对其做任何更改。接下来,则是 Tomcat的类加载器,在 Tomcat中,最重要的一个类加载器
是 Common类加载器,它的父类加载器是应用程序类加载器,负责加载 SCATALINA
BASE/ib、$ CATALINA HOME/ib两个目录下所有的clas文件与ar文件。而下面虚线框的
两个类加载器主要用在 Tomcat5版本中, Tomcat5版本中这两个类加载器实例默认与常见类
加载器实例不同, Common类加载器是它们的父类加载器。而在 Tomcat7版本中,这两个实
例变量也存在,只是 catalina.properties配置文件没有对 server loader和 share loader两项进行配
置,所以在程序里这两个类加载器实例就被赋值为 Common类加载器实例,即一个 Tomcat7
版本的实例其实就只有 Common类加载器实例
l92133 Tomcat中的类加载器
启动类加载器
扩展类加载器
应用程序类加载器
共享类加载器
Common类加载器
caim类加载器
WebApp类加载器
▲图13.3 Tomcat7中的类加载器
下面再看看 Tomcat7版本中对这些类加载器处理的代码。
private void initclassLoaders()
try
commonLoader createclassloader("common", null)i
if( commonLoader = null )i
commonLoader=this getclass(). getClassLoader ()i
catalinaloader createclassloader("server, commonLoader)i
sharedLoader createclassloader("shared",commonLoader)i
catch (Throwable t)
handleThrowable(t)i
log error("Class loader creation threw exception",t)i
System. exit(1)i
首先创建一个 Commor类加载器,再把 Common类加载器作为参数传进 create Classloader方法
里,在这个方法里面会根据 catalina. properties中的 server loader和 share loader属性是否为空判断是
否另外创建新的类加载器。如果属性为空,则把常见类加载器直接赋值给 Catalina类加载器和共亨
类加载器。如果默认配置满足不了你的需求,可以通过修改 catalina. properties配置文件满足需要。
从图133中的 WebApp ClassLoader来看,就大概知道它主要用于加载Web应用程序。它
的父类加载器是 Common类加载器, Tomcat中一般会有多个 WebApp类加载器实例,每个类
加载器负责加载一个Web程序。
对照这样的一个类加载器结构,看看上面需要解决的问题是否解决。由于每个Web应用
项目都有自己的 WebApp类加载器,很好地使多个Web应用程序之间互相隔离且能通过创建
l93第13章公共与隔离的类加载器
新的 Webapp类加载器达到热部署。这种类加载器结构能有效使 Tomcat不受Web应用程序影
响,而 Common类加载器的存在使多个Web应用程序能够互相共享类库。
134类加载器工厂— lassLoaderFactory
Java虚拟机利用类加载器将类载入内存的过程中,类加载器要做很多的事情,例如,读取
字节数组、验证、解析、初始化等。而Java提供的 URLClassLoader类能方便地将Jar、 Class
或网络资源加载到内存中。 Tomcat中则用一个工厂类 ClassLoaderFactory把创建类加载器的细
节进行封装,通过它可以很方便地创建自定义类加载器。
如图13.4所示,利用 create Classloader方法并传入资源路径和父类加载器即可创建一个
自定义类加载器,此类加载器负责加载传入的所有资源。
BB org. apache. catalina.startu
a= import declarations
PF ClassLoaderFactory
i9 create ClassLoader(File. File[, ClassLoader)
a new PrivilegedAction< StandardClassLoader>0 (-N
o create ClassLoader( List<Repository>, ClassLoader)
new PrivilegedAction< StandardClassLoader>0 f.
B validate File(File, Repository Type)
aBS Repository Type
SF DIR
UF GLOB
cSF JAR
CSF URL
s Repository
o location: String
c type: Repository Type
e Repository(String, Repository Type)
getLocation0
● getType0
▲图134类加载器工厂
ClassLoaderFactory有个内部类 Repository,它就是表示资源的类,资源的类型用一个
Repository type枚举表示。
I public static enum RepositoryType (DIR, GLOB, JAR, URLY
每个类型代表的意思如下。
≯DR:表示整个目录下的资源,包括所有 Class、Jar包及其他类型资源。
>GLOB:表示整个目录下所有的Jar包资源,仅仅是jar后缀的资源
JAR:表示单个Jar包资源。
URL:表示从URL上获取的Jar包资源。
194134类加载器工厂— ClassLoaderFactory
通过以上介绍,读者已经对 ClassLoaderFactory类有所了解。下面用一个简单的例子展示
Tomcat中的常见类加载器是如何利用 ClassLoaderFactory工厂类来创建的,代码如下
List<Repository> repositories new Arraylist<Repository>()i
Repositories. add (new Repository(
sicatalina. home / lib", RepositoryType DIR))i
Repositories. add (new Repository(
sicatalina. home /lib", RepositoryType. GLOB))
Repositories. add(new Repository(
sicatalina. base)/lib", RepositoryType DIR))i
Repositories. add(new Repository(
sicatalina. base)/lib", RepositoryType GLOB))i
Classloaderparent nulli
ClassLoader commonLoader= ClassLoaderFactory createclassLoader
(repositories, parent)i
至此 Common类加载器创建完毕。其中,${ catalina. home}与s{ catalina, base}表示变量,它
的值分别为 Tomcat安装目录与 Tomcat的工作目录。 Parent为父类加载器,如果它设置为null
ClassLoader Factory创建时会使用默认的父类加载器,即系统类加载器。总结起来,只需以下
几步就能完成一个类加载器的创建。首先,把要加载的资源都添加到一个列表中。其次,确定
父类加载器,默认就设置为null最后,把这些作为参数传入 ClassLoader Factory工厂类。
假如我们不确定要加载的资源是在网络上的还是本地的,那么可以用以下方式进行处理。
try i
URL ur1= new URl("路径")
repositories. add (new Repository("231", RepositoryType URL)
y catch (MalformedURLException e)i
这种方式处理得比较巧妙,URL在实例化时就可以检査这个路径的有效性。假如为本地资源
或者网络上不存在此路径的资源,那么将抛出异常,不会把此路径添加到资源列表中。
ClassLoader Factory工厂类最终将资源转换成URL囗数组,因为 ClassLoaderFactory生成的
类加载器是继承于 URLClassloader的,而 URLClassloader的构造函数只支持URL囗]数组。从
Repository类转换成URL囗数组可分为以下几种情况。
①若为 Repository Type.URL类型的资源,则直接新建一个URL实例并把它添加到URL
数组即可。
②若为 Repository Type. DIR类型的资源,则要把Fe类型转化为URL类型。由于URL
类用于网络,带有明显的协议,于是把本地文件的协议设定为file,即处理为new
URL(“file:/D:test”),末尾的“/”切记要加上,它表示D盘test整个目录下的所有资源。最
后,把这个URL实例添加到URLD数组中
195第13章公共与隔离的类加载器
③若为 Repository Type. JAR类型的资源,则与处理 Repository Type. DIR类型的资源类似,
本地文件协议为fle,处理为 new URL(“file:D:/ test/test. jar”),然后把这个URL实例添加到
URL囗数组中。
④若为 Repository type GLOB类型的资源,则找到某个目录下的所有文件,然后逐个判
断是不是以jar后缀结尾。如果是,则与处理 Repository Type.JAR类型的资源一样进行转换,
再将URL实例添加到URL数组中。如果不是以jar结尾,则直接忽略。
现在读者对 ClassLoader Factory有了更深的了解,知道了怎样轻松建立一个类加载器实例,
并且了解了其中的细节实现。
135遭遇 ClassNotFoundException
前面提到 Tomcat会创建 Common类加载器、 Catalina类加载器和共享类加载器三个类加
载器供自己使用,这三个其实是同一个类加载器对象。 Tomcat在创建类加载器后马上就将其
设置成当前线程类加载器,即 Thread. currentThread(). setContextclassloader( CatalinaLoader),
这里主要是为了避免后面加载类时加载不成功。下面将举一个典型的例子说明如何利用
URLClassloader加载指定的Jar包,并且解析由此引起的加载失败问题。
首先,定义一个提供服务的接口,并且打包成 Testinterface jar
public interface TestInterface
public string display ()i
其次,创建一个名为 Testclass loader的类,它实现 TestInterface jar包里面的 TestInterface
接口,包路径为 com. test。该类包含一个 display方法,将这个类编译并打包成 test. jar包,放
在D盘目录下。
public class TestclassLoader implements TestInterface f
public string display()i
return "I can load this class and execute the method. m
最后,利用 URLClassloader加载并运行 TestclassI_ oader类的 display方法。创建一个测试
类,如下所示。
public class Test i
public static void main(String[] args)i
try i
URLurl new URL(file: D:/test. jar")i
URLClassLoader myClassLoader new URLClassLoader(new URL[]url))i
Class my Class my ClassLoader loadclass("com. test. Testclassloader")i
19613.5遭遇 ClassNotFoundException
TestInterface testclassLoader =(TestInterface)myClass. newInstance()i
System. out. println(testClassLoader display())i
catch(Exception e)
e printstackTrace()i
测试类的main方法中首先用 URLClassLoader指定加载 test. Jar,然后再将
com. test. TestclassLoader类加载到内存中,最后用 newInstance方法生成一个 TestclassLoader
实例,即可调用它的 display方法。运行这个测试类,能够达到预期效果,输出“ I can load this
class and execute the method.”语句。看起来一切来得都是那么顺其自然,但当你把
Testlnterface jar包移植到Web应用中时,竟然抛出 java. lang ClassNotFoundException:com.test.
TestInterface异常,报错的位置正是代码中加粗的语句。怎么会抛出找不到这个类的异常呢?
要明白为什么会报这样的错,需要搞清楚以下几点
在Java中,我们用完全匹配类名来标识一个类,即用包名和类名。而在JVM中,一个类
由完全匹配类名和一个类加载器的实例ID作为唯一标识。也就是说,同一个虚拟机可以
有两个包名、类名都相同的类,只要它们由两个不同类加载器加载,而在各自类加载器中
的类实例也是不同的,并且不能互相转换。
在类加载器加载某个类时,一般会在类中引用、继承、扩展其他的类,于是类加载器查找
这些引用类也是一层一层往父类加载器上査找的,最后査看自己,如果都找不到,将会报
出找不到此类的错误。也就是说,只会向上查找引用类,而不会往下从子类加载器上查找。
每个运行中的线程都有一个成员 Contextclassloader,用来在运行时动态地载入其他类。在
没有显式声明由哪个类加载器加载的类(例如在程序中直接新建一个类)时,将默认由当
前线程类加载器加载,即线程运行到需要加载新类时,用自己的类加载器对其进行加载。
系统默认的 Contextclass Loader是系统类加载器,所以一般而言,Java程序在执行时可以
使用JVM自带的类、$ JAVA HOME/jre/ riblet中的类和$ CLASSPATH中的类。
了解了以上三点,再对前面加载时抛出找不到类的异常进行分析。
当测试类运行在命令行时,之所以能正常运行是因为,运行时当前线程类加载器是系统类
加载器, TestInterface接口类自然由它加载, URLClassLoader的默认父类加载器也是系统
类加载器。由双亲委派机制得知,最后 TestclassLoader由系统类加载器加载,那么接口与
类都由同一个类加载器加载,自然也就能找到类与接口并且进行转化
≯当测试类移到web项目中时,假如将代码移到 Servlet里面,将直接报错,指出无法运行。
其中运行时当前线程类加载器是 WebApp类加载器,而 WebApp类加载器在交给系统类加
载器试图加载无果后,自己尝试加载类,所以 TestInterface接口类由 WebApp类加载器加
载。同样, URLClassloader的父类加载器为系统类加载器,它负责加载 TestClassloader
类。于是,问题来了,两个不同的类加载器分别加载两个类,而且 WeaP类加载器又是
197第13章公共与隔离的类加载器
系统类加载器的子孙类加载器,因为 TestclassLoader类扩展了 TestInterface接口,所以当
URLClassl_ oader加载 Test classloader时找不到 WebApp类加载器中的 TestInterface接口类,
即抛出 java. lang. ClassNot Found Exception: com. test. TestInterface异常。
针对以上错误,有两种解决方法。
>既然是因为两个类被两个类加载器加载而导致找不到类,那么最简单的解决方法就是使这
两个类统一由一个类加载器来加载,即在加载 testclassloader jar时用当前线程类加载器加
载,只须稍微修改代码。
URLClassLoader myClassLoader= new URLClassloader(
new URL[] i url ) Thread currentThread(). getcontextclassLoader();
重点在加粗部分,即在创建 URLClassloader对象时将当前类加载器作为父类加载器传入,
WebAPp当前线程类加载器是 Web AppClassLoader,那么当加载 testclassloader jar时,将优先
交给 Webapp classloader加载,这样就保证了两个类都在同一个类加载器中,不会再报找不到
类异常。
URLClassloader如果不设置父类加载器,它的默认父类加载器为系统类加载器,于是
testclassloader: jar将由系统类加载器加载。为了能在系统类加载器中找到 TestInterface接口
类,必须使 TestInterface接口类由系统类加载器父类加载器以上的类加载器加载。对于扩
展类加载器,可以将 testclassloader jar复制到 SJAVA HOME/ jre/lib/ext目录下。保证了由
URLClassloader加载的类的引用类能从扩展类加载器中找到,问题同样得到解决。
讨论了这么多,回归到 Tomcat中的 Thread. currentThreado. setContext ClassLoader(catalinaLoader)
上面讨论的典型类加载器错误在 Tomcat中同样存在,因此 Tomcat正是通过设置线程上下文类加
载器来解决的。在 Tomcat中类加载器存在以下三个状况。
> Tomcat7默认由 Common classloader类加载器加载。
Commonloader的父类加载器是系统类加载器。
当前线程类加载器是系统类加载器。
如图13.5所示,先看默认情况, Contextclass loader被赋为系统类加载器,系统类加载器
看不见 Common类加载器加载的类,即如果在过程中引用就会报找不到类的错误,所以启动
Tomcat的过程肯定会报错。接着看看改进后的情况,把 Contextclass Loader赋为 Common类
加载器。此时, Tomcat在启动过程中如果用到 SCATALINA BASE/ib或 SCATALINA HOME/lIb
中的类,就不会报错了。同时,它也能看到系统类加载器及其父类加载器所有加载的类。简单
地说,解决方法就是把 Common类加载器设置为线程上下文类加载器。
为避免类加载错误,应该尽早设置线程上下文类加载器,所以在 Tomcat中启动一初始化
就马上设置,即初始化时马上通过 Thread. current Thread.setContextClass Loader( catalinaloader)
设置线程上下文类加载器。此后此线程运行时默认由 Common类加载器载入类。
19813.5遭遇C| assNotFoundException
Contextclas
Loader
②更换
①默认情况
运行时线程上的类
不可见
Common类加载器
系统类加载器
可见
SCATALINA BASE/II
SCATALINA BASE/E
CLASSPATH
▲图13.5 Tomcat中的类加载器第14章请求URI映射器 Mapper
Mapper组件主要的职责是负责 Tomcat的请求路由,每个客户端的请求到达 Tomcat后,
都将由 Mapper路由到对应的处理逻辑( Servlet)上。如图14.1所示,在 Tomcat的结构中有
两部分会包含 Mapper组件,一个是 Connector组件,称为全局路由 Mapper;另外一个是 Context
组件,称为局部路由 Mapper。本章将深入探讨 Tomcat的路由模块 Mapper组件。
Service
Context
Connector
Mapper
Mapper
▲图14.1 Mapper组件
11请求的映射模型
对于web容器来说,根据请求客户端路径路由到对应的资源属于其核心功能。假设用户
在自己的电脑上使用浏览器输入网址htp:/ww.test.com/test/index.jsp,报文通过互联网到达该
主机服务器,服务器应将其转到test应用的 index. jsp页面中进行处理,然后再返回。
如图14.2所示,当在客户端浏览器的地址栏中输入htp:/ tomcat. apache. org/tomcat-70-
doc/indexhtml时,浏览器产生的HTTP报文大致如下。
Get /Tomcat-7.0-doc/index. html httP/1.1
Host: tomcat. apache. org
Connection: keep-alive
Cache-Control: max-age=O
Accept: text/html, application/xhtml+xml, application/xml; c=0.9, image/webp, */*q=0.8
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0: WOW64)AppleWebkit/537.36 (KHTML,142 Mapper的实现
like Gecko) Chrome/45.0.2454. 101 Safari/537.36
Accept-Encoding: gzip, deflate, sdch
Accept-Language: zh-CN, zh;q=0.8
注意加粗的报文,Host: tomcat. apache.0rg表明访问的主机是 tomcat. apache. org,而
tomcat--7.0-doc/ index. htm则表示请求的资源是“ tomcat-7.0-doc”Web应用的 index. htm1页面,
Tomcat通过解析这些报文就可以知道该请求对应的资源。因为 Tomcat根据请求路径对处理进
行了容器级别的分层,所以请求URL与 Tomcat内部组件的对应关系如图143所示, tomcat
apache. org对应Host容器, tomcat-7.0-doc对应 Context容器, index. html对应 Wrapper容器
http:/tomcat.apacheorg/tomcat-7.0-doc/index.htmi
Host
ContextWrapper
tomcat. apache. org/tomcat- 7.0-doc/index. html
▲图14.2请求的响应
▲图14.3URL映射
对应上面的请求,该Web项目对应的配置文件主要如下。
<Host name="tomcat. apache. org" appBase="webapps"autoDeploy=true">
<Context path="/tomcat-7.0-doc"docBase="/usr/tomcat/tomcat-7.0-doc"/>
</Host>
当 Tomcat启动好后,首先htt:/ tomcat. apache. org/tomcat-7.0- doc/index. html请求就会被
Tomcat的路由器通过匹配算法路由到名为 tomcat.apache. org的Host容器上,然后在该容器中
继续匹配名为 tomcat--7.0-doc的 Context容器(Web应用),最后在该 Context容器中匹配
index htm资源,并返回给客户端。
以上大致介绍了web请求从客户端到服务端 tomcat的资源匹配过程。每个完整的请求都
有如上的层次结构, Tomcat内部中会有Host、 Context、 Wrapper层次与之对应,而具体的路
由工作则由 Mapper组件负责。下面介绍 Mapper的实现
12Maer的实现
Mapper组件的核心功能是提供请求路径的路由映射,根据某个请求路径,通过计算得到
相应的 Servlet( Wrapper)。下面介绍 Mapper的实现细节,包括Host容器、 Context容器、 Wrapper
容器等的映射关系以及映射算法。
如果要将整个 Tomcat容器中所有的Web项目以 Servlet级别组织起来,需要一个多层级
的类似Map结构的存储空间。如图144所示,以 Mapper作为映射的入口,按照容器等级,
首先 Mapper组件会包含了N个Host容器的引用,然后每个Host会有N个 Context容器的引
201第14章请求UR|映射器 Mapper
用,最后每个 Context容器包含N个 Wrapper容器的引用。例如,如果使用 Mapper组件查找
tomcat. apache. org/tomcat70-doc/ earch,它首先会匹配名为 tomcat. apache. org的Host,然后从
中继续匹配名为 tomcat-7.0-doc的 Context,最后匹配名为 search的 Wrapper( Servlet)
Mapper
Host
Host
Context
Context
ContextContext
Wrapper Wrapper
WrapperWrapper…
▲图14.4 Mapper的映射
为了方便阐述,下面实现一个简化后的 Mapper映射关系的存储模型,这里不考虑多版本
Context。
①提供一个基础的键值对模型,name为容器的名称, object为具体的容器。
public class MapElement
public String name null;
public Object object = nulli
②2提供Host映射模型,它继承 MapElement,且包含若干 Context映射。
public class Host extends MapElement
public. Context[] contexts = nulli
③提供 Context映射模型,它继承 MapElement,且包含不同类型的 Wrapper(servlet):默
认 Servlet y、精确匹配 Servlet、通配符 Servlet和扩展 Servlet。除此之外,还有欢迎页资源和path。
public class Context extends MapElement
public String path null
public String[] welcomeResources new String[0];
public Wrapper defaultWrapper null
public Wrapper [] exactWrappers new Wrapper[0];
public Wrapper[] wildcardwrappers
new Wrapper[0];
public Wrapper[] extensionWrappers
new Wrapper[o]i
④提供 Wrapper映射模型,它继承 Map element
202143局部路由 Mapper
public class Wrapper extends MapElement t
⑤定义 Mapper类。
public class Mapper(
public Host[] hosts;
Mapper只要包含一个Host数组即可完成所有组件关系的映射。在 Tomcat启动时将所有
Host容器和它的名字组成Host映射模型添加到 Mapper对象中,把每个Host下的 Context
容器和它的名字组成 Context映射模型添加到对应的Host下,把每个 Context下的 Wrapper
容器和它的名字组成的 Wrapper映射模型添加到对应的 Context下。 Mapper组件提供了对
Host映射、 Context映射、 Wrapper映射的添加和移除方法,在 Tomcat容器中添加或移除相
应的容器时,都要调用相应的方法维护这些映射关系。为了提高查找速度和效率, Mapper
组件使用了二分搜索法查找,所以在添加时应按照字典序把Host、 Context、 Wrapper等映射
排好序。
当 Tomcat启动稳定后,意味着这些映射都已经组织好,那么具体是如何查找对应容器的?
关于Host的匹配,直接对 Mapper中的Host映射数组进行忽略大小写的二分搜索查找。
关于 Context的匹配,对上面查找到的Host映射中的 Context映射数组进行忽略大小写的
二分搜索查找。这里有个比较特殊的情况是请求地址可以直接以 Context名结束,例如
htp:/ omat. apache. org/tomcat-7.0-doc,另外一些则类似htp!/ omat. apache. org/tomcat-7.0
doc/index. html。另外, Context映射中的name对应 Context容器的path属性。
关于 Wrapper的匹配,涉及几个步骤。首先,尝试使用精确匹配法匹配精确类型S
servlet
的路径。然后,尝试使用前缀匹配通配符类型 Servlet。接着,尝试使用扩展名匹配通配符
类型 Servlet。最后,匹配默认 Servlet
Tomcat在处理请求时对请求的路由分发全由 Mapper组件负责,请求通过 Mapper找到最
终的 Servlet或资源。而在 Tomcat I中会有两种类型的 Mapper,根据它们作用的范围,分别称
为全局路由 Mapper和局部路由 Mapper
143局部路由 Mapper
局部路由 Mapper是指提供了 Context容器内部路由导航功能的组件。它只存在于 Context
容器中,用于记录访问资源与 Wrapper之间的映射,每个Web应用都存在自己的局部路由
Mapper组件。
在做Web应用开发时,我们有时会用到类似 request.getRequestDispatcher(" servlet/jump?
action=do") forward (request, response)这样的代码。这里其实就使用了 Context容器内部的
203第14章请求∪R|映射器 Mapper
Mapper的功能,用它匹配/ servlet/jump? Paction=do对应的 Servlet,然后调用该 Servlet具体的处
理逻辑。从这点来看,它只能路由一部分的地址路径,而不能路由一个完整的请求地址。
所以局部路由 Mapper只能在同一个Web应用内进行转发路由,而不能实现跨Web应用
的路由。如果要实现跨web应用,需要用到重定向功能,让客户端重定向到其他主机或其他
Web应用上。而对于从客户端到服务端的请求,则需要全局路由Mapr组件的参与。
144全局路由 Mapper
除了局部路由 Mapper之外,另外一种 Mapper就是全局路由 Mapper,它是提供了完整的
路由导航功能的组件。它位于 Tomcat的 Connector组件中。通过它能对Host、 Context、 Wrapper
等路由,即对于一个完整的请求地址,它能定位到指定的Host容器、 Context容器以及 Wrapper
容器。
所以全局路由 Mapper拥有 Tomcat容器完整的路由映射,负责完整的请求地址路由功能
204第15章 Tomcat的JNDI
JNDI即Java命名和目录接口( Java Naming and Directory Interface)。本章将介绍JNDI的
概念和架构、JNDI运行机制、 Tomcat容器怎样集成JDI,以及如何在 Tomcat中使用JDI
和JNDI的标准资源。
11N叫简介
JND属于JE规范范畴,是JE的核心技术之一,它提供了一组接口、类和关于命名空
间的概念。JNDⅠ是基于提供商技术,它暴露一个API和一个服务供应接口(SPI)。它将名称
和对象联系起来,使我们可以用名称访问对象。我们可以把JND简单地看成里面封装了一个
名称到实体对象的映射,通过字符串可以方便得到想要的对象资源,例如JDBC、 JMail JMS、
EJB等。这意味着任何基于名字的技术都能通过JNDI而提供服务,现在它支持的技术包括
LDAP、RMI、 CORBA、NDS、NIS、DNS等。
JND包含很多的服务接口,如图15.1所示, JNDIAPI提供了访问不同JNDI服务的一个
标准的统一入口,其具体实现可由不同的服务提供商来完成,具体调用的类及通信过程对用户
来说是透明的。从架构上看,JNDI包含了一个API层及SPI层,SPI层提供了服务的具体实
现,再通过JND的API暴露给Java应用程序使用,这就将各种服务复杂的细节屏蔽了,提供
统一的接口供应用程序使用。
Java应用程序
JNDI API
命名管理器
JNDI SP
LDAP RMICORBA NDS
DNS
NIS
▲图15.1JND|的结构
JNDI主要包含了5个包。第15章 Tomcat的JND
Javax. naming:这个包下面主要是用于访问命名服务的类和接口。比如,其中定义了 Context
接口,该接口是执行查找时命名服务的入口点
javax. naming directory:这个包主要包含用于访问目录服务的类与接口的扩展命名类和接
口。例如,它增加了新的属性类,提供代表一个目录上下文的 DirContext接口,并且定义
了用于检查和更新与目录对象相关的属性的方法。
avax namingevent:这个包主要为访问命名和目录服务时提供事件通知以实现监控功能。
例如,它定义了一个 Naming Event类(用于表示由命名/目录服务生成的事件),以及一个
监视 Naming Events类的 Naming Listener接口。
avax.naming. ldap:这个包为 LDAP y3扩展操作和空间提供特定的支持。
Javax. naming. spI:这个包提供通过 Javax. naming及其相关包访问命名和目录服务的支持。
只有那些SPI开发人员才对这个包感兴趣, Tomcat也提供了自己的服务接口,所以也必须
与这个包打交道。
152J运行机制
Tomcat中涉及了 JNDI SPI的开发,下面深入讨论JND的运行机制。JND的主要工作就
是维护两个对象:命名上下文和命名对象。它们的关系可以用图152简单表示,其中圆圈表
示命名上下文,星形表示命名上下文所绑定的命名对象,初始上下文为入口。假如查找的对象
的URL是“AC03”,那么命名上下文将对这个URL进行分拆,首先找到名字为A的上下文,
接着再找到C的上下文,最后找到名字为03的命名对象。类似地,其他对象也是如此查找。
这便是JNDI树,所有的命名对象和命名上下文都绑定到树上。一般来说,命名上下文是树上
的节点,而命名对象是树上的树叶。不管是命名对象还是命名上下文,都有自己的名字。
初始
上下文
E
☆食☆
會
▲图152命名上下文与命名对象
206152JND|运行机制
关于命名对象,一般来说,在小ND中存在两种命名对象形态:①直接存在内存中的命名
对象;②使用时再根据指定类及属性信息创建的命名对象。
第一种命名对象形态,将实例化好的对象通过 Context. bindo绑定到上下文,当需要命名
对象时,通过 Context. lookup查找,这种情况是直接从内存中査找相应的对象,上下文会在
内存中维护所有绑定的命名对象。这种方式存在几个缺点。首先,内存大小限制了绑定到上下
文的对象的数量。其次,一些未持久保存的对象在命名服务重启后不可恢复。最后,有些对象
本身不适合这种方式,例如数据库连接对象;
第二种命名对象形态,将生成命名对象需要的类位置信息及一些属性信息进行绑定,在査找时
就可以使用这些信息创建适合Java应用使用的对象。这种情况下,在绑定时可能需要额外做一些处
理,例如将Java对象转化为对应的类位置信息及一些属性信息。绑定和查找这两个相反的过程通过
ObjectFactory和 StateFactory两个工厂类的 getObjectInstance和 getState ToBind方法进行实现。一般
来说,JND提供 Reference类作为存储类位置信息及属性信息的标准方式,并鼓励命名对象实现这
个类而不是自己另起炉灶。同时, Serializable也可作为小ND存储对象类型,表示可序列化的对象。
另外, Referenceable对象可通过 Referenceable. getReference(返回 Reference对象进行存储。
整个小D框架对命名上下文和命名对象的处理进行了巧妙、合理的设计。下面给出JNDI
涉及的主要类图。如图15.3所示,从类图中可以看到,不管是命名上下文相关的类还是命名
对象相关的类,都围绕着 Naming Manager这个类。命名上下文相关的类则提供了上下文实现
的一些策略。命名对象相关的类则提供了命名对象存储及创建的一些策略。两大部分内容如下。
通过 Factory Builder模式、URL模式、环境变量模式三种机制,确定初始上下文,相关接
口类分别为 InitialContextFactory Builder接口、 XXXURLContextFactory类、 InitialContext类。
〉通过工厂模式,定义上下文中绑定和査找对象的转化策略,相关接口类为 StateFactory接
口、 Object Factory接口。
围绕着 Naming Manager的这些类和接口是JNDI能正常运行的基础,所有的上下文都要实
现 Context接口。这个接口主要的方法是 lookup、bind,分别用于查找对象与绑定对象。我们
熟知的 InitialContext即是JNDI的入口, Naming Manager包含很多操作上下文的方法。其中,
getState ToBind及 getObjectInstance两个方法有必要提一下,它们将任意类型的对象转换成适
合在命名空间存储的形式,并且将存储在命名空间中的信息转换成对象。两者是相反的过程
具体的转换策略可以在自定义的 xXX Factory工厂类里面自己定义。另外,还有几个接口用于
约束在整个八ND机制实现中特定的方法。为了更好地理解JDI的运行机制,下面分步说明
JNDI的运行机制。
①实例化 InitialContext作为入口
②调用 InitialContext的 lookup或bind等方法。
③ lookup、bind方法实际上是调用 getURLOrDefaultInitialCtx返回的上下文的 lookup或
bind方法。
207第15章 Tomcat的JND
Initial ContextFactor
getlnitialContext(env. Hashtable)
<Interface>
<Interface>
XXXURLContext Factory
Context
InitialContextFactory Builder
getObjectlnstance(obj: Object, name: Name,
lookup(name: Name)
createlnitialContext Factory(env Hashtable)
name Ctx: Context, env: Hashtable)
bind(name Name)
InitialContext
NamingManager
props: Hashtable
initctx factory builder: InitialContext Factory Builder
defaultCtx: Context
defaultPkg PrefIx: String
lookup(name: Name)
getURLContext(scheme: String, env: Hashtable
bind(name: Name)
getlnitial Context(evn: Hashtable
getURLOrDefaultlnitialCtx(name)
getState ToBind(object, name: Name, name Ctx: Context, env Hashtable)
getObjectInstance(refinfo: Object, name: Name, name C tx: Context, env: Hashtable
x×× Factor
xxX Factory
getState To Bind(obj: Object, name: Name,
getObjectlnstance(obj: Object, name: Name,)
nameCtx: Context, env: Hashtable)
nameCtx:Context,env: Hashtable)
<Interface>
Interface>
StateFactory
ObjectFactory
getState To Bind(obj: Object, name: Name
getobjectlnstance(obj: Object, name: Name,
name Ctx Context, env: Hashtable)
name Ctx: Context, env: Hashtable)
▲图15.3JND|主要的类图
④ getURLOrDefaultlnitialCtx方法会判断是否用 Naming Manager的 setInitialContext
Factorybuilder方法设置了 InitialContext Factorybuilder,即判断 Naming Manager里面的 InitialContext
Factorybuilder变量是否为空。
⑤根据步骤④,如果设置了,则会调用 nitial ContextFactorybuilder的 createlnitialContextFactory
方法返回一个 InitialContextFactory,再调用这个工厂类的 getlnitialContext返回 Context,至此得到
了上下文。
⑥根据步骤④,如果没设置,则获取URL的 scheme,例如“java:comp/env”中java即
为这个URL的 scheme,接着根据 scheme继续判断怎么生成上下文。
⑦根据步骤⑥,如果 scheme不为空,则根据 Context URL PKG PREFIXES变量的值作
为工厂的前缀。然后,指定上下文工厂类路径,形式为:前缀 scheme. schmeURLContextFactory。
例如前缀值为com. sun jndi, scheme为java,则工厂类的路径为com. sun jndi. java.
javaURLContextFactory,接着,调用工厂类的 getObjectInstance返回上下文。如果按照上面的
操作获取上下文失败,则根据 ContexⅠ NITIAL CONTEXT FACTOR变量指定的工厂类生成
上下文。
208152JND运行机制
⑧根据步骤⑥,如果 scheme为空,则根据实例化 InitialContext时传入的 Context INItIaL
CONTEXT FACTORY变量指定的工厂类,调用其 getlnitialContext方法生成上下文。
⑨经过上面8个步骤,已经确定了真正执行bind与 lookup的上下文实例。此时,如果调
用bind方法,就会间接调用 getState ToBind把即将被绑定的对象转换成JNDI鼓励的存储类型。
而如果调用Jook叩p方法,则会间接调用 getObjectInstance把JND鼓励的存储类型数据转换为
Java程序使用的对象。
⑩0调用bind时, Naming Manage: getState ToBind( Object obj, Name name, Context name ctx,
Hashtable<?,?> environment)根据环境尝试获取 State Factory。如果设置了 StateFactory,则使用
这个工厂的 getState ToBind方法实现具体转换策略。
①调用 lookup时, Naming Manager: getobjectInstance( Object refInfo, Name name, Context
name Ctx, Hashtable<??> environment)根据 refInfo对象的 getFactory ClassName方法得到资源的
工厂类,再由这个工厂类的 getObjectInstance方法实现具体转换策略。例如, Tomcat中,用
ResourceRef作为JNDl鼓励的存储类型,当把一个 ResourceRef对象传进 Naming Manager.
getobjectInstance方法中时,将会调用 ResourceRef对象指定的资源工厂类 Resourcefactory的
getObjectInstance方法生成Java对象。
综上所述,在获取上下文的机制上,优先级最高的是 InitialContextFactorybuilder。如果存
在优先级最高的上下文,则直接根据 builder返回上下文,其他工厂类相关变量失效,例如
Context INITIAL CONTEXT FACTORY和 Context URL PKG PREFIXES;优先级次之的是根据有
无 scheme分别利用 Context URL PKG PREFIXES和 ContextⅠ NITIAL CONTEXT FACTORY
变量指定的工厂类创建上下文。
在了解了以上JNDI运行机制后,再看看下面常见的程序。它其实就是JNDI的使用,
先设置变量,再传进 InitialContext进行实例化,最后获取数据源。根据上面对JNDI框架
的剖析,从下面三段代码你能想象到内部的运行逻辑是怎样的吗?它们之间分别有什么不
同呢?
第一段代码如下。
Hashtable<string, String> env= new Hashtable<string, String>()i
env. put(Context. INITIAL CONTEXT_FACTORY, "org. apache. naming. factory. DataSourc
eLinkEactory")i
env. put(Context. URL__PKG_PREFIXES,"org. apache. naming")i
Context context new InitialContext(env)i
DataSource ds =(DataSource)context. lookup("i dbc/My DB")i
第二段代码如下
Context context new InitialContext(i
DataSource ds =(DataSource)context. lookup(java: comp/env/jdbc/myDB")i
第三段代码如下。第15章 Tomcat的JND
Hashtable<string, String> env new Hashtable<string, string>(
NamingManager. setInitialContextFactoryBuilder(new XxxInitialContextFactoryB
wilder())i
Context context new InitialContext(env)i
153在 Tomcat中集成N
通过上面的分析,读者对JDⅠ运行机制已经有了较深的了解。一般的JEE或Web应用
服务器都会实现对JND的支持,本节将对在 Tomcat中集成JND进行解析。我们在 Tomcat
中使用JNDI只需要通过简单地配置并在程序中调用API即可实现,这十分方便,因为 Tomcat
把复杂的处理逻辑封装了起来。
JNDⅠ有自己的接入机制, Tomcat要支持JNDI就要对这些接入框架有足够的理解,接入
框架使得不同的服务提供者能共用JNDⅠ的统一接口来访问各种不同的服务。一般接入JDI
必须与以下几个类打交道:初始上下文、对象工厂、状态工厂。总的来说,初始上下文负责封
装JNDI连接底层服务提供者的默认策略,而对象工厂及状态工厂用来定制命名上下文的实现。
其中,对象工厂用于定制使用绑定信息创建命名对象的策略,状态工厂用于定制从命名对象生
成绑定信息的策略。
初始上下文有以下几个特点。
它是访问命名服务的入口。
它将根据特定的策略指定一个上下文工厂类并生成一个上下文。
它支持以URL格式访问命名空间,根据特定的策略指定一个URL上下文工厂类并生成
个上下文。一般情况下,服务提供者没必要提供URL上下文工厂和URL上下文的实现,
只有在自定义方案识别的URL字符串名称时才需要,这是为了保证初始上下文能够识别
这个 scheme标识。
〉根据实际需要,我们可以覆盖默认策略。
〉如果自己重新定义一个上下文接口,为使之被初始上下文支持,我们需要扩展初始上下文,
这样便可继承初始上下文的处理方式。
对象工厂有以下几个特点。
它为命名上下文存储形式(绑定信息)转换成对象提供了机制策略,将 Reference或一个
URL或其他任意类型等转换成一个Java对象
它通过环境属性 javanaming factory object定位对象工厂类位置,多个工厂类用冒号分隔,
JNDI会尝试利用每个工厂类处理直到创建一个非空结果对象。
如果没有指定对象工厂类,则不会对对象做处理。
整个转换过程其实就是将现有的存储对象转换成可使用的Java对象的过程,可以用图15.4
进行说明,从Jaa程序一步一步调用,按照特定转换机制,最后获取到转换后的Java对象。
210153在 Tomcat中集成JND
④查找自
确定创建对己的属性Reen类
象的工厂类
③调用
命名空间
⑤调用
调用 Naming Manager的
调用工厂类的
etobjectInstance方法
getObjectInstanceHi4
②找到命名对象
☆◎
⑥创建对象
Java程序
①通过 lookup查找
▲图15.400kup过程
状态工厂有以下几个特点。
它为对象转换成适合命名上下文实现存储的形式(绑定信息)提供了机制策略,转换后可
以是 Reference、 Serializable对象、属性集或其他任意数据;
它通过环境属性 java naming factory. state定位状态工厂类位置,多个工厂类用冒号分隔,
JNDI会尝试利用每个工厂类处理,直到创建一个非空结果对象
如果没有指定状态工厂类,则不会对对象做处理。
整个转换过程其实就是将现有对象转换为可存储对象,可以用图15.5进行说明,Java程
序一步一步调用,按照特定转换机制,最后获得适合存储的对象
StateFactory
子类转换存储
形式
③调用
调用 Naming Manager的
getState To Bind方法
⑤调用
命名空间
②找到命名对象
调用工厂类的
getState ToBind方法
⑥返回适合的
①通过bind绑定
存储对象
Java程序
▲图15.5bind过程
对于 Tomcat来说,如果想集成JNDI,则要加入对命名空间的支持,维护一个树状的数据
结构,通过命名上下实现树状结构操作,每个命名上下文里面包含绑定集,绑定和查找围绕着
这个绑定集进行操作。如图15.6所示,通过bind操作将任意Java对象转换为适合存储的对象
(一般是 Reference子类)并放进一个 HashMap结构的绑定集中,再通过 lookup操作将存储的
对象( Reference子类)转换成对应的Java对象
在讲清楚JNDⅠ开发时的几个要点后,开始看 Tomcat具体的代码,直接借助一张类图说
明 Tomcat中对JNDI的集成。如图15.7所示,可以看到JNDI的几个核心类都在,只是扩展
211第15章 Tomcat的JND|
了一些类从而实现JNDI的集成。同时,为支持多命名上下文之间的隔离做了一些额外的工作。
为了更好地说明整个实现过程,下面尝试直接用简化的代码展示 Tomcat如何实现JNDI。
Hashmap<String Object
bind操作
lookup操作
绑定
利用对象
工厂机制
绑定2
利用对象
放入绑
获取存
任意Ja转换
工厂机制
般为定集
储对象
般为转换任意laa
对象
Reference
绑定3
Reference
子类
对象
子类
绑定n
▲图15.6 Tomcat中的bind和 lookup
<Interface>
Context
<Interface>
lookup(name: Name
InitialContextFactory
bind( name: Name)
getlnitialContext(env. Hashtable)
Naming Context
<Interface>
Selector Context
bindings: Hashtable
InitialContext Factory Builder
lookup(name: Name)
lookup(name: Name)
InitealContext
createlnitialContext F actory(env: Hashtable)
bind(name: Name)
bind(name: Name)
props: Hashtable
tx: Context
Name
XxxInitialContext Factory Builder
bind(na
getURLOrDefaultInitialCtx(name
createInitialContext Factory(env: Hashtable)
Context Bindings
:contextNameBindings: Hashtable
<Interface>
thread Bindings: Hashtable
createlnitialContextF actory(env. Hashtable)
threadName Bings: Hashtable
InitialContext Factory Builder
NamingManager
bindContext(Object Context)
initctx factory builder: InitialContext Factory Builder
aultPkg PrefIx: Stri
getURLContext(scheme: String env: Hashtable)
getInitial Context(evn Hashtable)
getState ToBind(object, name: Name, name Ctx: Context, env: Hashtable)
getObjectInstance(reflnfo: Object, name: Name, name Ctx: Context, env: Hashtable)
xxx Factory
javaURLContextFactory
ResourceFactory
getObjectInstance(obj: Object, name: Name,
getobjectlnstance(obj: Object, name Name,)
name Ctx: Context, env: Hashtable)
name Ctx: Context, eny: Hashtable)
name Ctx: Context, env: Hashtable)
<Interfa
State Facto
<Interface>
getState ToBind(obj: Object, name: Name
ObjectFactory
nameCtx: Context. env: Hashtable)
getobjectlnstance(obj: Object, name: Name,
name Ctx: Context, env: Hashtable)
▲图15.7 Tomcat中的JND类图
212153在 Tomcat中集成JNDl
①命名上下文类必须实现 Context接口。由于篇幅原因,这里只列出几个重要方法的实
现。每个命名上下文实例都包含环境变量、绑定集、名字,并且bind和 lookup方法必须支持
树状结构。
public class Naming Context implements Context
protected Hashtable<string, Object> envi
protected Hashtable bindings;
protected String name;
public NamingContext(Hashtable<string, Object> env, String name)
throws NamingException i
this bindings= new Hashtable(
thisenv=(env!=null?)( Hashtable )(env. clone): null;
this name
name i
@Override
public void bind(Name name, Object obj)throws NamingException t
while (( name isEmpty())&&(name. get(0).length()==0))
name name. getSuffix(1)i
Object entry bindings get(name. get(0))i
if (name size()>1)i
if (entryinstanceof Context) i
((Context) entry). bind (name. getsuffix(1),ob])i
y else
Object toBind NamingManager getStateToBind(obj,name
this, env)i
bindings. put(name. get(0), toBind)i
@Override
public object lookup(Name name)throws NamingException t
while (( name isEmpty())&&(name. get(o). length()==0)
name= name. getsuffix(1)i
Object entry bindings get(name. get(o))i
if (name size()>1) i
return ((Context) entry). lookup(name. getsuffix(1))i
y else t
if (entry instanceof Reference)
Object ob]= NamingManager getobjectInstance(entry, name, this, env)
return obj
213第15章 Tomcat的JND
y else i
return entry
@Override
public Context createSubcontext(Name name) throws NamingException t
NamingContext newContext new NamingContext(env, this name);
bind(name, newContext);
return newContexti
②引用类,必须继承 Reference类,用于替代那些不适合直接绑定的对象的一种数据类型。
public class ResourceRef extends Reference i
public static final String DEFAULT_FACTORY ="org. apache. naming factory Reso
urceractory i
public static final String DESCRIPTIon =description"
public ResourceRef(String resourceClass, String description)
this(resourceclass, description, null, null)i
public ResourceRef(String resourceClass, String description
string factory, String factoryLocation)(
super(resourceClass, factory, factoryLocation)
StringRefAddr refAddr = null
if (description ! null)(
refAddr new StringRefAddr(DESCRIPTION, description
add(re fAddr
OVerride
public string getFactoryClassName() i
string factory super. getFactoryClassName();
if (factory ! null) i
return factory
t else i
return DEFAULT FACTORY
214153在 Tomcat中集成JND
③对象工厂类,负责的是使用存储在命名空间中的信息创建对应的Java对象。
public class ResourceFactory implements objectFactory t
@override
public Object getobjectInstance(Object obj, Name name, Context nameCtx,
Hashtable<?,?> environment) throws Exception
if (obj instanceof ResourceRef
Object reto]= null
Reference ref =(Reference) obj
String className ref. getClassName (
Class<?> factoryclass null
retobj= class forName(className ).newInstance ()i
return retobji
return null
④由于在 Tomcat中使用JND时基本上都借助URL模式,因此必须实现URL上下文工厂
类,一般的 scheme为jva,于是URL上下文工厂类就应该命名为 javaURLContextFactory
public class javaURLContextFactory implements objectEactory i
@Override
public Object getobjectInstance(Object obj, Name name, Context nameCtx,
Hashtable<?,?> environment)throws NamingException
return new SelectorContext((Hashtable<string, Object>)environment)i
⑤选择器上下文,主要用于选择不同线程、不同类加载器绑定的对应上下文,这样就可
以区分不同应用程序下的上下文,提供隔离机制。
public class SelectorContext implements Context t
public static final String prefix
Java:
protected Hashtable<string, Object> envi
public SelectorContext(Hashtable<string, Object> env)t
215“““
第15章 Tomcat的JND
this env envi
override
public Object lookup(Namename) throws NamingException
return getBoundContext(). lookup(parseName(name))i
@override
public void bind (Name name, Object obj) throws NamingException
getBoundcontext().bind(parseName(name), obj)
@override
public void rebind (Name name, Object obj) throws NamingException
getBoundContext(). rebind (parseName(name), obj)
@Override
public void unbind(Name name) throws NamingException
getBoundContext(). unbind (parseName(name))i
@Override
public Context createSubcontext(Name name) throws NamingException i
return getBoundContext(). createSubcontext(parseName(name))i
protected Context getBoundContext() throws NamingException i
if (ContextBindings isThreadBound())(
return ContextBindings. getThread ();
s else
return ContextBindings. getclassLoader()i
protected Name parseName(Namename) throws NamingException t
return name. getSuffix(1)i
⑥上下文绑定集类,用于维护不同线程、不同类加载器的对应上下文的绑定。
public class ContextBindings t
private static final Hashtable<object, Context> contextNameBindings
216153在 Tomcat中集成JND
new Hashtable<object, Context>()i
private static final Hashtable<Thread, Context> threadBindings
new Hashtable<Thread, context>oi
private static final Hashtable<classLoader, Context> clBindings
new Hashtable<classloader, Context>()i
public static void bindContext(object name, Context context) t
contextNameBindings. put(name, context)i
public static void unbindcontext(Object name)[
contextNameBindings. remove(name)i
static Context getContext(object name)
return contextNameBindings get(name)i
public static void bindThread(object name) throws NamingException
Context context contextNameBindings get(name )i
threadBindings. put(Thread currentThread(), context)i
public static void unbindThread (object name
threadBindings. remove(Thread currentThread())i
public static Context getThread() throws NamingException i
Context context threadBindings get (Thread currentThread())i
return context
public static boolean isThreadBound()i
return (threadBindings. containskey(Thread currentThread()))i
public static void bindclassLoader(Object name) throws NamingException
Context context contextNameBindings get(name)i
Classloaderclassloader Thread currentThread(
getContextclassLoader(
clBindings. put(classLoader, context)i
public static void unbindclassLoader(Object name) i
Classloader classloader Thread currentThread ()
217第15章 Tomcat的JND
getContextClassLoader()i
clBindings. remove(classloader)i
public static Context getClassLoader() throws NamingException i
ClassLoader cl= Thread currentThread(). getContextclassLoader();
Context context null;
do i
context clBindings get(cl)i
if (context ! null)(
return context
y while ((cl cl getParent())!= null);
public static boolean isClassLoaderBound((
ClassLoader cl= Thread currentThread(). getContextclassLoader(
do i
f (clBindings. containsKey(cl))i
return truei
s while ((cl= cl getParent())!= null)i
return false;
上面便是 Tomcat中提供命名服务的基本实现过程。结合图15.8能更形象地说明 Tomcat
的JNDI实现,由于Web应用需要保证以 InitialContext作为入口,而且为了使用简单,因此都
会以URL方式查找命名上下文。另外,因为不同Web应用有自己的命名上下文,而且 Tomcat
还包含一个全局命名上下文,所以引入了 Selector Context上下文用于根据运行时当前线程或类
加载器来获取相应的命名上下文。这个工作就交给了 ContextBindings,不同的Web应用在使
用小ND时会路由到相应的命名资源上。
为了使 Tomcat的命名上下文互相隔离,需要绑定环节和査找环节。
对于绑定环节,如图15.9所示, Tomcat在初始化时将需要绑定的对象转换为
Resource Ref对象,然后绑定到 Naming Context中。当然,一个 Naming Context里面可能又
有若干个 Naming Context,以树状组织。全部组织完后,再用 ContextBindings进行绑定
这一步比较巧妙,它提供了命名上下文的三种绑定机制:直接绑定、与线程绑定、与类加
载器绑定。不同绑定机制有不同的用途,例如Web应用局部命名资源就是靠类加载器绑定
机制进行分隔的。
对于查找环节,如图15.10所示,程序查找命名资源前先实例化一个 InitialContext实例,
通过URL模式查找。假如用Java作为 scheme,则定位到 javaURLContextFactory工厂类,返
218153在 Tomcat中集成JND
回一个 SelectorContext对象,并且这个 Selector Context封装了对 ContextBindings的操作。而
ContextBindings则封装了 Naming Context与线程、类加载器等的绑定机制。最终找到URL指
定的 ResourceRef对象,并由此对象指定 Resourcefactory工厂类,此工厂类将生成Java对象
供程序使用。
InitialContext
Selector Context
局部命名资源
局部命名资源
全局部命名资源
根上
根上
根上
comp
comp
db
e
or
env
env
☆
☆☆☆☆
gl
☆☆
b
resource
resourc
resource3
resource
▲图158 Tomcat的JND|实现
绑定
初始化
Naming Context
①bind
ResourceRef
② bind Context
或
bind Thread
或
bindClassLoaderContextBindings
▲图15.9 Tomcat的绑定机制
219第15章 Tomcat的JND
查找
lookup(jave: comp/env/myqsl")
getobjectInstance
InitialContext
x javaURLContext Factory
Selector Context
getObjectInstance
get Bound Context
getConte
或
getFactory Class Name
ResourceRef/ lookup Naming fai
get Thread
ResourceFactory
ContextBindings
g
▲图15.10omat中的ND|查找
对于 Tomcat来说,我们把上面实现的JND放进 Tomcat中就可以运作了,在 Tomcat初始化
期间,要完成JNDⅠ所有必要的工作,组成一个树形结构的对象供Web程序开发使用。那么,整
个 Tomcat集成ND的过程可以用图1511表述。在 Tomcat初始化时,通过 Digester框架将
server xml的描述映射到对象,在 StandardServer或 StandardContext中创建两个对象。其中,一个
是 Namingresources,它包含不同类别的命名对象属性,例如我们常见的数据源用 ContextResources
保存命名对象属性,除此之外,还有 ContextEjb命名对象属性、 ContextEnvironment 1命名对象属性
ContextService命名对象属性等。另外一个是创建一个 Naming ContextListener,此监听器将在初始
化时利用 ContextResources里面的属性创建命名上下文,并且组织成树状。完成以上操作后,我
们也就全部完成了 Tomcat的JND集成工作。
InitialContext
Catalina
创建命名上下
Server
监听到Tmt初始化文,绑定资源
Naming ContextListerner
Q
Naming Context
Naming resources
☆9Q
ContextResources
☆价☆
ContextEnvironment
ContextLocalEib
MessageDestinationRef
ContextResource EnvRef
ContextResourceLink
ContextService
JNDI框架
运行机制
利用 Digester刨建
NamingResqurces实例
<Server>
<GlobalNaming Resources>
<Resources
server xml
<GlobalNaming Resources>
▲图15.11在 Tomcat中集成JND
220153在 Tomcat中集成JND
Tomcat中包含了全局与局部两种不同范围的命名资源。全局命名资源也就是上面所提到的,
Tomcat启动时将 server xml配置文件里面的 GlobalNamingResources节点通过 Digester框架映射到
个 Naming Resources对象,当然,这个对象里面包含了不同类型的资源对象,同时会创建一个
Naming ContextListener监听器。这个监听器负责的重要事情是在 Tomcat初始化期间触发一些响应
的事件,接收到事件后,将完成对命名资源的所有创建、组织、绑定等工作,使之符合JD标
准。而创建、组织、绑定等是根据 Naming Resources对象描述的资源属性进行处理的,绑定的路
径由配置文件的 Resource节点的name属性决定,name即为JND对象树的分支节点。例如,如
果 name为“ jdbc/my DB”,那么此对象就可通过“ java: jdbc/myDB”访问,而树的位置应该是
jdbc/my DB,但在Web应用中是无法直接访问全局命名资源的,因为根据Web应用的类加载器无
法找到该全局命名上下文。由于这些资源是全局命名资源,因此它们都必须放在 Server作用域中。
对于局部命名资源,工作机制也是相似的,局部命名上下文与对应于Web应用的类加载
器绑定,以此实现不同Web应用之间的互相隔离。如图15.12所示,局部资源同样主要由
NamingResources与 Naming Contextlistener两个对象完成所需工作,作为JND对象树,
Naming Context实现了JND的各种标准接口与方法, NamingResources描述的对象资源都将绑
定到这个对象树上,基础分支为“comp/eny”。每个Web应用都会有一个自己的命名上下文
组织的过程中 Naming Context将与相应web应用的类加载器进行绑定。不同的web应用只能
调用自己的类加载器对应的JNDI对象树,互相隔离,互不影响。当Web应用使用JNDI时,
通过ND运行机制进入不同的命名上下文中查找命名对象。
Catalin
Server
InitialContext
Service
Engine
Host
Context
创建命名上下
Naming ContextListerner
监听到应用初始化」文,绑定资源
感
Naming Context
NamingResources
Context resources
Context
☆☆☆
Context Enyironment
JNDI框架
ContextLocalEjb
运行机制
Message DestinationRef
ContextResource Refl
创建命名上下
ContextResourceLink
文,绑定资源
ContextService
NamingContext
<Server>
利用 Digester创建
<Service>
Naming resources实例
<Engine>
<Host>
<Resource/>
server xml
</Context>
</Host
</Engine>
</Service>
图15.12局部资源第15章 Tomcat的JNDl
14在T0mat中使用IN
上面主要从运行原理的角度剖析了 Tomcat中的JND如何运转,这一节重点从使用的角
度上讲述在 Tomcat中使用ND的不同方式在 Tomcat中可以通过字符串标识获取某个资源,
而这个资源包括很多种,例如数据库数据源、JMS、BJB等。其中,全局命名资源无法从Web
应用中直接获取,但它可以通过资源连接间接获得;局部命名资源都是以Java作为 scheme绑
定在 comp/env下面,即以 java: comp/env作为前缀通过URL模式查找资源。例如,在使用数
据源时,我们会用类似如下的代码。
Context context new InitialContext(i
Datasource ds =(DataSource)context. lookup("java: comp/env/jdbc/myDB");
通过两行简单的代码就可以查找到一个数据源对象,里面包含了所有数据库连接对象,同
时也封装了对这些连接的维护,以充当连接池。由于使用的是URL模式,因此在构造
InitialContext时并不需要传入任何参数。
般来说,要使用JNDI需要完成以下三个步骤
①驱动器Jar包放置。
②配置文件的配置。
③在程序中调用
根据范围层次,可分两种配置方案。一种是Web应用层次上的局部配置方式,它只可在
自己的Web应用上使用。另外一种是全局层次上的全局配置方式,通过资源连接,它可以供
所有Web应用使用。
154.1Web应用的局部配置方式
在 Tomcat中以JNDI形式配置某web应用使用的数据源,需要进行如下步骤。
1)将数据源相应的驱动包复制到 Tomcat安装目录的子目录lb下面。
2)修改 Tomcat安装目录的子目录conf下面的 server xml配置文件。
<Server port=8005 shutdown="SHUTDOWN">
<Service name="Catalina>
<Engine name=Catalina" de faultHost-"localhost">
<Host name="localhost" appBase="webapps"unpackWARs="true"autoDeploy="true">
<Context path="wyzz"docBase=wyzz" debug=o"reloadable="true">
<Resource
name=jdbc/my DB
auth="Container
type=javax. sql DataSource"
driverclassName="com mysql jdbc Driver
url=jdbc: mysql: //localhost: 3306/wyzz
222154在 Tomcat中使用JND
username="root
password=123456"
maxActive="5
maxIdle=2
mawAi七="10000"/>
</Context>
</Host>
</Engine>
</Service>
</Server>
除了上面的配置方法之外,还有另外一种配置方式,在Web应用目录的子目录 META-INF
下的 context. xn1配置文件中进行如下配置。
<Context>
<Resource
name="jdbc/myDB
auth= Container
type
avax sql, DataSource
driverClassName="com mysql jdbcDriver
url=jdbc: mysql: //localhost: 3306/wyzz
username="root
password=123456
maxActive="5'T
maxIdle="2 r
maxWait=10000"/>
</Context>
3)在Web应用程序中通过JND获取数据源的主要代码如下。
Context ctx new InitialContexto)i
DataSource ds=(DataSource)ctx lookup("java: comp/env/jdbc/myDB")i
Connection con
ds. getConnection ()i
两种配置方式本质上是一样的,二者只是分别从服务器级别和应用级别提供了各自的配置
方式,最终达到的效果都是一样的。另外,为什么这样配置后生成的资源只能由相应的Web
应用访问?通过什么机制实现不同应用之间的隔离?因为每个Web应用都有自己的类加载
器,为了提供不同Web应用之间的资源隔离功能, Tomcat把这些命名资源与类加载器进行了
绑定。当我们在web应用中查找命名资源时,将会根据本身Web应用的类加载器获取对应的
命名上下文对象,然后进行査找,由此达到隔离资源的效果,也就是说,每个Web应用只能
访问自己对应的命名资源。
1542服务器的全局配置方式
在 Tomcat中以JND形式配置所有web应用都能使用的数据源,需要按照如下步骤操作
223第15章 Tomcat的JND
1)将相应的驱动包复制到 Tomcat安装目录的子目录lb下面。
2)修改 Tomcat安装目录的子目录 conf下面的 server. xm配置文件。这次 server xml文件将
有两个地方需要配置,一个是添加 GlobalNamingResources节点,另一个是添加 ResourceLink节点。
<Server port=8005" shutdown ="SHUTDOWN">
<GlobalNamingResources>
<Resource
name="jdbc/mysql
auth= Container
type=javax. sql DataSource"
driverclassName="com mysql jdbc Driver"
url="jdbc: mysql: //localhost: 3306/wyzz
usernamesroot
password=123456
maxActive=5
maxIdle=2n
maxWait=100007>
</GlobalNamingResources>
<Service name=Catalina>
<Engine name=Catalina! defaul tHost="localhost">
<Host name=localhost" appBase="webapps" unpackWARs="true
autoDeploy=true>
<Context path=wyzz docBase=wyzz debug="0 reloadable="true">
<ResourceLink globalname=jdbc/mysql"name="myDB
type= javax. sql DataSource"/>
</Context>
</Host>
</Engine>
</Service>
</Server>
以上的配置很好理解,声明一个全局命名资源,并且在某个Web应用中使用资源连接对
全局命名资源进行引用。当然,还可以通过另外一种方式声明对全局命名资源的引用,即在
Web应用目录的子目录META-INF下的 context.xm中配置,代码如下所示。
<Context>
<ResourceLink globalname="jdbc/mysql" name="myDB
type=" javax. sql DataSource"/>
Context>
3)在Web应用程序中通过JND获取数据源的主要代码如下所示。
Context ctx= new InitialContext(i
DataSource ds =(DataSource)ctx lookup("java: comp/env/myDB")i
Connection con
ds. getConnection ()i
224154在 Tomcat中使用JNDl
通过配置文件可以清晰看出映射关系,它们之间的关系如图15.13所示。映射关系可能为
server xml( ResourceLink)→ server xml(( GlobalNaming resources);也有可能是 context. xml( ResourceLink)
→ server xml( GlobalNaming Resources)这里把 ResourceLink作为资源连接引用,当新部署一个Web
应用时,可直接通过添加资源连接引用得到全局的命名资源。
server xml
server xml
<Resource Link
<GlobalNamingResource
globalname="jdbc/mysql
name=“myDB”
Resource name="jdbc/mysql
type="javax. sql DataSource
auth=“ Container
</GlobaINaming Resources>
或者
context. xml
server xml
<Resource Link
<GlobaINamingResources>
lobalname"jdbc/mysql
Resource name="jdbc/mysql
name=“myDB”
auth=“ Container”.
type“ Javax. sql Data Source”
</GlobalNaming Resources>
▲图15.13映射关系
ResourceLink的工作原理其实很简单。如图15.14所示,因为对于 Tomcat来说,它可能
有若干个命名上下文对象,在各自的命名上下文对象中只能找到自己拥有的资源,所以如果在
Web应用中查找全局资源,就必须通过 ResourceLink。它通过一个工厂类 ResourcelinkFactory
会到全局命名资源上下文对象中查找关联的资源,返回相应的资源供Web应用使用。
局部命名资源
全局命名资源
根上
comp
dbe
el
org
☆
name
myeib
Resoucelink
ResouceLink
ResourceL ink Factory
▲图15.14 Resourcel ink的工作原理
225第15章 Tomcat的JND
通过局部配置和全局配置两种方式,都可以很方便地在 Tomcat中使用各种资源,以不同
方式配置文件稍微不同。对于 Tomcat内部来说,全局命名资源和局部命名资源有各自的命名
上下文,全局命名资源对Web应用是不可见的,只能通过 ResourceLink从全局命名资源中查
找对应的资源。局部部署只能由对应的Web应用使用,而全局部署可供所有Web应用使用,
两种方式各有各的特点,从而满足不同的使用场景。
155 Tomcat的标准资源
上面介绍在 Tomcat中使用JND时以数据源作为例子,但 Tomcat标准资源不仅有数
据源,还包含很多其他资源。不同的资源都有属于自己的资源工厂类,这些工厂类负责提
供服务资源的创建,而且 Tomcat提供了对这些资源的灵活配置。 Tomcat标准资源包括了
以下几类。
普通 Javabean资源,它主要用于创建某个Java类对象供Web应用使用。例如,如果要将
某个类提供的功能作为命名服务,则可以将此Java类配置成普通 JavaBean资源。
UserDatabase资源,它一般会配置成一个全局资源,作为具有认证功能的数据源使用,
般该数据源通过XML( conf/tomcat- users . xml)文件存储
JavaMail会话资源,很多Web应用都需要发送 Email,为方便Web应用,可以使用 JavaMail
接口, Tomcat提供了 JavaMail服务,让使用更加方便、简单。
JDBC数据源资源,基本上大多数Web应用都需要与数据库交互,而Java都是通过JDBC
驱动操作数据库,为方便Web应用,可以使用JDBC,并且提供一个数据库连接池,所以
提供了JDBC数据源资源。默认的JDBC数据源基于DBCP连接池。
以上便是 Tomcat自带的标准资源,在 Tomcat中配置资源都通过< Resource>节点配置,可
以配置全局资源,也可以配置局部资源。如果存在 Tomcat标准资源满足不了的场景,则可自
定义资源并在 Tomcat中配置
226第16章JSP编译器 Jasper
Jasper模块是 Tomcat的JSP核心引擎,我们知道JSsP本质上是 Servlet,那么从一个JSP
文件编写完成后到真正在 Tomcat中运行,它将经历从JsP转变成 Servlet、再由 Servlet转变成
Clas的过程。在 Tomcat中正是使用 Jasper对JsP语法进行解析、生成 Servlet并生成 Class
字节码。另外,在运行时, Jasper还会检测JSP文件是否修改,如果修改,则会重新编译JSP
文件。本章就讨论 Jasper引擎的内部原理及实现。JSP从语法上可以分为标准JSP和基于XML
的JSP,但其实现思路基本相同,只是规定了不同的语法,本质上都是对规定的语法进行解析
编译。所以本章只选择标准JsP进行深入探究。
标准的JSP大家都很熟悉,从开始学Java接触到的就是它。可以说,JSP是 Servlet的扩
展,它主要是为了解耦动静态内容,解决动态内容和静态内容一起混合在 Servlet中的问题。
但JSP本质上也是一个 Servlet,只不过它定义了一些语法糖让开发人员可以在HTML中进行
动态处理,而 Servlet其实是一个Java类,所以这里面其实就涉及一个从JSP编译为Java类的
过程。对于Java类来说,真正运行在JVM上的又是 Class字节码,所以这里还涉及另外一个
从Java到 Class字节码的编译过程。编译的具体实现由不同厂家实现,这里讨论 Tomcat如何
编译标准的JSP。
在探讨如何编译JSP之前我们应该先看看标准的JSP语法,只有在了解JSP语法之后才能
根据其语法进行编译。下面列举一些常见的语法,但并不包含所有语法,旨在说明一个大致的
编码过程。
对于代码脚本,格式为<%Java代码片段%>。
对于变量声明,格式为<%!inti=0;%>。
对于表达式,格式为<%=表达式%>。
对于注释,格式为<%-JSP注释-%>。
对于指令,格式为<%@page.%、<%@ Include.%<% @taglib.%。
>对于动作,格式为 jsp: include/>、jsp: use bean>、jsp: setProperty>、jsp: getProperty/>、
sp: forward、jsp; plugin、<jsp: telement/>、<jsp: attribute>、jsp:body/、jsp:text>。
对于内置对象,脚本中内置了 request、 response、out、 session、 application、 config、 page Context、
page、 Exception等对象第16章JSP编译器 Jasper
161从JsP到 Servlet
首先分析第一阶段:JSP到 Servlet的过程。
16.1.1语法树的生成——语法解析
般来说,语句按一定规则进行推导后会形成一个语法树。这种树状结构有利于对语句结
构层次的描述,它是对代码语句进行语法分析后得到的产物,编译器利用它可以方便地进行编译。
同样, Jasper对JsP语法解析后也会生成一棵树,这棵树中的各个节点包含了不同的信息,但对
于JSP来说,解析后的语法树比较简单,它只有一个父节点和N个子节点。如图16.1所示, nodel
表示形如<%-字符串->的注释节点,节点里面包含了一个表示注释字符串的属性;而node2则
可能表示形如<%=a+b%>的表达式节点,节点里面包含一个表示表达式的属性。同样地,其他节
点可能表示JSP的其他语法。有了这棵树,我们就可以很方便地生成对应的 Servlet
ot
del
node
node3
▲图16.1语法树
那么具体是怎样解析生成这棵树的呢?下面给出简单的代码实现。
①首先定义树数据结构,其中, parent指向父节点, nodes是此节点的子节点,且 nodes
应该是有序的列表,这样能保证与解析顺序一致。另外,由于每个节点的属性不同,Node类
只提供公共的部分属性,对于不同节点,其他属性需要继承Node额外的实现
public class Node
private Node parenti
private List<Node> nodes
private string texti
private Attributes attrsi
public class RootNode( K
public class CommentNode()
public class PageNodef
public class IncludeNode i
public class TaglibNode(
228161从JSP到 Servlet
②其次需要一个读取JSP文件的工具类,此工具类主要提供对JSP文件的字符操作。其
中,有个 cursor变量用于表示目前解析位置,主要的方法则包括判断是否到达文件末尾的
hasMorelnput方法,获取下一个字符的 nextchar方法,获取某个范围内字符组成的字符串的
getText方法,匹配是否包含某字符串的 matches方法,跳过空格符的 skipSpaces方法,以及跳
转到某个字符串的 skipUntil方法。有了这些辅助操作,就可以开始读取解析语法了
public class SprEader t
private int cursor
public int getcursor()i return cursor i j
boolean hasMoreInput()t.)
public int next char()I.)
public String getText(int start, int end)i
boolean matches(String string)f. h
int skipSpaces()I.)
int skipUntil(String limit)t..
③需要一个JSP语法解析器对JSP进行解析。为了简单说明,这里只解析<%-…->注
释语法、<@ apage…%>页面指令、<%@ Include%>包含指令、<%@ Taglib.%6>标签指令。假
设这里对 index. jsp进行语法解析。如果匹配到<%-,则表示注释语法,获取其中的注释文字
并创建 commentNode节点作为根节点的子节点。如果匹配到<%@,则有三种可能,所以需要
进一步解析,即对于页面指令、包含指令和标签指令的解析。最后解析出来的就是一棵语法树。
public class Parser t
public rootNode parse()t
JspReader reader new SprEader("index.jsp")
RootNode root new Rootnode oi
while (reader. hasMoreInput ()
if (reader. matches (<--))
int start reader. getcursor ()i
reader. skipUntil("-->)i
int end= reader. getcursor()i
CommentNodecommentNode new CommentNode ()i
commentNode. setText(reader. getText(start, stop))i
commentNode. setParent (parent)i
parent getList().add(commentNode)i
y else if (reader. matches(<%@))i
if (reader. matches("page))t
解析<@page../>里面的属性生成 attrs
PageNode pageNode new PageNode ()i
pageNode. setAttributes(attrs)i
pageNode. setParent (parent)i
parent getList(). add(pageNode)i
y else if(reader. matches(include)) t
229第16章JSP编译器 Jasper
解析<号@ include.../号>里面的属性生成 attrs
IncludeNodeincludeNode new IncludeNode (i
includeNode. setAttributes(attrs)i
includeNode. setParent (parent)i
parent getlist(). add(includeNode)i
else if (reader. matches(taglib"))(
解析<tag1ib.../%>里面的属性生成 attrs
TaglibNode taglibNode new TaglibNode ()i
taglibNode. setAttributes(attrs)i
taglibNode. setParent(parent)i
parent getList(). add(taglibNode)i
return rooti
16.1.2语法树的遍历——访问者模式
语法树可以理解成一种数据结构,假如某些语句已经被解析成一棵语法树,那么接下来就
是要对此语法树进行处理,但考虑到为了不把处理操作与数据结构混合在一块,我们需要一种
方法将其分离。对于语法树,最典型的处理模式就是访问者模式。它能很好地将数据结构与处
理分离,提供很好的解耦作用,让我们可以在生成语法树的过程中只须关注如何构建相关的数
据结构,而在对语法树处理时只须关注处理的逻辑,这是一种非常巧的设计模式。接下来,通
过一个简单的示例代码看看如何实现一个访问者模式。具体操作如下所示。
①定义访问者操作方法接口,声明所有访问者的操作方法。
public interface Visitor(
public void visit(rootNode rootNode
public void visit(CommentNode commentNode)i
public void visit(PageNode pageNode)i
public void visit(IncludeNode includeNode)i
public void visit(TaglibNode taglibNode)i
②定义接口提供访问入口,语法树的每个节点都必须要实现此方法。
public interface NodeElement i
public void accept(Visitor v)i
③不同类型的Node实现 Nodeelement接口,稍微修改原来定义的Node类,包括
RootNode、 CommentNode、 PageNode、 IncludeNode、Tag! libNode,为它们都添加 accept方法。
230161从JSP到 Servlet
public class RootNode implements NodeElement i
public void accept(Visitor v)i
visit(this)i
public class CommentNode implements NodeElement
public void accept(Visitor v)(
v visit(this)i
④现在假设这里要按顺序将语法树中的注释获取出来,那么只需要实现一个获取注释的
Ⅴitor,对于不同的处理逻辑,只须实现不同的Ⅴ Visitor即可。这里,由于对其他类型的节点不
进行处理,因此其他节点的Ⅴsit方法留空即可
public class CommentVisitor implements Visitor t
public List<string> getComments(rootNode)i
List<string> comments= new Arraylist()
List<Node> nodes rootNode. getNodes()i
Iterator<Node> iter nodes iterator (
while (iter hasNext())
Node n iter. nextoi
naccept(this)i
return comments
public void visit(rootNode rootNode)(
ublic void visit(CommentNode commentNode)i
comments. add( commentNode getText())i
public void visit(PageNode pageNode)i)
public void visit(IncludeNode includeNode)iI
public void visit(TaglibNode taglibNode)(
⑤测试类。
public class Testi
public static void main(String[] args)
RootNode root Parser parse ()i
Commentvisitor cv= new Commentvisitoroi
List<string> comments = cv. getcomments();
231第16章JSP编译器 Jasper
通过上面一个简单的例子,可以看出,访问者模式将数据结构和处理逻辑很好地解耦出来
了。这种模式经常用在语法树的解析处理上,熟悉此模式有助于对编译过程的理解,JSP对语
法的解析也是如此。
16.1.3JSP编译后的 Servlet
JSP编译后的 Servlet类会是怎样的呢?它们之间有着什么样的映射关系?在探讨JSP与
Servlet之间的关系时,先看一个简单的 Hello World. jsp编译成 Hello world jsp java后会是什么样。
Hello World. jsp文件如下所示。
<o@ page contentType="text/html; charset=gb2312" language="java">
< DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<TITLE>HelloWorld</TITLE>
</HEAD>
<BODY>
<8
out println("HelloWorld")
8>
</BODY>
<HTML>
Hello world_jsp java文件如下所示
package org. apache.jsp;
import javax. servlet. *i
importjavax.servlet.http.*i
import javax. servlet jsp.*i
public final class Helloworld_jsp extends org apache jasper runtime Httpjspbase
Implements org. apache. jasper. runtime. JspSourceDependent i
private static final javax. servlet jsp. UspFactory _jspxFactory
Javax. servlet jsp. JspFactory. getDefaultFactory()i
private static javautil. Map<java.lang String, java. lang Long>_jspx_dependants;
public javautil. Map<java. lang String, java. lang Long>
getDependants()(
return_jspx_ dependants
public void_ jspInit()
232161从JSP到 Servlet
public void _jspDestroy()t
publicvoid_jspservice(finaljavax.servlet.http.HttpservletrequeStrequest
finaljavax.servlet.http.HttpservletrespoNseresponse
throws java. io IOException, javax. servlet ServletException i
final javax. servlet jsp PageContext page Context
javax.servlet.http.Httpsessionsession=nulli
final javax. servlet ServletContext application;
final javax. servlet ServletConfig config
javax. servlet jsp. JspWriter out nulli
final java. lang Object page= this;
javax. servlet jsp. JspWriter _jspx_out = nulli
javax. servlet jsp Page Context_jspx_page_context nulli
try i
response. setContentType("text/html; charset=gb2312")i
pageContext =_jspxFactory getPageContext(this, request, response,
null, true, 8192, true)i
Jspx page_context
page Context
application= page Context. getservletcontext ()i
config pageContext getservletConfig()i
session= pageContext getsession()i
out= pageContext getout ()
Jspx_out
outi
out write("\r\n")i
out write("<! DOCTYPE HTMI PUBLIC \"-//W3C//DTD HIMI 4.0 TransitionalEN\">\r\n")i
out write("<hTMl>\r\n")i
out. write
<HEAD>\r\n")i
out. write
<TITLE>HelloWorld</TITLE>\r\n")
out. write
</HEAD>\r\n")i
out write("<BODY>\r\n")
out println("HelloWorld")i
out write(" \r\n")i
out write("</BoDY>\r\n")i
out write("</HTML>\r\n")i
y catch (java. lang Throwable t) f
if (!(t instanceof javax. servlet jsp. SkipPageException))t
out
Jspx_outi
if (out null & out getBuffersize()!=0)
try out. clearBuffer()i) catch (java. ioIOException e)i)
if (jspx_page_context null)-_jspx_page_context. handlePageException(t)i
else throw new ServletException(t)i
233第16章JSP编译器 Jasper
b finally
ospxFactory. releasePageContext(ispx_page context);
经过前面介绍的语法解析及使用访问者模式把 Hello world. jsp文件编译成相应的
Hello world jsp java文件,可以看到, Servlet类名由JSP文件名加jp拼成。下面看
Hello world jsp java文件的详细内容,类包名默认为 org. apache. jsp,默认有三个导入 Import
javax.servlet.importjavax.servlet.http*importjavax.servletjsp*
接下来是真正的类主体,JSP生成的Java类都必须继承 org. apache. jasper. runtime
Httpjsp basE。这个类的结构图如图16.2所示,它继承 Httpservlet是为了将 Http Servlet的所有
功能都继承下来。另外,又实现 Http jsppage接口,定义了一个JSP类的 Servlet的核心处理方
法 jsp Service。除此之外,还有 jspInit和 jspDestroy,它们用于在JsP初始化和销毁时执行。
这些方法其实都由 Servlet的 service、init、 destroy方法间接调用,所以JsP生成 Servlet主要
就是实现这三个方法。
<Interface>
Http jspbasE
<Interface>
Servlet
Servletconfig
Generic Servlet
Http servlet
Interface
Http jspl
jspservice
▲图16.2 JSP Servlet类图
除了继承 Httpjspbase外,还须实现 org. apache. jasper. runtime. Jsp Dependent接口。这
个接口只有一个返回 Map<String,Long类型的 getDependantsO方法,Map的键值分别为资源名
和最后修改时间。这个实现主要是为了记录某些依赖资源是否过时,依赖资源可能是Page指
令导入的,也可能是标签文件引用等。在生成 Servlet时,如果JsP页面中存在上述依赖,则
会在 Servlet类中添加一个 Static块,Stic块会把资源及最后修改时间添加到Map中。
在JSP类型的 Servlet处理过程中会依赖很多资源。比如,如果要操作会话,就需要此次
访问的 Http session对象,如果要操作 Context容器级别的对象,就要 Servletcontext对象,如
果要获取 Servlet配置信息,就要 ServletConfig对象。最后,还需要一个输出对象用于在处理
过程中将内容输出。这些对象都在核心方法 jspService中使用,作为 Servlet类,要获取这些
对象其实非常简单,因为这些对象本身就属于 Servlet属性,它们有相关方法可供直接获取。
但这里因为JSP有自己的标准,所以必须按照它的标准去实现。
234162从 Servlet到Cass字节码
具体的JSP标准是怎样的?首先,为了方便JSP的实现,提供一个统一的工厂类 JspFactory
用于获取不同的资源。其次,由于按照标准规定不能直接使用 Servlet上下文,因此需要定义
个 Page Context类封装 Servlet上下文。最后,同样按照标准需要定义一个输出类 Jsp Writer
封装 Servlet的输出。所以可以看到, Page Context对象通过 JspFactory获取,其他 Servletcontext
对象、 ServletConfig对象、 Httpsession对象及 Jsp writer则通过 Page Context对象获取。通过这
些对象,再加上前面的语法解析得到的语法树对象,再利用访问者模式对语法树遍历就可以生
成核心处理方法 jsp Service了。
上面只介绍了最简单的一个JSP页面转变成 Servlet的过程,旨在说明从JSP到 Servlet转
化的原理,实际上需要处理很多JSP指令标签。
162从$ret到Cas字节码
那么现在已经有了 Servlet对应的Java源码了,接下来就是下一阶段,把Java编译成 Class
字节码。
16.2.1JSR45标准
我们知道Java虚拟机只认识 Class文件,要在虚拟机上运行,就必须要遵守 Class文件的
格式,所以把JSP编译成 Servlet后还需要进一步编译成 Class文件,但从JSP文件到Java文
件再到Cass文件的过程需要考虑的事情比较多。其中一个比较重要的就是调试问题,由于语
法不一样,JSP中的代码在执行时需要通过某种机制与Java文件对应起来,这样在JVM执行
过程发生异常或错误才能找到JSP对应的行,提供一个友好的调试信息。类似地,JSP文件名
编译后的Java文件名同样也要有映射关系。
为了解决从非Java语言到Java语言调试时文件名及行号映射的问题, Java Community
Process组织提出了JSR-45( Debugging Support for Other Languages)规范,它为非Java语言提供
了一个进行调试的标准机制。这里的JSP其实就属于非Java语言,JSP如果想要方便开发者开
发,它就必须要遵循JsR-45规范。其实,简单地说,就是为了解决JSP编译后的Java文件与
JSP文件的对应关系,而且提供一个统一的标准,从而避免不同厂商有不同的实现方式。
JSR-45规范的核心对象是资源映射表( Source Map),简称SMAP。在这里它是指JSP文
件文件名及行号的映射表,把这个映射表存放到 Class文件中,在基于JPDA的调试工具中就
可以通过此映射表获取到对应JSP文件及行号,向开发者提示对应JSP文件的信息。
以前面的 Hello World. jsp为例,看看SMAP映射表是如何映射的, Hello World. jsp文件经
过编译后变成 Hello World jsp java文件,根据JR45的规范,最终我们会生成一份如下的映
射表。这里不打算探究SMAP的整个语法,只专注行号映射相关的部分,即从*到*中间的
内容。其中1,10:62表示 Hello World. jsp文件与 Hello World jsp java的映射关系为1-62,263,
3-64,…,10-71。同样地,10,3:72表示的对应关系为10-72,11-73,12-74。有了这些映射表,
235第16章JSP编译器 Jasper
就可以方便地将Java执行的代码的行号与JSP的行号对应起来了。
SMAP
HelloWorld_jsp java
USP
*S USP
大F
+0 HelloWorld. jsp
HelloWorld. jsp
L
1,10:62
10,3:72
E
讨论完SMAP,我们已经知道生成的SMAP的格式,那么要如何保存它呢?保存到哪里?因
为JM只会通过Cass文件加载相关信息,所以唯一的办法是通过 Class件附带SMAP消息,
Clas文件格式中可以附带信息的就只有属性表集合, Class文件格式的其他数据项都有严格的长
度、顺序和格式,而属性列表集合则没有严格要求,只要属性名不与已有属性冲突即可。任何人
都可以向 Class文件的属性列表中写入自定义的属性,虚拟机会自动忽略不认识的属性,所以我们
需要在支持调试信息的M中附带此属性。这里的属性名称就是 Source Debug Extension属性。这
个属性的结构如下,前面两个字节表示名称的索引值,接下来的4个字节表示属性长度,最后
个数组表示属性值。按照格式写入 Class x件JVM即可识别。
SourceDebugExtension attribute
u2 attribute name index
u4 attribute _ length
ul debug_extension [attribute_length]i
通过JsR45标准解决了JSP到Java之间的映射关系问题,从而让调试更加方便。在Java
领域中,为了达到统一而又不失灵活,基本上都是由 Java Community Process制定规范然后由
厂商按照规范进行实现。
16.22 UDT Compiler编译器
通过JSP编译器编译后,生成了对应的Java文件。接下来,要把Java文件编译成 Class
文件。对于这部分,完全没有必要重新造轮子,常见的优秀编译工具有 Eclipse JDT Java编译
器和Ant编译器。 Tomcat其实同时支持两个编译器,通过配置可以选择,而默认使用 Eclipse JDT
编译器。
通过调用这些现成编译器的API就可以方便地实现对Java文件的编译。由于两个编译器
的功能基本一样,因此就挑选默认编辑器来介绍它是如何进行编译的。下面仅看如何用 Eclipse
JDT编译器编译Java文件。
236162从 Servlet到 Class字节码
Eclipse JDT提供了 Compiler类用于编译,它的构造函数比较复杂,如下所示,其实,实
现自定义构造函数包含的参数即基本完成了编译工作。
public Compiler(
INameEnvironment environment,
IErrorHandlingPolicy policy,
Compileroptions options
final ICompilerRequestor requestor,
IProblemFactory problemFactory) i
为了方便说明,直接给出一个简单的编译实现,如下所示。
public class JDTCompile
private static final File WoRkDIR new File("D:\ \Program Files
\\tomcat\\work\\Catalina\\localhost\\test")i
public static void main(String[] args)
INameEnvironment name Environment new INameEnvironment()i
public NameEnvironmentAnswer findType(final char [][ compoundTypeName)
return findType(join(compoundTypeName))
public NameEnvironmentAnswer findType(final char[] typeName, final
char[][] packageName ) t
return findType(join(packageName)+". "+ new String(typeName));
private NameEnvironmentAnswer findrype(final String name)t
File file= new File(WORKDIR, name. replace(.', / )+ ".java)i
if (file.isFile())i
return new NameEnvironmentAnswer(new
CompilationUnit(file), null)i
try i
InputStream input =this getclass(). getclassLoader()
getResourceAsStream(name. replace(".",",")+" class")i
if (input null)I
byte[] bytes IOUtils. toByteArray (input)i
if (bytes null)(
ClassfileReader classFileReader new ClassFile
Reader(bytes, name. tocharArray(), true )i
return new NameEnvironmentAnswer(classFileReader
237第16章JSP编译器 Jasper
nu11);
y catch (ClassFormatException e)
throw new RuntimeException(e)i
y catch (IOException e)i
throw new RuntimeException(e)i
return null
public boolean isPackage(char[][] parentPackageName
char[] packageName) i
string name new String (packageName)i
if (parentPackageName ! null)i
name join(parentPackageName)+"."+name;
File target new File(WORKDIR, name. replace('',/'))
return target isFile()i
public void cleanup()[]
I CompilerRequestor compilerRequestor new ICompilerrequestor(
public void acceptResult(CompilationResult result)(
if (result. hasErrors())I
for (PRoblem problem result. getErrors())f
String className new String(problem
getOriginatingFileName().replace("/",
className className substring(0
className length()-5)i
string message problem getMessage()i
if (problem. getID(== IProblem CannotImportPackage)[
message problem getArguments()[0]+"cannot
be resolved"i
throw new RuntimeException(className + " " message)i
ClassFile[] clazzFiles result getclassFiles()
for (int 1 =0; i< clazzFiles length; i++)
String clazzName join(clazzFiles [i]. getCompoundName ())
238162从 Servlet到 Class字节码
File target = new File(WORKDIR, clazzName replace(
class")i
try i
FileUtils. writeByteArrayToFile(target,
clazzFiles[i]. getBytes())i
I catch (IOException e)
throw new RuntimeException(e)i
IProblemFactory problemFactory new DefaultProblemFactory
(Locale. ENGLISH)i
IErrorHandlingPolicy policy = DefaultErrorHandlingPolicies
exitonFirsterror(i
org. eclipse jdt internal compiler Compiler jdtCompiler
new org. eclipse jdt internal compiler Compiler(nameEnvironment,
policy, getCompileroptions()
compilerrequestor, problemFactory)i
jatcompiler
compile(new ICompilationUnit[] inew CompilationUnit(new File
(WORKDIR, "org\ \apache\\isp\\HelloWorld_jsp java))))i
public static CompilerOptions getCompileroptions ()(
Map settings= new HashMap()i
string
javaVersion=CompilerOptions VERSION_1_7;
settings. put (Compileroptions OPTION_ Source, javaVersion)i
settings. put(Compileroptions OPTION_ Compliance, javaversion)i
return new Compileroptions(settings)i
private static class CompilationUnit implements ICompilationUnit
private Filefile;
public CompilationUnit (File file)
this file file;
public char[] getContents()
try i
return Fileutils readFileTostring(file). tocharArray ()i
239第16章JSP编译器 Jasper
s catch (IOException e)(
throw new RuntimeException(e)i
public char[] getMainTypeName()
return file getName(). replace("java","). toCharArray()i
public char[][] getPackageName()[
String fullpkgName =this file. getParentFile(). getAbsolutePath(
).replace(WORKDIR. getAbsolutePath()r
fullPkgName= fullpkgName replace("","").replace("\\","")i
if (fullpkgName. startswith("."))
fullPkgName= fullpkgName substring(1)
String[] items fullpkgName split("[]")i
char[][] pkgName= new char [items. length][];
for (int i =0; i< items. length; i++)i
pkgName [i]=items [i]. toCharArray()i
return pkgNamei
public boolean ignoreOptionalProblems()
return false
public char[] getFileName()
return this file. getName(). toCharArray()i
private static string join(char[][] chars)(
StringBuilder sh=new stringBuilder(
for (char[] item chars)
if (sb. length()>0)
sb. append(".")i
sb. append(item)i
return sh tostring()i
为了有助于理解,我们根据构造函数的参数依次看看它们的作用
240162从 Servlet到 Class字节码
IName Environment接口,它需要实现的主要方法是 find Type和 paCkage。 FindType有助
于JDT找到相应的Java源文件或者Clas字节码,根据传进来的包名和类名去寻找。例如,
传入 java. lang String或org. apache. jsp. Hello World jsp,则分别要找到JDK自带的 String字
节码及 Tomcat中编译的 Hello world jsp java文件。接着,按要求封装这些对象,返回JT
规定的 Name Environmentanswer对象。而 isPackage则提供是否是包的判断。
IErrorHandling Policy接口,用于描述错误策略,可直接使用 Default Error Handling Policies,
exitOn FirstErroro,如果表示第一个错误,就退出编译。
Compileroptions对象,指定编译时的一些参数。例如,这里指定编译的Java版本为1.7。
I Compilerrequestor接口,它只有一个 acceptResult方法,这个方法用于处理编译后的结果。
如果包含了错误信息,则抛出异常,否则,把编译成功的字节码写到指定路径的 Hello world
jsp class文件中,即生成字节码
PRoblem Factory接口,主要用于控制编译错误信息的格式。
所有 Compiler构造函数需要的参数对象都已经准备好后,传入这些参数后创建一个
Compiler对象,然后调用 compile方法即可对指定的Java文件进行编译。这里完成了
Hello world jsp java的编译,结果生成了 Hello World jsp class字节码。实际上, Tomcat中基本
上也这样使用⑩DT实现 Servlet的编译,但它使用的某些策略可能不相同。例如,使用
Default ErrorHandling Policies. proceed With AllProblemso作为错误策略。
至此,我们已经清楚ˆ mcat对JsP编译处理的整个过程了。它首先根据JSP语法解析生
成类似XX3Java的 Servlet,然后再通过 Eclipse JDT对 XxxX Java编译,最后生成了JVM能识
别的 Class字节码。
16.2.3 Jasper自动检测机制
总的来说, Jasper的自动检测实现的机制比较简单,依靠某后台线程,不断检测JSP文件
与编译后的 Class文件的最后修改时间是否相同。若相同,则认为没有改动;倘若不同,则需
要重新编译。实际上,由于在 Tomcat部署的项目的JSP中可能引入了其他页面,或者引入了
其他Jar包,而且这些资源都可能是远程资源,因此实际处理会比较复杂,同样要遍历检测这
些引入的不同资源是否做了修改。
图16.3是一个形象的示意图。我们知道 Tomcat架构中有4个级别的容器: Engine容器、
Host容器、 Context容器和 Wrapper容器。而JSP编译对应于 Wrapper级别,所以需要通过
Standard Wrapper不断执行任务去调用 Jasper,而 Jasper则不断检验本地和远程的各种资源,
旦发现需要重新编译,则进行重编译。下面讨论具体如何实现。
首先,需要一个后台执行线程。 Tomcat中有专门的一条线程负责处理不同容器的后台任
务。要在不同的容器中执行某些后台任务,只须重写 backgroundProcess方法即可实现。由于
JspServlet对应于 Wrapper级别,因此要在 Standard Wrapper中重写 backgroundProces,它会调
用实现了 Periodic Eventlistener接口的 Servlet其中, Jspservlet就实现了 Periodic eventlistener
241.9000840008008408884488880940448449
第16章JSP编译器 Jasper
接口。此接口只有一个 periodicEvent方法,具体的检测逻辑在此方法中实现即可。
Standard Wrapper
本地
远程
JSP资源或其他的引入资源
JSP资源或其他的引入资源
▲图16.3 Jasper的自动检测
其次,判断重新编译的根据是什么?重新编译就是再次把JSP变成Java再变成 Class c。而触
发这个动作的条件就是,当我们修改了某个JSP文件后,或者某JSP文件引入的资源被修改后,
所以最好的判断依据就是某JSP或资源的最后修改时间— Lastmodified属性。正常顺序是JSP
经过编译后生成 Class文件,把此 Class文件的 Lastmodified属性设置成JSP文件的 Lastmodified,
此时两个文件的 LastModified属性值是相同的。当我们改了JSP文件保存后,JSP的 Lastmodified
属性就设置为当前时间。此时,通过判断两个文件的 LastModified属性值决定是否重新编译。重
新编译后,JSP与Cass文件的 Lastmodified属性再次设置为相同值。对于引入的资源,内存中维
护了上次编译时引入资源的 Lastmodified属性,不断获取引入资源的 Lastmodified属性并与内存
中对应的 Lastmodified属性进行比较,同样可以很容易判断是否需要重新编译。
最后,对于本地和远程资源分别如何检测?对于本地资源来说,使用 java. io. File类可以很
方便地实现对某JSP文件或其他文件的 Lastmodified属性读取。对于远程资源,比如Jar包,
为了方便处理Jar包含的属性,使用 Java.net:URL可以很方便操作。它包含了很多协议,例如
常见的Jar、Fil、Ftp等协议,使用它相当方便。
Urlincludeurl=newUrl("Gar:http://hostname/third.jar!/")i
URLConnection iuc includeUrl openConnection ()i
long includeLastModified =((JarURLConnection) iuc). getJarEntry(). getTime()i
如前所述,只需三步即可完成对远程Jar包的读取且取出最后修改时间。当然,URL还支
持本地文件资源的读取,所以它是很好的资源读取抽象对象, Tomcat中对引入资源的管理都
使用URL作为操作对象。
本节探讨了 Jasper自动检测机制的实现,自动检测机制给我们的开发带来了很好的体验,我们
不必自己修改了JSP后自己去执行编译操作,而是由 Tomcat通过 Jasper帮我们定时检测编译操作。
242第17章运行、通信及访问的安全管理
11运行安全管理
安全是系统应用很重要的部分,不管系统的性能多好,一旦安全性有问题将会给我们带来极大
的威胁。而安全性恰恰是比较模糊、多层次的概念,它包括网络层面、虚拟机层面、程序应用层面
等,并且安全性很难在开发时全面考虑。应用程序需求在安全方面也很难做一个明确的描述,就像
我们在需求文档中很少看到有对安全性的具体描述,我们也没听到过一个开发人员因为开发系统的
安全性有问题而被解雇,我们都认为Java本身是安全的,开发出来的程序应用也是安全的。
本节将主要讲解 Tomcat中的安全策略、安全管理,揭示 Tomcat怎样从自身应用程序上保
证自己的安全性。
171.1Java安全管理器— security Manager
总的来说,Java安全应该包括两方面的内容:一方面是Java平台(即是Java运行环境)的安
全性;另一方面是Java语言开发的应用程序的安全性。由于我们不是Java本身语言的制定开发者,
因此第一个方面的安全性不需要我们考虑。其中第二方面的安全性是我们重点考虑的问题。一般
我们可以通过安全管理器机制来完善安全性,安全管理器是安全的实施者,可对安全管理器进行
扩展,它提供了施加在应用程序上的安全措施,通过配置安全策略文件,达到对网络、本地文件
和程序其他部分的访问加以限制的效果
Java从应用层给我们提供了安全管理机制——安全管理器。每个Java应用都可以拥有自
己的安全管理器,它会在运行阶段检査需要保护的资源的访问权限及其他规定的操作权限,防
止系统受恶意操作攻击,以达到系统的安全策略。图17.1展示了安全管理器的工作机制。当
运行Java程序时,安全管理器会根据 Policy文件所描述的策略给程序不同模块分配权限。假
设把应用程序分成了三块,每块都有不同的权限,第一块有读取某文件的权限,第二块同时拥
有读取某文件与内存的权限,第三块有监听套接字的权限。通过这个机制就能很好地控制程序
各个部分的各种操作权限,从应用层上为我们提供了安全管理策略。
而图17.2则展示了安全管理器对文件操作进行管理的工作过程。当应用程序要读取本地
文件时, Security Manager就会在读取前进行拦截,判断它是否有读取此文件的权限,如果有第17章运行、通信及访问的安全管理
则顺利读取,否则,将抛出访问异常。 Security Manager类中提供了很多检查权限的方法,例
如, checkPermission方法会根据安全策略文件描述的权限判断是否有操作权限,而 checkRead
方法则用于判断对文件是否有访问权限。一旦发现没有权限,就会抛出安全异常
APP
分配权限[poly
文件
安全管理器
VM
判断是否有权限
文件内存套接字
读文件操作
没有权限则抛异常
▲图17.1安全管理机制
▲图17.2检查操作权限
一般而言,Java程序启动时并不会自动启动安全管理器。可以通过以下两种方法启动安全
管理器。
隐式方式。启动默认的安全管理器最简单的方法就是:直接在启动命令中添加 Djava
security. manager参数即可。
>显式方式。实例化一个 java. lang Security Manager或继承它的子类的对象,然后通过 System
setSecurity Manager(O来设置并启动一个安全管理器。
在启动安全管理器时,可以通过 Djavasecurity policy选项来指定安全策略文件。如果没
有指定策略文件的路径,那么安全管理器将使用默认的安全策略文件,它位于
% JAVA HOME%o/jre/ib/ security目录下面的 java policy中。 Policy文件包含了多个 Grant语句,
每一个 Grant语句描述某些代码拥有某些操作的权限。在启动安全管理器时会根据 Policy文件
生成一个 Policy对象,任何时候一个应用程序只能有一个 Policy对象。
那么如何才能实现自己的安全管理器并且配置权限呢?下面将通过一个简单的例子阐明
实现步骤,一般可以分为以下两步。
①创建一个 Security Manager子类,并根据需要重写一些方法。
⑨根据应用程序代码的权限需要配置策略文件。如果使用默认安全管理器则省略第①步。
下面用个例子说明安全管理器的使用
public class SecurityManagerTest
public static void main(String[] args) throws FileNotFoundException t
System. out. printin("SecurityManager: System getSecurityManager(
));
FileInputstream fis= new FileInputstream("c: \\protect. txt")
System. out. println (System. getProperty("file encoding"))i
分下面几种情况运行程序。
①假如不添加启动参数直接运行,则相当于没有启动安全管理器, Security Manager的输
24417.1运行安全管理
出为nul,且能正确读取 protect. txt件与 file encoding属性。
②添加启动参数 Djavasecurity manager- Djava security, policy=c: protect policy,两个参数
分别代表启动的默认安全管理器和指明的策略配置文件路径。此时 SecurityManager的输出不
为null,但由于此时 protect policy里面并没有做任何授权,因此在读取文件时就抛出
Access ControlException异常。
③在 protect policy文件中添加以下授权语句。
grant i
permission java. io FilePermission "c: /protect. txt","read"i
此时 SecurityManager不为空,并且有权限读取 protect. txt件,但最终它还是会抛一个
Access ControlException异常,因为并没有权限读取 file encoding系统属性。
④将 protect policy授权语句改为如下语句
grant
permission java. ioFilePermission "c:/protect. txt", "read"i
permission java util. PropertyPermission " file encoding",
rea
d
这次读取文件与读取系统属性的权限都有了,程序正常运行,不再抛出安全异常
通过上面几种情况我们已经清晰了解了安全管理器的使用,通过简单地配置策略文件,能
达到应用安全的管理。Java的 Permission类用来定义类所拥有的权限。Java本身包括了一些
Permission类,如表17.1所
表171Java中的 Permission类
类
说明
java security AllPermission
所有权限的集合
java util. Property Permission
系统/环境属性权限
java. lang Runtime Permission
运行时权限
java. net. SocketPermission
套接字权限
java. io FilePermission
文件权限,包括读、写、删除、执行
java. io. SerializablePermission
序列化权限
java. lang reflect. ReflectPermission
反射权限
java security UnresolvedPermission
未解析的权限
va.net. NetPermission
网络权限
java. awt. AWTPermission
AWT权限
java. sql. SQLPermission
数据库SQL权限
ava.security Security Permission
安全控制方面的权限
java util.logging Logging Permission
日志控制权限
javax. net. ssl. SSLPermission
安全连接权限
javax. security auth. Auth Permission
认证权限
javax. sound sampled. AudioPermission
音频系统资源的访问权限
245第17章运行、通信及访问的安全管理
17.1.2 Tomcat的系统安全管理
Tomcat是一个Web容器。我们开发的Web项目运行在 Tomcat平台上,这就好比将一个
应用嵌入到一个平台上面运行,要使嵌入的程序能正常运行,首先平台要能安全、正常运行。
同时,要尽量使平台不受嵌入式应用程序的影响,两者在一定程度上达到隔离的效果。 Tomcat
与Web项目也要尽量隔离,使 Tomcat平台足够安全。
我们先看看 Tomcat可能存在哪些安全威胁。
>在Web应用的JSP页面或 Servlet中使用 System. exit(1)
作为程序员的小明在离职前写了如下恶搞程序作为离别礼物。
SimpleDateFormat sdf new SimpleDateFormat("yyyy-MM-dd HH: mm: ss")i
Date date=sdf. parse("2020-01-0100:00:00");
Date now new Date()i
if(now. after(date))i
System. exit(1)i
在 Servlet中的这几行代码,平时运行时没有问题,但是它就像个定时炸弹,时间一到就
会让系统停止服务,并且还很难找出问题的所在。
在Web应用中调用 Tomcat内部的核心代码实现类,特别是静态类
Tomcat中有些代码可以给外部调用,而为了避免给 Tomcat带来威胁甚至是崩溃的危险,
需要控制外部程序访问有些核心代码
以上两种情况,都可能在 Tomcat运行时导致 Tomcat停止工作。针对这些情况,我们有必
要使用 Security Manager来防止服务器受类似木马的 Servlet、JSP和标签库等的影响,使服务
器多一层保护,能运行得更加安全、可靠。
Tomcat中有一般会使用到的权限有以下这些
java.uti. Property permission控制读/写Java虚拟器的属性,如java.home。
java. lang. RuntimePermission控制使用一些系统运行时( System/Runtime)的功能,
如ex0C和 execO。它也控制包的访问/定义
Java.1o. Filepermission—控制对文件和目录的读/写/执行操作。
java. net. SocketPermission—控制使用网路套接字连接
java. net. NetPermission-—控制使用多播网络连接
java. lang reflect. ReflectPermission-—控制使用反射来对类进行检视
java, security. Security Permission—控制对安全方法的访问。
java, security. AllPermission-给予所有访问权限。
亳无疑问,为了保证 Tomcat的安全性, Tomcat在启动时也开启了安全管理器,它采用的
是默认的安全管理器 Security Manager。在 Tomcat启动的批处理文件中能找到Dava
24617.1运行安全管理
securitymanager -Djava security policy==%CATALINA_BASE%\conf\catalina.policy, 1E Tomcat
并没有使用默认的策略文件,而是指定一个 catalina. policy作为策略文件。下面列出
Catalina. policy文件中有代表性的授权语句。
grant codeBase "file: $(java. home )/lib/-"t
permission java security AllPermission;
grant codeBase "file: s(catalina. home /bin/tomcat-juli jar
permission java. io FilePermission"s[catalina. base)sifile separator ) logs",
Read, write i
permission java. lang Runtime Permission "shutdownHooks"i
permission java util. PropertyPermission "catalina. base"," read"i
grant i
permission java. lang. RuntimePermission "accessClassInPackage. org. apache
tomcat i
上面有三个 Grant语句,第一个 Grant语句表示的意思比较简单,Java安裝路径下的ib
目录及其子目录下的Jar包拥有所有的权限。其中,符号*表示所有文件,-表示所有文件及其
子目录下的文件。第二个 grant语句对 Tomcat安装路径下bin目录中的 tomcat-juli jar包进行
授权,包括对 Tomcat安装目录下logs目录的读、写权限,关闭钩子的权限,以及对 catalina. base
系统变量的读取权限。第三个 Grant语句表示授权对 org. apache tomcat包里面类的访问权限。
与 access ClassInPackage权限类似的一个权限是 define ClassInPackage。由于默认情况下所
有包都可以被访问,因此如果要对一些包进行访问控制, Tomcat中可通过以下几个步骤使应
用具备这两种权限的安全检查。
首先,设置安全属性,告诉安全管理器哪些包需要进行访问权限检查,语法为 Security. setProperty
(" package definition"需要检查的包,多个包用逗号分隔")、 Security.setProperty( package.access,"需
要检查的包,多个包用逗号分隔")。
其次,配置策略文件 Policy,对指定类或包配置访问指定包的权限,例如:
grant codeBase "file: catalina. home /webapps/manager/-"(
permission java. lang Runtime Permission"accessClassInPackage org apache
tomcat i
上面指定$( atalina, home} webapps/manager/目录及其子目录下的文件都有访问 org. apache
tomcat包的权限,格式是" access ClassInPackage包路径"。
最后,如果你想检查此类是否有某个包的访问权限,可以显式地使用 System, getSecurity
Manager. check Package Access("包路径");否则,会在类加载器加载某个类时由 loadclas方法
触发权限检查。如果没权限,则抛出 Security Exception异常。
247第17章运行、通信及访问的安全管理
在 Tomcat启动时就完成了对 package definition与 package. access的安全属性设置,通过读
取 catalina, properties中的属性完成设置。
package. access=sun,org. apache. catalina. org apache. coyote, org. apache
tomcat, org. apache. jasper.
package definition=sun, java, org. apache. catalina, org. apache. coyote, org
apache tomcat, org. apache. jasper
Tomcat会对以上声明的这些包进行权限检查。另外, Tomcat在启动 Security Manager进行
安全管理时,有些类是必须要使用的类。为避免由安全管理器导致运行到一半抛
Access ControlException异常,在启动一开始就预先加载一些类,以此检查对某些类是否存在
读取权限。 Security ClassLoad类负责对一些类进行预加载
17.1.3安全管理器特权
安全管理器虽然给我们提供了很方便的权限管理,但某些情况下它可能不够灵活,例如某
些类的某些操作希望不受权限的约束,而是拥有特权。Java确实提供这么一种机制,使指定类
拥有执行特权,不受安全权限的检查。
Access Controller类中有个 doPrivileged静态方法,这里面的代码主体拥有操作的特权,它
可以对某资源进行访问,而不管是有权限的对象还是没有权限的对象调用它。在
Security Manager中对 Permission进行检查从栈的顶部开始,逐一向下,直到碰到 doPrivileged
的方法调用,或者到达栈底为止。如图173所示,假如调用链为 a class-→b, class-→c. class,b. class
中添加了 AccessController doPrivileged,那么需要检查的栈按从上往下的顺序,直到遇到
Access Controller. doPrivileged才停止检査。
往下
class
检查
需要检查的栈
b class
Access Controller, doPrivileged
a cl
图17.3安全检查栈
这种特权操作在 Tomcat中很多地方都可以看到。例如, ClassLoaderFactory中,这是一个
专门生产类加载器的工厂,在 create ClassLoader方法中利用如下方式返回,这样一来就不会检
查所有调用 ClassLoaderFactory中 create Classloader方法的其他实例的权限。
return AccessController doPrivileged(new PrivilegedAction<StandardclassLoad
er>(){
@Override
248172安全的通信
public Standardclassloader run()t
if (parent = null)
return new Standardclassloader (array)i
else
return new StandardclassLoader(array, parent
12安全的通信
我们知道HTTP协议加上SSL协议层就变成我们熟悉的Https,而在Java中为了让HTTP
协议与SSL协议融合,就需要用到JSSE。JSE即 Java Secure Socket Extension的缩写,它让
基于SSL协议的网络传输变得更加简单,开发者更加轻松地将SSL整合到程序中。本节将讨
论支撑 Tomcat实现 Https协议的SSL协议的具体实现原理。
17.2.1 SSL/TLS协议
SsL( Secure Socket Layer)是使用得最广泛的网络加密协议,它已广泛运用于Web浏览器和
服务器之间的身份认证以及传输数据加密。SSL利用数据加密技术保障在 Internet上数据的安
全传输,确保数据在网络上时传输不被截取窃听。同时,SSL是基于标准TCPP协议的安全
协议,是 Socket的安全版,它位于传输(TCPP)层和应用层协议之间。最普遍使用SSL协
议的是HTP协议,即 Https。
SSL协议包含两个子协议:SSL记录协议和SSL握手协议。其中,SSL记录协议用于规
定数据传输格式,而SSL握手协议用于服务器和客户端之间的身份互相认证,协商加密算法
MAC算法、SSL中发送数据的加密密钥。期间,客户端和服务器端需要交换大量的信息,以
此实现服务器与客户端之间的身份认证、密钥协商并建立加密的SSL连接。也就是说,SSL
协议主要有两个作用:一是建立一个信息安全通道,用来保证数据传输的安全;另一个是确认
网站的真实性。
由此看来,SSL层为我们提供了三方面的服务。
证书,认证客户端和服务器,确保数据发送到正确的客户端和服务器
≯加密,加密数据以防止数据中途被窃取。
γ签名,维护数据的完整性,确保数据在传输过程中不被篡改。
为了方便服务器和客户端之间加密、签名算法的选择,安全套接字层协议提供了众多加密、
签名算法,如此一来,就可以根据以往的算法、进出口限制等因素对算法进行选择,服务器和
客户端可以在建立协议会话之初协商确定。
在整个SSL握手通信的过程中,服务器的证书会发送到客户端,客户端会对此证书的合
法性及身份进行检查。客户端(一般是浏览器)在接收到证书后,浏览器会读取证书中的发布
249第17章运行、通信及访问的安全管理
机构,匹配浏览器内置的受信任的发布机构列表。如果找不到,则说明这个证书发布机构不可
信任,证书自然也不可信,程序也将抛出一个错误信息。如果是受信任机构发布的,浏览器将
使用受信任杋构证书的公钥对服务器证书里面的指纹和指纹算法进行解密,再利用这个指纹算
法计算服务器证书的指纹,把计算出来的指纹与证书里面的指纹进行对比,进而判断证书是否
被修改过以及证书是否是受信任机构发布的。如图174所示,完整的协议通信过程如下。
①发送Hllo消息
②回应 Hello消息
③发送X509证书或证书链
④发送 Server Key Exchange消息
⑤发送 Certificat Request消息
⑥发送 Server done消息
⑦检查服务器证书,发送客户端证书
⑧发送 Client Key Exchange消息
⑨发送 Certificate Verify消息
⑩发送 Change Cipher Spec消息
①发送 Finished消息
②发送 Change Cipher Spec消息
③3发送 Finished消息
④完成握手
▲图17.4SSL协议的通信过程
①客户端发送 Client hello消息给服务器,包括SSL版本、客户端随机数、会话⑩D、客
户端支持的密码套件及客户端支持的压缩方法列表。
②服务器响应 Server hello消息,包括握手期间使用的SSL版本、服务器随机数、会话
ID,挑选一套客户端支持的密码套件及选择一个压缩方法
③服务器发送自己的证书,包括一个X.509证书或一条证书链。
④服务器发送 Server_Key_ Exchange消息,此消息包含前两个随机数及服务器参数的
签名。
⑤服务器发送 Certificate_ Request消息给客户端请求证书
⑥服务器发送 Server done,等待应答。
25017.2安全的通信
⑦客户端接收到 Server done消息后,检查服务器传过来的证书,并且判断 Server hello
的参数是否可以接受,如果没问题,就发送一个或多个消息给服务器。客户端发送一个
Certificate消息,如果客户端没有证书,则发送一个 No Certificate警告。
⑧客户端发送 Client Key_Exchange消息,消息内容由密钥交换类型决定。假如把RSA
算法用于密码交换协议和认证,客户端产生一个48位的预主密钥( Premaster Secret),用服务
器传过来的证书中的公钥或 Server_ Key_ Exchange消息内的RSA密钥加密预主密钥,然后把
密文发送给服务器。
⑨客户端发送 Certificate Verify消息,其中包含一个用 Master Secret对第一条消息以来
的所有握手消息进行签名的签名值, Master Secret是双方通过预主密钥及双方随机数按照一定
算法生成的。
⑩客户端发送 Change Cipher_Spec消息,将协商好的加密信息复制到当前连接的状态中,
告诉服务器改变加密模式,保证以后所有消息都用新的密码套件进行加密与认证。
①客户端用新的算法与密钥加密一个 Finished消息,告诉服务器客户端已准备好安全数
据通信,此消息可以用于检查密钥交换和认证是否已经成功。另外,它还包含一个自通信以来
所有消息的校验值,可对以往消息进行校验。
②服务器端发送( Change Cipher_ Spec消息,告诉客户端修改加密模式。
③3服务器端发送 Finished消息,这是握手协议的最后一步,告诉客户端服务器端已经准
备好安全数据通信。
⑩④完成整个握手过程,客户端与服务器可以进行通信
握手过程中我们发现使用了两种类型的加密算法,分别是非对称加密算法与对称加密算
法。这两种算法的特点是:非对称加密更加安全且提供了更好的身份认证技术,但运算效率较
低;而对称加密安全性稍低,但运算效率高。所以在协商通信密钥的过程中使用非对称加密算
法更加安全,而完成握手后的通信过程中使用对称加密算法效率更高,这样既保证了安全又保
证了效率。
握手过程中几次涉及证书,证书是什么?证书包含了用于加密数据的密钥(采用公钥加密
技术),也包含了用于证实身份的数字签名。每个证书是全世界唯一的,证书可以从权威机构
购买,也可以自己创建,某些场合通信双方只关心数据在网络上可以安全传输,并不需要验证
对方身份(例如服务器之间的通信),这时可以使用自建证书。
与SSL类似,TLS( Transport Layer Security,传输层安全)协议是建立在SSL30协议规
范之上的,它是SSL3.0的后续版本。这两种协议都用来保护数据在网络传输过程中的秘密性
和完整性。
17.2.2Java安全套接字扩展—JSSE
上一节已经介绍了SSL/ILS协议的通信模式,而对于这些底层协议,如果要每个开发者
都自己去实现,显然会带来很多不便。为了解决这个问题,Java为广大开发者提供了Java安
251第17章运行、通信及访问的安全管理
全套接字扩展—JSSE。它包含了实现 Internet安全通信的一系列包的集合,是SSL和TLS
的纯Java实现。同时,它是一个开放的标准,每个公司都可以自己实现JSSE。通过它可以透
明地提供数据加密、服务器认证、信息完整性等功能,就像使用普通的套接字一样使用安全套
接字,大大减轻了开发者的负担,使开发者可以轻松将SSL协议整合到程序中,并且JSSE能
将安全隐患降到最低点。
在用JSSE实现SSL通信的过程中主要会遇到以下类和接口,由于过程中涉及加密、解密、
密钥生成等运算的框架和实现,因此也会间接用到JCE包的一些类。图17.5为 JSSE API的主
要类图
IC Key Manager Factory
C SecureRandom
<Interface
Key manager
IC SSLEngine
CSocketFactory
KeyStore
OSSLSocketFactory K-
SSLContext
CTrustManagerFactory
C SSLSocket
C SSLServer Socket Factory
<Interface>
TrustManager
LOSSLServer Socket
O <Interface>
SSLSession
C ServerSocket Factory
▲图17.5 JSSE AP|的主要类图
通信核心类— SSLSocket和 SSLServerSocket它们对于使用过 Socket进行通信开发的人
比较容易理解,它们对应的就是 Socket与 Server Socket,只是表示实现了SsL协议的 Socket
和 Server Socket,同时它们也是 Socket与 Server Socket的子类。 SSLSocket负责的事情包括
设置加密套件、管理SSL会话、处理握手结束时间、设置客户端模式或服务器模式。
>客户端与服务器端 Socket工厂— SSLSocketFactory和 SSLServer SocketFactory。这里把
SSLSocket、 SSLServer Socket对象创建的工作交给这两个工厂类
>SSL会话 SSLSession。安全通信握手过程需要一个会话。为了提高通信的效率,SsL
协议允许多个 SSLSocket共享同一个SSL会话。在同一个会话中,只有第一个打开的 SSLSocket
需要进行SSL握手,负责生成密钥及交换密钥,其余 SSLSocket都共享密钥信息。
>SSL上下文— SSLContext。它是对整个SSL/TLS协议的封装,表示安全套接字协议的实
现。它主要负责设置安全通信过程中的各种信息,例如与证书相关的信息,并且负责构建
SSLSocket Factory、 SSLServerSocketFactory和 SSLEngine等工厂类
252172安全的通信
>SSL非阻塞引擎—— SSlEngine。假如你要进行NIO通信,那么将使用这个类,它让通信
过程支持非阻塞的安全通信
密钥管理器 KeyManager。此接口负责选择用于证实自己身份的安全证书,并发送给通
信另一方。 KeyManager对象由 KeyManagerFactory工厂类生成。
信任管理器— TrustManager。此接口负责判断决定是否信任对方的安全证书, TrustManager
对象由 TrustManager Factory工厂类生成。
>密钥证书存储设施— Key Store。这个对象用于存放安全证书,安全证书一般以文件形式
存放, KeyStore负责将证书加载到内存中
通过上面这些类就可以完成SSL协议的安全通信了,在利用SSL/ILS进行安全通信时,
客户端与服务器端都必须要支持SSL/TLS协议,不然将无法进行通信。同时,客户端和服务
器端都可能要设置用于证实自己身份的安全证书,并且还要设置信任对方的哪些安全证书。
关于身份认证方面有个名词叫客户端模式,一般情况下客户端要对服务器端的身份进行验
证,但是无须向服务器证实自己的身份,这种不用向对方证实自己身份的通信端就处于客户端
模式,否则,它处于服务器模式。 SSLSocket的 setUse ClientMode( Boolean mode)方法可以设置
客户端模式或服务器模式。
1.以BO模式实现SSL通信
使用BO模式实现SSL通信,除了生成一些证书密钥外,只需要使用JDK自带的 SSLServer Socket
和 SSLSocket等相关类的API即可实现。
1)解决证书问题。
般而言,作为服务器端,必须要有证书以证明这个服务器的身份,并且证书应该描述此
服务器所有者的一些基本信息,例如公司名称、联系人名等。证书由所有人以密码形式签名,
基本不可伪造,获取证书的途径有两个。一是从权威机构购买证书,权威机构担保它颁发的证
书的真实性,而且这个权威机构被大家所信任,进而你可以相信这个证书的有效性。另外一个
是自己用JDK提供的工具 Key Tool创建一个自我签名的证书,这种情况下一般只希望保证数
据的安全性与完整性,避免数据在传送的过程中被窃听或篡改,此时身份的认证已不重要,重
点已经在端与端传输的秘密性上,证书的作用只体现在加解密签名上。
另外,关于证书的一些概念在这里陈述。证书是一个实体的数字签名,这个实体可以
是一个人、一个组织、一个程序、一个公司、一个银行。同时,证书还包含这个实体的共
钥,此公钥是这个实体的数字关联,让所有想同这个实体发生信任关系的其他实体用来检
验签名。而这个实体的数字签名是实体信息用实体的私钥加密后的数据,这条数据可以用
这个实体的公钥解密,进而鉴别实体的身份。这里用到的核心算法是非对称加密算法。
SSL协议通信涉及以密钥储存的文件格式比较多,很容易搞混,例如 XXX. cer、xpfx、
xiks、 xXX. keystore、 XXx. truststore等。如图17.6所示,搞清楚它们有助于理解后面的程序。
其中,,cer格式文件俗称证书,但这个证书中没有私钥,只包含了公钥。px文件也称为证
253第17章运行、通信及访问的安全管理
书,它由微软推出且一般供浏览器使用,而且它不仅包含公钥,还包含私钥,当然,这个
私钥是加密的,不输入密码是解不了密的。jkS文件表示Java密钥存储器( Java Key store
JKS),它可以同时容纳N个公钥与私钥,是一个密钥库。 keystore文件其实与jks基本上
是一样的,只是不同公司叫法不太一样,它是默认生成的证书存储库格式。 truststore文件
表示信任证书存储库,它仅仅包含通信对方的公钥。当然,可以直接把通信对方的JKS作
为信任库(就算如此,你也只能知道通信对方的公钥,要知道密钥都是加密的,你无从获
取,只要算法不被破解)。有些时候我们需要把Pfx或Cert转换为JKS以便于用Java进行
SSL通信,例如一个银行只提供了pfx证书,而我们想用Java进行SSL通信时就要将px
转换为JKS格式。
密钥存储器,保
存N个私钥和公钥
ks或 keystore
两者结构基本一样,只
是 uststore只用于
存放公钥
微软推出、
转换
浏览器使用
retool
导出
pfx
keytop
truststore
导入
retool
浏览器
导入
keytop
信任存储器,
导出
导出
保存N个公钥
▲图17.6密钥存储文件的格式
按照理论,我们一共需要准备4个文件,两个 KeyStore文件和两个 TrustStore文件。通信
双方分别拥有一个 Key Store和一个 TrustStore, KeyStore用于存放自己的密钥和公钥, TrustStore
用于存放所有需要的信任方的公钥。这里为了方便直接使用JKS(即 KeyStore替代 TrustStore
(免得证书导来导去),因为对方的 KeyStore包含了自己需要的信任公钥。
下面使用JDK自带的工具分别生成服务器端证书。如图17.7所示,通过如下命令并输入
姓名、组织单位名称、组织名称、城市、省份、国家信息即可生成证书密码为 Tomcat的证书,
此证书存放在密码也为 Tomcat的 tomcat. jks证书存储库中。如果你继续创建证书,则可以继
续向 tomcat. jks证书存储库中添加证书。如果你仅仅输入 keytool- genkey- alias tomcat -keyalg
RSA- keypass tomcat- -storepass tomcat,不指定证书存储库的文件名及路径,则工具会在用户目
25417.2安全的通信
录下生产一个“ keystore”文件作为证书存储库。
管理员: WINdows\system32 cmd.exe
:\>keytool -genkey -alias tomcat -ke yalg RSA -keypass tomcat -storepass tomcat
的组织单位名称是什么?
您的组织名称是什
您所在的城市或区域名称是什么?
所在的州或省份名称是什么?
该单位的两字母国家代码是什
[Unknown I:
tomcat,.o0u= tomcat,o= tomcat,L- be ijing.sr- be ijing.c=en正确吗?
古1:y
▲图17.7生成服务端证书
类似地,客户端证书也用此方式生成,如图17.8所示。
管理员:C: Windows\system32 cmd. exe
\ke tool -genkey -alias client -ke yalg RSA -keypass client -storepass client
lient. j
与姓氏是
的组织单位名称是什么?
[Unknown I
ient
的组织名称是什么?
client
您所在的城市或区域名称是什么?
[Unki
所在的州或省份名称是什么?
[Unknown]:
单位的两字母国家代码是什么
[Unknown 1: cn
ICN-client. oU - client, o-client, L"guangzhou, ST-guangzhou, C-cn E7 3?
图178生成客户端证书
2)创建服务端程序。
public class TomcatssLserver
private static final String SSL_TYPE ="SSL
private static final String KS_TYPE ="JKS"
private static final String X509 = "SunX509";
private final static int PoRT=443
private static TomcatssLServer sslserveri
private SSLServersocket svrSocketi
public static TomcatssLServer getInstance( throws Exception i
if (sslServer = null) i
sslServer new Tomcatsslserver(i
255第17章运行、通信及访问的安全管理
return sslServer:
private TomcatSsLServer() throws Exception
SSLContext sslContext createssLContext(i
SSIServerSocketFactory serverFactory
sslContext
getServer SocketFactory()i
svrSocket =(SSLServerSocket) serverFactory createServerSocket(PORT)i
svrSocket. setNeedclientAuth(true)i
string [] supported svrSocket getEnabledCipherSuites(;
svrSocket. setEnabledcipherSuites(supported);
private SSLContext createSSLContext() throws Exception i
KeyManagerFactory kmf= KeyManagerFactory getInstance(X509)i
TrustManagerFactory tmf TrustManagerFactory. getInstance(X509)i
string serverKeyStoreFile ="c:\\tomcat jks"i
string svrPassphrase = "tomcat";
char[] svrPassword svrPassphrase toCharArray()i
keystore serverKeyStore Keystore getInstance(KS_TYPE);
serverKeystore. load(new FileInputstream(serverKeyStoreFile), svrPassword);
kmf init(serverkeystore, svrPassword);
string clientKeystoreFile ="c: \\client jks"i
string cntPassphrase ="client"
char [ cntPassword cntPassphrase. tocharArray()i
Keystore clientKeyStore KeyStore getInstance(KS_TYPE)i
clientKeyStore. load (new FileInputStream (clientKeyStoreFile), cntPassword)
tmfinit(clientKeystore)i
SSLContext sslContext= SSLContext getInstance(SSL TYPE);
sslContext init(kmf. getKeyManagers(), tmf. getTrustManagers(), null)
return. sslContext:
public void startservice( f
SSLSocket cntSocket null
BufferedReader ioReader null
Printwriter iowriter null
String tmpMsg= nulli
while( true )(
try i
cntSocket =(SSLSocket) svrSocket accept()i
ioReader new BufferedReader(new InputstreamReader (cntSocket
getinputstream()))i
ioWriter new PrintWriter(cntSocket. getoutputstream())i
while((tmpMsg ioReader readLine())!= null)i
System. out. println("客户端通过SSL协议发送信息:"+ tpmS g)
25617.2安全的通信
tpmS g="欢迎通过SL协议连接";
ioWriter. println(tmpMsg)i
iowriter. flush()
t catch(IOException e
eprintstackTrace()i
finally i
try
if(cntSocket ! null) cntSocket close ()i
y catch(Exception ex)ex printStackTrace(i)
public static void main(String[] args)throws Exception
TomcatsSLServer. getInstance(). startservice ()i
这里首先得到一个 SSLContext实例,再对 SSLContext实例进行初始化,将密钥管理器及
信任管理器作为参数传入,证书管理器及信任管理器按照指定的密钥存储器路径和密码进行加
载。接着,设置支持的加密套件。最后,让 SSLServerSocket开始监听客户端发送过来的消息。
3)创建客户端程序。
public class TomcatssLClient
private static final String SSL_TYPE =ssl"
private static final String x509="SunX509";
private static final String KS_TYPE =Jks"
private SSLSocket ssISocket
public TomcatssLClient(String targetHost, int port) throws Exception
SSLContextsslContext createSSlContext(
SSLSocketFactory sslcntFactory =(SSISocketFactory) sslContext. getso
cketFactory()i
sslSocket =(SSLSocket) sslcntFactory createSocket(targetHost, port)i
String[] supported= sslSocket getsupportedCipherSuites()
sslSocket. setEnabledcipherSuites(supported)
private SSLContext createSSlContext() throws Exception i
KeyManagerFactory kmf KeyManagerFactory getInstance(X509)i
TrustManagerFactory tmf TrustManagerFactory. getInstance(X509);
String clientKeyStoreFile ="c:\\client jks";
String cntPassphrase ="client
char[] cntPassword cntPassphrase tocharArray ()i
257第17章运行、通信及访问的安全管理
KeyStore clientKeystore Keystore getInstance(KS TYPE
clientKeystore. load(new FileInputStream(clientKeyStoreFile), cntPassword)i
String serverkeystoreFile ="c: \\tomcat jks"i
String svrPassphrase =tomcat"i
char [] svrPassword svrPassphrase toCharArray()i
Keystore serverKeystore Keystore getInstance(KS_ TYPE)i
serverKeyStore. load(new FileInputStream(serverkeystoreFile), svrPassword)
kmf init(clientKeystore, cntPassword)i
tmf init(serverKeystore)i
SSLContext sslContext= SSLContext getInstance(SSL_ TYPE
sslContext init(kmf. getKeyManagers(), tmf. getTrustManagers(), null);
return sslContext
public String sayToSvr(String sayMsg) throws IOException
BufferedReader ioReader new BufferedReader(new InputStreamReader
ssISocket. getInputstream()))i
Printwriter ioWriter new Printwriter(ssISocket. getoutputstream())i
ioWriter. println(sayMsg)i
ioWriter. flush(
return ioReader. readline()i
public static void main(String[] args)throws Exception
TomcatssLClient sslSocket new TomcatssLClient("127.0.0.1",443)i
BufferedReader ioReader new BufferedReader(new InputStreamReader(
System in))i
String sayMsg =i
string svrRespMsg=
while((sayMsg ioReader. readLine())!= null
svrRespMsg= ssISocket, sayTosvr(sayMsg)i
if(svrRespMsg ! null && svrRespMsg trim().equals(""))(
System.out. print1n("服务器通过SSL协议响应:"+ svrRespMsg);
客户端的前半部分的操作基本上与服务器端的一样,首先创建一个 SSLContext实例,再
用密钥管理器及信仼管理器对 SSLContext进行初始化。当然,这里密钥存储的路径是指向客
户端的 client jks。接着,设置加密套件。最后,使用 SSLSocket进行通信。
注意,服务器端有行代码 sprOcket. setNeedclientauth(rue)。它是非常重要的一个设置方
法,用于设置是否验证客户端的身份。假如我们把它注释掉或设置为 false,此时客户端将不
再需要自己的密钥管理器,即服务器不需要通过 client jks对客户端的身份进行验证,把密钥
25817.2安全的通信
管理器直接设置为nul也可以与服务器端进行通信。
最后谈谈信任管理器,它的职责是决定是否信任远端的证书,那么它凭借什么去判断呢?
如果不显式设置信任存储器的文件路径,将遵循如下规则。
①如果系统属性 Javax. net.s! truststore指定了 Truststore文件,那么信任管理器将从JRE
路径下的 lib/security目录中寻找这个文件作为信任存储器
②如果没设置①中的系统属性,则寻找% java_ home%lib/ security/jssecacerts文件作为信
任存储器。
③如果 jssecacerts不存在,而 cacerts存在,则以 cacerts作为信任存储器。
至此,一个利用JSSE实现BIO模式的SSL协议通信的例子已完成
2.以N|O模式实现SSL通信
在JDK1.5之前,由于互联网还没快速发展起来,对于常见的应用使用BIO模式即可满足
需求,而这时JDK的JSSE接口也仅仅提供了基于流的安全套接字。然而,随着网络的发展,
BIO模型明显已经不足以满足一些高并发多连接接入的场景,体现在机器上,就是使用不同的
线程模型,以便能最大程度地利用机器的运算能力,于是此时引入了NO模式。原来基于流的阻
塞模式ⅠO只须使用 SSLServer Socket和 SSLSocket即可完成SSL通信。而JK中对于NO模式
并没有提供与之对应的“ SSLServerSocketChannel”和“ SSLSocketChannel”,这是由NO模式决
定的。很难设计一个“ SSLServer Socketchannel”类与 Selector交互,强行地引入将带来更多的问
题,这更像为了解决一个问题而引入了三个问题,并且还会导致API更加复杂。另外,NO细节
也不适合屏蔽,它应该由应用开发层去控制。所有的这些都决定了JDK不会也不能有NO安全套
接字。
JDK1.5为了支持NIO模式的SSL通信,引入了 SSLEngine引擎,它负责了底层SSL协
议的握手、加密、解密、关闭会话等操作。根据前面介绍过的SSL\TLS协议,我们知道SSL
协议在握手阶段会有11个步骤,在握手过程中不会有应用层的数据传输,只有在握手认证完
成后双方才会进行应用层数据交换。大致把握手分为下面4阶段。
①客户端发送Helo消息;
②服务端响应 Hello消息且发送附带的认证消息
③客户端向客户端发送证书和其他认证消息
④完成握手。
SSLEngine在握手过程中定义了5种 HandshakeStatus状态,分别为 NEED WRAP、
NEED UNWRAP、 NEED TASK、FⅠ NISHED和 NOT HANDSHAKING。通过它们实现协议通信
过程中的状态管理,按照4个阶段中的状态是这样转换的。刚开始它的状态为 NEED UNWRAP,
表示等待解包。读取客户端数据并解包后,把状态置为 NEED WRAP,表示等待打包。打包完并
向客户端响应数据后,状态又重置为 NEED UNWRAP。如此切换,直至握手完成时状态被设置
为 FINISHED,表示握手已经完成。此后把状态设置为 NOT HANDSHAKING,表示已经不在握
259第17章运行、通信及访问的安全管理
中中
手阶段了。另外,还有一个 NEED TASK状态表示 SSLEngine有额外的任务需要执行,而且这些
任务都是比较耗时或者可能阻塞的,例如访问密钥文件、连接远程证书认证服务、密钥管理器使
用何种认证方式作为客户端认证等操作。为了保证NIO特性,这些操作不能直接由当前线程操作,
当前线程只会把状态改为 NEED TASK,后面的处理线程会交由其他线程处理。
接着看程序是如何使用NIO模式进行SSL通信的,主要看服务器端如何实现。
public class NiosslServer
private SSLEngine sslEnginei
private Selector selector;
private SsLContext sslContexti
private ByteBuffer netInDatai
private ByteBuffer appInDatai
private ByteBuffer netoutData;
private ByteBuffer appoutData;
private static final String SsL_TYPE = "Ssl"
private static final String KS_TYPE ="JKS
private static final String X509 ="SunX509"i
private final static int PORT=443
public void run() throws Exception
createServersocket()i
createsslContextoi
createSsLEngine()i
createBuffer(i
while (true)
selector. select(;
Iterator<selectionKey> it= selector. selectedKeys().iterator()i
while (it. hasNext())(
SelectionKey selectionKey
t. nestor
it remove)i
handleRequest(selectionkey)i
private void createBuffer()
SSLSession session= sslEngine getsession()i
appInData= ByteBufferallocate(session. getApplicationBuffersize())i
netinData ByteBufferallocate(session. getPacketBuffersize())
appOutData= ByteBuffer wrap("Hello\n" getBytes())i
netoutData= ByteBuffer allocate(session. getPacketBuffersize())i
private void createSSLEngine(
SSlEngine= sslContext. createSSLEngine()i
SSlEngine. setUseClientMode(false)i
private void createServerSocket() throws Exception
26017.2安全的通信
ServerSocketChannel serverchannel= Server SocketChannel open()i
serverChannel. configureBlocking(false)i
selector Selector open()i
ServerSocket serverSocket serverChannel socket()i
serverSocket. bind (new InetSocketAddress (port))i
serverChannel. register(selector, SelectionKey OP_ ACCEPT)i
private void createSSLContext() throws Exception t
KeyManagerFactory kmf KeyManagerFactory getInstance(X509)i
TrustManagerFactory tmf TrustManagerFactory. getInstance(X509)i
String serverkeystoreFile ="c: \\tomcat jks";
String svrPassphrase ="tomcat"i
char[] svrPassword svrPassphrase. toCharArray(
Keystore serverKeyStore= KeyStore getInstance(KS_TYPE);
serverKeyStore. load(new FileInputStream(serverKeystoreFile), svrPassword)i
kmf init(serverKeystore, svrPassword)
String clientkeystoreFile ="c:\client jks";
String cntPassphrase ="client
char[ cntPassword cntPassphrase. toCharArray ()i
KeyStore clientKeyStore= KeyStore getInstance(KS_TYPE);
clientKeyStore. load(new FileInputStream(clientKeyStoreFile), cntPassword)i
tmf init(clientKeystore)i
sslContext SSLContext getInstance(SSL TYpe)i
sslContext init(kmf. getKeyManagers(), tmf. getTrustManagers(), null)i
private void handleRequest(SelectionKey key)throws Exception t
if (key.isAcceptable())i
ServerSocketChannel ssc=(ServerSocketchannel)key channel()i
Socketchannel channel = ssc accept()
channel. configureBlocking(false)i
doHandShake(channel
y else if (key. isReadable())i
f (sslEngine. getHandshakestatus()== Handshakestatus
NOT HANDSHAKING) I
Socketchannel sc =(SocketChannel)key channel()i
netInData. clearoi
appInData. clear()i
sc. read(netInData)i
netInData. flip()i
SSLEngineResult engineResult= sslEngine unwrap(netInData
appInData)i
doTask(i
if (engineResult getstatus()=- SSLEngineResult status OK)
appInData. flip()i
System. out. println(new String(appInDataarray()));
261第17章运行、通信及访问的安全管理
scregister(selector, SelectionKey OP_WRITE)i
A else if (key. isWritable())(
SocketChannel sc=(Socketchannel) key channel();
netoutData. clear()i
SSLEngineResult engineResult= sslEngine wrap(appOutData, netoutData);
doTask(i
netoutData. flip()i
while (netoutData. hasRemaining())
sc write(netoutData)i
scregister(selector, SelectionKey OP READ)i
private void doHandShake(SocketChannel sc) throws IOException
boolean handshakeDone false:
SSlEngine. beginHandshake()i
HandshakeStatus hastatus= sslEngine. getHandshakestatus()i
while ( handshake done
switch (hastatus)
case FINiSHed
break;
case NEEd TAsK
hastatus doTask(
break
case NEED UNWrap
netInData clear (i
sc. read (netInData)
netInData. flip()i
do i
SSLEngineResult engineResult sslEngine unwrap(netInData
appInData)i
hastatus dorask(i
while(hsstatus = SSLEngineResult HandshakeStatus NEED UNWRAP
& netinData remaining()>0)i
netInData. clear ()i
break
case NEeD Wrap
SSLEngineResult engineResult sslEngine wrap(appOutData,
netoutData)i
hastatus doTask()i
netOutData. flip()i
sc write(netoutData)i
netoutData. clearoi
break
26217.2安全的通信
case Not handshaKing:
sc. configureBlocking(false)i
sc register(selector, Selectionkey OP_READ)
handshakeDone true;
breaki
private HandshakeStatus doTask()t
Runnable task
while((task= sslEngine. getDelegatedTask())! =null)t
new Thread (task). start()
return sslEngine. getHandshakestatus ()i
public static void main (String[] args) throws Exception t
new NioSslServer(. run()i
根据程序大致说明具体思路。
①创建用于非阻塞通信的主要对象 ServerSocketChannel和 Selector,绑定端口,注册接
收事件。
②创建SSL上下文,此过程主要是根据前面创建好的密钥存储器 tomcat.jks和 client jks
创建密钥管理器和信任管理器,并通过密钥管理器和信仼管理器初始化SSL上下文。
③创建SSL引擎,主要通过SSL上下文创建SSL引擎,并将它设为不验证客户端身份。
④创建缓冲区,使用SSL协议通信的过程中涉及4个缓冲区,如图179所示。 netInData表示
实际从网络接收到的字节流,它是包含了SSL协议和应用数据的字节流,通过 SSLEngine引擎进行
认证解密等处理后的应用可直接使用的数据则用 appIn Data表示。同样地,应用层要传递的数据为
appOutData,而经过 SSLEngine引擎认证加密处理后放到网络中传输的字节流则为 netOut Data。
applicatio
applaNata
appu
SSLEngine
netIn Data
netOutData
network
图17.9SSL缓冲区
263第17章运行、通信及访问的安全管理
⑤接下来,开始监听处理客户端的连接请求,一日有可接受的连接,则会先进行SSL协
议握手,完成握手后才能进行传输,即对通道的读、写操作。
握手操作是一个比较复杂的过程,必须要保证握手完成后才能进行应用层数据的交换,所
以这里使用一个 while循环不断做握手操作直到完成。前面已经介绍了握手阶段会有
NEED WRAP、 NEED UNWRAP、 NEED TASK、 FINISHED、 NOT HANDSHAKING五种状态,
由于SSL协议握手的报文都由 SSLEngine引擎自动生成,因此我们只须对不同状态做不同操作即
可。例如,如果处于 NEED UNWRAP状态则调用 unwrap方法,如果处于 NEED WRAP状态则
调用wrap方法,如果处于 NEED TASK状态则使用其他线程处理委托任务,握手报文自动由这
些方法完成。当握手完成后状态则被设置为 FINISHED。接着状态变为 NOT HANDSHAKING
表示已经不在握手阶段了,已经可以进行应用层通信了,此时整个SSL握手结束。
应用层的安全通信过程其实也是靠 SSLEngine引擎的 unwrap和wap方法对数据进行加解
密并且对通信双方进行认证。例如,应用层读操作是将 netInData和 appInData传入 unwrap方
法,处理后的 appInData即为应用需要的数据,而写操作则是将 appOutData和 netoutData传
入wrap方法,处理后的 netOutData即为传输给对方的数据。
至此,通过在网络与应用之间增加一个 SSLEngine引擎层,则实现了安全通信,并且使用
了NO模式让服务器端拥有更加出色的处理性能。
17.23 Tomcat中SSL安全信道的实现
为了实现 Https通信, Tomcat需要利用JSSE把SSL/TLS协议集成到自身系统上,通过
上一节我们知道不同的厂商可以实现自己的JSSE,而 Tomcat默认使用的是以前sun公司开发
实现的包而且由JDK自带。
Tomcat实现HTTP及Https通信的基础是什么?其实HTTP与Https的不同就体现在
创建通信套接字服务器时的不同,HTP是没有任何加密措施的套接字服务器,而HTPS是靠嵌
套了一层密码机制的套接字服务器。在实现时只需要根据实际通信情况创建对应的套接字服务器,
这时果断想起工厂类,由各自的工厂负责创建及初始化套接字服务器。如图17.10所示,在 Tomcat
初始化时,其中一个组件 JloEndpoint会跟着初始化,届时它将根据配置文件的SSL标识来决定
创建 Server Socket还是 SSLServerSocket如果是HTP协议,则使用 DefaultServer Socket Factory
完成套接字服务器创建;如果是 Https,则要通过 SSLImplementation间接定位到
JSSESocket Factory,由它完成套接字服务器的创建。
关于HTTP协议使用的套接字,这里我们并不关心,重点研究Https使用的安全套接字
的生成及相关操作。具体由 JSSESocketFactory实现,此工厂类扩展了两个接口。其中,
ServerSocket Factory接口定义创建套接字,开始接受套接字,握手等方法,另外的 SSLUtil接
口则定义了一些SSL相关对象(例如SSL上下文、密钥管理器、信任管理器等)的操作方法。
在 Tomcat启动时将通过 create Socket方法创建安全套接字服务器,代码如下。
264172安全的通信
<Interface> Server SocketFactory
<Interface> SSLUtil
createSSLContextO
createSocket(int int Inet Address)
getKey Managers
acceptSocket(Server Socket)
get TrustManagersO
handshake( Socket)
configures Session Context(SSLSession Context)
Jloendpoint
DefaultServer SocketFactory
JSSESocketFactory
SSLimplementation
JSSelmplementation
图17.10套接字工厂类
public ServerSocket createSocket (int port) throws IOException t
init()i
ServerSocket socket sslProxy createServer Socket(port)i
initServerSocket(socket)i
return socket
首先, initO方法作为初始化方法进行一些初始化操作,包括创建SSL上下文、利用密钥
管理器和信任管理器初始化SSL上下文、设置SSL会话、检测SSL配置是否OK等,这一系列
操作都是 JSSE API的一些操作。接着,通过 sslProxy创建 SSLServerSocket, sslProxy其实是
SSLServerSocket Factory类的实例,此类属于 JSSE API的核心类,这里不再深入讨论
create ServerSocket的详细实现。然后,通过 initServer Socket方法对刚刚创建的 SSLServerSocket
做一些初始化操作,包括设置可用的加密套件、设置可用的协议、设置是否需要客户端提供身
份验证等。最后,返回 SSLServer Socket对象,即安全套接字服务器对象。
除了 createSocket方法之外, JSSESocketFactory还有几个重要的方法需要说明一下。
handshake方法,它负责执行SSL握手。一般握手可以通过 SSLSocket的 startHandshakeO
方法或 getSession(方法实现。 starthandshake是一种显式的调用,它将使会话使用新的密
钥、新的加密套件。而 getSession则是一种隐式的调用,它会判断当前是否存在有效会话,
如果没有则尝试建立会话。 JSSESocketFactory的 handshake方法选择通过 getSession方法
隐式实现。
> getKeystorePassword方法,它负责获取密钥存储器密码。 Tomcat将密码默认设为“ changeit”
在实际运行中,如果 server. xm的< connector>节点配置了 keystorePass属性,则密码为 keystorePass
的属性值;如果配置了 keyPass属性而没有配置 keystorePass属性,则密码为 keyPass F属
性值;否则,才使用默认密码“ changeit”。
265第17章运行、通信及访问的安全管理
≯ getKeystore方法,它负责读取密钥存储器。密钥存储器的默认文件路径是
System getProperty(" user home"),即用户目录下的 keystore文件。如果 server xml的
< connector>节点配置了 keystoreFile属性,则路径为指定的 keystoreFile属性值:否则,使
用默认路径。
check Config方法,它负责检查证书与启用的密码套件是否兼容。它有两种可能,一种是,
如果证书与密码套件有兼容问题则会抛出 SSLException异常,另外一种则是抛出超时异
常。根据不同异常处理即可。
关于 Tomcat的SsL安全信道实现其实很好理解,无非就是把JSSE的接口集成到 Tomcat
的核心程序中。
13客户端访问认证机制
各种各样的Web程序通过 Tomcat部署、发布到公网上供用户访问,有些系统资源只针对
某些指定用户开放,不同安全级别的Web资源需要不同安全级别身份的用户才能访问。这时
他们就需要有一种认证机制去保护系统资源的安全,并且进一步可以将资源通过不同用户权限
进行管理,这就是资源域安全管理。
首先从权限角度来看,在Web应用中一般会有各种各样的角色权限用于控制Web本身的
资源访问。例如,根据不同的使用人员控制某些功能的入口。这种类型的权限属于Web应用
级别的权限控制,每个Web应用需要自行实现,但如果要继续往下控制Web容器资源(即多
个Web应用的访问)的权限,web应用层则力不从心。另外,从资源共用角度上,有时一个
Web容器中可能不止部署一个应用,即多个Web会部署到同一个 Tomcat下,为使多个web
应用能共享资源安全管理, Tomcat需要从Web容器层提供对资源权限管理的支持。
然后,从认证协议角度来看,有些认证模式属于HTTP协议层面的,有些认证模式
是套接字层面的,还有些认证模式属于其他的规范。如果每个应用要自己去实现这些认
证功能,那简直就是噩梦,所以为了方便Web应用层,需要在web容器层提供各种认证
模式的支持。
接下来,看看 Tomcat在安全认证及资源权限管理方面是如何实现的。
17.3.1Web资源认证原理
Web服务器与浏览器之间的认证流程没有规定的步骤,根据不同的认证模式及鉴权方式
可能会有不同的执行步骤。图17.11用一个最简单的流程展示整个认证过程是如何工作的。首
先浏览器向服务器发起请求,然后服务器向浏览器询问用户名及密码,浏览器带上用户名及密
码重新请求,服务器根据用户名获取相应角色并判断是否有权限访问该资源,最后通过认证后
返回受保护的资源。
266173客户端访问认证机制
①请求某受保护的资源
②受保护的资源需要客户端输入用户名密码认证
④根据用户名密码
③带上用户密码重新请求
获取相应角色,判
断是否有权限访问
⑤认证通过返回受保护资源
该资源
图17.11认证过程
在整个过程中可以分为客户端与服务器端交互、服务器端权限验证两部分。客户端
与服务器端的交互其实就是认证模式,这是客户端与服务器端之间的约定,存在多种认
证模式。服务器端权限验证则是将资源与角色映射起来,根据保存的用户信息判断客户
端用户是否有权限访问。
17.3.2认证模式
认证模式由浏览器与Web服务器之间约定。它有很多不同的模式,有些可能是按照HTTP
协议规范,有些是在HTTP协议之上制定出来的,有些则建立在Https之上。不同模式有不
同的特点,下面讨论常见的一些认证模式。
1. Basic模式
HTP协议规范中有两种认证方式,一种是 Basic认证方式,另外一种是 Digest认证方式。
这两种方式都属于无状态认证方式,所谓无状态即服务器端都不会在会话中记录相关信息,客
户端每次访问都需要将用户名和密码放置到报文中一同发送给服务端,但这并不表示你在浏览
器中每次访问时都要自己输入用户名和密码,可能是你第一次输入账号后浏览器就把它保存在
内存中用于后面的交互。先看HTTP协议的Basic认证模式。
既然是HTP协议规范,那其实就是约束浏览器厂商与Web容器厂商实现各自软件时的
行为约束。例如,一个典型的认证交互过程是:浏览器向web容器发送HTTP请求报文,web
容器接收到HTTP请求报文后解析需要访问的资源。如果该资源刚好是受保护的资源,Web
容器则向浏览器发送认证HTTP响应报文,浏览器接收到报文后弹出窗口让用户输入账号及密
码。接着,再次发送包含了账号信息的HTTP请求报文,Web容器对账号信息进行鉴权,如
果通过验证,则返回对应资源,否则重新认证。
BasicAccessAuthenticationscheme是在HTTP1.0中提出的认证方法。它是一种基于
Challenge/ Response的认证模式,针对特定的 Realm需要提供用户名和密码认证后才可访问,
其中密码使用明文传输。 Basic模式的认证过程如下。
①浏览器发送HTTP报文请求一个受保护的资源。
②服务器端的Web容器将HTTP响应报文的响应码设为401,响应头部加入WWW
Authenticate: Basic realm=" my Tomcat"中。
267第17章运行、通信及访问的安全管理
③浏览器弹出对话框让用户输入用户名和密码,并用Base64进行编码,实际上是用户名+
冒号+密码进行Base64编码,即Base64(username;password),这次浏览器就会在HTTP报文头
部加入" Authorization: Basic bXIo0b21YXQ-"。
④服务器端Web容器获取HTTP报文头部的相关认证信息,确认此用户名与密码是否正确,
是否有相应资源的权限,如果认证成功,则返回相关资源,否则再执行步骤②,重新进行认证。
⑤以后每次访问都要带上认证头部。
服务器端返回的认证报文中包含了 realm=" my Tomcat'"。 realm的值用于定义保护的区域,
在服务器端可以通过 realm将不同的资源分成不同的域,域的名称即为 realm的值,每个域可
能会有自己的权限鉴别方案
Basic认证模式有两个明显的缺点:①无状态导致每次通信都要带上认证信息,即使是已
经认证过的资源;②传输安全性不足,认证信息用Base64编码,基本上就是明文传输,很容
易截取报文并盜用认证信息。
2. Digest模式
HTP协议规范的另一种认证模式是 Digest模式,在HITP1.I时提出。它主要是为了解」
决 Basic模式安全问题,用于替代原来的Basc认证模式 Digest认证也采用 Challenge/ Response
认证模式,基本的认证流程比较类似,整个过程如下。
①·浏览器发送HTTP报文请求一个受保护的资源。
②服务器端的Web容器将HTTP响应报文的响应码设为401,响应头部比Basic模式复
A4,WWW-Authenticate: Digest realm="my Tomcat", qop="auth", nonce=xxxXXXXXXXX", opaque=
" XXXXXXXX其中,qgop的auth表示鉴别方式; nonce是随机字符串; opaque服务器端指定的值,
客户端需要原值返回。
③浏览器弹出对话框让用户输入用户名和密码,浏览器对用户名、密码、nonce值、HTTP请
求方法、被请求资源URI等组合后进行MD5运算,把计算得到的摘要信息发送给服务器端。请求
头部类似如下, Authorization: Digest username-"xxx, realm=" my Tomcat'",qop-"auth", nonce==
xxxXX", uri=xxXX", nonce"xXXXXX",nc=00000001, response"xXxXXXXXX",opaqueXXXXXXXXX"o
其中, username是用户名;none是客户端生成的随机字符串;ne是运行认证的次数; response就是
最终计算得到的摘要。
④服务器端web容器获取HTTP报文头部的相关认证信息,从中获取到username,根据
username
获取对应的密码,同样对用户名、密码、nonce值、HTTP请求方法、被请求资源URI
等组合进行MD5运算,把计算结果和 response进行比较,如果匹配,则认证成功并返回相关
资源,否则再执行步骤②,重新进行认证。
⑤以后每次访问都要带上认证头部。
其实通过散列算法对通信双方身份的认证十分常见。它的好处就是不必把具备密码的信息
对外传输,只须将这些密码信息加入一个对方给定的随机值计算散列值,最后将散列值传给对
26817.3客户端访问认证机制
方,对方就可以认证你的身份。 Digest思想同样采如此,用了一种 nonce随机数字符串,双方
约好对哪些信息进行散列运算即可完成双方身份的验证。 Digest模式避免了密码在网络上明文
传输,提高了安全性,但它仍然存在缺点,例如,认证报文被攻击者拦截到,攻击者可以获取
到资源。
3.Form模式
上面介绍的两种模式都属于HTTP协议规范的范畴。由于它的规范使得很多东西无法自定
义,例如登录窗口、错误展示页面,所以需要另外一种模式以提供更加灵活的认证,也就是基
于Fom的认证模式。各种语言体系的Web容器都可以实现各自的Fom模式,这里只介绍Java
体系的Fom认证模式。
Form模式的认证流程如下。
①浏览器发送HTTP报文请求一个受保护的资源。
②服务器端的Web容器判断此URI为受保护的资源,于是将请求重定向到自定义的登录
页面上,例如 login. htm页面。可以自定义登录页面的样式,但要遵守的约定是表单的 action
必须以 i security_check结尾,即< sform action= xxXxxX/j_security_check' method=POST>。用户
名和密码输入框元素的name必须为 J_username和 j_password。
③浏览器展示自定义的登录页面让用户输入用户名和密码,然后提交表单。
④服务器端Web容器获取表单的用户名和密码,确认此用户名与密码是否正确,是否有
相应资源的权限,如果认证成功,则返回相关资源,否则再执行步骤②,重新进行认证
⑤后面在同个会话期间的访问都不用再进行认证,因为认证的结果已经保存在服务器端
的会话里面。
Fom模式跳出了HTTP规范提供了自定义的更加灵活的认证模式。由于每种语言都可以定义
自己的Fom模式,因此它没有一个通用的标准,而且它也存在密码明文传输安全问题。
4. Spnego模式
pnego模式是一种由微软提出的使用GSS-API接口的认证模式。它扩展了 Kerberos协议,
S
在了解 Spnego协议之前,必须先了解 Kerberos协议。 Kerberos协议主要解决身份认证及通信
密钥协商问题,它大致的工作流程如图17.12所示
①客户端根据自己用户名向密钥分发中心KDC的身份认证服务(AS)请求TGS票证。
②AS生成一个TGS票证,查询对应用户的密码,然后通过用户密码将TGS票证加密,
响应给客户端。
⑧③客户端通过用户密码解密TGS票证,如果密码正确,就能获取到TGS票证,然后用
TGS票证向票证授予服务请求服务票证。
④TGS将服务票证响应给客户端。
⑤客户端使用服务票证去访问某服务,该服务会验证服务票据是否合法。
269第17章运行、通信及访问的安全管理
⑥验证通过,开始通信。
用户数据库
密钥分发中心(KDC)
身份认证服票证授予服
服务
务(AS)
务(TGS)
②使用用户
密码加密
TGs票证
⑤服务票证
④颁发服务票证
⑥验证通过,
开始通信
③用TGS票证
请求服务票证
①根据用户名请求TGS票证
图17.12 Kerberos的工作流程
在了解了 Kerberos协议后,我们再来看看 Spnego的认证过程是怎样的。由于 Spnego扩
展自Kerberos协议,因此认证的核心流程一样,只是在浏览器与Web服务器之间的HTTP通
信过程中嵌入认证流程,如图17.13所示。
①客户端浏览器向Web服务器发送HTTP请求。
②服务器返回401状态码,响应头部加上 WWW-Authenticate: Negotiate
③用户通过浏览器输入用户名向AS请求TGS票证。
④AS生成TGS票证,然后查询用户密码并用此密码加密TGS票证,返回浏览器。
⑤浏览器使用用户密码解密出TGS票证,并向TGS服务发起请求。
⑥TGS服务生成服务票证响应给浏览器。
⑦浏览器将服务票证封装到 SPNEGO token中,并发送给Web服务器。
⑧服务器解密出用户名及服务票证,将票证发往TGS服务验证。
⑨通过验证,开始通信。
可以看到 Spnego模式提供了更加强大的安全认证,它将认证模块独立出来,虽然结
构复杂了,但这样可以为所有应用提供认证功能,例如它可以很容易实现多个系统之间
的单点登录。
27017.3客户端访问认证机制
用户数据库
密钥分发中心(KDC)
身份认证服票证授子服
⑧验证票证
Web服务器
务(AC)
务(TGS)
④使用用户
密码加密
①http
⑥颁发服务票证
http
TGS票证
401
⑤用TGS票证
请求服务票证
⑦ spnego token
③根据用户名请求TGS票证
⑨认证通过,开始通信
▲图1713 Song0认证过程
5.SSL模式
SSL模式是基于SSL通信的一种认证模式。它的大体流程是这样的:客户端与服务器之间通
过SSL协议建立起SSL通道,这个过程比较复杂,涉及客户端、服务器端证书互相交互验证,协
商通信密钥等过程。完成整个SSL通道的建立后才是认证的核心步骤,如图17.14所示
SSI
web服务
客户端
用户信息
①获取客户端证书,
解析证书
证书
③通过验证正常通信
②根据客户端
证书标识获取
用户相关信息
图17.14SL认证模式
①首先获取客户端证书文件,这个文件由于在SSL协议期间已经发送到服务器端,因此
可以直接从内存中获取它,然后解析证书文件得到证书标识
271第17章运行、通信及访问的安全管理
②通过这个证书标识去存放用户信息的地方查找出对应客户端证书用户的相关信息。
③检查此用户是否有相关资源的权限,如果验证通过,则返回请求相关资源
SSL模式也提供了高安全性的认证,它只对颁发的客户端证书个体信任,可用于服务器端
与服务器端之间的通信,也可以用于浏览器与Web服务器之间的通信,这时必须使用 Https,
因为它必须走SSL协议通道才能完成认证流程。
6. NonLogin模式
顾名思义,此模式不必要求用户登录,主要是说浏览器与服务器之间不必要求用户登录。
前面我们知道一般的流程需要在浏览器端输入用户及密码并传输到服务器,服务器再通过用户
名密码判断是否登录成功,成功后,再检查该用户对应的角色是否有某资源的权限。所以这里
把前面的登录过程省略了,只做后面资源权限的检查。
假如Web资源配置 role角色对应的资源为urll,即只有拥有 role角色的用户才拥有访
问url资源的权限,用户免登录就说明他不是任何角色,所以浏览器访问urll资源时出错,
但假如url2资源没有配置任何角色,则浏览器在 NonLogin模式下可以访问该资源。
17.3.3Ream域
Realm域其实可以看成一个包含了用户及密码的数据库,而且每个用户还会包含若干角
色。也就是包含用户名、密码、角色三列的数据记录集合,如图17.15所示,最下面椭圆内包
含的整块内容即可以看成 Realm域。它的出现是为了方便统一地提供一种ⅹ(用户,密码,
权限)与Y(Web资源)的映射关系。
web3
webl
web2
url资源
r12资源
ur3资源
role
i role2
url4资源
role
user、 password1、 role
user2、 password2、role2
user3、 password3、role3
wwwwwmww-mm
▲图17.15Ream域
我们有三个Web应用的资源及对应资源的访问角色,Web1应用中的urll资源必须拥有
role角色的用户才可以访问,Web2应用中的ru2资源则需要role2角色才可访问,而Web3
应用中的rule3角色可以访问url3资源和url4资源。这时,有了 realm域,就可以很方便建立
起用户与每个Web应用及相关资源的权限关系。
所以 Realm域是为了统一web容器资源安全管理、统一抽离重复认证工作、方便Web应
27217.3客户端访问认证机制
用资源杈限管理开发而提出的一个概念。它属于在Web容器级别提供权限认证的支持,它支
持三个 Container级别的共享,即 Engine容器、Host容器和 Context容器。我们知道 Tomcat
的结构分为四个级别,除了这三个之外,还有一个 Wrapper级别,由于它对应的是一个 Servlet,,
因此它不能有对应的 Realm。那么 Engine级别由所有Web应用共亨,Host级别则由在该虚拟
主机上的Web应用共享,而 Context级别则专属于某个Web应用。从这方面可以看出, Tomcat
又可以通过配置提供不同的 Realm共享级别。
那么在了解了什么是 Realm域后,我们进一步看看, Realm可以以不同的存储方式保存用
户名、密码、角色,例如数据库、配置文件、其他存储系统等。所以根据不同的存储方式 Tomcat
提供了各种支持。下面讨论 Realm的类型。
JDBCRealm,用户密码角色信息保存在一个关系数据库中,通过JDBC驱动程序对信息进
行获取。
γ Data SourceRealm,用户密码角色信息保存在一个关系数据库中,通过配置JDI的JDBC
数据源对信息进行获取。
JNDIRealm,用户密码角色信息保存在一个基于LDAP协议的目录服务器中,通过JND对信
息进行获取。
UserDatabase Realm,用户密码角色信息保存在一个名为“ UserDatabase”的JND资源中,
般默认保存在 conf/tomcat- users.xml文件中。这是 Tomcat默认的 Realm,它也通过JDl
对信息进行获取。
Memory Realm,用户密码角色信息保存在内存中,其通过 conf/tomcat-users xm进行初始
化。通过指定内存对信息进行获取。
JAASRealm,用户密码角色信息保存在JAAS相应的配置文件中,通过JAAS框架对信息
进行获取。
17.3.4 Tomcat如何实现资源安全管理
在了解了认证模式及 Realm域后,我们看看 Tomcat是如何实现资源安全管理的。在认证
模式上,必须要支持多种认证模式,包括 Basic模式、 Digest模式、rorm模式、 Spnego模式
SSL模式及 NonLogin模式。如何实现这些认证模式比较优雅?如图17.16所示,在 Tomcat中
个请求从浏览器发送过来后,请求接收后会流向四个级别容器处理,即 Engine→Host→
Context→ Wrapper,而且是以管道、阀门形式进行处理,只需往某个容器中添加一个阀门用于
认证处理。为了支持每个应用都可以有各自的认证机制,这个容器级别应该选为 Context
针对每种认证模式建立不同的认证器,例如 Basic模式对应 Basic authenticator、SSL
模式对应 SSLAuthenticator,这些认证器都要实现 Valve接口以便被 Context的管道调用。
认证器主要负责通过认证协议与客户端交互,收集用户的凭证信息并进行认证鉴权工作。
所以整个认证过程包含了两大步骤,一是收集用户凭证信息,另一个是对凭证鉴权,收集
凭证其实就是用不同的协议让客户端协助收集,例如 Http Basic协议。而对凭证的鉴权工
273第17章运行、通信及访问的安全管理
作又是如何实现的?
Stamdard Engi
StandardHost
浏览器
Standard Context
×× Authenticator
▲图17.16 Tomcat认证
鉴权工作主要是通过客户端用户名和密码找出相应的权限,然后根据查询出来的权限检查
是否可以请求相应资源。如图17.17所示,Web层对应 Context容器级别,所以在Web应用中
web. xml配置文件配置的权限信息会被加载到 Context容器中,例如 role对应url1,role2对
应url2、url3。除此之外,它还需要查询用户权限模块,这就交由 Realm完成, Realm抽象了
用户与角色关系的一层。客户端传输过来用户名和密码后, KXX Authenticator认证器通过 Realm
获取到该用户的角色,然后判断是否有请求资源的权限,假如 user l正在访问url,通过 user
和pwdl查出来的权限为 role,有urll权限,则返回该资源。
web
StandardEngine
url2、url3-role2
StandardHost
Standard Context
用户名和密码
x×× Authenticator
realm
user、pwdl、 role1
user2、pwd2、role2
▲图17.170mcat鉴权
Tomcat中实现资源安全管理的思路很清晰,通过不同认证协议让客户端输入身份信息,接收
到身份信息后,则通过 Realm模块和 web. xml权限配置共同判断是否返回正在请求的资源
17.3.5如何让你的Web具备权限认证
大多数Web系统都有权限需求,前面已经了解了它的整个认证过程的原理,本节将讲述
如何在 Tomcat中配置web资源的权限。先以 Tomcat默认的认证模式 Basic和默认的域
UserDatabase realm为例,看看如何完成整个配置。
首先,配置 server:xml文件,配置一个名为 UserDatabase的数据源,它绑定的存储文件为
conf/tomcat- users.xml。然后,在 Realm节点中引用名为 UserDatabase的数据源,这里的 Realm
27417.3客户端访问认证机制
由 Engine容器级别共享
<Server>
<GlobalNamingresources>
<Resource name="UserDatabase auth=Container
type=org. apache. catalina. UserDatabase "
description=User database that can be updated and saved"
factory=org. apache. catalina. users. MemoryUserDatabasefactory
pathname="conf/tomcat-users xml"/>
</GlobalNamingResources>
<Engine>
<Realm className="org. apache. catalina realm. UserDatabaseRealm"
resourceName="UserDatabase"/>
</Engine>
</Server>
其次,配置 tomcat-users.xml文件,定义一个名为 tomcatrole的角色,再定义一个用户名
为 tomcat、密码为 tomcat的用户,并赋予其 tomcatrole角色
<tomcat-users>
<role rolename="tomcatrole"/>
<user username="tomcat" password="tomcat" roles="tomcatRole">
</tomcat-users
最后,配置Web应用的web.xml文件,配置该Web应用 security目录下的资源需要
tomcatRole角色才能访问,并配置采用 BASIC认证模式
<security-constraint>
<web-resource-collection>
<web-resource-name>security resource</web-resource-name>
<url-pattern>/security/*</url-pattern>
</web-resource-collection>
<auth-constraint>
<role-name>tomcatRole</role-name>
</auth-constraint>
</security-constraint>
<login-config>
<auth-method>BASIC</auth-method>
<realm-name>Tomcat Manager Application</realm-name>
</login-config>
上面的内容全部配置完成后,就实现权限认证功能了。当用户访问/ security./*对应的资源
时,浏览器会弹出用户名密码输入框,用户输入后才可以访问。另外, Realm和认证模式都可
以根据实际情况配置成其他类型。
275第18章处理请求和响应的管道
1]管道摸式—管道与阀门
在一个比较复杂的大型系统中,假如存在某个对象或数据流需要进行繁杂的逻辑处理,我
们可以选择在一个大的组件中直接进行这些繁杂的逻辑处理,这种方式确实达到了目的,但是
简单粗暴。或许在某些情况下这种简单粗暴的方式将带来一些麻烦,例如,要改动其中某部分
处理逻辑,要添加一些处理逻辑到流程中,要在流程中减少一些处理逻辑,这里有些看似简单
的改动都让我们无从下手,除非对整个组件进行改动。整个系统看起来没有任何可扩展性和可
重用性。
是否有一种模式可以将整个处理流程进行详细划分?划分出的每个小模块互相独立且各
自负责一段逻辑处理,这些逻辑处理小模块根据顺序连接起来,前一模块的输岀作为后一模块
的输入,最后一个模块的输出为最终的处理结果。如此一来,修改逻辑时只针对某个模块修改,
添加或减少处理逻辑也可细化到某个模块颗粒度,并且每个模块可重复利用,可重用性大大增
强。这种模式就是本章要进行讨论的管道模式。
顾名思义,管道模式就像一条管道把多个对象连接起来,整体看起来就像若干个阀门嵌套
在管道中,而处理逻辑就放在阀门上。如图18.1所示,需要处理的对象进入管道后,分别经
过阀门一、阀门二、阀门三、阀门四,每个阀门都会对进入的对象进行一些逻辑处理,经过
层层的处理后从管道尾处理,此时的对象就是已完成处理的目标对象
既然管道模式这么有用,我们希望能在程序中适当地考虑使用,为了实现此模式,需要多
个对象协作。如图182所示, Valve接口定义了阀门的调用方法,由于阀门与阀门使用单链表
结构连接,因此需提供对下一个阀门的操作; Pipeline接口定义了管道操作阀门的方法,包括
获取第一个阀门、获取基础阀门、添加阀门等方法,管道需要对其扩展。
接下来,介绍如何简单地实现一个管道模式。18.1管道模式——管道与阀门
阀门一在
此处执行
些操作
阀门三在
阀门二在
此处执行
此处执行
一些操作
些操作
基础阀门在
此处执行
些操作
▲图18.1管道模型
<interface>
<interface
Valve
Pipeline
getNext()
getFirst()
setNet( Valve)
get Basic(
invoke(String
set Basic( Valve)
add valve( valve)
StandardPipeline
Basic valve
Second valve
Third valve
next: value
basic: Valve
▲图18.2管道类图
①定义阀门接口。
public interface Valve i
public valve getNext()i
public void setNext(Valvevalve)i
public void invoke(String handling)
277第18章处理请求和响应的管道
②定义管道接口
public interface Pipeline t
public Valve getFirst()i
public Valve getBasic()i
public void setBasic(valve valve)
public void addValve(valve valve)
③定义基础阀门,处理逻辑仅仅是简单地将传入的字符串中“a”替换成“bb”。
public class Basicvalve implements Valve
protected Valve next = nulli
public valve getNext()I
return nexti
public void invoke(String handling)
handling=handling replaceAll(aa,bb")i
System,out. print1n("基础阀门处理完后:"+ handling)
public void setNext(Valvevalve
this next valve
④定义第二个阀门,将传入的字符串中“11”替换成“22”。
public class SecondValve implements valve
protected Valve next null
public valve getNext()(
return nexti
public void invoke(string handling
handling handling replaceAll(1l ,22 )
System,out, print1n(" Second阀门处理完后:"+ handling);
getNext().invoke(handling)i
public void setNext(Valve valve) i
this next valve
⑤定义第三个阀门,将传入的字符串中“z”替换成“yy”。
public class Thirdvalve implements Valve i
protected Valve next = nulli
public valve getNext(
27818.1管道模式——管道与阀门
return next
public void invoke(String handling) i
handling handling replaceAll("zz","yy")
System,out. print1n(" Third阀门处理完后:"+ handling);
getNext().invoke(handling)i
public void setNext (Valvevalve)t
this next valve:
⑥定义管道,我们一般的操作是先通过 setBasic设置基础阀门,接着按顺序添加其他阀
门,执行顺序是:先添加进来的先执行,最后才执行基础阀门。
public class StandardPipeline implements Pipeline i
protected Valve first nulli
protected valve basic nulli
public void addvalve(Valvevalve)i
if (first = null) i
first valve;
valve. setNext(basic)i
y else i
Valve current first
while (current null)[
if (current getNext()== basic)i
current. setNext(valve)i
valve. setNext(basic)i
breaki
current current. getNextoi
public Valve getBasic()
return basic;
public valve getFirst(
return first
public void setBasic(Valvevalve)
this basic valve:
279第18章处理请求和响应的管道
⑦测试类。
public class Main i
public static void main(String[] args) t
String handling="aabbl122zzyy"i
StandardPipeline pipeline new StandardPipeline()i
Basicvalve basicvalve new Basicvalve(i
Secondvalvesecondvalve new Secondvalve()i
Thirdvalve thirdvalve new Thirdvalve()i
pipeline. setBasic(basicValve)i
pipeline. addvalve(secondvalve)i
pipeline. addvalve(thirdvalve)i
pipeline getFirst(). invoke (handling)i
输出的结果如下。
Second阀门处理完后:aabb2222zzyy
Third阀门处理完后:aabb2222yy
基础阀门处理完后:bbbb222yy
这就是管道模式,在管道中连接一个或多个阀门,每个阀门负责一部分逻辑处理,数据按
规定的顺序往下流。此模式分解了逻辑处理仼务,可方便对某任务单元进行安装、拆卸,提高
了流程的可扩展性、可重用性、机动性、灵活性
182Tmat中的管道
Tomcat中按照包含关系一共有4个级别的容器,它们的标准实现分别为 StandardEngine、
StandardHost、 StandardContext和 Standard Wrapper,请求对象及响应对象将分别被这4个容器
处理,请求响应对象在4个容器之间通过管道机制进行传递。如图18.3所示,请求响应对象
先通过 StandardEngine的管道,期间经过若干个阀门处理,基础阀门是 Standard Engine Valve;
往下流转到 StandardHost的管道,基础阀门为 StandardHost valve;类似地,通过 StandardContext;
最后到 Standard Wrapper完成整个处理流程
这种设计为每个容器都带来了灵活的机制,可以按照需要对不同容器添加自定义阀门进行
不同的逻辑处理,并且 Tomcat将管道机制设置成可配置形式,对于存在的阀门只须通过配置
文件即可,还可以自定义并配置阀门就可在相应作用域内生效。4个容器中,每个容器都包含
自己的管道对象,管道对象用于存放若干阀门对象,它们都有自己的基础阀门,且基础阀门是
Tomcat默认设置的,一般不可更改,以免运行时产生问题。
280182 Tomcat中的管道
Standard Context
StandardEngine
Standard Engine Valve
Stand Context Valve
StandardHost
Standard wrapper
StandardHost Valve
Standard Wrapper Valve
▲图18.3 Tomcat中的管道
下面分别详细介绍这些基础阀门的伪代码。
① StandardEngine Valve阀门最重要的逻辑如下。调用时,它会获取请求对应的主机Host
对象,同时负责调用Host对象中管道的第一个阀门。
public final void invoke(Request request, Response response)
throws IOException, ServletException t
Hosthost request getHost()
host. getPipeline(). getFirst(). invoke(request, response)i
②尽管 StandardHost valve包含了其他的处理逻辑,但不可缺少的逻辑是获取请求对应的
上下文 Context对象并调用 Context对象中管道的第一个阀门。
public final void invoke(Request request, Response response)
throws IOException, ServletException
Context context request getContext()i
触发 request初始化事件
context.getPipeline (). getFirst(). invoke(request, response)i
更新会话上次访问时间
281第18章处理请求和响应的管道
③ Standard Context Valve阀门首先会判断是否访问了禁止目录WEB-NF或META-INF,
接着获取请求对应的Wrapper对象,再向客户端发送通知报文“HTTP/l.1100Continue”,最
后调用 Wrapper对象中管道的第一个阅门。
public final void invoke(Request request, Response response)
throws IOException, ServletException
判断访问路径是否包含WEB-INF或META-INF,禁止访问此目录
Wrapper wrapper
request. getwrapper()i
向客户端发送"HTTP/1.1100Continue"通知
wrapper.getPipeline().getFirst().invoke(request, response);
④ Standard Wrapper Valve,阀门负责统计请求次数、统计处理时间、分配 Servlet内存、
执行 Servlet过滤器、调用 Servlet的 service方法、释放 Servlet内存
public final void invoke(Request request, Response response)
throws IOException, ServletException f
统计请求次数
Standardwrapper wrapper
(Standardwrapper) getContainer ()i
Servlet servlet wrapper allocate()i
执行Serv1et过滤器
servlet. service (request, response)i
wrapper deallocate(servlet)i
统计处理时间
183T0mGat中的定制阀门
管道机制给我们带来了更好的扩展性, Tomcat中,在扩展性方面具体如何体现便是本节
讨论的内容。从上一节了解到基础阀门是必须执行的,假如你需要一个额外的逻辑处理阀门,
就可以添加一个非基础阀门。
例如,需求是对每个请求访问进行IP记录,输出到日志里面,详细操作如下
①自定义一个阀门 PrintIPvalve,只要继承 Valve Base并重写 invoke方法即可, Valve Base
是 Tomcat抽象的一个基础类,它帮我们实现了声明接口及 MBean接口,使我们只须专注阀门
的逻辑处理即可。需要注意的地方是,一定要执行调用下一个阀门的操作,即执行
getNext(. invoke( request, response),否则运行时将出现错误,请求到这个阀门就停止往下处理
public class PrintIpvalve extends ValveBase
OVerride
public void invoke(Request request, Response response) throws IOException
ServletException i
28218.3 Tomcat中的定制阀门
System. out. println(request. getRemoteAddr ())
getNext(.invoke(request, response)i
②配置 Tomcat服务器配置 server:xm,这里把阀门配置到 Engine容器下,这样其作用范
围即为整个引擎,也可以根据作用范围配置在Host或 Context下。
<Server port="8005" shutdown=SHUTDOWN">
<Engine name="Catalina"defaultHost="localhost">
<Valve className="org. apache. catalina. valves. PrintIpvalve"/>
</Engine>
</Server>
③将 PrintIPvalve类编译成 class文件,可以导出一个Jar包放入 Tomcat安装目录中的ib
文件夹下,也可直接将 class x件放入 Tomcat官方包 catalina. jar中,这里的包名为
org. apache. catalina. valves
经过上面三个步骤配置阀门,启动 Tomcat后对其进行的任何请求访问的客户端的PP都将
记录到日志中。除了自定义阀门以外, Tomcat的开发者也十分友好,为我们提供了很多常用
的阀门,对于这些阀门,我们就无须再自定义阀门类,要做的仅仅是在 server xml中进行配置。
常用的阀门包括下面这些
AccessLog valve,请求访问日志阀门,通过此阀门可以记录所有客户端的访问日志,
包括远程主机IP、远程主机名、请求方法、请求协议、会话ID、请求时间、处理时
长、数据包大小等。它提供了任意参数化的配置,可以通过任意组合来定制访问日志
格式。
JDBCAccessLog Valve,同样是记录访问日志的阀门,但它有助于将访问日志通过JDBC持
久化到数据库中
> Errorreport Valve,这是一个将错误以HTML格式输出的阀门
Persistent valve,这是对每个请求的会话实现持久化的阀门。
≯ Remote Addr valve,这是一个访问控制阀门,通过配置可以决定哪些I可以访问Web应用。
RemoteHost valve,这也是一个访问控制阀门,与 Remote Addr valve不同的是,它通过主机
名限制访问者。
≯ RemotelPValve,这是一个针对代理或负载均衡处理的一个阀门,一般经过代理或负载均衡
转发的请求都将自己的P添加到请求头部“ X-Forwarded-ror”中,此时,通过此阀门可
以获取访问者真实的IP。
283第18章处理请求和响应的管道
Semaphore Valve,这是一个控制容器上并发访问的阀门,可以作用在不同容器上。例如,
如果放在 Context中则整个上下文只允许若干线程同时访问,并发数量可以自己配置
在实际的使用过程中,如果你需要的阀门 Tomcat已经写好,则只需要对配置文件进行配
置即可使它生效,如果无法满足自己需求,则可以通过自己定义一个阀门。
284第19章多样化的会话管理器
HTTP协议在设计之初被设计成无状态的,客户端的每次请求在服务器端看来都独立且无
任何相关性,同一个客户端第一次请求不会与第二次请求有任何关联,即使相隔时间很短。无
状态的特性让请求变得很快速且服务器也更加高效。然而,随着人们对浏览器功能要求的不断
提高,由于无状态导致的不足更加明显,因为有些场景下本次处理需要用到之前请求的一些信
息,如果单纯靠HTTP协议而没有额外的机制,是无法办到的。
为了提供一种让一定时间内的每次请求都拥有记忆的会话机制,需要在HTTP协议的基础
上提供一种解决方案。当然,由于涉及相关信息的存储,因此需要在HTTP协议外另外提供存
储介质,通信的主体无非就是客户端和服务器端,于是人们可以想到的就是借客户端或服务器
端存储状态信息,后来基于这两端的存储方式都被支持。在客户端,生成一种叫做 Cookie的
小文本并把它存放在客户端的指定目录,每次请求时,浏览器会从 Cookie找出此次请求服务
器希望得到的一些状态并附加到HTTP协议头部一并传往服务器端,服务器端由此实现通信的
状态性。在服务器端,有时需要保存的信息量很大,存放在客户端会导致一个问题,即每次客
户端请求都要携带大量的信息到服务器端,传输效率低下。这时,如果把客户端的信息都放在
服务器端,就能避免大量附加信息的传输,仅仅只要携带一个识别编号到服务器端即可,服务
器端根据此编号找到此客户端对应的保存信息,至此实现通信的状态性。
所以两种方式可以用图19.1和图192来表示,图19.1为客户端模式,客户端每次请求都
会将本地保存的状态一起传到服务器端,服务器端通过这些状态便可以辨别哪个客户端的某些
状态。而图19,2则是服务器端模式,这时客户端要传递的仅仅是一个ID,它其实是客户端的
身份标识,而其他状态变量保存在服务器端,通过客户端ID可以找到对应客户端的状态变量,
所有客户端的状态统一存放在服务器端进行管理。
客户端
客户端
服务器端
客户端
▲图19.1客户端模式第19章多样化的会话管理器
服务器端
客户端
ID1状态
IDI
ID2
客户端
ID2状态
ID3
ID3状态
客户端
▲图19.2服务器端模式
本节主要探讨的是 Tomcat状态性服务器端模式相关的内容,即我们通常所说的会话功能,
包括 Tomcat中如何实现状态的保存、保存的方式以及集群下的状态管理。
191We容器的会话机制
基本上所有Web应用开发人员都很熟悉会话这个概念。在某个特定时间内,我们说可以
在一个会话中存储某些状态,需要的时候又可以把状态取出来,整个过程的时间空间可以抽象成“会
话”这个概念。尽管你对会话的使用已经很熟悉了,但你未必真正理解会话是什么。因为你只是使
用了 request getsession(0, setattribute(" users, username)把某个值设置到会话中的 users变量里面,只是
使用了 String username=( String request. getSessionO. get Attribute("users"获取会话中uses变量的值,
对于里面具体做了哪些操作、实现杋制是如何可能比较模糊。下面将对符合Java规范的Web容
器的会话机制做一个简单的描述。
关于Web容器的会话运行机制可以借助图19.3加深理解。在图19.3(a)中,某个客户端
向web容器发起请求,HTTP请求报文的Cookie头部携带了会话标识jsessionid(因为本书讨
论的是 Tomcat,,所以会话标识取为 jsessionid,其他服务器中可能参数名称不叫 jsessionid
在web容器中,假如已经写好了一个 Servlet专门用于处理此请求,如果要设置某个值到会话中
则可以使用 request. getSessionC. setAttributel(key;val),这时执行此语句具体做了哪些操作呢?首先
getSession方法其实就根据 jsessionid从Web容器的会话集中查找属于此客户端的会话对象,数据
结构如图193(b)所示,例如客户端传的值为 jsessionidl,则找到对应的会话 session l。其次是
调用获取到的 Session的 setAttribute方法,它其实向会话中保存数据, session 1包含了一个KV
(Key-Vale,键-值)结构用于存放数据,所以其实就把键值放到KV结构中。那么如果要获取会
话的值,则使用 request getSession( getAttribute((key)。理解了会话的设置则很好理解,先根据
jsessionid获取 Session对象,再根据键获取 Session对象里面的KV集对应的值。
另外,客户端又是如何把 jsessionid传递到服务器端的呢?一般会有如下三种方式。
Cookie方式,即通过浏览器读取小文本Cookie,读取jsessionid值后,附加到HTTP协议
的Cookie头部,HTTP协议报文传输到服务器端后,解析Cookie头部便可以获取,但如
果把浏览器的 Cookie给禁止了,则这种方式会失效。
28619.2标准会话对象— Standard Session
Web容器
request getSession(). setAttribute("key", val) request. getSessionO getAttribute("key")
jsessionid
客户端
request. getSessione0根据 djsessionid从容器
request. getSessionO根据 jsessionid从
中取到对应会话
容器中取到对应会话
session. setAttribute("key"yval)将val设置
session. getAttribute(("ke”)从存储集合中
到此会话的指定位置上,存储为map结构
取出主键为key的对象
(a)
vall:
key 2
val2
sessionid I
session I
al3
JsessionId2
session2
Jsessionid3
session
(b)
▲图19.3会话机制
重写URL方式,即把jsessionid附加到请求的URL中,例如htp:/www.tomcatcom/index」jsp?
isessionid=326257DA6DB76F8D2E38F2C4540DIDEA
>表单隐藏方式,这种方式其实类似重写URL方式,把jsessionid及其值存放在HTTP表单
中,提交时就会一起提交,服务器端只要根据Post或Get方法分别解析便可获取到。
Web容器的会话机制补充了HTTP协议的无状态性,使Web在应用功能方面更加强大,
满足了更多更复杂的需求。不管是web应用层开发人员还是中间件开发人员,深入理解会话
机制在软件设计时都会有很大的帮助。下面将详细对 Tomcat的会话实现进行剖析。
192标准会话对象— Standard session
Tomcat使用了一个 StandardSession对象来表示标准的会话结构,它用来封装需要存储的
状态信息。如图194所示,标准会话对象 StandardSession实现了 Session、 Serializable、
Httpsession等接口,为什么需要实现这几个接口?
Session接口定义了 Tomcat内部用来操作会话的一些方法。
Serializable则是序列化接口,实现它是为了方便传输及持久化。
287第19章多样化的会话管理器
HttpsessIon是 Servlet规范中为会话操作而定义的一些方法,作为一个标准web容器,实
现它是必然的。
Session
SerializablehttpSession
StandardSession
I StandardSessionFacade
▲图19.4标准会话类图
另外,还会存在一个 StandardSession Facade外观类。关于外观设计模式,相信大家都很熟
悉了,前面的请求及响应也使用了同样的模式,都是出于安全考虑引入一个外观类。它可以把
Tomcat内部使用的一些方法屏蔽了,只暴露Web应用层以允许调用的一些方法。
一个最简单的标准会话应该包括ID和Map< String, Object>结构的属性。其中,ID用于表
示会话编号,它必须是全局唯一的,属性用于存储会话相关信息,以KV结构存储。另外,它
还应该包括会话创建时间、事件监听器,并且提供Web层面访问的外观类等
193增量会话对象— Deltasessio0
在集群环境中,为了使集群中各个节点的会话状态都同步,同步操作是集群重点解决的问题。
般来说,有两种同步策略。其一是每次同步都把整个会话对象传给集群中其他节点,其他节点
更新整个会话对象;其二是对会话中增量修改的属性进行同步。这两种同步方案各有优缺点。整
个会话对象同步策略的实现过程比较简单方便,但会造成大量无效信息的传输。增量同步方式则
不会传递无效的信息,但在实现上会比较复杂,因为其中涉及对会话属性操作过程的管理。
本节讨论的正是增量同步方式中涉及的会话对象 DeltaSession,这个对象其实是对标准会
话对象的扩展,使之在整个请求过程记录会话所有的增量更改。图195为 DeltaSession的类图,除
了继承 StandardSession类外,它还实现了 Externalizable、 ClusterSession、 ReplicatedMapEntry三个接
口。 Externalizable接口主要提供对外部对象的读写操作, Cluster Session接口主要提供判断集群会话
是否为原始的会话操作,只有原始会话才有资格使会话过期, ReplicatedMapEntry接口提供差异复
制的操作。对于 DeltaSession,其实除了继承 StandardSession特性外,还要额外实现这三个接口。
当客户端发起一个请求时,服务器端对请求的处理可能涉及会话相关的操作。例如,获取
客户端某些属性再根据属性值进行逻辑处理,而且在整个请求过程中可能涉及多次的会话操
作。为了将这些改变能同步到集群的其他节点上,必须要有一个机制来实现。实际上,同步的
颗粒度大小是很重要,颗粒度太大会导致同步不及时,而颗粒度太小则可能导致传输及性能问
28819.3增量会话对象— Delta Session
题。考虑到性能及可行性, Tomcat同步的颗粒度是以一个完整的请求为单位的,即从客户端
发起请求到服务器完成逻辑处理返回结果之前的这段时间为同步颗粒度。这个过程中对某会话
的所有操作(对同一个属性的操作只记录最新的操作)都会记录下来。如图196所示,深灰
色的大箭头表示一个完整的请求过程,期间包括了4个属性修改操作,分别修改了属性a、b、
c、d,这4个操作会被抽象成4个动作并放进一个列表中,集群其他节点获取列表后,根据这
些动作就可以对自己本地对应的会话进行同步。
ClusterSession
ReplicatedMapentr
Session
Serializable
Httpsession
Externalizable
Delta Session
Standardsession
匚 StandardSessionFacade
图19.5. DeltaSession的类图
修改会话的
修改会话的
修改会话的
修改会话的
a属性
b属性
c属性
d属性
date4
date
plate
updat
▲图19.6修改动作
集群成员接收到某节点发送过来的同步消息后,将会逐一执行动作集里面的每个动作。在
图197中,大箭头表示同步的整个过程,最下面的为动作集列表,一共有4个动作。按顺序
首先取出第一个↑ update动作,动作对象里面包含了指定修改哪个会话的会话ID,根据此ID
修改会话集对应的会话的属性。接着把剩下的其余3个动作执行完毕,于是完成了会话同步。
在 Tomcat中会话增量的具体功能由 DeltaSession类实现。 DeltaSession继承了
StandardSession标准会话的所有特性且增加了会话增量记录的功能,增量记录功能即通过动作
集实现,动作集被封装在 DeltaRequest类中,所以整个结构如图198所示。 Delta Session主要
通过 DeltaRequest实现动作集的管理,动作集由一个 LinkedList< Attributelnfo>结构保存,
289“““““““““““““““““““““““““““““““““
第19章多样化的会话管理器
Attributelnfo描述了动作的一些消息,所以一个动作就被抽象成了一个 AttributeInfo对象。它
主要包含4个属性:name( String)、 value( Object)、 action (int)、type(int)。其中,name表示会话
的属性名,即哪个属性要修改; value表示会话属性名对应的值; action表示动作类型,可能
是设置属性也可能是删除属性;type表示会话哪种类别的属性将被修改。
会话集
根据 update l动作
修改对应 sessionid
会话的属性
Delta Session
Delta Request
update4
update3
LinkedList<A ttributelnfo>
update2
datel
图19.7动作同步
▲图198 DeltaSession的结构
整个增量会话的实现机制就是上面所说的,会话的增量复制比起全量复制有很多好处,即
使实现相对比较复杂。
194标准会话管理器— -standardManager
用于保存状态的会话对象已经有了,现在就需要一个管理器来管理所有会话。例如,会话
ID生成,根据会话ID找出对应的会话,对于过期的会话进行销毁等操作。用一句话描述标准
会话管理器:提供一个专门管理某个Web应用所有会话的容器,并且会在web应用启动、停
止时进行会话重加载和持久化
会话管理主要提供的功能包括会话ID生成器、后台处理(处理过期会话)、持久化模块及
会话集的维护。如图199所示,标准会话管理器包含了 Sessionldgenerator组件
backgroundProcess模块、持久化模块以及会话集合。
首先看 Sessionld generator,它负责为每个会话生成、分配一个唯一标识。例如,最终会
生成类似“326257DA6DB76F8D2E38F2C4540DDEA”字符串的会话标识。具体的默认生成
算法主要依靠JDK提供的 SHAIPRNG算法。在集群环境中,为了方便识别会话归属,它最终
29019.5持久化会话管理器— PersistentManager
生成的会话标识类似于“326257DA6DB76F8D2E38F2C4540 DIDEA tomcat1”,后面会加上
Tomcat的集群标识 jvmRoute变量的值,这里假设其中一个集群标识配置为“ tomcat”。如果
你想置换随机数生成算法,可以通过配置 server:xml的 Manager节点 secureRandomalgorithm
及 secureRandom Class属性达到修改算法的效果。
Session manager
SessionldGenerato
会话集合
idl会话
background Process
会话
id3会话
持久化模块
▲图19.9标准会话管理器
然后看如何对过期会话进行处理。负责判断会话是否过期的逻辑主要在 backgroundProcess
模块中,在 Tomcat容器中会有一条线程专门用于执行后台处理。当然,也包括标准会话管理
器的 backgroundProcess,它不断循环判断所有的会话中是否有过期的,一旦过期,则从会话集
中删除此会话。
最后是关于持久化模块和会话集的维护。由于标准会话旨在提供一个简单便捷的管理器,
因此持久化和重加载操作并不会太灵活且扩展性弱, Tomcat会在每个 StandardContext(Web
应用)停止时调用管理器将属于此Web应用的所有会话持久化到磁盘中。文件名为
SESSIONS.ser,而目录路径则由 server xml的 Manager节点 pathname指定或 Javax. servlet
context. tempdir变量指定,默认存放路径为% CATALINA HOME% work/Catalina/ localhost/
WebName/ SESSIONS. Ser。当Web应用启动时,又会加载这些持久化的会话,加载完成后,
SESSIONS.ser文件将会被删除,所以每次启动成功后就不会看到此文件的存在。另外,会话
集的维护是指提供创建新会话对象、删除指定会话对象及更新会话对象的功能。
标准会话管理器是我们常用的会话管理器,也是 Tomcat默认的一个会话管理器,对它进
行深入了解有助于对 Tomcat会话功能的掌握,同时对后面其他会话管理器的理解也更容易。
15持久化会话管理器 ersistentManager
前面提到的标准会话管理器已经提供了基础的会话管理功能,但在持久化方面做得还不
够,或者说在某些情景下无法满足要求。例如,把会话以文件或数据库形式存储到存储介质中
这些都是标准会话管理器无法做到的,于是另外一种会话管理器被设计出来——持久化会话管
理器
在分析持久化会话管理器之前,不妨先了解另外一个抽象概念——会话存储设备( Store),弓
291第19章多样化的会话管理器
入这个概念是为了更方便地实现各种会话存储方式。作为存储设备,最重要的操作无非就是读、写
操作,读即是将会话从存储设备加载到内存中,而写则将会话写入存储设备中,所以定义了两个重
要的方法lad和save与之相对应。 Filestore和 JDBCStore只要扩展 Store接口,各自实现load和save
方法,即可分别实现以文件或数据库形式存储会话。它们的类图如图19.10所示。
<Interface>
Store
save(Session session)
load( String id)
FileStore
JDBCStore
▲图19.10 Store的类图
19.5.1 File Store
Filestore提供的是以文件形式保存会话,在写入时,会针对每个会话生成一个文件,用于
保存此会话的相关信息。每个会话文件名定义为 sessionId+ session的格式,例如
“326257DA6DB76F8D2E38F2C4540D1DEA. session”。而存放目录路径则由 Servletcontext
TEMPDIR变量指定,一般默认目录路径为% CATALINA HOME% work/catalina/ localhost
WebName/,其实就是 Tomcat安装根目录+work+ enginename+ hostName+contextName。所以,
假如有1万个会话则会有1万个会话文件。为了方便操作,写入直接使用JDK自带的
java1o.ObjectOutputStream对会话对象进行序列化并写入文件。所以有一点需要注意的是,所
有会话中的对象必须实现 Serializable接口。
类似地,加载会话是通过传入一个 session,拼装成 session+, session格式的文件名去寻
找对应的会话文件,然后使用JDK自带的 Java.10, ObjectInputStream将会话对象载入内存中,
其实就是一个反序列化过程。
配置文件可以按如下配置。
<Store className=org. apache. catalina. session. Filestore
directory="sessiondir"7>
如果配置了 directory,则将以% CATALINA HOME% work/catalina/ ocalhost/WebName
sessiondir为存放目录。当然,如果配置为绝对路径,则以配置的绝对路径为存放目录。
以 Filestore为存储设备使用时,看起来在文件操作IO上效率相当低。因为对每个文件操
作都是打开-操作-关闭,并未使用任何优化措施,所以 Tomcat在选择使用此方式时,这很可
能会成为影响整体性能的一个因素,这就要求必须要做好充分的性能测试。
29219.5持久化会话管理器— PersistentManager
19.5.2 JDBCStore
JDBCStore提供的是以数据库形式存放会话,后端可以是任意厂商的数据库,只要有对应
的数据库驱动程序即可。既然要存放数据,肯定就要先在数据库中创建一张会话表,表的结构
必须要 Tomcat与 MySQL双方约定好。例如, Tomcat默认的表名为 tomcatssessions,表字段
共有6个,分别为app、id、data、 valid、 maxinactive、 lastaccess其中,app字段用于区分
哪个Web应用,id字段即会话标识,data字段用于存放会话对象字节串, valid字段表示此会
话是否有效, maxinactive字段表示最大存活时间, lastaccess字段表示最后访问时间。其中需
要注意的是data字段,因为它的大小直接影响会话对象的大小,所以需要根据实际设置它的
类型,如果是 MySQL可以考虑设置为Blob(65KB)或 Mediumblob(16MB)。
这样一来,会话的加载和保存其实就转化为对数据库的读、写操作了。而获取数据库连接
的逻辑是先判断 Tomcat容器中是否有数据源,如果有,则从数据源中直接获取一条连接使用,
但是如果没有,则会自己通过驱动程序创建连接。需要注意的是,从数据源中获取的连接在使
用完后会放回数据源中,但自己通过驱动程序创建的连接使用完则不会关闭。这个很好理解,
因为数据源是一个池,重新获取连接很快,而对于自建的连接,重新创建一般需要消耗数秒时
间,这明显会造成大问题。
下面以 MySQL数据库为例配置一个 JDBCStore
<Store className=org. apache. catalina. session. JDBCStore
connectionuRl="jdbc: mysql: //localhost: 3306/web session?user=user&password=
password"
sessionAppCol="app_name"c Driver"
driverName="com mysql jdb
sessiondatacol="session data
sessionidcol="session id"
sessionlastAccessedcol=last access
sessionMaxInactiveCol-="max inactive"
sessionTable="tomcat sessions
sessionvalidcol="valid session"/>
其中关于会话表及其字段的一些属性可以不必配置,直接采用 Tomcat默认的即可,但驱
动程序及连接URL则一定要配置
以 JDBCStore为存储设备时,从表面看起来,这并不会有明显的IO性能问题。因为它使
用数据源获取连接,这是一种池化技术,采用长连接模式。一般情况下,如果数据流不是非常
大,都不会存在性能问题。
介绍完存储设备后,接着看持久化会话管理器,其实持久化会话管理器主要实现的就是在
种逻辑下对会话进行持久化操作。
〉当会话对象数量超过指定阀值时,则将超出的会话对象转换出(保存到存储设备中并把内
存中的此对象删除)到存储设备中。
293第19章多样化的会话管理器
当会话空闲时间超过指定阀值时,则将此会话对象换出。
当会话空闲时间超过指定阀值时,则将此会话进行备份(保存到存储设备中并且内存中还
存在此对象)。
实现上面的逻辑只需对所有会话集合进行遍历即可,把符合条件的通过存储设备保存。由于
有些会话被持久化到存储设备中,所以通过ID查找会话时需先从内存中查找再往存储设备查找。
下面是一个配置例子,会话数大于1000时,则将空闲时间大于60秒的会话转移到存储设
备中,直到会话数量控制在1000,超过120秒空闲时间的会话被换出到存储设备中,超过180
秒空闲时间的会话将备份到存储设备中。
<Manager className="org. apache. catalina. session. PersistentManager '
maxActivesessions=1000
minIdleSwap="60
maxIdleSwap="120
maxIdleBackup=180">
<Store className="org. apache. catalina. session. Filestore" directory=sessiondir"/>
</Manager>
所以在了解了两种存储设备后对持久化会话管理器的实现原理机制就相当清楚了。其实它
就是提供两种会话保存方式并提供管理这些会话的操作,它提髙了 Tomcat状态处理方面的容
错能力。
196集群增量会话管理器— DeltaManager
DeltaManager是 Tomcat默认的集群会话管理器。它主要用于集群中各个节点之间会话状
态的同步维护,由于相关内容涉及集群,因此可能会需要一些集群通信的相关知识,如果有疑
问可参考第21章
DeltaManager的职责是将某节点的会话改变同步到集群内其他成员节点上。它属于全节点
复制模式,所谓全节点复制是指集群中某个节点的状态变化后需要同步到集群中剩余的节点,
非全节点方式可能只同步到其中某个或若干节点。
在集群中全节点会话复制的一个大致步骤如图1911所示。首先,客户端发起一个请求,
假设通过一定的负载均衡设备分发策略分到其中一个节点 Nodel,如果还不存在会话对象,
Web容器将会创建一个会话对象。接着,执行一些逻辑处理,在对客户端响应之前,有个重
要的事情是要把会话对象同步到集群中其他节点上。最后,再响应客户端。当客户端第二次发
起请求时,假如分发到Node3上,因为同步了 Node 1的会话,所以在执行逻辑时并不会取不
到会话的值。如果删除某个会话对象,则要同时通知其他节点把相应会话删除。如果修改了某
个会话的某些属性,也同样要更新到其他节点的会话中
DeltaManager其实就是一个会话同步通信解决方案。除了具备上面提到的全节点复制外,
它还具有只复制会话增量的特性。增量以一个完整的请求为周期,即它会将一个请求过程中所
29419.6集群增量会话管理器—— DeltaManager
有的会话修改量在响应前进行集群同步。下面讨论 Tomcat具体的实现方案。
Node3
Nodel
④响应
Node2
客户端
①请求
l③同步
Node4
图19.11集群同步步骤
为区分不同的动作,必须要先定义好各种事件。例如,会话创建事件、会话访问事件、会
话失效事件、会话获取事件、会话增量事件、会话ID改变事件等,实际上, Tomcat集群会有
9种事件,集群根据这些不同的事件就可以彼此进行通信,接收方对不同事件做不同的操作。
在图1912中,例如 Nodel创建一个会话后,即向其他三个节点发送 EVT SESSION CREATED
事件,其他三个节点接收到此事件后,则各自在本地创建一个会话。会话包含了两个很重要的属
性——会话ID和创建时间,这两个属性都必须由 Node 1紧接着 EVT SESSION CREATED
起发送出去。本地会话创建成功后,即完成了会话创建同步工作,此时通过会话DD查找集群
中任意一个节点都可以找到对应的会话。同样,对于会话访问事件, Nodel向其他节点发送
EVT SESSION ACCESSED事件及会话ID,其他节点根据会话I找到对应会话并更新会话
最后访问时间,以免被认为是过期会话而被清理。类似地,还有会话失效事件(同步集群销毁
某会话)、会话ID改变事件(同步集群更改会话ID)等操作。
Nodel EVT SESSION _ CREATED
EVT SESSION CREATED
EVT SESSION CREATED
Node3
Node4
▲图19.12创建会话
Tomcat使用 Session Messagelmpl类定义了各种集群通信事件及操作方法,在整个集群通
信过程中就按照此类定义好的事件进行通信。 Session Messagelmpl包含的事件有{EVT
295第19章多样化的会话管理器
SESSION CREATEL、 EVT SESSION EXPIRED、 EVT SESSION ACCESSED、 EVT GET
ALL SESSIONS、 EVT SESSION DELTA、 EVT ALL SESSION DATA、 EVT ALL SESSION
TRANSFERCOMPLETE EVT CHANGE SESSION ID EVT ALL SESSION NOCONTEXT
MANAGER}。图19.13为 Session Messagelmpl的类图,它继承了序列化接口(方便序列化)
集群消息接口(集群的操作)、会话消息接口(事件定义及会话操作)。
DeltaManager通过 SessionMessagelmpl消息来管理 DeltaSession,即根据 SessionMessagelmpl里
面的事件响应不同的操作。 Tomcat的集群通信使用的是 Tribes组件(第21章会深入介绍 Tribes
组件),网络IO都交由 Tribes后应用可以更专注逻辑处理。 DeltaManager存在一个 message
DataReceived( ClusterMessage cmsg)方法,此方法会在本节点接收到其他节点发送过来的消息后
被调用,且传入的参数为 ClusterMessage类型(可转化为 Session Message类型),然后根据
SessionMessage定义的9种事件做不同处理。其中需要关注的一个事件是 EVT SESSION
DELTA,它是负责会话增量同步处理的事件。某个节点在一个完整的请求过程中把某会话相
关属性的所有操作抽象到了 DeltaRequest对象中,而 DeltaRequest被序列化后会放到
SessionMessage中,所以 EVT SESSION DELTA事件的处理逻辑就是从 Session message获取
并反序列化 DeltaRequest对象,再将 DeltaRequest包含的对某个会话的所有操作同步到本地该
会话中,至此完成会话增量同步。集群增量会话管理器相关类之间的关系如图19.14所示。
Serializable>
ClusterMessageBase
Managerbase
Session messagelmpl
<Cluster Message>
Cluster Basel
DeltaSession
Delta manager
<Cession Message>
▲图19.13 SessionMessagelmp|类图
图19.14 Del taNager类图
总的来说, DeltaManager就是 Delta Session的管理器,它提供了会话增量的同步方式而不
是全量同步,极大提高了同步效率。
197集群备份会话管理器— BackupManager
上一节介绍的 DeltaManager将所有会话都备份到集群中所有的节点上,它属于全节点复
制模式,但它存在不足的地方是容易造成网络阻塞,而使集群的大小不宜过大。因为全节点模
式流量随着节点的增加呈平方增长,所以每増加一个节点对总流量的增加都是十分可观的。为
296197集群备份会话管理器— BackupManager
解决这个问题,需要从机制上做出改进,使整个集群的所有会话只需一个备份,即一个源数据
个备份数据,此种模式下,流量随着节点的增加已经降到呈线性增长。下面看看 Tomcat集
群如何实现此模式的会话管理。
19.7.1机制与原理
正常情况下,为了支持高效的并发操作, Tomcat的所有会话集使用 ConcurrentHashMap
< String, MapEntry>结构保存。其中, String类型是指 Session, MapEntry则是对会话、源节
点成员及备份节点等的封装,详细的类结构如图19.15所示。备份节点虽然为数组类型,但实
际情况下我们只会设置一个备份节点。一般会话对象由哪个节点生成则以哪个节点为源节点,
备份节点则为集群中其他任意一节点,所以 MapEntry可以看成包含了源节点和备份节点信息
的会话对象。会话管理器其实就是对会话集操作的封装。从设计角度看,为了改变会话集的操
作行为,只须继承 ConcurrentHashMap类并重写其中一些方法即可实现,例如put、get、 remove
等操作以实现跨节点操作。于是 Tomcat的 BackupManager把整个会话集的跨节点操作封装到
个继承 Concurrent HashMap类的 Lazy ReplicatedMap子类中,而要实现跨节点操作要做的事
很多。例如,备份节点列表的维护、备份节点选择、通信协议、序列化&反序列化及复杂的IO
操作等,弄清楚了 Lazy ReplicatedMap的工作原理也就基本清楚了 BackupManager如何工作。
每个节点都要维护一份集群节点信息列表,以供会话备份路由选择,信息列表的维护主要通
过在启动时向所有节点广播节点信息及心跳而维护。在图19.16(a)中,n1启动时向其他节点广
播自己的信息,其他节点收到信息后,把nl添加到自己的列表中,而n1则把n2、n3、n4添加到
自己的列表中,接着按某一时间间隔继续向其他节点发心跳。在图19.16(b)中,假如n2末给nl
响应信息,n1则把n2从自己的列表中删除。 BackupManager使用经典的轮询算法选择备份节点,
它属于平均分配算法,按顺序依次选择节点。例如,集群一共有 Nodel、Node2、Node3三个节点,
Nodel将 Session 1备份到Node2,而 Session2则备份到Node3。对于节点信息列表, Backup Manager
使用 HashMap< Member,,Long≥结构保存, Member是包含了节点信息属性的节点抽象,Long是指节
点最新的存活时间,在做心跳时就根据最新的存活时间和超时阀值判断节点是否失效。
n2信息
n信息
n1信息
信息
n3信息
MapEntry
n1信息
n1信息
Member backupNodes
n1信息
n1信息
Member primary
Object key:
n4信息
n4信息
Object value
n4
图19.15 MapEntry
▲图19.16集群节点信息
297第19章多样化的会话管理器
通信的协议及信息载体由 MapMessage类定义。通信协议其实就是通信双方约定的语义,它
定义的常量包括 MSG BACKUP、 MSG RETRIEVE BACKUP、 MSG PROXY、 MSG REMOVE、
MSG STATE、 MSG START、 MSG STOP、 MSG INIT、 MSG COPY、 MSG STATE COPY、
MSG ACCESS}。这里,每个值都代表一个语义。例如, MSG BACKUP表示让接收方把接收
到的会话对象进行备份, MSG REMOVE则表示让接收方按照接收到的会话ID把对应的会话
删除。除此之外 MapMessage类还包含 valuedata(byte[)、 keydata(byte)、 nodes( Member[)、
primary( Member),它们分别表示会话对象字节流、会话ID字节流、备份节点、源节点。这样
一来,所有要素都有了,在备份操作中, MapMessage对象就像组成一个句子:“本人会话ID
为 keydata,会话值为 valuedata,我的源节点为 primary,我现在需要做备份操作。”
另外,序列化与反序列化工作交由JDK的 ObjectInputStream、 ObjectOutputStream完成,
而复杂的网络IO则交由 Tribes通信框架完成。
源节点、备份节点、代理节点分别代表什么意思?每个集群每个会话只有一个源节点、
个备份节点、若干个代理节点。在图19.17中,Node为源节点,会话对象由它创建,它保存
的是会话对象的原件;Node3为备份节点,它保存的是会话对象的备份件;Node2和Node4
为代理节点,它们保存的仅仅是会话位置信息,例如备份节点Node3的机器的IP。这样分类
是为了提供故障转移能力。想象一下下面的场景。
Node3
(备份节点)
Node l
Node2
(源节点)
(代理节点)
(代理节点)
▲图19.17集群节点
①假如刚好源节点宕机,请求落到备份节点,则能获取到会话对象,此时备份节点
变为源节点,再从Node2、Node4中选一个作为备份节点,并且把会话对象复制到新备份
节点上。
②假如备份节点宕机,请求一样能从源节点获取到会话对象,但此时会从Node2、Node4
中选一个新备份节点,并把会话对象复制到新备份节点上。
③假如代理节点宕机了,一切没影响,正常工作。
搞清楚上面介绍的基本原理后,再看看 Lazy replicatedMap具体是如何将会话对象既存储
在本地又跨节点备份。
首先,看它如何通过调用put方法进行保存。put操作的伪代码如下。
298197集群备份会话管理器— BackupManager
public Object put(Object key, Object value)
①实例化 MapEntry,将Key和vaue传入,传入的参数Key为会话ID, Value为会话对象,并设
置源节点为目前节点。
②判断会话集中是否已包含Key,如果已存在,则要删除本地及备份节点上的会话。
③通过轮询算法从 MapMember中选择一个作为备份节点,并赋值给 MapEntry对象的备份节点属性。
④实例化一个包含 MSG BACKUP标识的 MapMessage对象并发送给备份节点,告诉备份节点要备份这
里传过来的这个会话信息。
⑤实例化一个包含MSG_ PROXY标识的 MapMessage对象并发送给除了备份节点外的其他(代理)节
点,告诉它们“你们是代理,请记录此会话的ID、源节点、备份节点等信息
6把 Mapentry对象放进本地缓存中。
其次,再看看它通过get获取会话对象操作的伪代码。
public object get(Object key) t
①获取本地的 Mapentry对象,它或许直接包含了会话对象,或许包含了会话对象的存放位置信息。
②判断该节点是否属于源节点,如果为源节点,则直接获取 Mapentry对象里面的会话对象并返回。
③判断该节点是否属于备份节点,若为备份节点,则直接获取 Mapentry对象里面的会话对象作为返
回对象,并且还要将该节点升为源节点,重新选取一个新备份节点,把 MapEntry对象复制到新备份
节点中。
④判断该节点是否属于代理节点,若为代理节点,则向其他节点发送会话对象复制请求,“如果集群中某
节点有此会话对象,请发送给我”,把接收到的会话对象放到该节点并作为返回对象,最后将本节点升为
源节点。
最后,看看会话对象 remove操作的实现。
public object remove(Object key)(
①删除本地的 MapEntry对象。
②向其他节点广播,删除 MapEntry对象。
上面三个方法已经很清晰地描述了新的Map是如何进行跨节点的增、删、改、查的,
BackupManager就是通过这个新的Map进行会话管理的。
19.72高可用性及故障转移机制
集群要提供髙可用性就必须要有某种杋制去保证。常用的杋制为故障转移,简单说,就是
通过一定的心跳检测是否有故障,一旦故障发生,备份节点则接管故障节点的工作。下面看看
BackupManager如何实现故障转移能力。
使用 Backup Manager管理会话必须要有负载均衡器,它提供会话黏贴( Session stick)机
制。所谓会话黏贴其实是一种会话定位技术,即在 Tomcat节点上生成一种包含位置信息的会
话⑩D,它一般附带了 Tomcat实例名,当客户端再次请求时,负载均衡器会解析会话I中的
299第19章多样化的会话管理器
位置信息并转发到响应节点上。例如,在图19.18中,如果客户端1的请求解析出 tomcat I则
把请求转到 tomcat,,如果解析出 tomcat.3则转到 tomcat3,如果使用 Apache作为 Load balancer
则可以使用 Mod JK实现会话黏贴
服务器端
实例
sessionid. tomcat l
服务器端
tomcat
apach
实例
客户端1
服务器端
tomcat
实例
客户端2
▲图19.18会话黏贴
如图19.19所示,看看在不同的故障情况下 BackupManager会话管理器是如何让故障不影
响整体的可用性的。客户端1的一个请求会话包含了 tomcat I信息,通过 Apache负载均衡器
后定位到集群的 tomcat节点,此客户端对应的会话标识为id1。会话备份件存放在 tomcat2
节点上,假如 tomcat l一直运行得很好,那么客户端每次的请求都将到此节点处理。此节点包
含了用户的会话对象,所以涉及会话的逻辑运算都没问题。但假设集群中有节点发生故障而宕
机了,这时的故障转移机制应该如何考虑?
服务器
服务器
tomcat
fid, ip)
tomcat
备份sls2
sessionid. tomcat l
备份
备份s3
Apache
服务器
一服务器
tomcat 3
tomcat
备份s4s5
▲图19.19 BackupManager的故障转移
300197集群备份会话管理器— BackupManager
1)若 tomcat3或 tomcat44宕机了,请求依然转发到 tomcat,无须做任何额外处理。
2)若 tomcat2宕机了,请求依然转发到 tomcat,涉及会话相关处理的逻辑仍然正常,但 tomcat I
需要做一些额外工作,包括新备份节点选取,把会话备份到新节点上等。
3)若 tomcat1宕机了,请求可能转发到其他任意节点。具体分两种情况。
①转发到备份节点tmca2上,这能找到对应的会话备份件,其中涉及会话的运算逻辑
正常,但它需要做一些额外工作,包括将自己升为源节点,从 tomcat3或 tomcat4中选一个备
份节点,将会话备份到选出的节点。
②转发到代理节点 tomcat3或 tomcat4上,由于不能在本地找到对应的会话对象,因此它
要根据会话的位置信息向 tomcat2获取会话对象。此外,再将自己升为源节点。
Backup Manager的整个故障转移机制比较清晰明了,可能有一点会产生疑惑,某个节
点宕机后,由它生成的会话经过 Apache会分发到哪些节点?会不会随机分发?例如,若
tomcat宕机,把 sessionid. tomcat l会话的第一次请求转发到 tomcat3,第二次请求会转发
到哪里?实际情况是它会一直转发到 tomcat3,因为 Tomcat在整个处理过程中存在一个
JvmRoute Binder valve阀门,它的作用是提供检测会话路由的功能。当它检测到会话的会
话ID包含的路由信息非本地JVM时,它将会对其进行更改。例如,把 sessionid. tomcat
转发到 tomcat3时,它会修改为 sessionid. tomcat.3,也正是有此保证,才得以实现
Backup Manager的故障转移机制。
19.73集群RPC通信
RPC即远程过程调用,它的提出旨在消除通信细节,屏蔽繁杂且易错的底层网络通信操
作,像调用本地服务一般地调用远程服务,让业务开发者更多关注业务开发,而不必考虑网络、
硬件、系统的异构复杂环境。
同样,在 Tomcat集群中会话对象互相复制会涉及各种逻辑处理及网络IO操作。为
避免重复的网络通信编码及方便更加关注上层逻辑处理,在会话同步组件中提供了RPC
方式供集群各节点之间通信,例如做心跳测试,向集群广播请求后只接受第一个应答节
点的信息等。
先看看集群中RPC的整个通信过程,为更加形象且容易理解整个过程,结合图19,20看
看每个步骤,假设从节点 nodel开始一个RPC调用。
①先将待传递的数据放到NO集群通信框架(这里使用的是 Tribes框架)中。
②由于使用的是NO模式,线程无须阻塞直接返回。
③由于与集群中其他节点通信需要占用若干时间,因此为了提高CPU使用率,当前线程
应该放弃CPU的使用权进行等待操作。
④NIO集群通信框架 Tribes接收到Node2节点的响应消息,并将消息封装成 Response
对象保存至响应数组中。
301第19章多样化的会话管理器
你的
NIO
发送
④接收
应答
①放入
Node2
发送
②2返回
⑥接收
应答
Nodel RPC
Node3
③放弃CPU使用
权并等待
⑤接收八
发送
应答
Node4
⑦通知线程
Response
▲图19.20集群RPC通信
⑤ Tribes接收到Node4节点的响应消息,因为使用了并行通信,所以Node4可能比Node3
先返回消息,并将消息封装成 Response对象保存至响应数组中
⑥ Tribes最后接收到Node3节点的响应消息,并将消息封装成 Response对象保存至响应
数组中。
⑦现在所有节点的响应都已经收集完毕,是时候通知刚刚阻塞的那条线程了,原来
的线程被唤醒后,接收到所有节点的响应 Response进行处理,至此完成了整个集群RPC
过程。
上面的整个过程是在只有一条线程的情况下实现的,一切看起来没什么问题,但如果有多
条线程并发调用则会导致一个问题:线程与响应的对应关系将被打乱,无法确定哪个线程对应
哪几个响应。因为NIO通信框架不会为每个线程都独自使用一个套接字通道,所以为提高性
能,一般都使用长连接,所有线程共用一个套接字通道。这时,就算线程1比线程2先放入
Tribes也不能保证响应1比响应2先接收到,所以接收到响应1后不知道该通知线程1还是线
程2。只有解决了这个问题,才能保证RPC调用的正确性。
要解决线程与响应对应的问题,就需要维护一个线程响应关系列表,响应从关系列表中就
能查找对应的线程。图1921中,在发送之前生成一个UUD标识,此标识要保证同套接字中
的唯一性。再把UUD与线程对象关系对应起来,这可使用Map数据结构实现,UUID的值
作为键,线程对应的锁对象为值。接着制定一个协议报文,UUID作为报文的其中一部分,报
文发往另一个节点Node2后,将响应消息放入报文中并返回, Nodel对接收到的报文进行解
包,再根据UUID查找并唤起对应的线程,告诉它“你要的消息已经收到,请往下处理”。但
在集群环境下,我们更希望集群中所有节点的消息都接收到了才往下处理。如图1921中的半
部分,一个UUID1的请求报文会发往Node2、Node3和Node4三个节点,这时假如只接收到
个响应则不唤起线程,直到Node2、Node3对应UUD1的响应报文都接收到后,才唤起对
应线程往下执行。同样地,UUID2、UUID3的报文消息都是如此处理。最后,集群中对应的
响应都能正确回到各自的线程上。
下面用简单的代码实现一个RPC例子,根据实际情况选择一个集群通信框架负责底层通
30219.7集群备份会话管理器— BackupManager
信,这里使用 Tribes。接着往下介绍。
UUID
UUID2
Nodel
Node2
NIO
UUD消息
2消息
UUIDI
Node?
Nodel
UUID2
Node3
UUID3
▲图19.21线程与响应对应关系
①定义一个RPC接口,这些方法是预留提供给上层具体逻辑处理的入口, reply Request
方法用于处理响应逻辑, leftover方法用于残留请求的逻辑处理。
public interface RpcCallback
public Serializable replyRequest (Serializable msg, Member sender)i
public void leftover(Serializable msg, Member sender)i
②定义通信消息协议,使 Externalizable接口自定义序列化和反序列化, message用于存
放响应消息,uuid标识用于关联线程, pald用于标识RPC实例, reply表示是否回复。
public class RpcMessage implements Externalizable
protected Serializable messagei
protected byte[] uuid
protected byte[] rpcIdi
protected boolean reply false;
public RpcMessage()t
public RpcMessage(byte[] rpcId, byte[ uuid, Serializable message
this. rpcId= rpcIdi
this uuid uuid:
this message messagei
303第19章多样化的会话管理器
@Override
public void readExternal(ObjectInput in)throws IOException,
ClassNot FoundException i
reply in. readBoolean ()i
int length in readInt()i
uuid= new byte [length]i
in. readFully(uuid)i
length in readInt()i
rpcId new byte [length]i
in. readFully(rpcId)i
message =(Serializable) in readobject()i
@override
public void writeExternal(Objectoutput out) throws IOException t
out writeBoolean(reply)i
out. writeInt(uuid length)i
out write(uuid, 0, uuidlength)i
out. writeInt(rpcId. length)i
out write(rpcId, 0, rpcId length)i
out writeobject(message)i
③响应类型,提供多种唤起线程的条件。一共有4种类型,分别表示接收到第一个响应
就唤起线程,接收到集群中大多数节点的响应就唤起线程,接收到集群中所有节点的响应才唤
起线程,无须等待响应的无响应模式。
public class RpcResponse Type i
public static final int FIRST_ REPLY = 1i
public static final int MAJORITY_ REPLY = 2i
public static final int ALL_REPLY =3;
public static final int NO_REPLY =4
④响应对象,用于封装接收到的消息, Member在通信框架 Tribes中是节点的抽象,这
里它用来表示来源节点
public class RpcResponse i
private Member source;
private Serializable messagei
public RpcResponse() i
public RpcResponse(Member source, Serializable message) i
this source source;
this. message message
30419.7集群备份会话管理器— BackupManager
public void setSource(Member source)(
this source
sourcei
public void setMessage(Serializable message)
this message messagei
public Member getSource()i
return sourcei
public Serializable getMessage()
return message;
⑤RPC响应集,用于存放同一个UUID的所有响应。
public class Rpccollector
public Arraylist<RpcResponse> responses= new ArrayList<RpcResponse>()i
public byte[] keyi
public int options
public int destcnti
public Rpccollector(byte[] key, int options, int destcnt) t
this key keyi
this options options
this. destcnt destcnt
public void addResponse(Serializable message, Member sender)(
RpcResponse resp new RpcResponse(sender, message)i
responses. add(resp)
public boolean isComplete()[
if( destcnt <=0 return truei
switch (options)
case RpcResponseType ALL REPLY
return destcnt = responses size()i
case RpcResponseType. MAUORITY_ REPLY:
float perc =((float)responses. size())/((float)destcnt)
return perc >=0. 50fi
case RpcResponseType FIRST_ REPLY:
return responses. size()>0i
default
return false;
305第19章多样化的会话管理器
public RpcResponse[] getResponses() t
return responses. toArray(new RpcResponse [responses. size()I
⑥RPC核心类,是整个RPC的抽象,它要实现 Tribes框架的 ChannelListener接口,在
messageReceived方法中处理接收到的消息。因为所有的消息都会通过此方法,所以它必须要
根据键处理对应的线程。同时,它也要负责调用 RpcCallback接口定义的相关的方法。例如,
响应请求的 reply request方法和处理残留的响应 leftover方法。残留响应是指有时我们在接收
到第一个响应后就唤起线程。
public class RpcChannel implements ChannelListener i
private Channel channeli
private RpcCallback callback
private byte[ rpcIdi
private int repl yMes sageOptions =0;
private HashMap<byte [], Rpccollector> responseMap = new HashMap<byte [
Rpccollector>()
public RpcChannel(byte [ rpcId, Channel channel, RpcCallback callback)i
this. rpcId rpcId;
this channel= channel
this callback callback
channel. addChannellistener(this)i
public RpcResponse[] send(Member[] destination, Serializable message,
int rpcOptions, int channeloptions, long timeout
throws ChannelException t
int sendOptions channeloptions& -Channel. SEND OPTIONS SYNCHRONIZED ACK;
byte[] key UUIDGenerator. randomUUID(false)i
RpcCollector collector new RpcCollector(key, rpcoptions,
destination. length)i
ry
synchronized (collector) t
if (rpcOptions !=RpcResponse Type NO_ REPLY
responseMap put(key, collector)i
RpcMessage rmsg = new RpcMessage(rpcId, key, message)i
channel. send (destination, rmsg, sendoptions)i
if (rpcOptions !=RpcResponse Type NO_REPLY
collector. wait(timeout)
catch (InterruptedException ix)
Thread currentThread().interrupt()i
y finally i
responseMap remove(key)i
306197集群备份会话管理器— BackupManager
return collector. getResponses()i
@override
public void messageReceived(Serializable msg, Member sender
RpcMessage rmsg=(RpcMes sage) msg
byte[] key rmsg uuid
if (rmsg. reply) i
RpcCollector collector responseMap get(key)i
if (collector = null
callbackleftover(rmsg message, sender)i
s else
synchronized (collector) i
if (responseMap containsKey(key))(
collector addResponse(rmsg message, sender)i
if (collector iscomplete())
collector notifyAll();
else i
callback leftover(rmsg message, sender)i
t else i
Serializable reply =callback. replyRequest(rmsg message, sender);
rmsg reply =true;
rmsg. message reply;
try i
channel. send (new Member[]( sender ) rmsg, repl yMessageOptions
Channel SEND OPTIONS SYNCHRONI ZED ACK)i
t catch (Exception x)
@override
public boolean accept(Serializable msg, Member sender)i
if (msg instanceof RpcMes sage)(
RpcMessage rmsg =(RpcMessage)msg;
return Arrays. equals(rmsg. rpcId, rpcid)i
e⊥se
return false
⑦自定义一个RPC,它要实现 RpcCallback接口,分别对请求处理和残留响应处理。这
里请求处理仅仅返回“hell, response for you!”作为响应消息,残留响应处理则是仅输出“ receive
a leftover message!”。假如整个集群中有5个节点,由于接收模式设置成 FIRST REPLY,因此
307第19章多样化的会话管理器
每个节点只会接收一个响应消息,其他的响应都被当做残留响应处理。
public class myrpc implements RpcCallback
@override
public Serializable replyRequest(Serializable msg, Member sender) t
RpcMessage mapmsg =(RpcMessage) msgi
mapmsg message hello, response for you! i
return mapmsg
@Override
public void leftover(Serializable msg, Member sender)
System. out. println("receive a leftover message! ")i
public static void main(string[] args)
MYRPC myRPC new MyRPC ()i
byte[] rpcId new byte[]f 1, 1, 1, 1 i
byte[] key new byte[][ 0,0,0,0 ji
String message =hello"i
nt sendoptions= Channel. SEND_OPTIONS_ SYNCHRONI ZED_ ACK
I Channel. SEND OPTIONS USE ACK;
RpcMessage msg= new RpcMessage (rpcId, key, (Serializable) message)i
RpcChannel rpcChannel= new RpcChannel(rpcId, channel, myRPC)i
RpcResponse [] resp rpcChannel send(channel getMembers(), msg,
RpcResponseType. FIRST_ REPLY, sendoptions,3000)
while(true)
Thread currentThread(). sleep(1000)i
可以看到通过上面的RPC封装后,上层可以把更多的精力放到消息逻辑处理上面,而
不必关注具体的网络ⅠO如何实现。这屏蔽了繁杂重复的网络传输操作,为上层提供了很
大的方便。
198T0mGa会话管理器的集成
前面已经介绍了 Tomcat中所有的会话管理器,包括标准会话管理器、持久化会话管理器、
集群增量会话管理器、集群备份会话管理器。它们为用户提供了各种功能的会话管理器,有非
持久化模式的,也有持久化模式的,有集群全量复制模式的,也有集群备份模式。在不同场景
中,用户根据实际情况可以选择不同的会话管理器。为了方便使用,需要提供一种简易的方法,
Tomcat提供的是配置方式,你只须通过对配置文件进行配置即可完成对会话管理器的选择。
下面看看 Tomcat是如何完成配置的
在程序层面上,为了让会话管理器实现可配置化,它需要定义一个统一的管理接口— Manager
30819.8 Tomcat会话管理器的集成
接口。其他具体的管理器通过实现此接口实现动态实例化。例如,可以根据配置文件判断具体实例
化哪个管理器。唯一要做的就是要定义 Manager接口的方法。如图19.22所示,4种会话管理器都
由 Manager接口统管理,再分别实现后,使它们能完整嵌入 Tomcat容器。
Catalina
管理器
StandardManager Persistent Manager Delta Manager BackupManager
▲图19.224种会话管理器
下面讨论需要定义哪些重要的方法。创建会话使用 createSession方法,添加会话使用add
方法,查找会话使用 findSession方法,删除会话使用 remove方法,载入会话使用load方法,
卸载会话使用 unload方法,执行后台任务使用 backgroundProcess方法。除此之外,还会提供
其他涉及会话管理器属性的各种方法,包括会话失效最大间隔、会话DD长度、会话最大活跃
数、创建会话的累计数、失效会话数、拒绝生成会话数、会话最大存活时间、会话生成速率、
会话失效速率、是否支持分布式会话。根据这些定义好的接口方法,4个会话管理器
StandardManager、 PersistentManager、 DeltaManager和 Backup Manager实现接口的方法。例如,
createSession方法的具体实现中,标准管理器和持久化管理器只须在本地创建会话即可,而对
于增量管理器和备份管理器,这些分布式管理器则要通过一定的通信在集群指定节点上创建会
话。当这些管理器都按照定义的 Manager接口实现后,即可实现动态实例化
Tomcat容器中整个组件的实例化是通过 Digester框架组织起来的,它负责将配置文件转
化成对应描述的对象。同样,作为重要的组件之一,会话管理器也通过配置完成实例化。只要
在代码中存在这4种会话管理器类,就可以通过配置指定类进行实例化。
首先,对于 StandardManager,它属于 Tomcat默认的会话管理器,可以通过 server xml显式配置,
也可不配置,而容器会默认使用 StandardManager类进行实例化,显式配置是在< Context>节点下添
加一个子节点 Manager className" org.ap
g. apache. catalina. session. StandardManager"
其次,对于 PersistentManager,如要使用它,就必须通过配置 server.xml文件在< Context>
节点下添加一个子节点。
<Manager className="org. apache. catalina. session. PersistentManager>
<Store className="org. apache. catalina. session. Filestore" directory="mydir"/>
</Manager>
即会将会话以一定的策略持久化到Web应用根目录的 mydir目录下。
再次,对于 DeltaManager,可通过配置 server. Xm文件使用它。在 Tomcat中使用集群模
309第19章多样化的会话管理器
式需要在< Engine>节点下添加< cluster>节点,而 DeltaManager正是在此节点下添加一个子节点
<Manager className="org. apache. catalina. ha. session DeltaManager)>
最后,对于 Backup Manager,可通过配置 server xml文件使用它。它的配置与 DeltaManager
的配置基本相似,在< cluster节点下添加一个子节点< Manager className=" org. apache. catalina
ha. session. BackupManager">
Tomcat在会话管理方面提供了很强的模块化功能,而这些功能的模块化、可配置化让用
户使用起来相当简易方便。可以看到 Tomcat一共提供了4种类型的会话管理器,这些会话管
理器并不是刚开始就一并设计的,而是根据实际需求发展而来的。
310第20章高可用的集群实现
对于Web容器来说,在请求是无状态的情况下,如果实现做集群功能其是非常简单的,
只须把机器连接到具备一定分发策略的分发器上即实现集群功能,同时也要保证这个分发器必
须具备故障转移能力。后面需要多少机器的集群直接往上堆就行了,不但达到负载均衡效果,
而且达到了高可用效果。
实际情况并没有这么简单,因为很多请求都是有状态的,简单来说,就是请求与会话相关,
服务器端是根据 Cookie的 jsessionid查找对应的内存记录,假如请求刚好被分发到有此
SessionId的机器,则不存在问题,但如果分到了其他机器上,则会由于査不到记录而导致问
题。集群主要解决的就是这种有状态的情形。
Tomcat中使用了自己的 Tribes组件实现集群之间的通信,第21章会对其通信的一些细节
进行了深入剖析。由于集群通信都是重复性的工作而且独立性比较强,因此这块逻辑被 Tomcat
单独抽离出来了。对于 Tomcat,它需要一个更高层次的抽象,而不是直接使用 Tribes组件,
所以这就有了 Cluster组件, Cluster组件将集群相关的所有组件都封裝起来以实现集群功能。
下面就讨论 Tomcat中的集群。
201从单机到集群的会话管理
20.1.1单机模式
单机时代对会话的管理主要有两种方式—非持久化方式和持久化方式。非持久化方式指
会话直接由 Tomcat管理并保存在机器内存上,它是最简单的方式。如图20.1所示,所有的会
话集合都保存在内存上,客户端访问时根据自己的会话ID直接在服务器内存中寻找,查找简
单且速度快。但非持久化方式同时也存在两个缺点:容量比较小,当数据量大时,容易导致内
存不足;机器意外停止会导致会话数据丢失。
为了解决非持久化方式存在的缺陷,我们需要引入持久化机制,即持久化方式。持久化方
式可以将会话数据以文件形式持久化到硬盘中,也可以通过数据库持久化会话数据。首先看硬
盘持久化。如图20.2所示,会话数据会以文件形式保存在硬盘中。因为硬盘存储空间比内存
大且机器意外关机都不会使数据丢失,所以硬盘存储解决了非持久化方式中的两个缺点。但是第20章高可用的集群实现
硬盘读取的速度比较慢,可能会影响整体的响应时间,因此硬盘持久化方式在实际中基本不会
使用
服务器
tomcat实例
sessionid
状态
状态
状态
▲图20.1非持久化会话
服务器
tomcat实例
sessionid
disk
▲图20.2硬盘持久化会话
Tomcat提供的另外一种默认的持久化方式就是将会话数据持久化到数据库上。如图20.3
所示,所有会话数据交由数据库存储, Tomcat通过JDBC数据库驱动程序并使用连接池技术
从数据库指定表中读取会话信息。此种方式避免了非持久化方式的所有缺点,同时也对以文件
方式存储方式的IO进行了优化。用数据库存储会话其实是一种集中管理模式,现在实际中更
多地使用一个分布式缓存替代数据库,例如 Memcached、 Redis集群等,因为缓存的查询读取
速度快,且集群解决了高可用性的问题,但 Tomcat官方版本不提供会话保存到 Memcached或
Redis的支持。如要使用,可自己编写一个会话管理器及一个阀门或使用第三方Jar包。需要
说明的是,不管是 Tomcat单机还是集群模式,都可以使用集中管理模式。
服务器
tomcat实例
sessionid
图20.3数据库持久化会话
31220.1从单机到集群的会话管理
20.1.2集群模式
为什么要使用集群?主要有两方面原因。一是对于一些核心系统,要求长期不能中断服务,
为了提供高可用性,我们需要由多台机器组成的集群。另外一方面,随着访问量越来越大且业
务逻辑越来越复杂,单台杋器的处理能力已经不足以处理如此多且复杂的逻辑,于是需要增加
若干台机器使整个服务处理能力得到提升。
如果一个Web应用不涉及会话,那么实现集群是相当简单的,因为节点都是无状态的,
集群内各个节点无须互相通信,只需要将各个请求均匀分配到集群节点即可。但基本上所有
Web应用都会使用会话机制,所以实现Web应用集群时的整个难点在于会话数据的同步。当
然,可以通过一些策略规避复杂的额数据同步操作,例如,前面说到的把会话信息保存在分布
式缓存或数据库中,便于统一集中管理。如图20.4所示,每个 Tomcat实例只须写入或读取数
据库即可,这避免了 Tomcat集群之间的通信。但这种方式也有不足,要额外引入数据库或缓
存服务,同时也要保证它们的高可用性,这增加了机器和维护的成本。
服务器
tomcat实例
sessionS
服务器
服务器
omat实例
服务器
tomcat实例
▲图20.4集群数据库会话
鉴于以上存在的不足,另一种解决思路就是 Tomcat集群节点自身完成各自的数据同步,
不管访问到哪个节点都能找到对应的会话。在图20.5中,客户端第一次访问时生成会话, Tomcat
自身会将会话信息同步到其他节点上,而且每次请求完成都会同步此次请求过程中对会话的所有
操作,这样一来,下一次请求到集群中任意节点,都能找到响应的会话信息,且能保证信息的及
时性。细看很容易发现,集群中节点之间的会话是两两互相复制的,一旦集群中节点数量及访问
量变大,将导致大量的会话信息需要互相复制同步,这很容易导致网络阻塞,而且这些同步操作
很可能会成为整体性能的瓶颈。根据经验,此种方案在实际中推荐的集群节点个数为3~6个,无
法组建更大的集群,而且存在大量冗余的数据,利用率不高。
全节点复制的网络流量随节点数量增加呈平方趋势增长,也正是因为这个因素,导致无法构建
较大规模的集群。为了使集群节点能更加大,首先要解决的就是复制数据时流量増长的问题。下面
313第20章高可用的集群实现
将介绍另外一种会话管理方式。其中,每个会话只会有一个备份,它使会话备份的网络流量随节点
数量的增加呈线性趋势增长,大大减少了网络流量和逻辑操作,可用于构建较大的集群。
服务器
服务器
tomcat实例
tomcat实例
sessionid
服务器y
服务器
tomcat实例
tomcat实例
▲图20.5集群会话复制
下面介绍会话备份方式具体的工作机制。集群一般通过负载均衡对外提供整体服务,所有节
点隐藏在后端组成一个整体。前面各种集群模式的实现都无须负载均衡协助,但现在讨论的集群
方式则需要负载均衡器的协助。最常见的负载方式是前面用 Apache拖所有节点,它支持将类似
“326257DA6DB76F8D2E38F2C4540 DIDEA tomcat1”的会话D进行分解,并定位到 Tomcat集群
中以 tomcat命名的节点上。每个会话存在一个原件和一个备份,且备份与原件不会保存在同
个节点上。如图20.6所示,当客户端发起请求后,通过负载均衡把它分发到 tomcat实例节点上,
生成一个包含 tomcat后缀的会话标识,并且 tomcat节点根据一定策略选出此次会话对象备份的
节点,然后将包含了{会话id,备份i}的信息发送给 tomcat2、 tomcat3、 tomcat4+,如图206中虚
线所示,这样每个节点都有一个会话i、备份i列表,即每个节点都有每个会话的备份j地址。
服务器
服务器
tomcat
Hid, ip)
tomcat
备份sl/s2
sessionid. tomcat
备份S6
Apache
备份S3
服务器
服务器
tomcat
tomcat4
备份s4s5
图20.6集群会话备份
31420.2 Cluster组件
完成上面一步后,就将会话内容备份到备份节点上。假如 tomcat1的s1、s2两个会话的备
份地址为 tomcat2,则把会话对象备份到 tomcat.2中。类似地, tomcat2把s3会话备份到 tomcat4
中, tomcat4把s4、s5两个对话备份到 tomcat3中,这样集群中所有的会话都已经有了一份备
份。只要 tomcat一直不出故障,会话黏贴机制就保证客户端将一直访问到 tomcat1节点上,
直能获取到会话。而当 tomcat出故障时, Tomcat也提供了一个故障转移机制, Apache感
知到后端集群 tomcat1节点被移除了,这时它会把请求随机分配到其他任意节点上。接下来,
会有两种情况。
〉假如请求刚好分到了备份节点 tomcat2上,此时仍能获取到sl会话。除此之外, tomcat2
另外做的事是将这个sl会话标记为原件且继续选取一个备份地址备份s1会话,这样,它
又有了备份。
假如分到了非备份节点 tomcat3上,此时肯定找不到sl会话,于是它将向集群所有节点询
问:“请问谁有s1会话的备份j地址信息?”因为只有 tomcat2有sl的备份地址信息,所
以它接收到询问后应答,告知 tomcat3节点s1会话的备份在 tomcat2上,根据这个信息就
能查到s1会话,并且 tomcat3在本地生成sl会话并标为原件, tomcat2上的副本不变,这
样一来,同样能找到s1会话,正常完成整个请求处理。
虽然这种模式支持更大的集群,但它也有自己的缺点,例如,它只有一个数据备份,假如刚好
源数据和备份数据所在的机器同时宕机了,则没办法恢复数据。不过,刚好同时宕机的概率很小。
本节从单机到集群分析了Web服务器的会话管理的不同模型,其中包含了单机非持久化、
单机文件持久化、单机数据库(缓存)持久化、集群数据库(缓存)、集群全节点复制、集群
原件副本备份等。本节还分析了不同模型的工作原理及优缺点,深入理解各种会话管理模式对
于实际项目的会话方案选型有很大的帮助。
202 Huster组件
Cluster其实就是集群的意思,它是为了更方便上层调用而抽象出来的一个比较高层次
的一个概念。总的来说,它最重要的两个接口就是发送和接收接口。对于 Cluster来说,它
可以让你不必关心集群之间如何通信、与谁通信,你只要调用 Cluster接口将消息发送出去
即完成了集群内消息的传递。 Cluster的抽象将各种繁杂的细节屏蔽了,使我们能很容易实
现集群通信。
如图20.7所示, Cluster组件包含(或者说关联)的组件包括:会话管理器、集群通信通
道、部署器( Deployer)、集群监听器( Clusterlistener)、集群阀门等。下面将对每个组件进
步介绍。
Tomcat的 Cluster模块主要的功能是提供会话复制、上下文属性的复制和在集群下的web
应用部署。这些操作都存在跨节点问题。默认的集群组件实现为 SimpleTcp Cluster,
SimpleTcp Cluster使用组播作为集群通信方式,它提供组播发射器和接收器用于消息的传递。
315第20章高可用的集群实现
Cluster
会话管理器
通道
部署器
群集监听器
阀门
▲图20.7 Cluster结构
集群会话管理器
会话管理器主要用于管理集群中的会话。这些会话都涉及跨节点操作,包括 DeltaManager
和 Backup Manager两个会话管理器,这两个会话管理器也是 Tomcat集群中目前可选的两种自
带会话管理器。
集群通信通道
通道是集群之间的通道组件。它是一个代表消息传递的通道的抽象,通道默认的实现为
Group Channel,即意为群组通道。通道是一个比较复杂组件,它其实是 Tribes组件封装的一个
对象,它可能包含若干个监听器和拦截器。对数据的发送只须调用通道的发送方法,而数据的
接收则在监听器中实现,每当接收到数据都会调 Channellistener进行处理。
集群部署器
集群部署器主要用于集群内的应用部署。默认的实现是 Farm War Deployer,,它可以帮你自
动在集群的其他实例上部署或卸载应用。在集群中可以任意选择一个实例作为管理实例,它通
过对某个目录的监听实现集群对应用部署的自动同步功能。
更多的实现细节可以参考第21章。
集群监听器
集群监听器用于监听集群消息,一旦接收到集群其他实例发过来的消息,所有集群监听器
监听的 messageReceived方法会被调用。默认情况下,会有两个监听器在启动时加入到 Cluster
中,它们分别是 JvmRoute SessionID BinderListener和 Cluster Session listener
Jvm Route SessionIDBinderlistener主要负责的工作是监听会话ID的变更。在使用
Backup Manager的情况下,当某节点失效后,为保证会话能被正确找到而更改会话ID,更改
后的会话ID会同步集群中其他节点。这个修改会话ID的工作就交由此监听器。它的逻辑相
当简单,当获取到 SessionIDMessage类型的消息时,通过原来的I从会话管理器中找到会话
对象,然后再通过会话的setd设置变更后的ID。这个监听器的作用主要是协助实现集群的故
障转移机制。
Cluster Session listener主要的工作就是处理从集群其他节点接收到的会话消息,例如,如
果其他节点新建或变更了会话,则会把这些变更后的会话发往其他节点进行同步,同步的逻辑
31620.3 Tomcat的 Cluster工作机制
则由这些监听器处理。
集群阀门
这里的阀门其实就是容器的管道处理机制中的阀门,它的逻辑在请求处理的过程中将会调
用。默认情况下有两个阀门,分别为 JvmRoute Binder Valve和 Replication Valve
Jvm Route Binder valve主要用于检测会话ID中的 jvmRoute是否正确,如果检查出异常则
做一些额外处理。在modj模式下,由于会话黏贴机制,会话ID为 xxxxx, tomcat l的会话会
发送到 tomcat l处理,但假如 tomcat刚好失效了,则可能随机转到其他节点。此时其他节点
就要将 xxxxx. tomcat1改为 xxxxX, tomcat,将此后该会话的请求都定位到 tomcat节点上。不
然,当 tomcat重新启动后,这些请求又分配到 tomcat。这个阀门的处理其实是与
JvmRouteSessionIDBinderListener监听器共同完成的。
Replication Valve主要负责的工作就是将请求处理后的会话对象进行集群同步。另外,它
有一个过滤器功能用于过滤是否需要同步。例如,对于HTML、CSS、JS等资源的请求。由
于这些静态资源的请求并不会操作会话,因此这些请求没必要触发集群会话同步。
203 Tomcat的啡sr工作机制
Cluster组件在 Tomcat中具体的工作流程是怎样的呢?浏览器发起一个涉及会话的请求的处理
步骤是什么?每个 Tomcat内部都包含了4个级别的容器,一般集群 Cluster组件集成在 Engine容器
中,此容器的标准实现为 Standard Engine。因为容器都使用了管道的处理模式,所以对会话的绑定
和复制工作等的逻辑需要以阀门形式添加进去,分别以 JvmRoute Binder Valve和 Replication valve作
为对应的阀门添加到管道中。当请求对象进入管道时,就会分别被管道的所有阀门处理。
如图20.8所示, Tomcat集群组件对一个请求的大致处理过程如下所示。
Engi
管道
响应
Standard
Engine valve
Context
④、 Wrapper Wrapper
Replication
Valve
请求
JymRoute
⑥
Binder valve
Cluster
图20.8 Cluster处理流程
317第20章高可用的集群实现
①客户端发送请求后被 Tomcat接收,成为一个 request对象传入 Engine容器准备处理。
②首先通过 JvmRoute Binder valve进行处理,对不符合的会话ID进行处理,最后再调用
下一个阀门。
③通过 Replication valve阀门继续处理,它会先调下一个阀门进行处理,之后才进行会话
数据集群同步。
④ StandardEngine valve调用其他子容器对请求进行处理,找到对应的 Servlet处理
响应客户端
⑥ Replication valve调用 Cluster组件将会话数据同步到集群其他实例上。
⑦把会话数据传输给其他实例。
204T0mcat中ser的级别
Tomcat的集群组件可以分成两个级别,分别为 Engine级别和Host级别,即 Cluster
组件可以放到 Engine容器中,也可以放到Host容器中。这也就意味着,如果是 Engine
级别,则整个集群组件由所有Host共享,如果是Host级别,则由该Host专享,其他Host
无法使用。
如图20.9所示,(a)图是 Engine容器的 Cluster之间的相互通信,而(b)图则是Host容
器的 Cluster之间的相互通信。
Engine
Engine
Host
luster Host
Engine
Engine
Host
H
Cluster
▲图20.9 Cluster级别
205如何让Tmat实现集群功能
在 Tomcat中使用集群功能相对简单。最简单的用法是直接在 server xml文件的< Engine>
或<Hos节点下添加< Cluster className=" org. apache. catalina. ha. tcp. SimpleTcpCluster"/>配置,
这意味着集群相关的配置都使用默认的。它其实等同于如下代码。
31820.5如何让 Tomcat实现集群功能
<Cluster className="org. apache. catalina. ha. tcp. SimpleTcpCluster
channelSend Options=8>
<Manager className="org. apache. catalina. ha. session. DeltaManager'
expireSessionsOnShutdown="false
notifyListenersOnReplication="true"/>
<Channel className="org. apache. catalina. tribes. group Group Channel">
<Membership className="org. apache. catalina. tribes. membership. Mcastservice
address="228.0.0.4
port="45564"
frequency=500
dropTime="3000/>
<Receiver className="org. apache. catalina. tribes. transport nio. NioReceiver"
address=auto
ort="4000"
autoBind=100"
selectortimeout=5000
maxThreads="6"/>
<Sender className=org. apache. catalina. tribes. transport. ReplicationTransmitter
<Transport className=org. apache. catalina. tribes. transport nio. PooledParall
elSener"/>
</Sender>
<Interceptor className="org. apache. catalina. tribes. group. interceptors. TcpFa
ilureDetector"/>
<Interceptor className="org. apache. catalina. tribes. group. interceptors, Messa
geDispatch15Interceptor"1>
</Channel>
<Valve className="org. apache. catalina. ha. tcp. ReplicationValve
filter=""/>
<Valve className="org. apache. catalina. ha. session. JvmRouteBinder Valve"/>
<Deployer className="org. apache. catalina. ha. deploy. FarmWarDeployer
tempDir=/tmp/war-temp
deployDir="/tmp/war-deploy
watchDir="/tmp/war-listen/
watchEnabled="false"/>
<ClusterListener className="org. apache. catalina. ha. session. UvmRoutesessionI
DBinderlistener>
<ClusterListener className="org. apache. catalina. ha. session. ClustersessionLl
stener>
</Cluster>
默认情况下,会使用 DeltaManager;会使用 Group Channel作为集群通信通道,组播地址和端
口为228004和4554:会使用 ReplicationTransmitter作为消息发射器;会使用 NioReceiver作为消
息接收器。另外,会添加 TcpFailureDetector. Message Dispatch15Interceptor两个拦截器;会使用
Replication Valve和 Jvm Route Binder valve两个管道阀门;会使用 Farm War Deployer作为集群部署器;
还会添加 JvmRouteSessionIDBinderListener和 Cluster Session listener集群监听器。
319第21章集群通信框架
21Ts简介
当把若干机器组合成一个集群时,集群为了使这些机器能协同工作,成员之间的通信是必
不可少的。当然,可以说这也是集群实现中重点需要解决的核心问题,一个强大的通信协同机
制是集群的基础。本章将对 Tomcat集群通信的核心组件 Tribes进行剖析。
简单地说, Tribes是一个具备让你通过网络向组成员发送和接收信息、动态检测其他节点
的组通信能力的高度可扩展和独立的消息框架。在组成员之间进行信息复制及成员维护是一个
相对复杂的事情,因为这不仅要考虑各种通信协议,还要有必要的机制提供不同的消息传输保
证级别,且成员关系的维护要及时准确。另外,针对不同IO场景需要提供不同的IO模式
这些都是组成员消息传输过程中需要深入考虑的几点。而 Tribes很好地将点对点、点对组的通
信抽象得既简单又相对灵活。
Tribes拥有消息可靠的传输机制,它默认基于TCP协议传输,TCP拥有三次握手机制保
证且有流量控制机制。另外,在应用层面的消息可靠性分为三个级别。
NO ACK级别,这是可靠级别最低的。使用此种级别时,则认为 Tribes一旦把消息发送给
Socket的发送队列,就认为发送成功,尽管传输过程中发生异常,导致接收方可能没有接
收到。当然,这种级别也是发送最快的方式
ACK级别,这是最推荐使用的一种级别。它能保证接收方肯定接能收到消息, Tribes向其他
节点发送消息后,只有接收到了接收者的确认消息,才会认为发送成功。这种确认机制能在更
高层面保证消息可靠性,不过发送效率会有影响,因为每个消息都需要确认,得不到确认的会
重发。
≯ SYNC ACK级别,这种级别不仅保证传输成功,还保证执行成功。 Tribes向其他节点发送
消息后,接收者接收到后并不马上返回ACK确认,而是对接收到的消息进行处理,直到
处理成功才返回ACK确认。如果接收成功而处理失败,接收者会返回 ACK FAIL给发送
者,发送者将会重发。当然,这种级别的消息发送效率是最低、最慢的。
整个 Tribes的设计核心可以用图21.1表示,在IO层有三个重要的模块。其中
Membership Service模块主要负责组成员关系的维护,包括维护现有成员及发现新成员,这些21.2集群成员维护服务— Membership Service
工作都是模块自动运行完成,你无须关心组成员的维护工作; ChannelSender模块负责向组内
其他成员发送消息及其各种机制的详细实现; ChannelReceiver模块用于接收组内其他成员发
送过来的消息及其各种机制的详细实现。消息的可靠性就是通过 ChannelSender及
Channelreceiver的协同得到不同级别的保证的。拦截器栈在消息传送到应用层之前对消息进
行一些额外的操作,例如,对某些信息进行过滤编码等操作。最后到应用层,多数情况下我们
只须关注应用层的东西即能使用,应用层面主要就是一些监听器,所以只要实现监听器里面指
定的方法即可以对IO层传输的消息做逻辑处理。
ChannelListener 1. ChannelListener N
MembershipListener-_1. MembershipLister
N应用层
Channellnterceptor_ I
拦截器栈
ChannelInterceptor M
Coordinate
Membership Service
ChannelSender
ChannelReceiver
l/O层
▲图21.1 Tribes设计核心
拦截器、监听器的引入都是经典的模式,抽象一个底层作为数据处理层,实现各种复杂的
通信及机制。而拦截器则是对底层数据的一种统一的额外加工处理。监听器则作为接口提供应
用层,以对数据做业务逻辑处理,进而组成一个优雅的设计方案。
212集群成员维护服务 MembershinService
个集群包含若干成员,要对这些成员进行管理,就必须要有一张包含所有成员的列表
当要对某个节点做操作时,通过这个列表可以准确找到该节点的地址,进而向该节点发送操作
消息。如何维护这张包含所有成员的列表是本节要讨论的主题。
成员维护是集群的基础功能,它一般划分一个独立模块或层完成此功能,它提供成员列表
查询、成员维护、成员列表改变事件通知等能力。由于 Tribes定位于基于同等节点之间的通信,
因此并不存在主节点选举的问题,它所要具备的功能是自动发现节点,即加入新节点后要通知
集群其他成员更新成员列表,让每个节点都能及时更新成员列表,每个节点都维护一份集群成
员表。如图21.2所示, Node l、Node2、Node3使用组播通过交换机各自已经维护一份成员列
表,且它们隔一段时间向交换机组播自己的节点消息,即心跳操作。当Node4加入集群组中
321aa““““++=
第21章集群通信框架
时,Node4向交换机组播自己的节点消息。原来的三个节点接收到后,各自把Node4加入到
各自的成员列表中。而原来的三个节点也不断向交换机发送节点消息,Node4接收到后,依次
更新成员列表信息,最终达到4个节点都拥有4个节点成员信息。
Node3
Node l
Node2
mI
交换机
mI
m2
m2
m
Node3
m4
Node I
Node2
交换机
2
m
m4
m4
Node4
m2
m4
▲图21.2集群成员的维护
322212集群成员维护服务—Membership Service
Tribes的集群是如何实现以上功能的?其成员列表的创建、维护基于经典的组播方式实
现,每个节点都创建一个节点信息发射器和节点信息接收器,让它们运行于独立的线程中。发
射器用于向组内发送自己节点的消息,而接收器则用于接收其他节点发送过来的节点消息并进
行处理。要使节点之间的通信能被识别就需要定义一个语义,即约定报文协议的结构。 Tribes
的成员报文是这样定义的,两个固定值用于表示报文的开始和结束,开始标识
TRIBES MBR BEGIN的值为字节数组84,82,73,66,69,83,45,66,1,0,结束标识
TRIBES MBR END的值为字节数组84,82,73,66,69,83,45,69,1,0。整个协议包的结构为
开始标识(10字节)+包长度(4字节)+存活时间(8字节)+TCP端口(4字节)+安全端口
(4字节)+UDP端口(4字节)+HOST长度(1字节)+HOST(n字节)+命令长度(4字节)
+命令(n字节)+域名长度(4字节)+域名(n字节)+唯一会话ID(16字节)+有效负载长
度(4字节)+有效负载(n字节)+结束标识(10字节)。成员发射器按照协议组织成包结构
并组播,接收器接收包并按照协议进行解包,根据包信息维护成员表。
下面用一段代码简单地展示实现过程,由于篇幅问题,包的处理省略了。
public class Mcastservice I
private MulticastSocket socket
private string address =228.0.0.4i
private int port =8000;
private InetAddress addr
private byte[] buffer new byte [20481
private DatagramPacket receive Packeti
private final Object sendLock new Object (i
public void start()i
try
addr= InetAddress getByName(address)i
receive Packet
new DatagramPacket (buffer, buffer length, addr,
port)i
socket joinGroup(addr)i
new ReceiverThread(. start()i
new Sender Thread(. start)i
catch (IOException e)(
public class ReceiverThread extends Thread
public void run()(
while (true)(
try t
receive(i
catch (ArrayIndexOutofBoundsException ax)(
323第21章集群通信框架
public class SenderThread extends Thread f
public void run() i
while (true)
try i
send(i
s catch (Exception x)
try i
Thread. sleep(1000);
1 catch (Exception ignore)
public void send() I
byte[]data=按照成员协议组织包结构;
DatagramPacket packet new DatagramPacket(data, data length, addr,
port)i
y
socket send (packet)
A catch (IOException e)
public void receive()(
try t
socket receive(receivePacket)i
解析成员报文
y catch (IOException e
首先,要执行加入组播成员的操作。接着,分别启动接收器线程、发射器线程,一般接收
器要优先启动。发射器每隔1秒组织协议包发送心跳,组播组内成员的接收器对接收到的协议
报文进行解析,按照一定的逻辑更新各自节点木地成员列表。如果成员表已包含协议包的成员,
则只更新存活时间等消息。另外,每次发送、接收都会检查所有成员是否超时。如果某个成员
的上次更新时间距离现在超过设定的间隔(默认是3000ms),就删除此成员,因为超过间隔的
成员被视为已失效成员。这里因为各个节点更新成员时使用节点本身的时间做比较,所以不同
节点的时间即使不同也不会有问题。
总的来说, Tribes利用上述原理维护集群成员,基于组播技术不断对外组播各自节点的相
关信息,各个节点接收到信息后更新成员信息列表,再由独立模块 Membership Service提供成
32421.3平行的消息发送通道— ChanneISender
员的相关服务。例如,获取集群所有成员的相关信息等服务。
213平行的消息发送通道— Channe sender
前面的集群成员维护服务为我们提供了集群内所有成员的地址端口等信息。通过
Membership Service可以轻易从节点本地的成员列表获取集群所有的成员信息,有了这些成员
信息后,就可以使用可靠的TCPP协议进行通信了。本节讨论的是实际中真正用于消息传送
通道的相关机制及实现细节。
如图21.3所示,4个节点在本地都拥有了一张集群成员的信息列表,这时 Nodel有这样
个需求:为了保证数据的安全可靠,在向自己的内存中存放一份数据的同时,还要把数据同
步到其他三个节点的内存中。Node有一个专门负责发送的组件 ChannelSender,首先,从成
员列表中获取其他三个节点的通信地址和端口,然后分别为这三个节点建立TCPP通道以发
送数据。其他节点中有一个负责接收数据的服务,并将数据更新到内存中
Node 3
m
m2
m3
4
CP/IP
Nodel
Node2
Channelsender
TCP/IP
TCP/IP
Node4
图21.3平行发送数据
最理想的状态是数据成功发送给Node2、Node3、Node4,这样从整体来看 ChannelSender
像是提供了一个多通道的平行发送方式,所以它也称为平行发送器。但现实中并不能保证同
批消息对于所有节点发送都成功,有可能发送到Node3时因为某种原因失败了,而Node2、
Node4都成功了,这时通常要采取一些策略来应对,例如重新发送。 Tribes所使用的策略是优
先尝试进行若干次发送,若干次失败后,将向上抛出异常信息。异常信息包含哪些节点发送失
325第21章集群通信框架
败及其原因,默认的尝试次数是1次。
为确保数据确实被节点接收到,需要在应用层引入一个协议以保证传输的可靠性,即通知
机制,发送者发送消息给接收者,接收者接收到后返回一个ACK表示自己已经接收成功
Tribes中详细的协议报文定义如下: START DATA(7字节)+消息长度(4字节)+消息长度
(n字节)+ END DATA(7字节)。 START DATA为数据开始标识,为固定数组值70,76,84,
50,48,48,50, END DATA为数据结束标识,为固定数组值84,76,70,50,48,48,51。
ACK DATA表示通知报文,为固定数组值6,2,3。如果传输的是通知报文,则为
START DATA+ ACK DATA的长度+ ACK DATA+END DATA。所以整个集群的消息同步如图21.4
所示, Node1通过 ChannelSender发送消息给Node2、Node3、Node4,发送成功的判定标准就是
Node2、Node3、Node4返回给 Nodel一个ack标识,若 Node1接收到,则认为发送成功。
NIO
①发送
②应答
0 Node2
①发送
②2应答
ChannelSende
Node3
①发
②2应答
Node4
datal
n4
data2
4
data3
n4
▲图21.4消息平行发送
为提高通信效率,这里默认使用了NIO模式而非BIO模式(也可设置为BIO模式),使
用NO模式能统一管理所有通信的通道,避免了等待一个通道发送完毕另一个通道才能发送,
如果逐个通信将导致阻塞IO时间很长,通信效率低下。另外,平行发送的过程需要一个锁以
保证消息的正确发送,例如有 data1、data2、data3三个数据需要发送,应该一个接一个数据包
发送,而不能 datal发一部分data2发一部分。
本节介绍了 Tribes如何向集群其他成员发送数据,通过本地获取其他成员节点的地址
326214消息接收通道— ChannelReceiver
和端口,再通过平行消息发送通道发送给其他节点,其中借助ACK机制和重发机制保证
数据成功接收。
214消息接收通道— dianne receiver
与消息发送通道对应,发送的消息需要一个接收端,它就是 ChannelReceiver。接收端负
责接收其他节点从消息发送通道发送过来的消息。实际情况如图21.5所示,每个节点都有
个 Channelsender和 Channelreceiver, ChannelSender向其他节点的 ChannelReceiver发送消息
本质是每个节点暴露一个端口作为服务器端的监听客户端,而每个节点又充当客户端连接其他
节点的服务器端,所以 ChannelSender就充当客户端集合, ChannelReceiver充当服务端。
Node4
ChannelSender
ChannelReceiver
Nodel
Node3
ChannelSender
ChannelSender
Channel Receiver
ChannelReceiver
ChannelSender
Channel Receiver
▲图21.5消息接收
在集群消息的复制过程中,每个节点 ChannelReceiver负责接收来自其他节点的消息。假
设有一个包含n个节点的集群,一般情况下每个 ChannelReceiver对应n-1个连接,因为集群
之间的通信连接都是长连接,长连接有助于提高通信效率。如图21.6所示,对于包含4个节
点的集群, Nodel的 Channelreceiver的客户端连接数为3,分别是Node2、Node3、Node4
个节点作为客户端发起的套接字连接。这三个节点产生的数据会通过此通道同步到 Nodel。同
样地,Node2的 ChannelReceiver拥有 Node 1、Node3、Node4的客户端连接,这三个节点产生
的数据也会同步到Node2。Node3、Node4也拥有三个客户端连接。为提高处理效率,此处还
是使用NIO处理模型。
327第21章集群通信框架
NIO
Node2
Listen
Nodel ChannelReceiver
Node3
Node
▲图21.6平行接收
除此之外,在接收操作中,为了优化性能,采取了很多措施。例如,引入任务池,即
把接收任务提前定义好并放入内存中,接收时可直接获取而不用再实例化。再例如,一次
获取若干个报文进行处理,即使用NO模式读取消息到缓冲区后,直接处理整个缓冲区的
消息,它可能包含若干个报文。网络IO需要优化的地方及手段都比较多, Tribes确实已经
做了很多优化方面的工作。
25通道拦截器 channellnterceptor
拦截器应该可以说是一个很经典的设计模式,它有点类似于过滤器。在某信息从一个地方
流向目的地的过程中,可能需要统一对信息进行处理。如果考虑到系统的可扩展性和灵活性,
通常就会使用拦截器模式,它就像一个个关卡被设置在信息流动的通道中,并且可以按照实际
需要添加和减少关卡。 Tribes为了在应用层提供对源消息统一处理的渠道引入通道拦截器,用
户在应用层只需要根据自己的需要添加拦截器即可。例如,压缩/解压拦截器、消息输出输入
统计拦截器、异步消息发送器等。
拦截器的数据流从ⅣO层流向应用层,中间就会经过一个拦截器栈,应用层处理完就会返
回一个ACK给发送端,表示已经接收并处理完毕(消息可靠级别为 SYNC ACK)。下面尝试
用最简单的一些代码和伪代码说明 Tribes的拦截器实现,旨在揭示拦截器如何设计(而并非具
体的实现)。最终实现的功能如图21.7所示,最底层的协调者 Channelcoordinator永远作为第
个加入拦截器栈的拦截器,往上则是按照添加顺序排列,且每个拦截器的 previous、next分
别指向前一个拦截器和下一个拦截器。
下面介绍如何在 Tribes中实现拦截器的整体设计。具体步骤如下。
①定义拦截器接口。
public interface ChannelInterceptor i
public void setNext( ChannelInterceptor next
public ChannelInterceptor getPrevious()i
328215通道拦截器— -channellnterceptor
public void sendMessage( ChannelMessage msg)i
public void messageReceived ( channe IMessage msg)i
Interceptor w
previous
next
Gziplnterceptor
next
Channelcoordinator
d previous
nex
▲图21.7拦截器
②定义一个基础拦截器,提供一些公共的操作,因为拦截器执行完后要触发下一个拦
截器,所以把触发工作统一抽离到基础类里面完成。当然,里面必须包含前一个和后一个
拦截器的引用。
public class ChannelInterceptorBase implements ChannelInterceptor
private ChannelInterceptor nexti
private ChannelInterceptor previous;
public ChannelInterceptorBase()(
public final void setNext ( ChannelInterceptor next)
this next nexti
public final ChannelInterceptor getNext(
return nexti
public final void setPrevious( ChannelInterceptor previous) I
this previous= previous
public final ChannelInterceptor getPrevious()
return previous氵
public void sendMessage( ChannelMessage msg)
if (getNext()!= null) getNext(). sendMessage(msg, )i
329第21章集群通信框架
public void messageReceived( ChannelMessage msg)t
if (getPrevious()!= null) getPrevious().messageReceived(msg)i
③压缩解压拦截器,此拦截器负责按一定算法进行压缩和解压处理。
public class GzipInterceptor extends ChannelInterceptorBase i
public void sendMessage( Channe IMessage msg)t
compress the msgi
getNext(). sendMessage(msg)i
public void messageReceived( Channe IMessage msg)I
decompress the msgi
getPrevious(). messageReceived(msg)i
④最底层的协调器,直接与网络IO做交互。
public class Channel Coordinator extends ChannelInterceptorBase l
public Channel Coordinator()t
public void sendMessage(ChannelMessage msg) throws ChannelException i
Network Io Send
public void messageReceived( ChannelMessage msg) t
Network IO READ
super. messageReceived (msg)i
⑤测试类。
public class Test(
public void main(String [] args)t
ChannelCoordinator coordinator new ChannelCoordinatoroi
GzipInterceptor gzipInterceptor new GzipInterceptor ()i
coordinator. setNet(null)i
coordinator. setPrevious(gzipInterceptor)i
gzipInterceptor. setPrevious(null)i
gzipInterceptor setNext(coordinator)i
gzipInterceptor. sendMessage(msg)i
coordinator. messageReceived(msg)i
330216应用层处理入口— MembershipListener与 ChannelListener
整个拦截器的执行顺序如下。当执行写操作时,数据流向为 GzipInterceptor→
Channelcoordinator→ Network Ic;当执行读操作时,数据流向则为 Network IC→
ChannelCoordinator-→ GzipInterceptor理解了整个设计原理后,对于 Tribes的整体把握将会更
加深入。
26应用层处理入口— Membershinlistener与 Channellistener
Tribes为了更清晰、更好地划分职责,它分成IO层和应用层。IO层专心负责网络传输
方面的逻辑处理,把接收到的数据往应用层传送。当然,应用层发送的数据也通过此IO层发
送,数据传往应用层后,必须要留一些处理入口供应用层进行逻辑处理。而考虑到系统解耦,
处理这个入口最好的方式是使用监听器模式,在底层发生各种事件时,触发所有安装的监
听器,使之执行监听器里面的处理逻辑。这些事件主要包含了集群成员的加入和退出、消
息报文接收完毕等信息。所以,整个消息流转过程分成两类监听器,一类是与集群成员的
变化相关的监听器 Membershiplistener,另外一类是与集群消息接收、发送相关的监听器
Channellistener。应用层只要关注这两个接口,写好各种处理逻辑的监听器添加到通道中
即可。
下面是这两个监听器的接口,从接口定义的方法可以很清晰地看到各个方法被调用的时
机。 Membershiplistener类型中的 member Added是成员加入时调用的方法, member Disappeared
是成员退出时调用的方法。 Channellistener类型中的 accept用于判断是否接受消息,
messageReceived用于对消息进行处理。应用层把逻辑分别写到这儿个方法就可以在对应时刻
执行相应的逻辑。
public interface Membershiplistener
public void memberAdded (Member member)i
public void member Disappeared(Member member)i
public interface ChannelListener
public void messageReceived (Serializable msg, Member sender)
public boolean accept(Serializable msg, Member sender)i
如图21.8所示,我们可以在应用层自定义若干监听器并且添加到 Group Channel中的两个
监听器列表中。 Group Channel其实可以看成一个封装了IO层的抽象容器,它会在各个适当的
时期遍历监听器列表中的所有监听器并调用监听器对应的方法,即执行应用层定义的业务逻
辑,至此完成了数据从IO层流向应用层并完成处理。两种类型的监听器给应用层提供了处理
入口,应用层只须关注逻辑处理,而其他的IO操作则交由O层,这两层通过监听器模式串
联起来,优雅地将模块解耦。
331第21章集群通信框架
自定义
自定义
自定义
自定义
监听器
监听器
监听器
监听器
Group Channel
Membership List
ChannelL istenerList
▲图21.8应用层入口
217如何使用 Tribes进行数据传输
上面已经对 Tribes的内部实现机制及原理进行了深入的剖析,在理解它的设计原理后,看
看如何使用 Tribes进行集群之间的数据传输。整个过程相当简单便捷,只需要4步。
①定义一个消息对象,由于这个消息对象是要在网络之间传递的,网络传输涉及序列化,
因此需要实现 Serializable接口。
public class MyMessage implements Serializable i
private string message
public String getMessage()(
return message;
public void setMessage(String message)
this message message
②定义一个 Channellistener监听器,把消息的处理逻辑放在 messageReceived方法中
public class. MyMessageListener implements Channellistener t
public boolean accept (Serializable myMessage, Member member)(
return true;
public void messageReceived(Serializable myMessage, Member member)(
System. out. println(((MyMessage)myMessage). getMessage()+ from
member getName())i
③定义一个 Membershiplistener监听器,它负责对集群成员的加入及失效的逻辑处理。
在 member Added中对成员加入事件进行逻辑处理,在 memberDisappeared中对成员失效事件
332217如何使用 Tribes进行数据传输
进行逻辑处理
public class MyMemberListener implements MembershipListener t
public void memberAdded(Member member
System. out. println(member getName(+Added")
public void memberDisappeared(Member member
System. out. println(member getName()+"Disappeared")i
④主程序分别实例化 Channellistener、 MembershipListener并把它们添加到 Channel中,
然后启动 Channel。由于集群通信需要启动几个节点才可实现,为方便操作这里引入args参数
当参数值为r时,表示只启动一个节点并加入集群,而当参数值为s时则表示启动节点加入集
群后向集群所有成员发送 Message。主程序使用循环睡眠是为了不让程序结束,一旦结束节点,
它就不存在了。可以先带r参数运行两次,这意味着启动了两个节点,然后再带s参数运行
即第三个节点启动并向前两个成员节点发送消息。前两个节点分别输出了“ hello from
tcp:∥/{169,254,75,186}:4002”,而成员监听器则会在节点加入或失效时输出类似这样的消息
“tcp:/{169,254,75,186}:4002 Added”、“tcp:!/{169,254,75,186}:4000 Disappeared"
public class TribesTest i
public static void main(String [ args)throws ChannelException
InterruptedException i
Channel my Channel =new GroupChannel()
Channellistener msgListener new MyMessageListener ()i
Membershiplistener mbrlistener new MyMemberListener ()i
my Channel. addMembershiplistener (mbrlistener)i
myChannel. addchannelListener(msgListener)i
myChannel start(Channel. DEFAULT)i
switch (args[0])(
case (r):
while (true)
Thread currentThread(). sleep(1000)i
case ( s"):
MyMessage myMsg new MyMessage()i
myMsg. setMessage("hello)i
Member[] group = my Channel getMembers()i
my Channel. send(group, myMsg, Channel. SEND OPTIONS_ DEFAULT);
while (true
hread currentThread(). sleep(1000)i
333第21章集群通信框架
218T0mGa使用Ts同步会话
Tomcat集群中最重要的交换信息就是会话消息,对某个 Tomcat实例某会话做的更改,要
同步到集群中其他 Tomcat实例的该会话对象上,这样才能保证集群所有实例的会话数据一致。
在 Tribes组件的基础上完成这些工作就相当容易,上一节简单说了如何用 Tribes传输数据,所
以基本上就是按照这个思路。
如图21.9所示, Tomcat实现会话同步的过程中大致会使用如下组件。现在假设中间的
Tomcat实例的会话改变了,它会通过会话管理器将改变的动作消息封装成消息然后调用集群
对象 Cluster,通过 Cluster将消息发送出去,同时 Cluster又依赖于 Tribes。最后消息其实是交
由 Tribes真正发送的通信过程是以 ClusterMessage为对象传输的,它会先序列化再进行传输,
到达左边和右边的 Tomcat实例时会反序列化,消息由 Tribes接收后向 Cluster上传。最后到达
会话管理器,它根据动作消息同步会话。
会话管理器
会话管理器
会话管理器
个
Cluster
Cluster
Cluster
Tribes
ClusterMessage
Tribes
-Cluster Message
Tribes
图21.9会话消息的同步
所以 Cluster其实就是实现了 Channellistener的监听类,当 Tribes接收到消息后,就会调
用此监听器的 messageReceived方法处理逻辑。此方法又会继续往上通知 Manager的
messageDataReceived方法,在此方法内完成会话同步处理逻辑。
219 Tomcat使用 Tribes部署集群应用
Tribes组件在集群中使用时,除了对会话数据同步之外,它还可以进行集群应用的部署。
这也是一个很重要的应用场景,设想一下如果没有集群应用部署功能,每当我们发布应用时都
要登录每台机器对每个 Tomcat实例进行部署。这些工作量都是繁杂且重复的,而对于程序员
来说,是不能容忍重复的事情发生的。于是需要一种功能,使得在集群中某实例部署后集群中
的其他 Tomcat实例会自动完成部署。
集群部署主要分为两部分:第一部分是关于应用的传输问题,主要是在 Tomcat中如何把
个Web应用传输到其他 Tomcat实例上;第二部分是应用部署方式及应用更新方式,主要是
33421.9 Tomcat使用 Tribes部署集群应用
在 Tomcat中如何以集群同步方式部署一个Web应用,以及集群实例在接收到新版本Web应
用时如何进行更新。这两部分弄清楚也就明白了 Tomcat如何基于 Tribes部署集群应用。
关于第一部分传输的问题,其实它和前面的使用 Tribes进行数据传输的场景很像,但它又
有一个很不相同的地方。常见的数据都可以一次性直接发送,但Web应用一般都比较大,不
可能一次性将其全部读到内存再直接写入套接字中,所以需要分开多次传输。部署的几个主要
组件如图21.10所示, tomcat集群中的每个实例都会包含 Cluster组件,它包含专门用于集群
部署的 ClusterDeployer(集群部署器),而且 ClusterDeployer组件也建立在 Tribes之上。假如
将Web应用部署到中间的 Tomcat实例上,它的 Cluster Deployer组件则会读取该Web应用WAR
包文件,然后通过 Tribes向集群的其他两个 Tomcat实例发送。前面也说到不可能一次性全部
读取,所以读取时使用了一个缓冲区。它默认是10KB大小,所以一次最多能传输10KB数据,
这些数据会被封装成 FileMessage对象进行传递。集群中其他 Tomcat实例的 ClusterDeployer
将所有 FileMessage接收后组成一个完整的WAR包文件。
Cluster
Cluster
Cluster
Cluster Deployer
Cluster Deployer
ClusterDeployer
Tribes+
FileMessage
Tribes
FileMessage
Tribes
FileMessa
File Message
FileMessage
▲图21.10集群应用中的消息传输
另外,从发送端到接收端存在多个缓冲队列并且可能还有多线程操作,所以在发送端的应
用层按顺序将文件数据一份一份发送,在接收端的应用层并不能保证按顺序接收到。为了解决
乱序的问题,需要在传输的消息中引入消息编号,即对每个 FileMessage进行累加编号。例如,
发送时每个 FileMessage对象按顺序编码从1开始累加,在接收端就可以从编码为1的
FileMessage对象开始处理,接着处理编码为2的 FileMessage,以此类推。这样就保证了数据
的顺序性,保证了拼凑的数据最终的准确性。这样就解决了Web应用传输的问题了,接下来
看第二部分。
集群中的应用是如何部署及如何更新的?如图21.1所示,每个 Tomcat实例的
ClusterDeployer都包含了一个 War Watcher组件,这个组件主要用于监听某个目录下是否有新
的应用包或某个应用包是否有更新。一旦监听到这些事件,则把新的应用同步到集群中其他实
例上。这个过程大致如下。
①集群中某实例的 War Watcher负责监听 watchD目录下部署了新应用 XX. war包
②将新应用 XX. war包先复制到该实例的 deployDir部署目录下
③ Cluster Deployer将xx.war包传递到另外一个 Tomcat实例。
④另外一个 Tomcat实例的 Cluster Deployer将 XX. war包暂时存放到 tempD目录中。
335第21章集群通信框架
⑤ XX. war包完整接收后,重命名该包,并存放到 deploydir目录下。
Cluster
Cluster
Cluster Deploy
ClusterDeployer
War Watcher
War Watcher
temp Dir
s watch Dir
deploy Dir
tempDir
watchDir deploy Dir
▲图21.11集群应用部署
下面介绍其中的三个目录。 watchDir目录属于监听目录,一旦有WAR包部署或更新就会
被检测到。 tempDir目录用于存放临时接收到的WAR包数据,不能直接保存到 deploy dir目录
中,异常情况下可能把原来的WAR包覆盖了且又没能接收完整的新WAR包,所以需要临时
目录中; deploy dir目录是真正的部署目录,WAR包从 tempDir目录转移到 deploy dir目录中
时一般使用 renameTo操作,它不用真正地进行文件复制操作,不管文件多大,都可以在瞬间
完成操作。
至此, Tomcat集群如何进行集群应用部署的整个工作过程及其机制已经全部讲完。总的
来说,就是通过监听实例的某个目录,一旦发现新应用,就同步到集群其他实例上,传输时引
入缓冲机制,避免文件过大,而且通过对消息编号以避免消息乱序,接收时先暂存应用到某目
录,避免因为网络异常造成文件覆盖。
336第22章监控与管理
Tomcat在对内部的监控上主要使用了JMX。JMX即Java管理扩展( Java Management
Extension),作为一个Java管理体系的规范标准,其主要负责系统管理,使基于此规范而扩展
的系统拥有管理监控功能。通过它对 Tomcat运行时进行监控和管理,包括服务器性能、JVM
相关性能、web连接数、线程池、数据库连接池、配置文件重新加载等,并且提供一些远程
可视化管理。它实时性高,同时也为分布式系统的管理提供了一个基础框架,提供了较丰富的
管理手段。
221Jaa管理扩展—M
22.1.1JMX的基本结构
如图22.1所示,总的来说,JMX体系结构分为三个层次:设备层、代理层、分布服务层。
管理应用
应用
管理应用
分布服务层HM适配器SNMP适配器RM适配器
代理层
MBean Server
代理服务
设备层
MBean
MBean
MBean
▲图22.1JM结构
设备层( Instrumentation level):主要定义了信息模型。在JMX中,各种管理对象以管理
构件的形式存在,需要管理时,向 MBean服务器进行注册。它定义了如何实现JMX管理第22章监控与管理
资源的规范,只要将资源置入JMX框架中就可以成为JMX的一个管理构件( MBean),
资源可以是一个Java应用、一个服务或一个设备。另外,该层还定义了通知机制以及
些辅助元数据类
代理层( Agent Level):主要定义了各种服务以及通信模型。该层的核心是一个 MBean服
务器,所有的管理构件都需要向它注册,才能被管理。注册在 MBean服务器上的管理构件
并不直接和远程应用程序进行通信,它们通过协议适配器进行通信。而协议适配器也以管
理构件的形式向 MBean服务器注册后才能提供相应的服务。
分布服务层( Distributed Service Level):JMX架构的最外一层。它负责使JMX代理对外
界可用,主要定义了能对代理层进行操作的管理接口和构件,具体内容依靠适配器实现,
这样外部管理者就可以操作代理。
除此之外,JMX还定义了一些附加管理协议API,用来支持当前已经存在的网络管理协
议,如SNMP、TMN、 CIMWBEM等。
22.1.2JMX例子
前面介绍了JMX的基本结构,下面用一个简洁的例子展示MX的用途。
①定义一个 MBean接口。
public interface TomcatUtilMBean(
public void setserverName (String serverName);
public string getserverName()i
public void setPort(int port)i
public int getPort()i
public String getTomcatInfo()i
②实现上面定义的 MBean接口。
public class Tomcatutil implements TomcatUtilMBean
public String serverName="Catalina";
public int port=8080;
public void setserverName(String serverName)t
this serverName=serverName i
public String getserverName()(
return serverName
public void setPort (int port)(
thisport=porti
public int getPort()i
return porti
338222JMX管理下的 Tomcat
public string getTomcatInfo()i
return "The Tomcat's name is +serverName+, port is+porti
③注册 MBean并启动MX服务。
public class TomcatMonitor
public static void main (String[] args) throws Exception i
MBeanServer mbServer=ManagementFactory getplatformMBeanServer();
TomcatutilMBean tomcatutil=new TomcatUtilo)i
mbServer. registerMBean(tomcatutil, new ObjectName("myMBean: name=tomc
atUtil ))i
HtmlAdaptorServer adaptor=new HtmlAdaptorserver ()i
adaptor. setPort(8888)i
mbServer. registerMBean(adaptor, new ObjectName("myMBean: name=html
Adaptor, port=8888 )
adaptor. start(i
④启动 Tomcatmonitor,并使用浏览器访问htp: localhost:888将看到所有管理的资源,
对应的 TomcatUtil资源如图2所示。对应的三个属性值显示在方框内,在运行过程中可以
随时对Port和 ServerName两个属性值进行修改,单击 Apply按钮即完成内存中的属性值修改
MBean view
JDMK5.1+34.2]
垂 MBean
myllBean: name=tomcatUtil
Class: TomcatUtil
Reload Period in seconds:
Back to Agent View
Reload
MBean description:
Information on the management interface of the MBean
List of mBean attributes
T
Access
Value
Port
IServerName
java. l ang String
TOmcat Info
java. lang String Ro the Tomcat's name is Catalina, port is 8080
Apply
▲图22.2 TomcatUti l资源
222JM管理下的 Tomcat
经过上一节的讨论我们知道JX可以为一个应用程序、设备、系统等植入监控和管理功
339第22章监控与管理
能,如果我们要对这些资源进行监控、管理,就要实现JX规定的规范。当程序运行时,就
可以很容易地管理资源。本书讨论的服务器 Tomcat也使用JMⅹ作为监控管理框架,它提供多
种管理接口,例如,在 Tomcat运行时可以通过web控制台对运行情况进行管理。下面介绍
Tomcat是如何利用JMX进行管理的。
Tomcat是一个完全组件化的结构,每个组件都有自己负责的事情,每个组件都正常运作
时,它才是一个正常的 Tomcat。而对于出故障的 Tomcat,我们需要能找到故障在哪里才可以
对症下药,所以我们需要获取 Tomcat各个部位的信息,最终才能确定问题所在。各个组件的
信息都通过JMX传递,使得我们能实时了解 Tomcat各个组件的情况。
Tomcat实现通过XML配置托管类、属性和方法。图2.3所示展示了整个 Tomcat中的各
个组件怎么通过JMX管理
Catalina
完成MX注册,
Server
管理所有组件
Service
Engine
Host
MBean Until或
Registry根据
Context
ManagedBean
实例创建真正的
MBean,并完
Wrapper
成注册
利用 Digester创建
多个 Managed Bean实
例, ManagedBean主要
描述组件有哪些属性,
哪些操作要注册到MX中
Connector
(mbeans-descriptors
〈 mbean〉
<attributor <attributor>
mbeans-
Operation>(/operation>
descriptors. xml
(/mbean>
〈/ mbeans-descriptors
▲图22.3JM管理组件的过程
首先,通过一个 mbeans-descriptors. xml配置文件描述需要管理的类的属性与操作。比如
主要的几个组件类 Server、 Service、 Engine、Host、 Context、 Wrapper、 Connector等,只需将
需要管理的部分配置一下。
其次,由 Digester框架把这个XML的描述转化为多个 ManagedBean实例,这些实例不是
真正的 MBean,只用于存放描述信息。
340222JMX管理下的 Tomcat
接着, MBeanutil或 Registry会根据这些 ManagedBean实例创建真正的 MBean,包括 Server、
Service、 Engine、Host、 Context、 Wrapper、 Connector的 MBean,并注册到 Mbean server中。
最后,完成了所有组件JMX的注册,已经把所有组件管理起来了。
现实中, Tomcat管理组件是以包为单位的,即在需要管理的每个包中放置一个
mbeans-descriptor. xml文件,包下所有的类共用一个配置文件。整个 Tomcat中有哪些组件被
JMⅹ管理?如图22.4所示,这是 MBean管理类 MBeanuti加载描述文件的代码,这十几个包
下面都包含一个描述文件 mbeans- descriptor:xml,具体哪些类、哪些属性、哪些操作需要管理
就由此配置文件配置。
public static synchronized Registry createRegistry()(
if (registry a null)(
registr
(na1,na11)
ClassLoader cl- MBeanutils. class. getclassloader();
registry. loadDescriptors(org. apache. catalina. mbeans", cl)i
registry. loadDescriptors(org. apache. catalina. authenticator, cl);
registry. loadDescriptors(org. apache. catalina. core",cl)i
registry. loadDescriptors("org. apache. catalina",cl):
registry. loadDescriptors(org. apache. catalina deploy ", cl);
registry. loadDescriptors(org. apache. catalina loader", cl);
egistry. loadDescriptors (org. apache, catalina, realm",cl)i
registry. loadDescriptors(org. apache. catalina, session", cl):
registry. loadDescriptors("org. apache. catalina. startup",cl);
registry. loadDescriptors("org. apache. catalina. users",cl);
registry. loadDescriptors(org. apache. catalina. ha",cl);
registry. loadDescriptors ("org. apache, catalina connector", cl);
registry. loadDescriptors("org. apache. catalina. valves", cl):
return (registry)i
▲图2.4加载描述文件
下面讨论如何在 Tomcat中使用XML注册 Mbean。假如现在要将一个组件交由 Tomcat的
JMX托管,需要做如下操作。
①编写被托管类 TomcatModel
public class TomcatModel(
private string serverName="catalina"i
private Integer port=8080;
public String getserverName()t
return serverName i
public void setServerName(String serverName)
this serverName serverName;
public Integer getport()t
return porti
public void setport(Integer port)
341第22章监控与管理
this port = porti
public void getTomcatInfo()
System. out. println ("The Tomcat's name is " serverName + " and the port is"+
port)i
②找到 TomcatModel类所在的包下面的配置文件 mbeans- descriptors. xml,添加如下几行
配置。
<mbean name=TomcatModel" description="Server Component" domain="Catalina"
group="Server" type=org. apache. catalina. TomcatModel">
< attribute name=" serverName" description="服务器名字
type="java. lang String"/>
< attribute name="port" description="服务器端囗
type=java. lang Integer"/>
Operation name=getTomcatInfo" description="print message"impact="ACTION
returnType="void"/>
</mbean>
③注册托管对象。
public class Register f
public static void main(String[] args)
try i
Registry registry=Registry. getRegistry(null, null)i
Registry. loadDescriptors("TomcatModel", TomcatModel class getclassLoader());
ObjectName name=new ObjectName("TomcatModel: type=test")i
ManagedBean bean=registry. findManagedBean(TomcatModel class getName());
TomcatModel tm=new TomcatModel()
BaseModelMBean bmmb=bean. createMBean(tm)i
Registry. getMBeanServer().registerMBean(bmmb, name)i
A catch(Exception)[
在 Tomcat内部注册JMX就这么简单,它把复杂重复的逻辑处理都封装起来并实现XML
配置,具有很大的便捷性和灵活性。同时, Tomcat将组件和操作都交由JMX,当 Tomcat以
JMX模式启动运行时,则可以很方便地对其进行监控、管理。
34222.3 Manager Serve
22.3 ManagerServlet
为了提供可以管理 Tomcat内部各个模块资源的 Servlet入口, Tomcat必须暴露它的
个内部模块作为入口,于是就有了 Manager Servlet。我们知道普通的 Servlet是无法访问 Tomcat
内部的,所以为了区别于普通的 Servlet,, Tomcat提出了 Container Servlet接口,有了它,Web
容器就能进行区别了。
具体是如何进行区别的呢?如图22.5所示,请求经过各个容器最后到达 Wrapper容器,
Wrapper管道的基础阀门的过滤器链负责调用 Servlet,当第一次访问时会加载 Servlet实例,
这时就会有如下判断
if ((servlet instanceof ContainerServlet)&&
(isContainerProvidedservlet(servletclass
((Context)getParent()).getPrivileged())t
(Container Servlet) servlet). setwrapper(this)
Engine
Pipeline
Host
请求
xxx Valve
Pipeline
Context
Standard
xxx Valve
Pipeline
Wrappe
er
Engine Valve
Pipeline
Stamdard
x× Valve
xxXValve
Serve
Host valve
Standard
Context Valve
Standard Wrapper Valve
ApplicationFilterChain
请求
▲图22.5 Servlet实例加载
可以看到它会判断该 Servlet是否实现了 Container Servlet接口,若实现了,则会将 Wrapper
容器关联到 Servlet实例中。后面就可以通过该 Servlet来访问 Tomcat内部的各个模块资源,
比如,若要访问 Context容器,则直接通过 Wrapper的 getParent方法访问。
另外还要注意的是,我们不能让普通的Web应用获取到 Tomcat的访问权,即普通web
应用的 Servlet不能通过实现 Container Servlet接口而获得访问 Tomcat内部的权限,否则将造
成一个极大的安全隐患。所以这里会判断该 Servlet是不是 org. apache. catalina包下的,如果是,
343第22章监控与管理
才能加载。另外,如果Web应用有特权,也能获取到 Tomcat内部的访问权限。
有了这个访问 Tomcat内部的入口后,要管理 Tomcat内部各个模块的资源就容易了。下面
介绍 Manager Servlet提供的常见功能。
列出已部署的应用。
在浏览器地址栏中输入http://localhost:8080/manager/text/list
浏览器显示
OK Listed applications for virtual host localhost
/ running: 0: ROOT
/manager: running: 0: manager
/docs: running: 0: docs
examples: running: 0: examples
/test: running: 0:test
/host-manager: running: 0: host-manager
Manager Servlet通过遍历 Context容器来实现。
重加载某个应用。
在浏览器地址栏中输入http://localhost:8080/manager/text/reload?path=/test
浏览器显示
OK -Reloaded application at context path/test
Manager Servlet中对某个Web应用的重加载操作的实现是通过 Context的 reload方法实现的。
输出操作系统和JVM的信息。
在浏览器地址栏中输入http://localhost:8080/manager/text/serverinfo
浏览器显示
OK Server info
Tomcat Version: Apache Tomcat/7.0. 47
os Name: Windows 8.1
os Version: 6.3
os Architecture: amd 64
UVM Version: 1.7.080-b15
JVM Vendor: Oracle Corporation
ManagerServlet可以很简单地通过Java来获取这些信息。
列出可用的全局JNDI资源。
在浏览器地址栏中输入http://localhost:8080/manager/text/resources
浏览器显示
OK- Listed global resources of all types
UserDatabase: org. apache. catalina. users. MemoryUserDatabase
ManagerServlet通过遍历 Tomcat内部的全局资源即可列出这些资源。
34422. 3 Manager Servlet
会话统计。
在浏览器地址栏中输入http://localhost:8080/manager/text/sessions?path=/test
浏览器显示:
OK- Session information for application at context path /test
Default maximum session inactive interval 30 minutes
<1 minutes: 1 sessions
Manager Servlet通过 Tomcat内部的会话管理器即可实现会话统计
停止某个应用。
在浏览器地址栏中输入http://localhost:8080/manager/text/stop?path=/test
浏览器显示
OK -Stopped application at context path /test
ManagerServlet中停止某个Wb应用的实现是通过 Context的sop方法实现的。
启动某个应用。
在浏览器地址栏中输入http://localhost:8080/manager/text/start?path=/test
浏览器显示
OK - Started application at context path /test
Manager Servlet中启动某个web应用的实现是通过 Context的sar方法实现的。
345