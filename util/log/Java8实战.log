URING图灵程设计M书
MANNING
通过示例全面讲解Java8新特性
为Java程序员开启函数式编程的大门
lava 8
实战
Java 8 in Action
Lambdas. streams
and functional-style programming
英]Raou|- Gabrie|Urma
[意] Mario fusco著
[英]A| an Mycroft
陆明刚劳佳译
中国信出版集团影民邮比出版社100101000101001010100104
00010101001010101001010101001
0001010101010101011007
00101001010100100100100100
110101010101001010
0100101001010010
01010100101010
01100101
01010100101101
000010101010
001011110101010
0100101010010
0010101000
11001101010
101101014010
01010100101
01010001
0001010001
10010100010
10010111110011000000
10101001
0001010
010110010001
00100100
1010101010100101010010100
11010010
010101
1010101010011001
数字版权声明
0101101
1000010101010100101011001011
1010010
101101011010100011111011101110110101014
0100101
01010001010010100101001001010100001010
1010001
1001010001010010101001011
00010101010101010110010001
图灵社区的电子书没有采用专有客00
o001001端,您可以在任意设备上,用自
0000101010101001010110
1010010
1011010
10001
己喜欢的浏览器和PDF阅读器进行
10100101
010100010100101001
100101000010010101001
阅读。
010
001010001
1010010101001
1000101010101010101100,000
00100:01001001
11010101010100101010010100但您购买的电子书仅供您个人使用,1001010010
01010100101010101010011001100107010710
0000101101
00001010101010010101100101
10110101101010001111101110
未经授权,不得进行传播。01011010000
010100010100
101001001
0001010001
11001010001010
我们愿意相信读者具有这样的良知
1010101001
00010101010101010110010001
11010101010100101010010100
和觉悟;与我们共同保护知识产权。090
0101010010101010101001100110
01010100101101
0000101010101001040
10100101010010
1011010110101000
10101010100101
0101000101001010010
如果购买者有侵权行为,我们可能
0001010001
100101000101001001001011
1010101001
0001010101010101011001000
101010101010010101001010
对该用户实施包括但不限于关闭该90
010101001010101010100110
帐号等维权措施,并可能追究法律
001011011
00001010101010010101100
40010
1011010110101000111
责任。
11010
0
010100010100100
1010010
10010100010100101010010
1010010
00010101010101010110000u
01010010
1101010101010010101000100
010010
010101001010101010100110011001010101010100100100
000010101010100101011001011101010101010101010
101101011010100011101110111011010101101010110
010101
010100010100101001010010010101000010100101010
10010100010100101010010111110011000000001010
010101001
00010101010101010110010001010100101001010010
010100101
101007
01001001001000Raoul-Gabriel urma
剑桥大学计算机科学博士,软件工程师,演讲
者,培训师, Cambridge Coding Academy联
合创始人、CEO。曾与谷歌、eBay、甲骨文和
高盛集团等大公司合作,并参与过多个创业项
目。撰写过十余篇经同行审阅的技术文章,并在
国际会议上发表过40多篇演讲。
Mario fusco
Red hat高级软件工程师,负责 JBoss规则引擎
Drools的核心开发。拥有丰富的Java开发经验,
曾领导媒体公司、金融部门等多个行业的企业级
项目开发。对函数式编程和领域特定语言等有浓
厚兴趣,并创建了开放源码库 lambda
Alan Mycroft
剑桥大学计算机实验室计算学教授,剑桥大学
罗宾逊学院研究员,欧洲编程语言和系统协会
联合创始人,树莓派基金会联合创始人和理
事。发表过大约100篇研究论文,指导过20多篇
博士论文。他的研究主要关注编程语言及其语
义、优化和实施。他与业界联系紧密,曾于学
术休假期间在AT&T实验室和英特尔工作,还创
立了 Codemist公司,该公司设计了最初的ARM
C编译器 Norcroft。
陆明刚
毕业于四川大学,目前在EMC中国卓越研发集
团任首席工程师,曾任趋势科技中国软件研发中
心技术经理,在信息科学和工程领域有十余年的
实践和研究经验,拥有多项中国及美国专利。关
注JM性能调优和大数据及其实践,喜欢挖掘技
术背后的内幕并乐此不疲。
劳佳
硕士毕业于上海交通大学,现在SAP美国任高级
软件支持顾问。业余爱好语言、数学、设计,近
年翻译出版了《咨询的奧秘》《卓越程序员密
码》等书。TURING图灵程序设计M书
Java 8
实战
Java 8 in Action
ambdas, streams
and functional-style programming
Ee Raoul-Gabriel Urma
意] Mario fusco著
[英] Alan Mycroft
陆明刚劳佳译
人民邮电出版社
北京序言致谢关于本书3
5
9
10关于封面图目录5
10
11
12
13
15
185
10
11
12
13
15
18Part
第一部分
基础知识
本书第一部分将介绍Java8的基础知识。学完第一部分,你将会对 Lambda表达式有充分的
解,并可以编写简洁而灵活的代码,能够轻松地适应不断变化的需求
第1章将总结Java的主要变化( Lambda表达式、方法引用、流和默认方法),并为学习本
做好准备
在第2
你将了解行为参数化,这是Java8非常依赖的一种软件开发模式,也是引入
da表达式的主要原因
第3章全面地解释了 Lambda表达式和方法引用的概念,每一步都有代码示例和测骀aVa怎么又变
新月异的计算应用背景:多核和处理大型数据集(大数据)
改进的压力:函数式比命令式更适应新的体系架构
ava8的核心新特性: Lambda(匿名函数)、流、默认方法什么要关心Javaa是怎么进入通用编程市场的
面向对象在20世纪90年代开始时兴的原因有两个:封装原则使得其软件工程问题比
作为
维模型,它轻松地反映了 Windows95及之后的WIMP编程模式。可以这样总结
切都是对象;单击鼠标就能给处理程序发:
事件消息(在 Mouse对象中触发法)。Java的
编写,随处运行”模式,以及早期浏览器安全地执行JaⅤa小应用的能力让它
领了大学市场,毕业生随后把它带进了业界。开始时由于运行成本比CC++要高,Java还
到了一些阻力,但后来机器变得越来越快,程序员的时间也变得越来越重要了。微软的C#进
步验证了Java的面向对象模型。
气候变化(多核处理器,新程序员的影响
S
C#/#
avascriple 2 "[A-Z]b2选隐藏文件的老方法
方法筛选
文件吋,需要把方法
妻在
里,然
能传
法
象
方法
Java8风格
在Java8里
使
方法引用
把
数传
方
语法2什么是谓词
前面的代码传递了方法App1
snApple(它接受参数 Apple并返回
olean)给fi1 terApples,后者则希望接
Pre
te< Apple>参数。谓词( predicate)
数学上常常用来代表一个类似函数的东西,它接受一个参数值,并返回true或fa1se
在后面会看到,Java8也会允许你写 Funct
pple, B
在学校学过函数却没学
过谓词的读者对此可能更熟悉,但用Pr
是更标准的方式,效率也会更高
这避免了把boo1ean封装在 Boolean里面2所有新的台式和笔记本电脑都是多核的。它们不是仅有一个CPU,而是有四个、八个,甚
更多CPU,通常称为内核。问题是,经典的Java程序只能和
核,其他核的处理
能力都浪费了。类似地,很多公司利用计算集群(用高速网络连接起来的多台计算机)来高效
处理海量数据。Java8提供了新的编程风格,可更好地利用这样的计算机
Google的搜索引擎就是一个无法在单台计算机上运行的代码的例子。它要读取互联网
的每个页面并建立索引,将每个互联网网页上出现的每个词都映射到包含该词的网址上。然
后,如果你用多个单词进行搜索,软件就可以快速利用索引,给你一个包含这些词的网页集
合。想想看,你会如何在Java中实现这个算法,哪怕是比 Google
擎也需要你利用计算
机上所有的核执
线程1
100
03
103
加(3)
读
sum
100
100
100
103
105
读
加(5)支
C
苹果
CPU
CPU
C
E
开
B
果
与无共享可变状态
都说Java里面并行很难,而且和
ed相关的玩意儿都容易出问题。那Java8
面有什么“灵丹妙药”呢?事实上有两个。首先,库会负责分块,即把大的流分成几个小的
,以便并行处理。其次,流提供的这个几乎免费的并
有在传递给fi1ter之类的库
法的方法不会互动(比方说有可变的共享对象)时才能
是其实这个限制对于程序员
说挺自然的,举
我
Sareer
e就是这样。确实,虽然函数式编程
的函数的主要意思是“把函数作为一等值”,不过它也常常隐含着第二层意思,即“执
元素之间无互动”22第2章
不断变化的需求
行为参数
匿名类
Lambda表达式预览
真实示例
parator、R
和GU2Apr
装了选择苹果的策略
b
Apeavyeredlcate
o⊥ ean tes
Pple apple
为参数新的行为
为参数
输出
重的
绿色
苹果
苹果
测验2.1:编写灵活的 pretty
Ap
法,它接受
的
t
对它参数化,以
多种方式根据苹果生成一个 String输出(有点儿像多
制的
法)。例如,你
告诉 prettyprintApple方法,只打印每个革果的重量。此外,你可以让
pple方法分别打印每个苹果,然后说明它是重的还是轻的。解决方案和我
前面讨论的筛选的例子类似。为了帮你上手,我们提供了 prettyprintApp1e方法的一个粗
略的框架
P
答案如下
首先,你需要一种表示接受App1e并返
格式 String值的方法。前面我们在编
App⊥e
接口的时候
类似的东西
Formatter
现在你就可以通过实现
tter方法,来表示多种格式行为了对付啰嗦
g
blic
matter
pK
pp⊥e. getwelg
最后,你需要告诉pre
法接受
tter对象,并在内部使用
们。你可以给 prettyprintApp1e加上一个参数
atter form
搞定啦!现在你就可以给 prettyPrintApple方法传递多种行为了。为此,你首先要实
例化 AppleFormatter的实现,然后把它们作为参数传给
prett
这将产生一个类似于下面的输出
pp⊥e
或者试试这个
e上orma
将产生一个类似于下面的输
g清单2
为参数化:用谓词筛选苹果2,3对付啰嗦
板
测验22:匿名类谜题
的代码执行时会有什么样的输出呢,4
还是4答案是5,因为this指的是
包合它的m1e,而不是外面的类
ea
类
ambda22Lambda管中窥豹
在哪里以及如何使用 Lambda
环绕执行模式
函数式接口,类型推断
方法引用
Lambda复2代码清单31JVa8中有效的Lamb表达式
测验3.1: Lambda语法
根据上述语法规
哪个不是有效的 Lambda表达式
(3)()
Mar
(4)(
tr
安
有4和5是无效的 Lambda
(1)这个 Lambda没有参数,并返回void它类似于主体为空的方法: public void run(){
(2)这个 Lambda没有参数,并返回 string作为表
(3)这个 Lambda没有参数,并
ring
用显式返回语句)(4) return是一个控制流语句。要使此 Lambda有效,需要使花括号,如下所示
re
lan
不是一个语句。要使此 Lambda有效,你可以去除花括号
>" Iron man"。或者如果你喜欢
使用显式返回语
句,如下所
(S
g
eur测验32:函数式接
面哪些接口是函数式接
ad
答案:只有 Adder是函数式接口。
martAdder不是函数式接口,因为它定义了两个叫作ad的抽象方法(其中一个是从
er那里继承来
hing也不是函数式接口,因为它没有声明抽象方法2用La
以下哪些是使用 Lambda表达式的有效方式
答案:只有1和2是有效的
第一个例子有效,是因为 Lambda()->{}具有签名()
R
a
抽象方法run的签名相匹配。请注意,此代码运行后什么都不会做,因为 Lambda是空的
第二个例子也是有效的。事实
etch方法的返回类型是Ca11ab1e< string>。
g>基本上就定义了一个方法,签名
其中被 String代替
了。因为 Lambda
① rickyex
的签名是()-> String,所以在这个上下文
中可以使用 Lambda
第三个例子无效,因为 Lambda表达式( Apple a)->a. getWeight()的签名是
ger
这和
re
aesaR
(App1e)-> boolean中定义的test方法的签名不同
又是怎么回事
如果你去看看新的 Java APi,会发现函数式接口带有
ona
terface的标注(3.4
节中会深入研究函数式接口,并会给出一个长长的列表)这个标注用于表示该接口会设计成
函数式接口。如果你用@ FunctionalInterface定义了一个接口,而它却不是函数式接
的话,编译器将返回一个提示原因的错误。例如,错误消息可能是“M
di
abstract methods found in interface Foo”,表明存在多个抽象方法。请注意,@
tiona
ter
ace不是必需的,但对于为此设计的接口而言,使用它是比较好的做法。它就像是@ Override
表
被重写了初始化/备代码
仞始化/准备代码
任务A
任务B
青理结東代码
青理结束代码2代码清单32使用 Predicate
代码清单3-3使用c代码清单3-4使用测验34:函数式接
于下列函数描述符(即 Lambda表达式的签名),你会使用哪些函数式接口?在表3-2
可以找到大部分答案。作为进一步
请构造一个可以利用这些函数式接口的有效 Lambda
表达
(2)
t
(3
(4)()
答案如下
<T,R>不错
般用于将类型哩的对象转换为类型R的对象(比如
teger>用来提取苹果的重量
(2
B
roper
具有唯
抽象方法,叫作app
t,它代表的函数描
七
(3)C
er<>具有唯一一个抽象方法叫作 accept,代表的函数描述符是
有唯
抽象方法叫作get,代表的函数描述符是(
者
Ca11ab1e<T>具有唯
抽象方法叫作ca11,代表的函数描述符是()
(5)B
ction<
具有唯一一个抽象方法叫作app1y,代表的函数描述符是异常、Lal
还有函数式接口又是怎么回事呢
请注意,任何函数式接口都不允许拋出受检异常( checked exception)。如果你需要 Lambda
表达式来拋出异常,有两种办法:定义一个自己的函数式接口,并声明受检异常,或者把 Lambda
/ catch块中
如
3节我们介绍了一个新的函数式接口 Bufferedreaderpro
明了一个
aR
但是你可能是在使用一个接受函数式接口的API,比如
On<,R>,没有办法自
创建一个(你会在下一章看到, Stream API中大量使用表3-2中的函数式接口)这种情况下,
你可以显式捕捉受检异常
Fur
(Buff
b
aline(使用Lamb
我
先来看看
好
标类型是
绑定到
类
配
接受
接
象方法乂
因
390士edte2}上e"a上re
并返形运算符
那些熟悉Java的演变的人会记得,Java7中已经引入了菱形运算符(<>),利用泛型推断从
上下文推断类型的思想(
尽想甚至可以追溯到更早的泛型方法)
类实例表达式可
出现在两个或更多不同的上下文中,并会像下面这样推断出适当的类型参数
rray
()
特殊的void兼容规!
如果一个 Lambda的主体是一个语句表达式,它就和一个返回void的函数描述符兼
然需要参数列表也兼容
如,以下两行都是合法的,尽管List的ad方法返回了
boolean,而不是
r上下文(T
)所要求的voidt
测验3.5:类型检查——为什
的代码不能编译呢
该如何解决
可题呢
ct
答案: Lambda表达式的上下文是 Object(目标类型)。但 Object不是一个函数式接
为了解决这个问题,你可以把目标类型改成 Sunnah1e,它的函数描述符是
p你可能已经听说过闭包( closure,不要和( lojure编程语言混淆)这个词,你可能会想
Lambda是否满足闭包
用科学的说法来说,闭包就是一个函数的实例,且它可以无限
制地访问那个函数的非本地变量。例如,闭包可以作为参数传递给另一个函数。它也可以
问和修改其作用域之外的变量。现在,Java8的 Lambda和匿名类可以做类似于闭包的事情
作为参数传递给方法,并且可以访问其作用域之外的变量。但有一个限制
能修改定义 Lambda的方法的局部变量的内容。这些变量必须是隐式最终的。可以认为 Lambda
是对值封闭,而不是对变量封闭。如前所述,这种限制存在的原因在于局部变量保存在栈
并且隐式表示它们仅限于其所在线程。如果允许捕获可改变的局部变量,就会引发造成线程
不安全的新的可能性,而这是我们不想看到的(实例变量可以,因为它们保存在堆中,而堆
是在线程之间共享的)2引用
ambda
方
用测验36:方法引用
列 Lambda表达式的等效方法引用是什么
t
答案
)这个 Lambda表达式将其参数传给了 Integer的静态方法 parseInt。这种方法接受
需要解析的 string,并返回
以使用图3-5中的办法①( Lambda表
式调用静态方法)来重写 Lambda表达式,如下所
(2)这个 Lambda使用其第一个参数,调用其 contains方法。由于第一个参数是ist类型
的,你可以使用图3-5中的办法2,如下所示
这是因为,目标类型描述的函数描述符是
st<st
> str
L
可以被解包成这个函数描述符验3.7:构造函数
你已经看到了如何将有零个、一个、两个参数的构造函数转变为构造函数引用。那要
样才能对具有三个参数的构造函数
(int
t),使用构造函数引用
答案:你看,构造函数引用的语法是C1
那么在这个例子里面就是
ew。但是你需要与构造函数引用的签名匹配的函数式接口。但是语言本身并没有提
供这样的函数式接
以自己创建一个
e
Fu
R>{
现在你可以像下面这样使用构造函数引用了
eger
ger, Colo2ggg
468
3
果
ggg
fffeager6
数的
方城2Part 2
第二部分
函数式数据处理
本书第二部分深入探索了新的 Stream ap
可以让你编写功能强大的代码,用声明性的
方式处理数据集。学完第二部分,你将充分理解流是什么,以及如何在代码中使用它来简明而高
效地处理数据集
第4章介绍了流的概念,并解释了它与集合的异同
第5章详细讨论了表达复杂数据处理查询可以使用的流操作。我们
很多模式,如筛
选、切片、査找、匹配、映射和归约
第6章介绍了收集器
eam AP的一个功能,可以让你表达更为复杂的数据处理查询
在第7章中,你将了解流为何可以自动并行执行,并利用多核架构的优势。此外,你还会
解到要避免的若干陷阱,以便正确而髙效地使用并行流.第4章
什么是流
集合与流
内部迭代与外部迭代
间操作与终端操2其他库
e和a
为了给Java程序员提供更好的库操作集合,前人已经做过了很多尝试。比如, Guava就是
a
等额
类。 Apache
Commons Collections/库也提供了类似的功能。最后,本书作者 Mario fusco编写的 lambda受到
函数式编程的启发,也提供了很多声明性操作集合的
a
带了官方库,可以以更加声明性
操作集合了。2从DVD上读出
所有信息哲学中的流和集合
对于喜欢哲学的读者,你可以把流看
间中分布的一组值。相反,集合则是空间(这
里就是计算机内存)中分布的一组值,在一个时间点上全体存在
使用迭代器来访
循环
内部成
代码清单41集合:用for-eac循环外部迭代
代码清单42集合:用背后的迭代器做外部迭代
代码清单43流:内部迭代素
你的代码
素
你的代码
集合测验4
操作与终端操作
在下列流水线中,你能找
操作和终端操作吗?
案:流水线中最后一个操作
ong,这是一个非 stream的值。因此它是终端操作。所有前面的操作,fi1ter
t、
都是连接起来的,并返回
个 Stream,因此它们是中间操2筛选、切片和匹
找、匹配和归约
使用数值范围等数值流
从多个源创建流
限流菜单流
Stream<dish>数值流菜单流
D
List<dish>测验
你将如何利用流来筛选前两个荤莱呢
答案:你可以把 ilter和]imit复合在一起来解决这个问题,并
ct(t
将流转换成一个列表
rea
ectdistre
测验5.2:映射
)给定一个数字列表,如何
个由每个数的平方构成的列表呢?例如,给定[1,2,3,4,
该返回
9.16,2
答案:你可以利用
法的 Lambda,接受一个数字,并返回该数字平方的 Lambda来解
决这个问题
(2)给定两个数字列表,如何返回所有的数对呢?例如,给定列表[1,2,3和列表[3,4],应
该返回[(1,3),(1,4),(2,3),(2,4),(3,3),(3,4)]。为简单起见,你可以用有两个元素的数组来代
表数对案:你可以使用两个map来迭代这两个列表,并生成数对。但这样会返回
rea
tream<intege
需要让生成的流扁平化,以得到一个 Stream< Intege
这
t
atma
mbers2. stream)
t
(3)如何扩展前一个例子,只返回总和能被3整除的数对呢?例如(2,4)和(3,3)是可
案:你在前面看到了, filter可以配合谓词使用来筛选流中的元素。因为在
lamar
操作后,你有了一个代表数对的int[流,所以你只需要一个谓词来
和是否能被3整除
就
a
eam
ter(
t
其结果是[(2,4),(3,3路求
有些操作不需要处理整个流就能得到结果。例如,假设你需要对一个用and连起来的大布
尔表达式求值。不管表达式有多长
需找到一个表达式为 false,就可以推断整个表达
将返回 false,所以用不着计算整个表达式。这就是短路
和个能得到是只共到一个元:业可以有结案了同,e
对于流而言,某些操作(例如a11
atch、a
tc
和
只需要创建一个给定大小的流,而用不着处理
有的元素。在碰到无限大
的流的时候,这种操作就有用了:它们可以把无限流变成有限流。我们会在57节中介绍无限
例何时使用￡ indfirst和f主nd
你可能会想,为什么会同时有
Frst
y呢?答案是并行。找到第一个元素
在并行上限制更多。如果你不关心返回的元素是哪个,请
dAny,因为它在使用
时限制较2数
9
12
21
Integermax
5
测验53:归约
样用map和 reduce方法数一数流中有多少个莱呢
答案:要解决这个问题,你可以把流中每个元素都映射成数字1,然后用 reduce求和。这
目当于按顺序数流中的元素个数
reduce(和
reduc
的连接通常称为map- reduce模式,因Goog!le用它来进行网络搜索而出名
因为它很容易并
请注意,在第4章中我们也看到了内置 count方法可用来计算流中元素
数
归约方法的
并行化
相比于前面写的逐步迭代求和,使用 reduce的好处在于,这里的迭代被内部迭代抽象掉
了,这让内部实现得以选择并行执行 reduce操作。而迭代式求和例子要更新共享变量sum,
能提升!这种计算的并行化需要另一种办法:将输入分块,分块求和,最后再合并起
不是那么容易并行化的。如果你加入了同步,很可能会发现线程竞争抵消了并行本应带来
这样的话代码看起来就完全不一样了。你在第7章会看到使用分攴/合并框架来做是什么样子
但现在重要的是要认识到,可变的累加器模式对于并行化来说是死路一条。你需要一种新的模
是r
所提供的。你还将在第7章看到,使用流来对所有的元素并行求和时,你的
码几乎不用修改: stream()换成了para11 el stream(
umbe
paralle
但要并行执行这段代码也要付一定代价,我们稍后会向你解释:传递给 reduce的 Lambda
不能更改状态(如实例变量),而且操作必须满足结合律才可以按任意顺序执行
经看到了很多的流操作。乍一看流操作简直是灵丹妙药,而且只要在从集合生成流的
时候把 Stream换成para1 Netstream就可以实现并行。
当然,对于许多应用来说确实是这样,就像前面的那些例
以把一张菜单变成流
用丘 ilter选出某一类的莱肴,然后对得到的流做map来对卡路里求和,最后 reduce得到菜单
的总热量。这个流计算甚至可以并行进行。但这些操作的特性并不相同。它们需要操作的内部
状态还是有些问题
诸如map或 filter等操作会从输入流中获取每
并在输出流中得到0或1个结果
些操作一般都是无状态的
没有内部状态(假设用户提供的 Lambda或
没有
部可变状态)
诸如 reduce、sum、max等操作需要内部状态来累积结果。在上面的情况下,内部状态
很小。在我们的例子里就是
t或aoub
不管流中有多少元素要处理,内部状态都是有界的。
反,诸如sort或 distinct等操作一开始都和fi1ter和mar
多—都是接
流,再生成一个流(中间操作),但有一个关键的区别。从流中排序和删除重复项时都需要知
首先前的历史。例如,排序要求所有元素都放入缓冲区后才能给输出流
的存储要求是无界
要是流比较大或是无限的,就可能会有问题(把质数流倒序会做什
呢?它应当返回最大的质数,但数学告诉我们它不存在)。我们把这些操作叫作有状态操作代码清单51找出201的有交易并按交易额排序(从低到高)
代码清单52交易员都在哪些不同的城市工作过代码清单53查找所有来自于剑桥的交易员。并按姓名排序
代码清单54返回所有交易员的姓名字符串,按字母顺序排序
代码清单55有没有交易员是在米兰工作的
代码清单56打印生淅在剑桥的交易员的所有交易额代码清单57所有交易中,最高的交易额是多
代码清单58找到交易额最小的交易22测验54:斐波纳契元组序列
斐波纳契数列是著名的经典编程练习。下面这个数列就是斐波纳契数列的一部分:0,1,
8,13,21,34,55…数列中开始的两个数字是0和1,后续的每个数字都是前两个数字之和
斐波纳契元组序列与此类似,是数列中数字和其后续数字组成的元组构成的序列:(O,1),
(1,1),(1,2),(2,3),(3,5),(5,8),(8,13),(13,21)
你的任务是用 iterate方法生成斐波纳契元组序列中的前20个元素
我们帮你入手吧。第一个问题是, iterate方法要接受一个 Unaryoper
七>作为
参数,而你需要一个像(0,1)这样的元组流。你还是可以(这次又是比较草率地)使用一个数组
的两个元素来代表元组。例如,ne
1}就代表了斐波纳契序列(0,1)中的第一个元
素。这就是 iterate方法的初始值
在这个测验中,你需要搞清楚?3代表的代码是什么。请记住, iterate会按顺序应用
定的 Lambda答案
tream
in七
七
呢? Iterate需要一个 Lambda来确定后续的元素。对于元组(3,5),其
续元素是(5,3+5)=(5,8)。下一个是(8,5+8)。看到这个模式了吗?给定一个元组,其后续
素是(t1],t0+t[1])。这可以用这个 Lambda来计算:t->ne
t[1
t
运行这段
你就得到了序列(0,1),、(1,1),(1,2,(2,3),(3,5),(5,8),(8,13),(13,21)…请注意,
果你只想打印正常的斐波纳契数列,可以使用map提取每个元组中的第
t(10)
段代码将生成斐波纳契数列:0,1,1,2,3,5,8,13,21,34·2第6章
内
用co1 lectors类创建和使用收集器
将数据流归约为一个值
汇总:归约的特殊情况
数据分组和分区
开发自己的自定义收集器代码清单61用指令式风格对交易按照货币分组集器
转换函数
取交易
货
偏历
组映身
母
货
易0
0
4集
在上一章和本章中讨论了很多有关归约的内容。你可能想知道, Stream接口的c
ct
和 reduce方法有
因为两种方法通常会获得相同的结果。例如,你可以像下面这样使
用 reduce方法来实现t
Co1 lector所做的
duce这个解决方案有两个问题:一个语义问题和一个实际问题。语义问题在于, reduce方法
在把两个值结合起来生成一个新值
不可变
此相反
eC万法的
要改变容器,从而累积要输出的结果。这意味着,上面的代码片段是在滥用r
因为它在原地改变了作为累加器的List
下一章中会更详细地看到,以错误的语义
reau
会造成一个实际问题:这个归约过程不能并行工作,因为由多个线程并发
修改同一个数据结构可能会破坏List本身。在这种情况下,如果你想要线程安全,就需要每
次分配一个新的L
对象分配又会影响性能。这就是
法特
表达
器上的归约的原因,更关键的是它适合并行操作,本章后面会谈到这一点
工nt9e:[tg:在刚刚提到的代码片段中,你可能已经注意到了?通配符,它用作 count
方法返
的收集器签名中的第二个泛型类型。对这种记法你应该已经很熟悉了,特别是如果你经常
用Jaa的集合框架的话。在这里,它仅仅意味着收集器的累加器类型未知,换勹话说,累加
本身可以是任何类型。我们在这里原封不动地写出了Co1 lectors类中原始定义的方法签名
但在本章其余部分我们将避免使用任何通配符表示法,以使讨论尽可能简单
测验6.1:用red
下哪一种re
g收集器的用法能够合法地替代j
集器(如6.2.3节用法)
tream
getName)(2)
g((d1,a2)
stream
2
答案:语勺1和语句3是有效的,语句2无法编译
(1)这会将每道菜转换为菜名,就像原先使
ng收集器的语句一样。然后用一个
String作为累加器归约得到的字符串流,并将菜名逐个连接在它后
(2)这无法编译,因为 reducing接受的参数是一个 Binaryoperator<t>,也就是一个
。这就意味着它需要的函数必须能接受两个参数,然后返回一个相同类
型的值,但这里用的 Lambda表达式接受的参数是两个菜,返回的却是一个字符串
(3)这会把一个空字符串作为累加器来进行归约,在遍历菜肴流时,它会把每道菜转换成
莱名,并追加到累加器上。请注意,我们前面讲过, reducing要返回一个 Optiona1并不需
要三个参数,因为如果是空流的话,它的返回值更有意义—也就是作为累加器初始值的空字
请注意,虽然语句1和语句3都能够合法地替
ng收集器,它们在这里是用来展示我
何可以(至少在概念上)把 reducing看作本章中讨论的所有其他收集器的概括。然而就
实际应用
管是从可读性还是性能方面考虑,我们始终建议使用 Joining收集器分组映射
应用
键
函数
代码清单62多级分组f代码清单63查找每个子组中热量最高的2数测验62:使用 partitioning
我们已经看到,和 grouping By收集器类似, partitioning By收集器也可以结合其他收
集器使用。尤其是它可以与第二个 partitioning By收集器一起使用来实现多级分区。以下多
级分区的结果会是什么呢
lect (p
d. getcalorie
rearm
tt
By(D
答案如下
(1)这是一个有效的多级分区
f
f
(2)这无法编译,因为
By需要一个谓词,也就是返回一个布尔值的函数
万
能用作谓词
算每个分区中项目的数目,得到
ap2码清单6
collector
接2开始
的的
有
取
束拆代码清单6-5
ector代码清单66将前个自然数按质数和非质数分区2代码清单6-7 Prime
niColleD第7章
内
用并行流并行处理数据
并行流的性能分析
分支冾合并框架
使用
ter
分割流流
7
0
11
18
10
26
36
配置并行流使用的线程池
看看流的para11e1方法,你可能会想,并行流用的线程是从哪儿来的?有多
自定义并行流内部使用了默认的 Forkjoinpool(7.2节会进一步讲到分支/合并框架),它默认
线程数量就是你的处理器数量,这个值是由 Runtime. getRuntime().avai1ab
rs()得到
但是你可以通过系统属性java.ut
oncurre
ork
来改变线程池大小,如下所
P
是一个全局设置
将影响代码中所有的并行流。反过来说,目前还无法专为某
并行流指定这个值。一般而言,让 Forkjoinpool的大小等于处理器数量是个不错的默认值
除非你有很好的理由,否则我们强烈建议你不要修改它
代码清
然数求和的函数的性能数22代码清
用分支/合并框架执行并行求和2拆分
拆分
工作线程1
1正在运行
拆分
工作线程2
窃取
2
1正在运行
工作线程3
窃取
1正在运行
工作线程4
窃取
1正在运行代码清单73sp1 iterator接口terato
代码清单74一个迭代式字数统计方法码清单7-5用来在遍历 Character流时计数的类teratSplitePart i
第三部分
高效Java8编程
本书第三部分将探究如何结合现代程序设计方法利用Java8的各种特性更有效地改善代码
质量
第8章会介绍如何利用Java8的新特性及一些技巧,改进现有代码。除此之外,还会探
些非常重要的软件开发技术,譬如设计模式、重构、测试以及调试
第9章中,你会了解什么是默认方法,如何以兼容的方式使用默认方法改进
实
使用模式,以及有效地利用默认方法的规
第10章围绕Java8中全新引入
a1类展开。java.u
n a
类能帮助我们设计出更优秀的API,同时降低了空指针异常发生的几率
第11章着重介绍 Completab1 efuture类。通过 Completablefuture类,我们能以
性方式描述复杂的异步计算,即并行 Stream API的
第12章探讨了新的Date和Time接口,这些新接口极大地优化了之前处理日期和时间时极
易出错的本章内容
如何使用 Lambda表达式重构代码
Lambda表达式对面向对象的设计模式的影响
ambda表达式的测试
如何调试使用 Lambda表达式和 Stream ap的代码2头2222222第9章
内
么是默认方法
如何以一种兼容的方式改进A
默认方法的使用模式
解析规贝支持的方
法,虚
表示抽象方法
攴持的方法
2227
持的方法
实态方法及接
时定义接口以及工具辅助类( companion class)是Java语言常用的一种模式,工具类定
义了与接口实例协作的很多静态方法。比如,Co1 lect ions就是处理Co]] ection对象的辅
助类。由于静态方法可以存在于接口内部,你代码中的这些辅助类就没有了存在的必要,你
以把这些静态方法转移到接口内部。为了保持后向的兼容性,这些类依然会存在于Java应用程
序的接口之2不同类型的兼容性:二进制、源代码和函数行为
变更对Java程序的影响大体可以分成三种类型的兼容性,分
进制级的兼容、源代
玛级的兼容,以及函数行为的兼容。刚才我们看到,向接口添加新方法是二进制级的兼容,
最终编译实现接口的类时却会发生编译错误。了解不同类型兼容性的特性是非常有益的
我们会深
这部分的
制级的兼容性表示现有的二进制执行文件能无缝持续链接(包括验证、准备和解析)
和
比如,为接口添加一个方法就是二进制级的兼容,这种方式下,如果新添加的方法不
被调用,接
实现的方法可以继续运行,不会出现错误。
简单地说,源代码级的兼容性表示引入变化辶后,现有的程序依然能成功编译通过。比如
接口添加新的方法就不是源码级的兼容,因为遗留代码并没有实现新引入的方法,所以
无法顺
过编译
最后,函数行为的兼容性表示变更发生之后,程序接受同样的输入能得到同样的结果
如,为接口添加新的方法就是函数行为兼容的,因为新添加的方法在程序中并未被调用(抑或
该接口在实现中被覆ava
象类和抽象接
那么抽象类和抽象接口之间的区别是什么呢?它们不都能包含抽象方法和包含方法体的
实现吗
类只能继承一个抽象类
类可以实现多个接
其次,一个抽象类可以通过实例变量(字段)保存一个通用
接口是不能有实例变
验9
这个测验里,假设你是Java语言和API的一个负责人。你收到了关于rem
方法的很
请求,希望能为Ar
reeset
ke
以及其他集合类型添加
法的功能是删除满足给定谓词的所有元素。你的任务是找到添加这个新方法、优
化 Collecti
的最佳途径。
答案:改进 Collection api破坏性最大
是什么?你可以把 removeif的实现直接复制
到 Collection apl的每个实体类中,但这种做法实际是在对Java界的犯罪。还有其他的方式吗
你知道吗,所有的
tion类都实现了一个名为java.uti1.co1 lection的接
好
那么我
在这里添加一个方法
需要牢记,默认方法是一种以源码兼
向接口内添加实现的方法。这样实现Co1 Iction的所有类(包括并不隶属 Collection API
用户扩展类)都能使用 removeif的默认实现。 remover的代码实现如下(它实际就是Java8Collection apl的实现)
n接
个默认方法
b
e
era
each功
功能
力能
功能关于继承的一些错误观点
继承不应该成为你一谈到代码复用就试图倚靠的万精油。比如
个拥有100个方法及
字段的类进行继承就不是个好主意,因为这其实会引入不必要的复杂性。你完全可以使用代理
有效地规避这种窘境
建
通过该类的成员变量直接调用该类的方法。这就是为什
有的时候我们发现有些类被刻意地声明为fina1类型:声明
的类不能被其他的类继
承,避免发生这样的反模式,防止核心代码的功能被污染。注意,有的时候声明为￡ina1的类
都会有其不同的原因,比如, string类被声明
为我们不希望有人对这样的核心
功能产生干扰
这种思想同样也适用于使用默认方法的接口。通过精简的接口,你能获得最有效的组
因为你可以只选择你需要的实现2测验92:牢记这
我们在这个测验中继续复用之前的例子,唯一的不同在于D现在显式地覆盖了从A接口中
继承的he11方法。你认为现在的输出会是什么呢
答案:由于依据规则(1),父类中声明的方法具有更高的优先级,所以程序会打印输出¨Hel
意,D的声明如
这样的结果是,虽然在结构上,其他的地方已经声明了默认方法的实现,C还是必须提供测验93
全一样的函数签名
个测试中,我们假设接口A和B的声明如下所
public
recur
B
pub static venenmainistring.. aras)
这个程序的会打印输出什么呢?
答案:类C无法判断λ或者B到底哪一个更加具体。这就是类C无法通过编译的原因题
C艹语言中的茇形问题要复杂得多。首先,C艹允许类的多继承。默认情况下,如果类D
继承了类B和类C,而类B和类C又都继承自类A,类D实际直接访问的是B对象和C对象的副本
最后的结果是,要使用A中的方法必须显式地声明:这些方法来自于B接
是来自于C接
此外,类也有状态,所以修改B的成员变量不会在C对象的副本中反映出来第10章
10
发的问题,以及为什么要避免
从
nal
11安全的方式重写你的域模型
ption发光发热:去除代码中对nu11的检查
读取
1中可能值的几种方法
可能缺失值的再思考代码清单
Perso
rance的数据模型
代码清单102m1安全的第一种尝试:深层质疑
每
用
乘
套代码清单103m11安全的第二种尝试:过多的退出语句
添加新的退出点
每个n11检查都
新的退2
0包
类型的对象
象3应用
a
代码清单104使用 ption.重新定义
erson/
的数据模型
有车,也可
有车,因此将这个字段
能没有保
段
假着用
飞种模
Strea
Strea
tional
ap
△sn△△△△△△0.3
用
的几种模
代码清单10-5使
a1获取car的
名称
果
空,设置默认值
/optional/
∠opti。nal/
p(
第1步
第2步
tional/
保险公
名称
第4步
第3步域模型中使用 optio
以及为什么它们无法序列化
在代码清单10-4中,我们展示了如何在你的域模型中使用 Optiona1,将允许缺失或者暂
义的变量值用特殊的形式标记出来。
ption1类设计者的初衷并非如此,他们构
思时怀揣的是另一个用例。这一点,Java语言的架构师 Brian goetz曾经非常明确地陈述过
ona1的设计初衷仅仅是要支持能返回 Optiona1对象的语法
由于 Optional类设计时就没特别考虑将其作为类的字段使用,所以它也并未实现
ble接口。由于这个原因,如果你的应用使用了某些要求序列化的库或者框架,在
域模型中使
1,有可能引发应用程序故障。然而,我们相信,通过前面的介绍,你
看到用Op
明域模型中的某些类型是个不错的主意,尤其是你需要遍历有可能全
部或部分为空,或者
存在的对象时。如果
要实现序列化的域模型,作为替代方案,
我们建议你像
例子那样,提供一个能访问声明为 Optional、变量值可能缺失的接口,
代码清单如下
C Op
a
e
ble(用
飞种模验101:以不解包的方式组合两
对象
结合本
绍的map和 flatMap方法,用一行语句重新实现之前出现的nu11sa
案:你可以像使用三元操作符那样,无需任何条件判断的结构,以
句实现该方法,
11
retur
eapest
rar
这段代码中,你对第一个 Optiona1对象调用 atAp方法,如果它是个空值,传递给它
Lambda表达式不会执行,这次调用会直接
对象。反之,如果per
对象存在,这次调用就会将其作为函数 Function的输入,并按照与
Mar
法的约定返
nce>对象。这个函数的函数体会对第
t
象执行map操
作,如果第二个对象不包含Car,函数
就
空的
a1对象,整个
a士e
eapest
法的返回值也是一个空的 Optiona1对象。最后,如果
er son
和car对象都存在,作为参数传递给map方法的 Lambda表达式能够使用这两个值安全
地调用原始的 findc
insurance方法,完成期望的操作用 Optiona
种模
测验102
象
假设在我们的Per
模型中, Person还提供了一个方法可以取得
erso
对象的年龄,请使用下面的签名改写代码清单10-5中的 getcarInsurance№ame方法
找出年龄大于或者等于 minAge参数的P
所对应的保险公司列表
答案:你可以对 Optional封装的 Person对象进行fi1ter操作,设置相应的条件谓词
如果 person的年龄大于 minAge参数的设定值,就返回该值,并将谓词传递
七er方法
码如下所
ge)
ge
nAge)0.4
用
a1的实战示例
代码清单10-6将 String转换为 Integer,并返
个Op
na1对象
如果
g
Opt
对象中返
象清单10
式编程的方式从属性中读取
tion
名
的属性存在
条件测验10.3:使
d
请尝试使
onal类提供的特性及代码清单10-6中提供的工具方法,通过一条精炼
语句重构代码清单10-7中的方法
答案:如果需要访问的属性值不存在, Properties. getproperty( String)方法的返回
值就是一个
使
ble工厂方法非常轻易地就能把该值转换为 Optional对象。接
可以向它的￡ atMan方法传递代码清单10-6中实现的 OptionalUtility. string
方法的引用,将
tring>转换为 Optiona1< Integer>。最后
常轻易地就
以过滤掉负数。这种方式下,如果任何一个操作返回一个空的opt
对象,该方法都会返
Blse方法设置的默认值0;否则就返回封装在oρ tiona1对象中的正整数。下面就是这段
简化的实现
s. getP第11章
创建异步计算,并获取计算结果
使用非阻塞操作提升吞
设计和实现异步A
如何以异步的方式使用同步的A
如何对两个或多个异步操作进行流水线和合并操作
如何处理异步操作的完成状态第11章comp1etab1 eFuture:组合式异步编程
尔的程序
排序
某个话题
留言回帖
前热帖
法文版
前热帖
acebook
程服务
Google Translate
Witte
任务1
任务2
任务
任务2
任务1代码清单
使用Fut
的方式执行一个耗时的操
父
象
它
万
新的线
任
操作进
耗时的操
可
他的事
获取
的
果,如果最终被
果
多
待1
后退re接同步AP与异步AP
同步API其实只是对传统方法调用的另一种称呼:你调用了某个方法,调用方在被调
运行的过程中会等待,被调用方运行结束返回,调用方取得被调用方的返回值并继续运行。即
使调用方和被调用方在不同的线程中运行,调用方还是需要等待被调用方结束运行,这就是阻
塞式调用这个名词的由来
此相反,异步API会直接返
者至少在被调用方计算完成之前,将它剩余的计算任
务交给另一个线程去做,该线程和调用方是异步的——这就是非阻塞式调用的由来。执行剩余
算任务的线程会将它的计算结果返回给调用方。返回的方式要么是通过回调函数,要么是
调用方再次执
等待,直到计算完成”的方法调用。这种方式的计算在ⅠO系统程序设
计中非常常见:你发起了一次磁盘访问,这次访问和你的其他计算操作是异步的,你完成其他
的任务时,磁盘块的数据可能还没载入到内存,你只需要等待数据的载入完成代码清单11-2模拟1秒钟延迟的方法
代码清单113在 netprice方法中引人一个模拟的延清单11-4getP
方法的实现
另
含计算的结
万
长
算的任务
束并得出结果
等待
直接返
象
代码清
使用异步AP
查询商店,试图
商
价格,如果
未知码清单11-6抛
tablefuture内的异常
并设
就抛出导致失
成代码清单117使用厂力法 supplyAsyno创 tcompletableFuture对象代码清单118釆用顺序查询所有商店的方式实现的 findPrices方法
代码清单119验证 findprices的正确性和执行性
代和
码清单11-10对fina
进行并行操作
高获取地然代码清单111使用 completableFuture实现 lfinaprices方法
方式计算每种商
勺价格
待所
操作结束顺序执
并行执
P
future2
()
()使用顺序流方式的程序输出
使用并行流方式的程序输出
C
etable调整线程池的大
《Java并发编程实战》(
gbz/979c)一书中, Brian goetz和合著者们为线程池大
的优化提供了不少中肯的建议。这非常重要,如果线程池中线程的数量过多,最终它们会竞争
稀缺的处理器和内存资源,浪费大量的时间在上下文切换
果线程的数目
如你的应用所面临的情况,处理器的一些核可能就无法充分利用。 Brian goetz建议,线程池大
小与处理器的利用率之比可以使用下面的公式进行估算
/C)
其
CpU是处理器的核的数目,可以通过 Runtime.getR
tabler
SSOrS()得到
PU是期望的CPU利用率(该值应该介于0和1之间)
口WC是等待时间与计算时间的比率
代码清单112为“最优价格查询器”应用定制的执行器
线
数
戋程—这
和商店
较
关行——使用流
目前为止,你已经知道对集合进行并行计算有两种方式:要么将其转化为并行流,利用
这样的操作开展工作,要么枚举出集合中的每一个元素,创建新的线程,在 Completab1
Future内对其进行操作。后者提供了更多的灵活性
调整线程池的大小
能帮助
确保整体的计算不会因为线程都在等待IO而发生阻塞
我们对使用这些API的建议如下
如果你进行的是计算密集型的操作,并且没有ⅣO,那么推荐使用 Stream接口,因为实
简单,同时效率也可能是最高的(如果所有的线程都是计算密集型的,那就没有必要
创建比处理器核数更多的线程)
反之,如果你并行的工作单元还涉及等待IO的操作(包括网络连接等待),那么使用
theFuture灵活性更妤,你可以像前文讨论的那样,依据等待/计算,或者
W℃的比率设定需要使用的线程数。这种情况不使用并行流的另一个原因是,处理流的
流水线中如果发生ⅠO等待,流的延迟特性会让我们很难判断到底什么时候触发了等待代码清
枚举类型定义的折扣代码代砰
4 D
服务
扣代码
的原始价格
码清单11-15以最简单的方式实现使用 DIscount服务的 indices方法
商品的原e对象
返
符
换
务,为每
代码清单11-16使
potable
ure
实现 findprices方法
每
te对象存在时
听有
并提2代码清单
并两个独
p⊥e
eFuture对象
第一个任务查询
商
格
乘
敕攵
商
第
务换
询
美元和欧代码清单118利用ANa7的方法合并两个 Future对象
任务
线程池
换汇率的
第二个
查询指定商
查找价格操作的同
特定商
率代码清单19个模拟生成05秒至25秒随机延迟的方法应C
letablefuture
leto
事
代码清单1120重构 IfindPrices达返回一个由 Future枃成的流清
响应 Completab1
的comp1
件2第12章
为什么在Java8中需要引入新的日期和时间库
同时为人和机器表示日期和
定义时间的度量
操纵、格式化以及解析日期
处理不同的时区和历法代码清单12-1创建
caudate对象并读取其值
AR冯清单12-2使用 Tempora1Fied读取 Locellate的值
代码清单123创建 Localtimej读取其值
码清单
创建 Localdaterime对象,或者通过合并日期和时间的方式创建ca⊥Date、L
nstant
t
以及P
20140318
万纳秒码清单
建 Duration和代码清单126以比较直观的方式操纵 ( LoculAte的属性
代码清单127以相对方式修改 LocalDate对象的属性测验12.1操纵
e对象
经过下面这些操作,date变量的值是什么
Dat
R
(2
D
011
答案
正如我们刚才看到的,你可以通过绝对的方式,也能以相对的方式操纵日期。你甚至还可
以在一个语句中连接多个操作,因为每个动作都会创建一个新的Loca1Date对象,后续的方
去调用可以操纵前一方法创建的对象。这段代码的最后一句不会产生任何我们能看到的
因为它像前面的那些操作一样,会创建一个新的 LocalDate实例,不过我们并没有将这个新
创建的值赋给任何的变量代码清单128使用预定义的 emporalAd
014-03
20140331清单12-9
1
ster接
实现一个定制的
青设计一个
kingDay类,该类实现了Term
e接口,能够计算明天
的日期,同时过滤掉周六和周日这些节假日。格式如下所
如果当天的星期介于周一至周五之间,日期向后移动
果当天是周六或者周日
返回
答案
是参考的Next
gDay类的实现
Wor
卖取当前
五,增加3天
如果当天是周
该Te
ter通常情况下将日期往后顺延一天,如果当天
或者周日,则
依据情况分别将日期顺延3天或者2天。注意,由于T
疋
数式扫
你只能以 Lambda表达式的方式向该 adjuster接口传递行为
dd
Week. FR
Week
RD
Add
DUnit. DAYS
你大概会希望在你代码的多个地方使用同样的方式去操作日期,为了达到这一目的,我
建议你像我们的示例那样将它的逻辑封装到一个类中。对
常使用的操作,都应该采用类
似的
进行封装。最终,你会创建自己的类库,让你和你的团队能轻松地实现代码复用
如果你想要使用 Lambda表达式定义
x对象,推荐使用 Tempora
xs类的静态
法
ter,它接受
opErat
t类型的参数,代码如
Y
O
e
(ae
k. FR
dd
140318
代码清单1210按照某个模式创建 tDateTimeFormatte.代码清单1211创建一个本地化的 DateTime Formatte.
代和
12构造
Daten
matter代码清单12-13为时间点添加时区信息
2014-05-14T15:33:05.941+01:00
L○na
Ca⊥Date
ocala
need
Locatedater
dDat得当前
期,紧接着
行修正,得到斋月的
月始于2014-06-28
014Part 4
第四部分
超越Java8
在本书的最后一部分,我们简单地
ava中的函数式编程,并对Java8和 Scala中
特性进
第13
地介绍函数式编程,介绍它的术语,并详细介绍如何在Java8
进行函数式编程
第14章会讨论函数式编程的一些高级技术,包括高阶函数、科里化、持久化数据结构
延迟列表,以及模式匹配。你可以将这一章看作一道混合大餐,它既包含了能直接应用到你
代码中的实战技巧,也囊括了一些学术性的知
助你成为知识更加渊博的程序员
第15章讨论Java8和 Scala语言的特性比较—— Scala是一种新型
和Java有几分
似,都构建于JVM之上,最近一段时间发展很迅猛,在编程生态系统中已经对Java某些方
的固有地位造成了威胁
最后,我们在第16章回顾了学习Java8的旅程,以及向函数式编程转变的潮流。除此
外,我们还展望了会有哪些改进以及重要的新的特性可能出现在Java8之后的版本里第13章
为什么要进行函数式编程
么是函数式编程
声明式编程以及引用透明性
编写函数式Java的准贝
迭代和递类拥
类2输入
functio
输出输出果
就
集,既空列表自身
将两
就取出
素
案
找出剩
有子集
在一起就
并将其赋
成了任
构成了结果
半
务,简
案的
听有列表
调
每个列表的第
兀素之削
f使你有
其
添加操作。即
孩复制底层的结构
过 Integer底层是不可变的2清
迭代式的阶乘
码清单13-2递归式的阶乘计算
代码清单
阶乘
代码清单13-4基于“尾-递”的阶乘第一次调用
4
第二次调用
f
士
第三次调用
第四次调用
factorialtailre
fact
rialfailRecursive(1, 4)
factorialtailr
(24,第14章
内
等成员、高阶方法、科里化以及局部应用
持久化数据结构
生成 Java stream时的延迟计算和延迟列表
模式匹配以及如何在Java中应用
引用透明性和缓存作用和高阶函数
第7章中我们了解到传递给流操作的函数应该是无副作用
各种各样(比如错误的结果,有时由于竞争条件甚至会产生我们无法预期的结果)。这一原则在你使用高
阶函数时也同样适用。编写高阶函数或者方法时,你无法预知会接收什么样的参数—一旦传
入的参数有某些副作用,我们将会一筹莫展!如果作为参数传入的函数可能对你程序的状
某些无法预期的改变,一旦发生问题,你将很难理解程序中发生了什么;它们甚至会用某种
难于调试的方式调用你的代码。因此,将所有你愿意接收的作为参数的函数可能带来的副作用
以文档的方式记录下来是一个不错的设计原则,最理想的情况下你接收的函数参数应该没有任
何副作用化的理论定义
科里化是一种将具备2个参数(比如,x和y)的函数f转化为使用一个参数的函数g,并
这个函数的返回值也是一个函数,它会作为新函数的一个参数。后者的返回值和初始函数的
返回值相同,即f(x,y)=(
当然,我们可以由此推出:你可以将一个使用了6个参数的函数科里化成一个接受第
6号参数,并返回一个接受5号参数的函数,这个函数又返回一个接受剩下的第1号和第3号参数
的函数。
函数使用所有参数仅有部分被传递时,通常我们说这个函数是部分应用的( partial
applied )o2→
X
之
竽2Georgie: 23
W:2622Fun
azy2音
使用了一个sur
方法提供了延迟性新的
(),不
象的效22代码清单141使用模式匹配简化表达式
处
果用户
无
机制2果n的
接返
不做”的标认
执行函数f,重复执
次,紧接着再执第15章
本章内容
8与 Scala是如何相生相承的
Scala中的函数与Java8中的函数有哪些区别
类和trai在字符串中插值2这里的操作符+会将8添加
建并返回一个新的set对象
修改与不可变的比较
Java中提供了多种方法创建不可修改的( unmodifiable)集合。下面的代
mbers是集合Set对象 numbers的一个只读视图
意味着你无法通过操作变量new№ umbers向其中加入新的元素。不过,不可修改集合仅
是对可变集合进行了一层封装。通过直接访问 numbers变量,你还是能向其中加入元
与此相反,不可变(
)集合确保了该集合在任何时候都不会发生变化,无论有
少个变量同时指向
我们在第14章介绍过如何创建一个持久化的数据结构:你需要创建一个不可变数据结构
该数据结构会保存它自身修改之前的版本。任何的修改都会创建一个更新的数据结构()
perc
()
输入
结类型为
014
打印输出32这是一个函数类型的变量,它接
数
布尔类型的
一个匿名函数
返回a16e捕获并递增
输
打印输
须为
或者在
为科里化函数圆题为size的字段
默认实现的
万
一个继承自 trait sized的类
输
在对象实例化时构建trat第16章
内
Java8的新特性以及其对编程风格颠覆性的影响
由Java8萌生的一些尚未成熟的编程思
ava9以及Java10可能发生的变2类型不兼容222对象
值类
0.1
12附录A重
注解返
由重复注解
成的数1附录B
B查数据
否已经缓
果数据没有缓存,那就访问网
数据,紧接着对Map中的数
行缓存
来使用之需
4,6ongAdder计算多个值之和
多个不
的
线程中进
法运算
代码清单B2
LongAn
算多个值之
几个不同的线
算值
某
果代码清.
使用para11e1 Prefix并发地累积数组中的元素2附录C
码清单C-1定
treamF'orker,
在一个流上执行多个操使用
键
的函数进
流
ork
并行计算
结果代码清单C2使用b1方法创建1n
例廴
队列组成的列表
操
用
乍的键与
作结果
射关系代和
3
getoperat
方法创建 Futur
并将其添
rator
的元素
t
re对象
万
作为数据源
算
特定函数的结果
码清单C-4实现 ForkingstreamConsumer类
添加处理多个队列的流遍历的元素
到所有的队列
最后一个元素
流已经结束
等待Pu
关的计算
特定键
处理结果
代码清单C5个遍历B1king9uee并读取其中元的sp1 erato.1象
接
调用
用
周用
应用
应用
应用
esp
码清单C-6将 StreamForker运用于实战1附录D
D代码清单D-1以匿名内部类的方式实现的
n接代码清单D2使用 Lambd表达式实现的 Funct
字节码指令 invokedynamic最初被JDK7引入,用于支持运行于JVM上的动态类型语
执行方法调用时,
添加了更高层的抽象,使得一部分逻辑可以依据动态语言
的特征来决定调用目标。这一指令的典型使用场景如
这里a和b的类型在编译时都未知,有可能随着运行时发生变化。由于这个原因,JVM首
次执行 invokedynamic调用时
杳
bootstrap方法,该方法实现了依赖语言的逻
辑,可以决定选择哪一个方法进行调用。υ bootstrap方法返回一个链接调用点( linked
很多情况下,如果ada方法使用两
类型的变量,紧接下来的调用也会使用两个int类型
的值。所以,每次调用也没有必要都重新选择调用的方法。调用点自身就包含了一定的逻辑,
可以判断在什么情况下需要进行重新链接1TURING
图灵教育
延展阅读
圆灵程序设计品带
TNG图灵程序设计丛书
OREILLY
ava性能优化圣经!Java之父重磅推荐!
Java缟衔
Java Performance
Jaa性能
lava 8
权威指南
函数式编程
柳飞陆羽刚臧秀
中工信出爹人图性
回响国工信出集团人出服
参A民邮电出腰
OREILLY
TN图灵程序设计丛书
The Well-Grounded
d Polyglot Programmer
Java
程序员思维修炼
(修订版)
程序员
本让你重新认识大脑、认知自己的书
Java
e修炼之道
中;B
] Andy Hunt著
技术手册
而61的用
回中国工出酸剩从民邮出图
参A民邮电图
拿人民邮电出社
OREILLY
《人件】作者又一力作,入末三分刻
TuNG圈灵程序设计丛书
ms国设计
项目百态
Scala与 Clojure
软件项目管理面面观
函数式编程模式
(修订版
Java虚拟机高效编程
学会方,最大程度完化
学握21个国式,从置句对象从容过图数式编程
器
全端Web开发
使用 JavaScript与Java
ORono
Chent Server Web Apps with Jarwarscript and
口中工信出版集团参太民邮电出
回中信較集寥以电也艇
团中国工信出版集团參為民無出版关注图灵教育关注图灵社区
tUring. cn
在线出版电子书《码农》杂志图灵访谈
QQ联系我们
图灵读者官方群I:218139230
图灵读者官方群:164939616
微博联系我们
官方账号:@图灵教育@图灵社区@图灵新知
市场合作:@图灵袁野
写作本版书:@图灵小花@图灵张霞@毛倩倩-图灵
翻译英文书:@朱巍 Turing@楼伟珊
翻译日文书或文章:@图灵日语编辑部
翻译韩文书:@图灵陈曦
电子书合作:@h_ anne
图灵访谈/《码农》杂志:@刘敏tung
加入我们:@王子是好人
微信联系我们
口
图灵教育
图灵访谈
turingbooks
turing interviewJava8的发布使Java程序设计发生了翻天
覆地的变化。利用Java8中新引入的函数式特
性,你可以在更短的时间内用更简洁的代码完
这是一部十分优秀且简明的著作,书
成更复杂的功能,同时还能充分利用硬件的多
中提供了大量的示例,能帮助你迅速地掌
核架构。
握Java8中的新特性。”
本书结构清晰、内容翔实,从实例入手,
Jason lee,甲骨文公司
涵盖Java8的主要新特性,包括 Lambda表达
式、方法引用、流、默认方法、 fiona1、
“这是最棒的ava8指南!”
Comp1etab1 efuture以及新的日期和时间
William Wheeler
APl,是程序员了解Java8新特性的终极指南。
ProData Computer Systems公司
本书的主要内容如下:
“这本书中有关新的 Stream api及 Lambda
●如何使用Java8新增的强大特性
表达式的示例非常有用。”
●如何编写能有效利用多核架构的程序
Steve Rogers, CGTek公司
●重构、测试和调试
●怎样高效地应用函数式编程
“这是所有使用Jaa8函数式特性的程序
员都必备的工具书。”
Mayur S.Pati,麻省理工学院
ISBN978-7-115-41934-7
MANNING
图灵社区: Turing. cn
热线:(010)51095186转600
9m7871154193471>
分类建议计算机程序设计ava
SBN978-7-115-41934-7
定价:7900元
人民邮电出版社网址:www.ptpress.com.cn看完了
如果您对本书内容有疑问,可发邮件至 contact@ turingbook.c
有编辑或作
译者协助答疑。也可访问图灵社区,参与本书
如果是有关电子书的建议或问题,请联系专用客服邮箱
book@turingbook
微博@图灵教育:好书、活动每日播报
微博@图灵社区:电子书和好文章的消
微博@图灵新知:图灵教育的禾
微信
n
述码农精彩人生
数信图灵教育
books