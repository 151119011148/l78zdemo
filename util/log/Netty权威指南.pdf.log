Broadview
ww broadview,om,面
Nett
权威指南
(第∠版)
李林锋/著
Java高性能N|O通信首选框架
大数据时代构建高可用分布式系统利器
Netty: The Definitive Guide, 2nd Edtion
回中国工信出版集团重子三出照社Broadview博文视点·「出版旗舰品牌
Duawiew,Gomen技术凝聚实力·专业创新出版
4专家力荐
林锋让我给这本新书写个推荐,不胜荣幸。我和林锋最近几年,Nety社区的发展如火如茶,无论是大数
接触时间不长,已经感受到了他对技术的热爱和不尽据领域的演进,还是微服务架构的流行,都需要髙效
探索。这种热爱完全来自于内心的驱动,不掺杂任何的分布式通信机制作为基本支撑, Netty凭借优异的
杂质,我认为他是我见到的为数不多的技术热爱者。
性能、灵活的扩展性得到了广泛的应用。林锋兄曾将
也正是因为这种热爱,促使林锋花费了很多业余时自己在NO领域的积累以博文的形式共享,得到了
间,完成了这样一本对Net的权威编程指南。相信Java社区的热烈响应,他对NO领域的积累和见解令
人敬佩。本次升级更新后的第2版,相信会有更多新
读者在阔读此书时,在感叹内容之丰富详实的同时,鲜和实用的知识增加进来,毫无疑间,它会成为学习
也会深深感受到林锋对所著技术的热爱。我想这就是高性能NO的必备图书
我们通过书中文字相遇的初衷吧。当我们的技术能够
「图书译者、 InfoQ编辑张卫滨
日益精进,达到专业的水准,生产力会成倍甚至指数
級地増长。希塱读者能够通过阅读此书获取这种精进设计开发基于异步編程模型的髙性能服务器,除了理
的力量。
解和熟练应用NIO等这些ava层面的基础知识之外,
BM中国开发实验室开发总监黄省江能够驾驭优秀的异步通信框架也是非常重要的,
Nety无疑是lava领域最值得学习和研究的异步事件
Ne的越之处在于它是一个高性能、异步事件驱动驱动的NO框架。作者有着多年的NO开发和运维经
的NO框架,目前很多著名的开源框架开始将底层的验,本书浓缩了作者多年实战经验,推荐给对Nety
通信框架切换到Net!,如 Hadoop、 Storm等,技术感兴趣、想研究的攻城狮阅读!
Facebook的后台也即将启用这一优秀框架。希望这本
蚂蚁金服基础技术部 JVM Architect李三红
书的面市能够对Net在国内的发展起到推动作用。
Facebook.资深工程师覃超ey是一个令人惊讶的项目,在短短几年内成为众多
Java高并发异步通信的首选框架。但目前国内资料极
中国最大的阅读类应用—中国移动手机阅读基地,少并缺乏系统性,而李兄的这本系统介绍Nety开发和
每天承受着5-75亿PV的访问量,为了实现业务的弹
原理的书籍,很完美地填补了这个空白。国内的技术
性,华为 Digital SDP产品承接了对其后台进行微服务
人员对 lava NIo和Nety的理解多一些,也就意味着国
重构的工作,一个PV背后的后台原子接口访问达到
内整体网络编程技术的进步。本书条理清晰,对技术
几十乃至上百次,还要保证9%的页面访问在500ms的阐述循序渐进,是一本难得的Ne学习教材,推荐
内响应,在这样的压力下,高效的通信机制尤其重
要,林锋基于Net构建的对等通信虚拟总线很好地有志青年仔细学习研究本书,共同把NO异步通信编
承载了这一需求。平均通信时延07m,80%以上的程推向一个新高度
通信时延都保持在lms以下,其余通信时延都低于
JBoss应用服务器核心开发组成员张建锋
3ms,在响应速度这一重要指标上不仅满足了客户的《Net权威指南》是本难得的循序渐进地介绍Java
要求,而且还带来了系统可伸缩性和弹性上的巨大提NO到Nety演变历程的好书,能让读者身临其境地
升,林锋在本书中阐释的Nety应用上的经验和技巧绝明晓通信开发中的各种问题场景和解决办法,更高效
对值得期待。
更合理地开发PC通信程序。
华为 Digital SDP首席架构师王慷
苏宁易购架构师吴杰
上架建议:计算机>程序开发斗
口
IsBN978-7-121-25801-5
新浪微博
weibo. com
博文视点 Broadview回论@博文视点 Broadview
责任编辑:董英
97871211258015l
封面设计:侯士卿
定价:8900元Netty
权威指南2n
李林锋/著
電子工業出版社
Publishing House of Electronics Industry
北京 BEIJING内容简介
Nety权威指南(第2版)》是异步非阻塞通信领域的经典之作,基于最新版本的Nety5.0编写,是
国内首本深入介绍Nety原理和架构的书籍,也是作者多年实战经验的总结和浓缩。内容不仅包含 Java nio
入门知识、Nety的基础功能开发指导、编解码框架定制等,还包括私有协议栈定制和开发、Nety核心类
库源码分析,以及Nety的架构剖析。
本书适合架构师、设计师、软件开发工程师、测试人员以及其他对 Java nic框架、Nety感兴趣的相
关人士阅读,通过本书的学习,读者不仅能够掌握Net基础功能的使用和开发,更能够掌握Nety核心
类库的原理和使用约束,从而在实际工作中更好地使用Net!ys
未经许可,不得以任何方式复制或抄袭本书之部分或全部内容。
版权所有,侵权必究。
图书在版编目(C|P)数据
Nety权威指南/李林锋著.-2版.一北京:电子工业出版社,20154
ISBN978-7-121-25801-5
1.①N…Ⅱ.①李…Ⅲ①JAA语言一程序设计一指南Ⅳ.①TP31262
中国版本图书馆CP数据核字(2015)第067682号
责任编辑:董英
印刷:北京丰源印刷厂
装订:三河市皇庄路通装订厂
出版发行:电子工业出版社
北京市海淀区万寿路173信箱邮编100036
开本:787×9801/16印张:35.75字数:758千字
版次:2014年6月第1版
2015年4月第2版
印次:2015年4月第1次印刷
定价:89.00元
凡所购买电子工业出版社图书有缺损问题,请向购买书店调换。若书店售缺,请与本社发行部联系,
联系及邮购电话:(010)88254888。
质量投诉请发邮件至zls@phei.com.cn,盗版侵权举报请发邮件至dbqqaphei.com.cn。
服务热线:(010)88258888前
2014年6月《 Netty权威指南》第1版面世之后,很多读者通过邮件等方式向我表达
了对本书的喜爱和赞誉。同时,对本书的一些瑕疵和不足也进行了指正,并给出了合理的
建议。我对读者反馈的合理建议进行了记录和总结,以期在未来修订版或者第2版中能够
修正这些问题
大约在2014年11月份的时候,编辑与我协商出版《Nety权威指南(第2版)》的事
宜,考虑到如下几个因素,最终我决定推出第2版:
第一版需要修正少部分印刷不太清晰的图片,这会改变后续章节的页码;
源码分析章节的代码希望重新编排一下,与前面的开发示例保持一致;
部分章节和内容需要优化调整
部分读者对推出第2版的要求
第2版的主要变更如下,删除第1版中的如下章节:
a第7章:Java序列化;
第12章:UDP协议开发
第13章:文件传输
第22章:Nety行业应用
新增本书中的如下章节:
第7章: MessagePack编解码
第13章:服务端创建;
第14章:客户端创建;
第22章:高性能之道
第23章:可靠性Net权威指南(第2版)
第24章:安全性
第1版最初的想法是尽量照顾NIO编程和Nety初学者,因此入门和基础功能使用示
例占了很大比例,涵盖的范围也很广。但事实上,由于Ney的功能过于庞杂,一本书很
难涵盖 Netty的所有功能点,因此,删除了不太常用的Java序列化、UDP协议开发和文件
传输。
Net!y行业应用的内容很多读者都很期望,希望能够展开详细讲解一下。我思索再三,
忍痛割爱,不仅没有加强本章节,反而删除了它。为什么昵?对于真正想了解行业应用的
读者,需要展开详细讲解才能够讲透,剖开Nety在 Spark、 Hadoop等大数据领域的应用
不谈,即便是作为分布式服务框架的内部高性能通信组件,例如 Dubbo,没有大篇幅也很
难讲透,与其一笔概括,泛泛而谈,还不如留给其他作者或者未来抽空单独梳理。
掌握Nety的基础功能使用比较容易,但是理解 Netty底层的架构以及主要架构特性
的设计理念却是件困难的事情,它需要长期的行业积累以及对Net!y底层源码的透彻理解。
应广大读者的要求,在第2版中新增了Nety的高性能、安全性和可靠性的架构剖析,通
过这些章节的学习,读者可以更加清晰地理解 Netty架构设计理念。
尽管我本人已经有7年的NO编程和实战经验,在产品中也广泛应用了 Netty和Mina
等NIO框架。但是,受限于个人能力和水平,本书一定还有纰漏和不妥之处,希望广大读
者能够批评指正。读者在阅读本书或者实际工作中如果有Nety相关的疑问,也可以直接
联系我,我会尽量回复。我的联系方式如下:
邮箱:neulilinfeng(asina.com
新浪微博: Netting
微信: Netting
《Net!威指南》第1版出版之后,很多读者来信咨询自己实际工作和学习中遇到的
Netty问题和案例,有些案例和问题颇具典型性。我将这些案例进行了总结,在微信公众
号“Nety之家”中定期推送,希望广大读者可以关注。
感谢博文视点的小编丁一琼MM和幕后的美工,正是你们的辛苦工作才保证了本书能
够顺利出版:感谢华为 IT Paas望岳、莫小君和 Digital SDP集成开发部徐皓等领导对我的
信任和支持;感谢我的老婆在我编辑第2版期间赦免了我做饭和刷碗的义务,我得以抽出
时间安心写作
最后感谢《 Netty杈威指南》第1版的读者,你们的理解、鼓励和支持,使我有足够的
勇气和动力继续前行。希望大家携起手来共同推动NIO编程和Net在国内的应用和发展。
李林锋
2015年1月27日于南京第1版前言
大约在2008年的时候,我参与设计和开发的一个电信系统在月初出账期,总是发生
大量的连接超时和读写超时异常,业务的失败率相比于平时高了很多,报表中的很多指标
都差强人意。后来经过排査,发现问题主要出现在下游网元的处理性能上,月初的时候
BSS出账,在出账期间BSS系统运行缓慢,由于双方采用了同步阻塞式的HTTP+XML进
行通信,导致任何一方处理缓慢都会影响对方的处理性能。按照故障隔离的设计原则,对
方处理速度慢或者不回应,不应该影响系统的其他功能模块或者协议栈,但是在同步阻塞
I/O通信模型下,这种故障传播和相互影响是不可避免的,很难通过业务层面解决。
受限于当时Tomcat和Servlet的同步阻塞IO模型,以及在Java领域异步HTTP协议
栈的技术积累不足,当时我们并没冇办法完全解决这个问题,只能通过调整线程池策略和
HTTP超时时间来从业务层面做规避
2009年,由于对技术的热爱,我作为业务骨干被领导派去参加一个重点业务平台的研
发工作,与两位资深的架构师(其中一位工作20年,做华为交换机出身)共同参与。这
是我第一次全面接触异步IO编程和高性能电信级协议栈的开发,眼界大开——异步高性
能内部协议栈、异步HTTP、异步SOAP、异步SMPP……所有的协议栈都是异步非阻塞的。
后来的性能测试表明:基于 Reactor模型统一调度的长连接和短连接协议栈,无论是性能
可靠性还是可维护性,都可以“秒杀”传统基于BIO开发的应用服务器和各种协议栈,这
种差异本质上是一种代差。
在我从事异步NIO编程的2009年,业界还没有成熟的NIO框架,那个时候Mina刚
刚开始起步,功能和性能都达不到商用标准。最困难的是,国内Java领域的异步通信还
没有流行,整个业界的积累都非常少。那时资料匮乏,能够交流和探讨的圈内人很少,
旦踩住“地雷”,就需要夜以继日地维护。在随后2年多的时间里,经历了十多次的在通
宵、凌晨被一线的运维人员电话吵醒等种种磨难之后,我们自研的NIO框架才逐渐稳定和
成熟。期间,解决的BUG总计20~30个。
从2004年JDK14首次提供NIO1.0类库到现在,已经过去了整整10年。JSR51的
设计初衷就是让Java能够提供非阻塞、具有弹性伸缩能力的异步1O类库,从而结束了Java
在高性能服务器领域的不利局面。然而,在相当长的一段时间里,Java的NIO编程并没
有流行起来,究其原因如下Nety权威指南(第2版)
1.大多数高性能服务器,被C和C++语言盘踞,由于它们可以直接使用操作系统的
异步IO能力,所以对JDK的NIO并不关心
2.移动互联网尚未兴起,基于Java的大规模分布式系统极少,很多中小型应用服务
对于异步IO的诉求不是很强烈;
3.高性能、高可靠性领域,例如银行、证券、电信等,依然以C++为主导,Java充
当打杂的角色,NIO暂时没有用武之地
4.当时主流的J2EE服务器,几乎全部基于同步阻塞IO构建,例如 Servlet、 Tomcat
等,由于它们应用广泛,如果这些容器不支持NIO,用户很难具备独立构建异步协议栈的
能力;
5.异步NO编程门槛比较高,开发和维护一款基于NIO的协议栈对很多中小型公司
来说像是一场噩梦;
6.业界NIO框架不成熟,很难商用;
7.国内研发界对NIO的陌生和认识不足,没有充分重视
基于上述几种原因,NO编程的推广和发展长期滞后。值得欣慰的是,随着大规模分
布式系统、大数据和流式计算框架的兴起,基于Java来构建这些系统已经成为主流,NIO
编程和NO框架在此期间得到了大规模的商用。在互联网领域,阿里的分布式服务框架
Dubbo、 RocketMQ,大数据的基础序列化和通信框架Avro,以及很多开源的软件都已经
开始使用Nεt’y来构建髙性能、分布式邇信能力,Net社区的活跃度也名列前茅。根据目
前的信息, Netty已经在如下几个领域得到了大规模的商业应用。
互联网领域;
2.电信领域
3.大数据领域
4.银行、证券等金融领域;
5.游戏行业;
6.电力等企业市场
2014年春节前,我分亨了一篇博文《 Netty 5.0架构剖析和源码解读》,短短1个月下
载量达到了4000多。很多网友向我咨询NIO编程技术、NI○框架如何选择等问题,也有
些圈内朋友和出版社邀请我写一本关于 Netty的技术书籍。作为最流行、表现最优异的
NIO框架,Nety深受大家喜爱,但是长期以来除了User(uide之外,国内鲜有Net!y相
关的技术书籍供广大NO编程爱好者学习和参考。由于Nety源码的复杂性和№O编程本
身的技术门槛限制,对于大多数读者而言,通过自己阅读和分析源码来深入掌握Nety的
oVI.第1版前言
设计原理和实现细节是件困难的事情。从2011年开始我系统性地分析和应用了 Netty和
Mina,转瞬间已经过去了3年多。在这3年的时间里,我们的系统经受了无数严苛的考验,
在这个过程中,我对Nety和Mina有了更深刻的体验,也积累了丰富的运维和实战经验
我们都是开源框架Nety的受益者,为了让更多的朋友和同行能够了解NO编程,深入学
习和掌握 Netty这个NO利器,我打算将我的经验和大家分享,同时也结束国内尚无Nety
学习教材的尴尬境地。
联系方式
尽管我也有技术洁癖,希望诸事完美,但是由于 Netty代码的庞杂和涉及的知识点太
多,一本书籍很难涵盖所冇的功能点。如有遗漏或者错误,恳请大家能够及时批评和指正
如果你有好的建议或者想法,也可以联系我。我的联系方式如下
邮箱:neulilinfeng@sina.com。
新浪微博: Netting.
微信: Netting
致谢
如果说个人能够改变自己命运的话,对于程序员来说,唯有通过不断地学习和实践,
努力提升自己的技能,才有可能找到更好的机会,充分发挥和体现自己的价值。我希望本
书能够为你的成功助一臂之力。
感谢博文视点的策划编辑丁一琼和幕后的美编,正是你们的辛苦工作才保证了本书能
够顺利出版;感谢华为 Netty爱好者和关注本书的领导同事们的支持,你们的理解和鼓励
为我提供了足够的勇气:感谢我的家人和老婆的支持,写书占用了我几乎所有的业余时间,
没有你们的理解和支持,我很难安心写作。
最后感谢Nety中国社区的朋友,我的微博粉丝和所有喜欢Ney的朋友们,你们对
技术的热情是鼓励我写书的最重要动力,没有你们,就没有本书。希望大家一如既往地喜
欢NO编程,喜欢Net!y,以及相互交流和分享,共同推动整个国内异步高性能通信领域
的技术发展。
李林锋
2014年5月11日于南京紫轩阁
VII目录
基础篇走进 Java NIO
第1章Java的l/O演进之路……2
1.11/O基础入门
1.1. I Linux网络O模型简介
11.2LO多路复用技术………6
1.2Java的IO演进……………………………………………………8
1.3总结…
…10
第2章N|O入门…
4++日++
2.1传统的BlO编程
“““++“““+“““+“““如如如日““中““““中书日节和日
2.1.1BIO通信模型图……
…2
2.1.2同步阻塞式IO创建的 Timeserver源码分析……
13
2.1.3同步阻塞式IO创建的 Time Client源码分析…
16
2.2伪异步O编程……
18
2.2.1伪异步IO模型图
19
2.2.2伪异步I/O创建的 Time Server源码分析…9
2.2.3伪异步IO弊端分析…
………21
2.3NO编程
t nt nn+ttt世ttt世世++t计十什+t++++
普+普普+
24
2.3.1NIO类库简介………
………………24
2.3.2NIO服务端序列图
…28
2.3.3NIO创建的 Timeserver源码分析
………30
234NIO客户端序列图…
36
2.3.5NIO创建的 TimeClient源码分析…………………139
2.4AIO编程
45
24.1AO创建的 Time server源码分析……
46
2.4.2AlO创建的 Time Client源码分析…
……:5l目录
2.4.3AIO版本时间服务器运行结果
56
2.54种IO的对比
““,…5
2.5.1概念澄清
nnrnn177T++t++++日平
=…·““““““““““““““日“5
88
2.5.2不同IO模型对比…
…59
2.6选择 Netty的理由
60
2.6.1不选择Java原生NlO编程的原因
61
2.6.2为什么选择
Netty………62
2.7总结…………………………………………………………………………63
入门篇 Netty Nio开发指南
第3章 Netty入门应用…
66
3. I Netty开发环境的搭建
……66
3.1.1下载 Netty的软件包
67
3..2搭建Nely应用工程
……67
32Net!服务端开发
……………68
33 Netty客户端开发
···
…………73
3.4运行和调试…………………………………………………………………76
34.服务端和客户端的运行…
·"·::"····",··,,"!""·想,·"··::···::·
76
34.2打包和部署
+77
3.5总结………………………………77
第4章TCP粘包/拆包问题的解决之道…
79
TCP粘包/拆包
………………79
4.1.1TCP粘包/拆包问题说明
80
4.1.2TCP粘包/拆包发生的原因
80
4.1.3粘包问题的解决策略…81
4.2未考虑TCP粘包导致功能异常案例……………82
4.2. I TimeServer的改造
量t+tt世 r"-"""""""""""""""""t-"rnat
82
4.2.2 TimeClient的改造
……83
4.2.3运行结果…
…………84
4.3利用 Line baseframe Decoder解决TCP粘包问题
4+甲“““““““““+“++““+++++“++++++“
85
43.1支持TCP粘包的 Timeserver……
…………86
4.3.,2支持TCP粘包的 Timeclient……………………………………………………88
43.3运行支持TCP粘包的时间服务器程序…
+90Nety权威指南(第2版)
4.34 LineBasedframe Decoder和 String Decoder的原理分析
4.4总结
92
第5章分隔符和定长解码器的应用
5.1 Delimiter based frame Decoder应用开发
…94
5.1.1 Delimiter Based Frame Decoder服务端开发…
94
5.1.2 Delimiter Based frameDecoder客户端开发
97
5.1.3运行 DelimiterBased frame decoder服务端和客户端
……“………………99
52 FixedLength Frame Decoder应用开发…………………………………………101
52.1 FixedLength Frame Decoder服务端开发…………………………………………101
5.2.2利用 telnet命令行测试 EchoServer服务端………
+“++··
103
53总结
1
……104
中级篇Ne!编解码开发指南
第6章编解码技术………
106
6.1Java序列化的缺点
自1国面1面
……………107
6.1.1无法跨语言…
……107
6.1.2序列化后的码流太大……………………………,………………107
6.L.3序列化性能太低……
10
6.,2业界主流的编解码框架
l13
621 Google的 Protobuf介绍…
目国L和面1和国通
113
6,22 Facebook的 Thrift介绍…
115
623 JBoss Marshalling介绍……
……16
6.3总结………
:117
第7章 Message Pack编解码-
中··中丰···曹和,·,,"··曹曹曾!唐曹
118
7.1 Message Pack介绍………
71.1 MessagePack多语言支持
7.1.2 Message pack java api介绍…
……………19
7.1.3 MessagePack开发包下载……………………………120
7.2 MessagePack编码器和解码器开发
120
7.2. Message Pack编码器开发
120
7.2.2 MessagePack解码器开发
121
7.2.3功能测试
·+“++++“++++++分分+++t+++·++ttt++ r"t
12
73粘包/半包支持
444444+++“日++++++++++开+++·+十+·++世世 at"" B n
………124目录
74总结…
翻非重主tttt十t+++是
自 trent
…127
第8章 Google Protobuf编解码
28
8.1 Protobuf的入门
129
8.1.1 Protobuf开发环境搭建……29
8.1.2 Protobuf编解码开发…
131
8.1.3运行 Protobuf例程
““
133
8.2Nety的 Protobuf服务端开发……………133
82. Protobuf版本的图书订购服务端开发…………………………………134
822 Protobuf版本的图书订购客户端开发…36
823 Protobuf版本的图书订购程序功能测试
………139
83 Protobuf的使用注意事项
140
84总结…
……………142
第9章 JBoss Marshalling编解码……
…143
9.1 Marshalling开发环境准备
143
9.2 Netty的 Marshalling服务端开发
144
9.3 Netty的 Marshalling客户端开发……………………………147
94运行 Marshalling客户端和服务端例程………………………………………………149
95总结…………………………………………………………150
高级篇Nety多协议开发和应用
第10章HTTP协议开发应用…
154
10.1HTTP协议介绍……
……………155
10.1.1HTTP协议的URL
………155
10.1.2HTTP请求消息(Httprequest)……………………155
10.1.3HTTP响应消息(Httpresponse)
158
10.2 Netty Http服务端入门开发
++和+普鲁++++.++++++++++十世世十世世出世 7n-- n
………159
10.2.HTTP服务端例程场景描述
……………160
10.2.2HTTP服务端开发……
……60
10.2.3 Netty Http文件服务器例程运行结果
166
10.3 Netty Http+XML协议栈开发……………………………………170
10.3.1开发场景介绍……
171
10.3.2HTTP+XML协议栈设计
174
10.3,3高效的XML绑定框架JiBx
…175Netty权威指南(第2版)
10.3.4HTTP+XML编解码框架开发…
10.3.5HTTP+XML协议栈测试…
199
10.3.6小结……
201
104总结
‘日画
…………………202
第11章 Web Socket协议开发…
203
11.1HTTP协议的弊端
………204
112 WebSocket入门
画。画
204
11.2.1 Web Socket背景…
…205
11.2.2 Web Socket连接建立………
206
1.2.3 WebSocket生命周期
207
11.2.4 WebSocket连接关闭………………………208
I1.3 Netty WebSocket协议开发…
209
11.3.1 Web socket服务端功能介绍
29
1.3.2 Web Socket服务端开发…210
11.3.3运行 WebSocket服务端
……218
114总结
…219
第12章私有协议栈开发
…………221
12.1私有协议介绍
…………221
12.2Nety协议栈功能设计
223
12.2.1网络拓扑图…………………23
122.2协议栈功能描述
…124
12.2.3通信模型
++·*+··::=+t·+++++·++++甲“·*.",
…………………224
122.4消息定义
:1225
12.2.5Nety协议支持的字段类型
……26
12.2.6Nety协议的编解码规范…
翻国日串
227
122.7链路的建立…
……………………29
12.2.8链路的关闭
1日日
…………………………230
12.29可靠性设计…
230
122.10安全性设计
………232
122.11可扩展性设计
…232
12.3 Netty协议栈开发…
4和
233
123.1数据结构定义
233
12.3.2消息编解码………
……·237
X||目录
12.3.3握手和安全认证
24l
12.3.4心跳检测机制
·和画画丰丰画和和‘画和品面1
245
12.3.5断连重连…………………………………………………248
12.3.6客户端代码
…249
12.3.7服务端代码
251
12.4运行协议栈…
曹想,曹,曹
12.4.正常场景………………252
12.4.2异常场景:服务端宕机重启…
253
12.4.3异常场景:客户端宕机重启……………256
12.5总结
256
第13章服务端创建
258
13.1原生NIO类库的复杂性…………………………………259
13.2Nety服务端创建源码分析
259
1321Ney服务端创建时序图
…260
13.2.2Net;服务端创建源码分析
263
13.3客户端接入源码分析
4;;;4#“a++
…………272
13.4总结………………………………………………………………………275
第14章客户端创建
…276
141Nety客户端创建流程分析………………………………276
142.1 Netty客户端创建时序图…
276
14.2.2Nety客户端创建流程分析
e..n.8...m88nnnn0nnn888BE084D
………277
14.2 Netty客户端创建源码分析…………………………27
14.2.1客户端连接辅助类 Bootstrap
中和
278
142.2客户端连接操作
…………281
14.2、3异步连接结果通知
283
14.2.4客户端连接超时机制……………………………………………284
143总结
………+286
源码分析篇 Netty功能介绍和源码分析
第15章 ByteBuf和相关辅助类
288
15.1 Byte Buf功能说明…
288
15.1,1 ByteBuf的工作原理
…289
15.1.2 ByteBuf的功能介绍
1丰副
294
·XlNetty权威指南(第2版)
15.2 Byte Buf源码分析
308
15.2.1 ByteBuf的主要类继承关系
309
15.22 AbstractByte Buf源码分析…
310
15.2.3 AbstractReference Counted Byte Buf源码分析…………319
15.24 UnpooledHeap Byte Buf源码分析…
321
15.2.5 PooledByteBuf内存池原理分析………………………326
15.26 Pooled Direct Byte But源码分析
…………329
15.3 Byte Buf相关的辅助类功能介绍
332
15.3. 1 Byte.r,.,...
……332
15.3.2 ByteBufAllocator
……333
15.3.3 Composite Byte Buf………………………………………………334
15.3.4 ByteBufUtil………1336
154总结……
aa非
……337
第16章 Channe|和 Unsafe……………………………38
16.1 Channel功能说明
338
16.1.1 Channel的工作原理…………………339
16.1.2 Channel的功能介绍…
340
16.2 Channel源码分析
………343
16.2.1 Channel的主要继承关系类图
343
162.2 Abstract channel源码分析
344
16.2.3 AbstractNioChannel源码分析………47
16.2.4 AbstractNioByte Channel源码分析
日日日书如日日日日日“““日日数份世中日
350
16.2.5 AbstractNioMessage Channel源码分析…
353
162.6 AbstractNio Message ServerChannel源码分析
…354
1627 NioServer Socketchannel源码分析
355
16.2.8 NioSocket Channel源码分析…
…358
16.3 Unsafe功能说明…
……364
16.4 Unsafe源码分析…………………………………………365
164. 1 Unsafe继承关系类图
365
164,2 AbstractUnsafe源码分析
……366
164.3 AbstractNio Unsafe源码分析
375
1644 NioByte Unsafe源码分析
379
16.5总结
L444a44a
387
·X|目录
第17章 ChannelPipeline和 ChannelHandler
……388
17.1 ChannelPipeline功能说明
389
17.1.1 ChannelPipeline的事件处理
389
17.1.2自定义拦截器…
…391
17.1.3构建 pipeline…………………………392
17.14 ChannelPipeline的主要特性…………………393
17.2 ChannelPipeline源码分析
…1393
17.2.1 Channel pipeline的类继承关系图
393
17.2.2 Channelpipeline对 Channelhandler的管理…
393
17.23 ChannelPipeline的 inbound事件…
…396
17.24 ChannelPipeline的 outbound事件
397
17.3 Channelhandler功能说明…
398
17.3.1 ChannelHandler Adapter功能说明………………………………………399
17.3.2 Byte ToMessage Decoder功能说明
399
17.3.3 Message To Message Decoder功能说明
:400
17.3.4 Length FieldBasedFrameDecoder功能说明……………………400
17.3.5 MessageToByte Encoder功能说明……………………………………………404
17.3.6 Message ToMessage Encoder功能说明…4
17.3.7 LengthField Prepender功能说明
……405
17.4 Channelhandler源码分析………………………………………………406
174.1 Channelhandler的类继承关系图
406
17.4.2 Byte ToMessageDecoder源码分析…407
174.3 Message ToMessage Decoder源码分析…………………:410
1744 LengthField Based Frame Decoder源码分析
4l1
174.5 MessageToByteEncoder源码分析
415
174.6 Message ToMessage Encoder源码分析…
416
17.4.7 Length Field Prepender源码分析……………………………1417
17.5总结
4l8
第18章 EventLoop和 EventLoop Group…………………………………419
18.1Net!y的线程模型…
…………………………………419
18.1.1 Reactor单线程模型……420
18.1.2 Reactor多线程模型………………1421
18.1.3主从 Reactor多线程模型
…1422
XV·Nety权威指南(第2版)
18.14Nety的线程模型…
423
18.1.5最佳实践………………………………………………………424
18.2 NioEventLoop源码分析
…………425
18.2.1 Nio EventLoop设计原理…………1425
8.2.2 NioEventLoop
继承关系类图
426
18.2.3 NioEventLoop…
:427
18.3总结
-.+.--tteeeeheettenntetrnnganngnnnninr
436
第19章 Future和 Promise…
438
19.1 Future功能
438
19.2 Channelfuture源码分析
443
93 Promise功能介绍
……………445
19.4 Promise源码分析
………………47
19.4. I Promise继承关系图……………………………447
19.4.2 Default Promise………1-47
19.5总结……
薛d品副国
…1449
架构和行业应用篇Nett高级特性
第20章Net!架构剖析…2
20.1Netl逻辑架
452
20.1.1 Reactor通信调度层
453
20.1.2职责链 ChannelPipeline
新和‘·画
……………453
20.1.3业务逻辑编排层( Service channelhandler)……:454
20.2关键架构质量属性…………………………454
20.2.1高性能
…………454
20.22可靠性…
457
202.3可定制性……
460
202.4可扩展性…………………1460
20.3总结…………………………………………460
第21章Java多线程编程在 Netty中的应用
………………461
21.1Jaa内存模型与多线程编程
461
21.1.1硬件的发展和多任务处理
461
21.1.2Java内存模型…
…462
21.2Nety的并发编程实践
…464
●XV|·目录
21.2.1对共享的可变数据进行正确的同步…
一+
…:464
21.2.2正确使用锁……
03
21,2,3 volatile的正确使用……1467
2L.2,4CAS指令和原子类
470
212.5线程安全类的应用
………………472
21.26读写锁的应用…
……476
21.2.7线程安全性文档说明…………………………………477
21.2.8不要依赖线程优先级………478
21.3总结
+请+普++
479
第22章高性能之道……………………………………48
22.1RPC调用性能模型分析………………………………………………………480
22.1.1传统RPC调用性能差的三宗罪
480
22.1.2L/O通信性能三原则…
……-481
222Nety高性能之道
482
22,2.1异步非阻塞通信………
482
22.2.2高效的 Reactor线程模型………482
22.2.3无锁化的串行设计
1485
22.2.4高效的并发编程…
486
222.5高性能的序列化框架
486
2226零拷贝
……487
2227内存池
…1491
22.2.8灵活的TCP参数配置能力……………494
22.3主流NIO框架性能对比…………
……495
224总结……
497
第23章可靠性
498
23.1可靠性需求………………………………………498
23.1.1宕机的代价…
…498
231.2 Netty可靠性需求
499
23.2 Netty高可靠性设计
,++中、,,中·+,··,中主虚主书_
500
23.2.1网络通信类故障…………………………………………500
23.2.2链路的有效性检测
““++“+“+““+“+*··+·:
:507
23.2.3 Reactor线程的保护…
510
23.24内存保护……………
513
·XV|Net权威指南(第2版)
23.2.5流量整形…………516
3.2.6优雅停机接口……………………………………519
23.3优化建议
520
23.3.发送队列容量上限控制
520
23.3.2回推发送失败的消息………………………………………………………521
23.4总结
521
第24章安全性
画目1目自日
……………………522
241严峻的安全形势……………………………………………522
24.1. OpenSSL Heart bleed漏洞
……+4“+++++++5
24.1.2安全漏洞的代价
画和国画新国面画面浦
523
241.3 Netty面临的安全风险
……523
242 Netty SSL安全特性
…525
24.2.1SSL单向认证
525
2422SSL双向认证
…………32
24.2.3第三方CA认证…………
-+++++
536
243 Netty SSL源码分析…
…………………………………538
24.3.1客户端…………………538
243.2服务端
541
24.3.3消息读取…
544
243.4消息发送
…545
244Ney扩展的安全特性……
546
244.1IP地址黑名单机制
串副国;a丰丰篇丰和1目目非主整世曾主主和由想主主想s想把,t.·世想想
547
24.4.2
接入认证…
t世t+普世t+世+++++++++
……548
244总结…
…550
第25章 Netty未来展望…551
25.1应用范围
551
252技术演进
552
25.3社区活跃度…
……552
254 Road Map…
………………………………………552
255总结
……553
附录ANe!y参数配置表…
554
ⅩVl·基础篇
走进 Java nic
第1章Java的LO演进之路
第2章NO入门第1章
Java的IO演进之路
Java是由 Sun Microsystems公司在1995年首先发布的编程语言和计算平台。这项基
础技术支持最新的程序,包括实用程序、游戏和业务应用程序。Java在世界各地的8.5亿
多台个人计算机和数十亿套设备上运行着,其中包括移动设备和电视设备。
Java之所以能够得到如此广泛的应用,除了摆脱硬件平台的依赖具有“一次编写、到
处运行”的平台无关性特性之外,另一个重要原因是:其丰富而强大的类库以及众多第三
方开源类库使得基于Java语言的开发更加简单和便捷。
但是,对于一些经验丰富的程序员来说,Java的一些类库在早期设计中功能并不完善
或者存在一些缺陷,其中最令人恼火的就是基于同步LO的 Socket通信类厍。直到2002
年2月13日JDK14 Merlin的发布,Java才第一次支持非阻塞I/O,这个类库的提供为JDK
的通信模型带来了翻天覆地的变化。
在开始学习Ney之前,我们首先对UNX东统常用的Io模型进行介绍,然后对Java
的IO历史演进进行简单说明。通过本章节的学习,希望读者对同步和异步IO以及Java的
I/O类库发展有个直观的了解,方便后续章节的学习。如果你已经熟练NIO编程或者从事过
UNIX网络编程,希望直接学习Java的NO和Nety,那就可以直接跳到第2章进行学习。
本章主要内容包括:
◎I/O基础入门
◎Java的IO演进第1章Java的∥O演进之路
11I/O基础入门
Java1.4之前的早期版本,Jaⅶa对IO的支持并不完善,开发人员在开发高性能O程
序的时候,会面临一些巨大的挑战和困难,主要问题如下。
⑦没有数据缓冲区,IO性能存在问题;
◎没有C或者C艹+中的 Channel概念,只有输入和输出流;
◎同步阻塞式ⅠO通信(BIO),通常会导致通信线程被长时间阻塞」
◎支持的字符集有限,硬件可移植性不好。
在Java支持异步O之前的很长一段时间里,高性能服务端开发领域一直被C++和C
长期占据,Java的同步阻塞I/O被大家所诟病
1.1.1 Linux网络1O模型简介
Linu的内核将所有外部设备都看做一个文件来操作,对一个文件的读写操作会调用
内核提供的系统命令,返回一个 file descriptor(fd,文件描述符)。而对一个 socket的读
写也会有相应的描述符,称为 socketed( socket描述符),描述符就是一个数字,它指向内
核中的一个结构体(文件路径,数据区等一些属性)。
根据UNIX网络编程对IO模型的分类,UNIX提供了5种MO模型,分别如下。
1)阻塞IO模型:最常用的IO模型就是阻塞IO模型,缺省情形下,所有文件操
作都是阻塞的。我们以套接字接口为例来讲解此模型:在进程空间中调用 recvfrom,其系
统调用直到数据包到达且被复制到应用进程的缓冲区中或者发生错误时才返回,在此期间
直会等待,进程在从调用 recvfrom开始到它返回的整段时间内都是被阻塞的,因此被称
为阻塞IO模型,如图1-1所示。
(2)非阻塞1O模型: recvfrom从应用层到内核的时候,如果该缓冲区没有数据的话,
就直接返回一个 EWOULDBLOCK错误,一般都对非阻蹇1O模型进行轮询检查这个状态,
看内核是不是有数据到来,如图1-2所示。Nety权威指南(第2版)
应用进程系统调用→无数据报
内核
rectron
准备好
等待数据
准备就绪
数据报准备好
进程阻塞于
rectron调用
复制数据报
数据从内
核复制到
处理数据报←返回成功
用户空间
复制完成
图1-1阻塞1O模型
应用进程系统调用
内核
recvfrom
无数据报
EWOULDBLOCK准备好
系统调用
等待数据
recaro
无数据报
EWOULDBLOCK准备好
准备就绪
系统调用
进程反复调用
recvfrom-
数据报准备好
recvfrom等待
返回成功(轮询
复制数据报
数据从内
核复制到
用户空间
处理数据报←回成功
复制完成
图1-2非阻塞IO模型
3)IO复用模型: Linux提供 select/poll,进程通过将一个或多个fd传递给 select或
po系统调用,阻塞在 select操作上,这样 select/poll可以帮我们侦测多个fd是否处于就
绪状态。 select/poll是顺序扫描fd是否就绪,而且攴持的fd数量有限,因此它的使用受到
了一些制约。 Linux还提供了一个 epoll系统调用, epoll使用基于事件驱动方式代替顺序
扫描,因此性能更高。当有fd就绪时,立即回调函数 rollback,如图1-3所示。
(4)信号驱动IO模型:首先开启套接口信号驱动IO功能,并通过系统调用 sIgaction
执行一个信号处理函数(此系统调用立即返回,进程继续工作,它是非阻塞的)。当数据
准备就绪时,就为该进程生成一个 SIGIO信号,通过信号回调通知应用程序调用 recvfrom
来读取数据,并通知主循环函数处理数据,如图1-4所示。
4第1章Java的/O演进之路
应用进程系统调用
内核
select
无数据报
准备好
等待数据
准备就绪
进程受阻于 select
调用,等待1个或
多个套接字变为
,返回可读条件一数据报准备好
可读
系统调用→复制数据报
数据复制到应用
数据从内
缓冲区期间进程
核复制到
阻塞
用户空间
处理数据报返回成功复制完成
图1-3I/O复用模型
建立sGiO统调内核
lon
信号处理程序
sig
进程继续执行
等待数据
准备就绪
信号处理,递交S|GC
数据报准备好
系统调用
recvfrom
复制数据报
数据复制到应用
数据从内
缓冲区期间进程
核复制到
阻塞
用户空间
处理数据报+返国成功复制完成
图1-4信号驱动O模型
(5)异步Oε告知内核启动某个操作,并让内核在整个操作完成后(包括将数据从
内核复制到用户自己的缓冲区)通知我们。这种模型与信号驱动模型的主要区别是:信号
驱动IO由内核通知我们何时可以开始一个IO操作;异步IO模型由内核通知我们I/O
操作何时已经完成,如图1-5所示
如果想要了解更多的UNX系统网络编程知识,可以阅读《UNX网络编程》,里面有
非常详细的原理和API介绍。对于大多数Java程序员来说,不需要了解网络编程的底层
细节,大家只需要有个概念,知道对于操作系统而言,底层是支持异步IO通信的。只不
过在很长一段时间Java并没有提供异步I/O通信的类库,导致很多原生的Java程序员对
这块儿比较陌生。当你了解了网络编程的基础知识后,理解Java的NO类库就会更加容
易一些
5Nety权威指南(第2版
应用法程系统调用无数据报
返回
准备好
等待数据
准备就绪
信号处理+父数据报准备好
进程继续执行
复制数据报
数据从内
核复制到
递交在 aio read中
用户空间
信号处理程序←
一复制完成
图1-5异步IO模型
下一个小结我们重点讲下1O多路复用技术,因为 Java NIO的核心类库多路复用器
Selector就是基于 epoll I的多路复用技术实现
1.1.21O多路复用技术
在IO编程过程中,当需要同时处理多个客户端接入请求时,可以利用多线程或者L/O
多路复用技术进行处理。IO多路复用技术通过把多个I/O的阻塞复用到同一个 select的阻
塞上,从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程
多进程模型比,IO多路复用的最大优势是系统开销小,系统不需要创建新的额外进程或
者线程,也不需要维护这些进程和线程的运行,降低了系统的维护工作量,节省了系统资
源,O多路复用的主要应用场景如下。
◎服务器需要同时处理多个处于监听状态或者多个连接状态的套接字
服务器需要同时处理多种网络协议的套接字
日前支持I/O多路复用的系统调用有 select、 select、poll、 epoll,在Liux网络编程
过程中,很长一段时间都使用 select做轮询和网络事件通知,然而 select的一些固有缺陷
导致了它的应用受到了很大的限制,最终 Linux不得不在新的内核版本中寻找 select的替
代方案,最终选择了 pollo epoll与 select的原理比较类似,为了克服 select的缺点, epoll
作了很多重大改进,现总结如下。
6第1章Java的O演进之路
1.支持一个进程打开的 socket描述符(FD)不受限制(仅受限于操作系统的最大文
件句柄数)。
select最大的缺陷就是单个进程所打开的FD是有一定限制的,它由 FD SETSIZE设
置,默认值是1024。对于那些需要支持上万个TCP连接的大型服务器来说显然太少了。
可以选择修改这个宏然后重新编译内核,不过这会带来网络效率的下降。我们也可以通过
选择多进程的方案(传统的 Apache方案)解决这个问题,不过虽然在 Linux上创建进程
的代价比较小,但仍旧是不可忽视的。另外,进程间的数据交换非常麻烦,对于Java来
说,由于没有共享内存,需要通过 Socket通信或者其他方式进行数据同步,这带来了额外
的性能损耗,增加了程序复杂度,所以也不是一种完美的解决方案。值得庆幸的是, epoll
并没有这个限制,它所支持的FD上限是操作系统的最大文件句柄数,这个数字远远大于
1024。例如,在1GB内存的机器上大约是10万个句柄左右,具体的值可以通过cat
φproc/ sys/fs/file-max察看,通常情况下这个值跟系统的内存关系比较大。
2./O效率不会随着FD数目的增加而线性下降。
传统 select/pol的另一个致命弱点,就是当你拥有一个很大的 socket集合时,由于网
络延时或者链路空闲,任一时刻只有少部分的 socket是“活跃”的,但是 select/poll每次
调用都会线性扫描全部的集合,导致效率呈现线性下降。 epoll不存在这个问题,它只会对
“活跃”的 socket进行操作—这是因为在内核实现中, epoll是根据每个fd上面的 callback
函数实现的。那么,只有“活跃”的 socket才会去主动调用 callback函数,其他idl状态
的 socket则不会。在这点上, epoll实现了一个伪AIO。针对 epoll和 select性能对比的
benchmark测试表明:如果所有的 socket都处于活跃态——例如一个高速LAN环境, epoll
并不比 select/poll效率高太多;相反,如果过多使用 epoll ctl,效率相比还有稍微地降低
但是一旦使用 idle connections模拟WAN环境, epoll I的效率就远在 select/poll之上了。
3.使用mmap加速内核与用户空间的消息传递。
无论是 select、po还是 epoll i都需要内核把FD消息通知给用户空间,如何避免不必
要的内存复制就显得非常重要,epol是通过内核和用户空间mmap同一块内存来实现的。
4.epo的AP更加简单。
包括创建一个 epoll描述符、添加监听事件、阻塞等待所监听的事件发生、关闭 epoll
描述符等。
7·Ney权威指南(第2版)
值得说明的是,用来克服 select/poll缺点的方法不只有 epoll, epoll只是一种 Linux的
实现方案。在 free BSD下有 kqueue,而dev/poll是最古老的 Solaris的方案,使用难度依次
递增。 kqueue是 freebsd的宠儿,它实际上是一个功能相当丰富的 kernel事件队列,它不
仅仅是 select/poll的升级,而且可以处理 signal、目录结构变化、进程等多种事件。 kqueue
是边缘触发的。 /dev/poll是 Solaris的产物,是这一系列高性能API中最早出现的。 Kernel
提供了一个特殊的设备文件/ dev/poll,应用程序打开这个文件得到操作 fd set的句柄,通
过写入 polled来修改它,一个特殊的 ioctl调用用来替換 select。不过由于出现的年代比较
早,所以dev/poll的接口实现比较原始。
到这里,1O的基础知识已经介绍完毕。从1.2节开始介绍Java的I/O演进历史,
从BO到NIO是Java通信类库迈出的一小步,但却对Java在高性能通信领域的发展
起到了关键性的推动作用。随着基于NIO的各类NIO框架的发展,以及基于NIO的
Web服务器的发展,Java在很多领域取代了C和C++,成为企业服务端应用开发的首
选语言。
12Java的I/O演进
在JDK1.4推出 Java nio之前,基于Java的所有 Socket通信都采用了同步阻塞模式
(BIO),这种一请求一应答的通信模型简化了上层的应用开发,但是在性能和可靠性方面
却存在着巨大的瓶颈。因此,在很长一段时间里,大型的应用服务器都采用C或者C++
语言开发,因为它们可以直接使用操作系统提供的异步IAO或者AIO能力。当并发访问量
增大、响应时间延迟增大之后,采用 Java blo开发的服务端软件只有通过硬件的不断扩容
来满足高并发和低时延,它极大地增加了企业的成本,并且随着集群规模的不断膨胀,系
统的可维护性也面临巨大的挑战,只能通过采购性能更高的硬件服务器来解决问题,这会
导致恶性循环
正是由于Java传统BO的拙劣表现,才使得Java支持非阻塞IO的呼声日渐高涨,
最终,JDK1.4版本提供了新的NIO类库,Java终于也可以支持非阻塞I/O了。
Java的O发展简史
从JDK1.0到JDK1.3,Java的1O类库都非常原始,很多UNIX网络编程中的概念或
者接口在1O类库中都没有体现,例如Pipe、 Channel、 Buffer和 Selector等。2002年发布
8第1章Java的O演进之路
JDK14时,NO以JSR-51的身份正式随JDK发布。它新增了个 Java nio包,提供了很多
进行异步I/O开发的API和类库,主要的类和接口如下。
◎进行异步O操作的缓冲区 ByteBuffer等;
◎进行异步I/O操作的管道pipe;
进行各种I/O操作(异步或者同步)的 Channel,包括 ServerSocketchanne和
Socketchannel
◎多种字符集的编码能力和解码能力;
实现非阻塞IO操作的多路复用器 selector
◎基于流行的Perl实现的正则表达式类库;
◎文件通道 File channel
新的NIO类库的提供,极大地促进了基于Java的异步非阻塞编程的发展和应用,但
是,它依然有不完善的地方,特别是对文件系统的处理能力仍显不足,主要问题如下。
◎没有统一的文件属性(例如读写权限);
◎API能力比较弱,例如目录的级联创建和递归遍历,往往需要自己实现
◎底层存储系统的一些高级API无法使用
◎所有的文件操作都是同步阻塞调用,不支持异步文件读写操作
2011年7月28日,JDK1.7正式发布。它的一个比较大的亮点就是将原来的NIO类
库进行了升级,被称为NIO20。NIO2.0由JSR-203演进而来,它主要提供了如下三个方
面的改进。
◎提供能够批量获取文件属性的API,这些API具有平台无关性,不与特性的文
件系统相耦合。另外它还提供了标准文件系统的SPI,供各个服务提供商扩展
实现;
◎提供A1O功能,支持基于文件的异步1O操作和针对网络套接字的异步操作
◎完成JSR-51定义的通道功能,包括对配置和多播数据报的支持等
9Net!y权威指南(第2版)
13总结
通过本章的学习,我们了解了UNIX网络编程的5种O模型,学习了1O多路复用
技术的基础知识。通过对 Java 1/0演进历史的总结和介绍,相信大家对Java的IO演进有
了一个更加直观的认识。后面的第2章节会对阻塞1O和非阻塞IO进行详细讲解,同时
给出代码示例。相信学完第2章之后,大家就能够对传统的阻塞IO的弊端和非阻塞IO
的优点有更加深刻的体会。好,稍微休息片刻,我们继续畅游在NO编程的快乐海洋中!
10·第2章
NIO入门
在本章中,我们会分别对JDK的BIO、NIO和JDK1.7最新提供的NIO2.0的使用进
行详细说明,通过流程图和代码讲解,让大家体会到:随着 Java 1/0类库的不断发展和改
进,基于Java的网络编程会变得越来越简单;随着异步1O功能的增强,基于 Java NIC
开发的网络服务器甚至不逊色于采用C++开发的网络程序。
本章主要内容包括
◎传统的同步阻塞式I/O编程
◎基于NIO的非阻塞编程
◎基于NIO2.0的异步非阻塞(AIO)编程
◎为什么要使用NIO编程
◎为什么选择 Netty
2.1传统的BIO编程
网络编程的基本模型是 Client/Server模型,也就是两个进程之间进行相互通信,其中
服务端提供位置信息(绑定的P地址和监听端口),客户端通过连接操作向服务端监听的Net!y权威指南(第2版
地址发起连接请求,通过三次握手建立连接,如果连接建立成功,双方就可以通过网络套
接字〔 Socket)进行通信
在基于传统同步阻塞模型开发中, Server socket负责绑定IP地址,启动监听端口
Socket负责发起连接操作。连接成功之后,双方通过输入和输出流进行同步阻塞式通信。
下面,我们就以经典的时间服务器( Timeserver)为例,通过代码分析来回顾和熟悉
BIO编程。
2.1.1B|O通信模型图
首先,我们通过图2-1所示的通信模型图来熟悉BIO的服务端通信模型:采用BlO通
信模型的服务端,通常由一个独立的 Acceptor线程负责监听客户端的连接,它接收到客户
端连接请求之后为每个客户端创建一个新的线程进行链路处理,处理完成之后,通过输出
流返回应答给客户端,线程销毁。这就是典型的一请求一应答通信模型
I connect I
New Thread I
Web Browser I
I connect?
Web Browser 2
handle(Req)
I connect
Acceptor
New Thread2
Web Browser
1 connect4
Web Browser
New Thread3
3 send Response to peer c-s,
New Thread
图2-1同步阻塞IO服务端通信模型(一客户端一线程)
该模型最大的问题就是缺乏弹性伸缩能力,当客户端并发汸问量增加后,服务端的线
程个数和客户端并发访问数呈1:1的正比关系,由于线程是Java虚拟机非常宝贵的系统
资源,当线程数膨胀之后,系统的性能将急剧下降,随着并发访问量的继续增大,系统会
发生线程堆栈溢出、创建新线程失败等冋题,并最终导致进程宕机或者僵死,不能对外提
供服务
下面的两个小节,我们会分别对服务端和客户端进行源码分析,寻找同步阻塞IO的
弊端。
12·第2章NO入门
2.1.2同步阻塞式UO创建的 Time Server源码分析
代码清单2-1同步阻塞O的 Timeserver
(备注:以下代码行号均对应源代码中实际行号。)
1. package com phei,netty bioi
2. import java.io. IOException;
3. import java. net Server Socket
4. import java. net. Socket
Author linfeng
7
date2014年2月14日
8.* version 1.0
10. public class Time Server I
11
12
param args
14,
@throws IOException
15
16
public static void main(String[] args) throws IOException f
17
int port =8080;
18
if (args ! null & args, length >0)i
19
20
try t
21
port= Integer, valueof(args[0])i
22
catch ( NumberFormatException e)(
23
/采用默认值
24
25
26
27
Server Socket server= null:
28
try i
29
server= new ServerSocket(port)i
30
System. out. println("The time server is start in port port)
31,
Socket socket= null
32
while (true) I
socket server accept()i
34
new Thread (new TimeserverHandler(socket)). start()i
36
F finally
13Netty权威指南(第2版)
37,
if (server != null)[
38
System, out. println("The time server close")i
39,
server. close()
40.
server null
41
42
43
44.}
TimeServer根据传入的参数设置监听端口,如果没有入参,使用默认值8080。第29
行通过构造函数创建 Server Socket,如果端口合法且没有被占用,服务端监听成功。第32~
35行通过一个无限循环来监听客户端的连接,如果没有客户端接入,则主线程阻塞在
Server socket的 accept操作上。启动 Timeserver,通过 Jvisualvm打印线程堆栈,我们可
以发现主程序确实阻塞在 accept操作上,如图2-2所示。
main prio=6 tid=Ox00879800 ni d=Oxbl c runnable [Ox009af000]
jav. lang Thread, State: RUNNABLE
at java. net. TwoStacksPlainSocketInpl, soeketAccept ative Method)
at java. net. AbstractPlainSocketImpl, accept (Abstr actPlainSocketInpl java: 398)
at java net. PlainSocketImpl. accept (PlainSocketInpl java: 198)
locked <0x23021358>(a java. net. SockssocketImpl
at java. net Server Socket inpl Accept (ServerSocket java: 530)
at java. net Server Socket. accept (Server Socket. java: 498)
at com phei. netty bio TimeServer. main (TimeServer java: 50)
Locked ownable synchroni zers
None
图2-2主程序线程堆栈
当有新的客户端接入的时候,执行代码第34行,以 Socket为参数构造 Time serverhandler
对象, Time Serverhandler是一个 Runnable,使用它为构造函数的参数创建一个新的客户端
线程处理这条 Socket链路。下面我们继续分析 TimeServer handler的代码。
代码清单2-2同步阻塞IO的 Time ServerHandler
13. public class Time ServerHandler implements Runnable i
14,
15
private Socketsocket;
16
17. public Time Server Handler(Socket socket)[
18
this, socket socket
●14第2章NO入门
20
21
22
(non-Javadoc
24,
esee java. lang Runnable#run(
25
26,
override
27
public void run() t
28,
Bufferedreader in= null
29
PrintWriter out nulli
30,
try I
31
in= new BufferedReader(new InputstreamReader
32
this socket. getInputstream()))i
out new Printwriter(this socket getOutputstream(), true)i
34,
string currentTime null;
35
String body =null;
36
while (true) I
37
body in readLine()
38
f (body = null
39
breaki
40
System,out. println("The time server receive order "t body)
41
urrentTime =QUERY TIME ORDER".equals IgnoreCase(body)? new
java util. Date(
42
System, currentTimeMillis()).tostring():"BAD ORDER";
43
out println(currentTime)i
44,
45
46,
I catch (Exception e) i
47,
if (in != null) I
48
try t
49
in close()i
50
t catch (IOException el) t
51,
el printstackTrace()i
52
53
54
if (out
nu11)
55
out close();
56
out
u11
57
58.
if (this socket ! null)[
15·Net!y权威指南(第2版
59
try i
60
this socket. close(i
61
catch (IOException el) t
62
el printstackTrace ()i
63
64
this, socket null:
66,
67
68.}
第37行通过 BufferedReader读取一行,如果已经读到了输入流的尾部,则返回值为
nul,退出循环。如果读到了非空值,则对内容进行判断,如果请求消息为查询时间的指
令" QUERY TIME ORDER",则获取当前最新的系统时间,通过 Print Writer的 printIn函数
发送给客户端,最后退岀循环。代码第47~64行释放输λ流、输岀流和Sσcket套接字句
柄资源,最后线程自动销毁并被虚拟机回收
在下一个小结,我们将介绍同步阻塞IO的客户端代码,然后分别运行服务端和客户
端,查看下程序的运行结果。
2.1.3同步阻塞式WO创建的 Time Client源码分析
客户端通过 Socket创建,发送査询时间服务器的" QUERY TIME ORDER"指令,然后
读取服务端的响应并将结果打印出来,随后关闭连接,释放资源,程序退出执行。
代码清单2-3同步阻塞IO的 Time client
13. public class TimeClient
14
15,
16
k param args
17
18
public static void main(String[] args)f
19
int port =8080F
20
if (args ! null & args length >0)t
21
try t
22,
port Integer valueof(args[0])i
23
catch (Number FormatException e) t
24
采用默认值
25
16第2章N|O入门
26
27
Socket socket null
28
BufferedReader in null;
29
Printwriter out null:
30,
try t
1
socket new Socket(127.0.0.l, port)i
32
in= new BufferedReader (new Input streamReader
socket. getInputStream()))i
out new Printwriter(socket getOutputstream(), true)
out println("QUERY TIME ORDER");
36
System, out. println("Send order 2 server succeed. )i
37
String resp
in readline()i
38
System, out.println
1
resp)i
39
I catch (Exception e) i
40
//不需要处理
41
finally I
42
if (out
nu11)
43
out close()i
44,
out null
45
46
47
if (in
48
try i
49
in close(;
50
3 catch (IOException e)I
51,
e printstackTrace()i
52
53.
in nulli
54
55
if (socket ! null)I
56
try
57
socket,cl。se();
58
t catch (IOException e)[
9
printStackTrace();
60
61
rocket= null
62
63
64
65.}Netty权威指南(第2版)
第35行客户端通过 Printwriter向服务端发送" QUERY TIME ORDER"指令,然后通过
BufferedReader的 read Line读取响应并打印。
分别执行服务端和客户端,执行结果如下。
服务端执行结果如图2-3所示。
Problens o Jurado haclarstion4Search日 Cmsole kss a s亡日
r;sHw口Aplc1m】E1g*170钙B0014年?月4日下,312)
The time server 1s start in port 808D
The tine server receive order t QUERY TIME ORDER
图2-3同步阻塞ⅠO时间服务器服务端运行结果
客户端执行结果如图2-4所示。
Mess forec bedlwratien sach回cmt1shm算即曰
(red) TisE口 ws ApplicatiM] E \roga r1 eswl70451ial罗②2014年2月日下午:2954)
Srnd order2 arwr HTc四看d,
Not 15 Sat Feb IS 20: 29:54 CST 201
图2-4同步阻塞1O时间服务器客户端运行结果
到此为止,同步阻塞式LO开发的时间服务器程序已经讲解完毕。我们发现,BIO主
要的问题在于每当有一个新的客户端请求接入时,服务端必须创建一个新的线程处理新接
入的客户端链路,一个线程只能处理一个客户端连接。在高性能服务器应用领域,往往需
要面向成千上万个客户端的并发连接,这种模型显然无法满足高性能、高并发接入的场景。
为了改进一线程一连接模型,后来又演进出了一种通过线程池或者消息队列实现1个
或者多个线程处理N个客户端的模型,由于它的底层通信机制依然使用同步阻塞LO,所
以被称为“伪异步”。下面的章节我们就对伪异步代码进行分析,看看伪异步是否能够满
足我们对高性能、高并发接入的诉求。
2伪异步IO编程
为了解决同步阻塞IO面临的一个链路需要一个线程处理的问题,后来有人对它的线
程模型进行了优化—后端通过一个线程池来处理多个客户端的请求接入,形成客户端个
数M:线程池最大线程数N的比例关系,其中M可以远远大于N。通过线程池可以灵活
地调配线程资源,设置线程的最大值,防止由于海量并发接入导致线程耗尽
下面,我们结合连接模型图和源码,对伪异步IO进行分析,看它是否能够解决同步
阻塞LO面临的问题。
18·第2章NO入门
2.2.1伪异步1/O模型图
采用线程池和任务队列可以实现一种叫做伪异步的lO通信框架,它的模型图如图2-5
所示
当有新的客户端接入时,将客户端的 Socket封装成一个Task(该任务实现java.lang.
Runnable接口)投递到后端的线程池中进行处理,JDK的线程池维护一个消息队列和N
个活跃线程,对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大
线程数,因此,它的资源占用是可控的,无论多少个客户端并发访问,都不会导致资源的
耗尽和宕机。
I connect I
Web Browser
Runnable
I connect2
Web Browser?
I connect 3
aCceptor
Task
Web Browser 3
connect4
3 new Thread execute
Web Browser
…,…12
Thread pool
4 send Response lo peer
图2-5伪异步IO服务端通信模型(M:N)
下面的小节,我们依然采用时间服务器程序,将其改造成伪异步IO时间服务器,然
后通过对代码进行分析,找出其弊端
222伪异步M/O创建的 Time Server源码分析
我们对服务端代码进行一些改造,代码如下。
代码清单2-4伪异步1O的 Time server
13. public class Time Server I
14
15
16
x @param args
17
x @ throws IOException
19Nety权威指南(第2版)
19,
public static void main(string[] args) throws IOException t
20
int port =8080;
21
if (args ! null & args length >0)i
22,
try t
23,
port Integer, valueof(args [o])i
24
r catch (NumberFormatException e) I
25
//采用默认值
26
27
28,
Serversocket server nulli
29
try i
30,
server new ServerSocket(port)i
31
System.out. println("The time server is start in port port)i
32
Socket socket null:
33,
Timeserver handlerExecutePool
singleExecutor
nefr
Time Server HandlerExecutePooI(
34
50,10000);//创建I/O任务线程池
35
while (true) I
36
socket server accept()i
37,
singleExecutor. execute (new TimeserverHandler (socket))/
38
39
t finally f
40
if (server ! null) I
41
System. out. println("The time server close);
42,
server. close();
43,
server= nulli
44,
45
46
47.
伪异步LO的主函数代码发生了变化,我们首先创建一个时间服务器处理类的线程池,
当接收到新的客户端连接时,将请求 Socket封装成一个Task,然后调用线程池的 execute
方法执行,从而避免了每个请求接入都创建一个新的线程
代码清单2-5伪异步IO的 Time ServerHandlerExecute Pool
12. public class Time ServerHandlerExecute Pool t
13
14
private Executorservice executor
16
public Time ServerHandlerExecutePool (int maxPoolSizer int queueSize)i
20·第2章NO入门
executor new ThreadPoolExecutor(Runtime. getRuntime (
availableProcessors(, maxPoolSize, 120L Time Unit. SECONDS
1
new ArrayBlockingQueue<java. lang Runnable>(queuesize)):
20
public void execute(java. lang Runnable task
22.
executor. execute(task)i
23
24.}
由于线程池和消息队列都是有界的,因此,无论客户端并发连接数多大,它都不会导
致线程个数过于膨胀或者内存溢出,相比于传统的一连接一线程模型,是一种改良。
由于客户端代码并没有改变,因此,我们直接运行服务端和客户端,执行结果如下。
服务端运行结果如图2-6所示。
R Problems a Javadoc E, Deelaration 4 Such B Console 2-6Progress
萬伊
<terminated> TimeServer (1)[Java Application] E: \Progan Files\araljdk1 7 0-45\bin javar. exe (2014F215E FTe: 29
The time server is start in port 8080
The time server receive order QUERT TIME ORDER
图2-6伪异步IO时间服务器服务端运行结果
客户端运行结果如图2-7所示。
应rd@ Javadoc B Declaration Search E Console8sr其圆回
terminated) Tine1int口Java衄 plication] E: \Progran Files \awaijdklT.045 abinljav.(014年2月15日下午235
Send order 2 server succeed
Now is: Sat Feb 15 21: 29: 59 CST 2014
图2-7伪异步O时间服务器客户端运行结果
伪异步IO通信框架采用了线程池实现,因此避免了为每个请求都创建一个独立线程
造成的线程资源耗尽问题。但是由于它底层的通信依然采用同步阻塞模型,因此无法从根
本上解决问题。下个小节我们对伪异步O进行深入分析,找到它的弊端,然后看看NIO
是如何从根本上解决这个问题的。
2.2.3伪异步WO弊端分析
要对伪异步I/O的弊端进行深入分析,首先我们看两个Java同步IO的API说明,随
后结合代码进行详细分析。
21·Ney权威指南(第2版)
代码清单2-6Java输入流 InputStream
Reads some number of bytes from the input stream and stores them into
k the buffer array <code>b</code>, The number of bytes actually read is
returned as an integer. This me thod blocks until input data is
available, end of file is detected, or an exception is thrown
<p> If the length of <code>b</code> is zero, then no bytes are read and
<code>0</code> is returned; otherwise, there is an attempt to read at
least one byte. If no byte is available because the stream is at the
end of the file, the value <code>-1</code> is returned; otherwise, at
k least one byte is read and stored into <code>b</ code>
<p> The first byte read is stored into element <code>b[0]</code>,the
next one into <code>b[1]</code>, and so on. The number of bytes read is
k at most, equal to the length of <code>b</code>. Let <i>k</i> be the
number of bytes actually read; these bytes will be stored in elements
ode>b[0]</code> through <code>b[</code><i>k</i><code>-1]</code>
leaving elements <code>b[</code><i>k</i><code>]</code> through
s <code>b [b length-l]</code> unaffected
gpar
b the buffer into which the data is read
areturn
the total number of bytes read into the buffer, or
<code>-1</code> if there is no more data because the end of
the stream has been reached
Exception IOException If the first byte cannot be read for any reason
other than the end of the file, if the input stream has been closed, or
if some other I/o error occurs
Exception NullPointerException if <code>b</code> is <code>null
</code>
public int read(byte b[]) throws IOException
return read(b, 0, b length)i
请注意加粗斜体字部分的APⅠ说明,当对 Socket的输入流进行读取操作的时候,它
会一直阻塞下去,直到发生如下三种事件
◎有数据可读
◎可用数据已经读取完毕;
·22第2章NO入门
◎发生空指针或者IO异常。
这意味着当对方发送请求或者应答消息比较缓慢,或者网络传输较慢时,读取输入流
一方的通信线程将被长时间阻塞,如果对方要60s才能够将数据发送完成,读取一方的IO
线程也将会被同步阻塞60s,在此期间,其他接入消息只能在消息队列中排队
下面我们接着对输出流进行分析,还是看 JDK I/C类库输出流的API文档,然后结合
文档说明进行故障分析。
代码清单2-7Java输入流 OutputStream
public void write(byte b[]) throws IOException
*Writes an array of bytes, This method will block until the bytes are *actually
written
Parameters
b -the data to be written
Throws: IOException
If an I/o error has occurred
当调用 Output Strean的 write方法写输出流的时候,它将会被阻塞,直到所有要发送
的字节全部写入完毕,或者发生异常。学习过TCP/P相关知识的人都知道,当消息的接
收方处理缓慢的时候,将不能及时地从TCP缓冲区读取数据,这将会导致发送方的TCP
window size不断减小,直到为0,双方处于Keep- Alive状态,消息发送方将不能再向TCP
缓冲区写入消息,这时如果采用的是同步阻塞1O, write操作将会被无限期阻塞,直到TCP
window size大于0或者发生IO异常。
通过对输入和输出流的API文档进行分析,我们了解到读和写操作都是同步阻塞的,
阻塞的时间取决于对方IO线程的处理速度和网络I/O的传输速度。本质上来讲,我们无
法保证生产环境的网络状况和对端的应用程序能足够快,如果我们的应用程序依赖对方的
处理速度,它的可靠性就非常差。也许在实验室进行的性能测试结果令人满意,但是一旦
上线运行,面对恶劣的网络环境和良莠不齐的第三方系统,问题就会如火山一样喷发。
伪异步IO实际上仅仅是对之前IO线程模型的一个简单优化,它无法从根本上解决
同步I○导致的通信线程阻塞问题。下面我们就简单分析下通信对方返回应答时间过长会
引起的级联故障。
1)服务端处理缓慢,返回应答消息耗费60s,平时只需要10ms。
(2)采用伪异步O的线程正在读取故障服务节点的响应,由于读取输入流是阻塞的,
23·Net!y权威指南(第2版)
它将会被同步阻塞60s。
3)假如所有的可用线程都被故障服务器阻塞,那后续所有的IO消息都将在队列中
排队。
(4)由于线程池采用阻塞队列实现,当队列积满之后,后续入队列的操作将被阻塞。
5)由于前端只有一个 Acceptor线程接收客户端接入,它被阻塞在线程池的同步阻塞
队列之后,新的客户端请求消息将被拒绝,客户端会发生大量的连接超时。
(6)由于几乎所有的连接都超时,调用者会认为系统已经崩溃,无法接收新的请求消息。
如何破解这个难题?下节的NIO将给出答案
2.3NIO编程
在介绍NIO编程之前,我们首先需要澄清一个概念:NIO到底是什么的简称?有人称
之为NewI/O,原因在于它相对于之前的1/0类库是新增的。这是它的官方叫法。但是,
由于之前老的1/O类库是阻塞IO,NewI/O类库的目标就是要让Java支持非阻塞IO,所
以,更多的人喜欢称之为非阻塞IO(Non- block v/o)。由于非阻塞O更能够体现NIO的
特点,所以本书使用的NO都指的是非阻塞IO。
与 Socket类和 Server Socket类相对应,NlO也提供了 Socketchannel和 Server Socketchannel
两种不同的套接字通道实现。这两种新增的通道都支持阻塞和非阻塞两种模式。阻塞模式
使用非常简单,但是性能和可靠性都不好,非阻塞模式则正好相反。开发人员可以根据自
己的需要来选择合适的模式。一般来说,低负载、低并发的应用程序可以选择同步阻塞I/O
以降低编程复杂度;对于髙负载、高并发的网络应用,需要使用NIO的非阻塞模式进行开
发
下面的小节首先介绍NO编程中的一些基本概念,然后通过NIO服务端的序列图和
源码讲解,让大家快速地熟悉NIO编程的关键步骤和API的使用。如果你已经熟悉了NIO
编程,可以跳过2.3节直接学习后面的章节。
2.3.1NO类库简介
新的输入/输出(NIO)厍是在JDK14中引入的。NIO弥补了原来同步阻塞LO的不
24·第2章NO入门
足,它在标准Java代码中提供了高速的、面向块的O。通过定义包含数据的类,以及通
过以块的形式处理这些数据,NIO不用使用本机代码就可以利用低级优化,这是原来的IO
包所无法做到的。下面我们对NIO的一些概念和功能做下简单介绍,以便大家能够快速地
了解NIO类库和相关概念。
1.绶冲区 Buffer
我们首先介绍缓冲区( Buffer)的概念。Bufr是一个对象,它包含一些要写入或者
要读出的数据。在NIO类库中加入 Buffer对象,体现了新库与原Io的一个重要区别。在
面向流的IO中,可以将数据直接写入或者将数据直接读到 Strean对象中。
在NIO厍中,所有数据都是用缓冲区处理的。在读取薮据时,它是直接读到缓冲区中
的:在写入数据时,写入到缓冲区中。任何时候访问NIO中的数据,都是通过缓冲区进行
操作。
缓冲区实质上是一个数组。通常它是一个字节数组( Byte Buffer),也可以使用其他种
类的数组。但是一个缓冲区不仅仅是一个数组,缓冲区提供了对数据的结构化访问以及维
护读写位置( limit)等信息。
最常用的缓冲区是 Byte Buffer,一个 Byte Buffer提供了一组功能用于操作byte数组。
除了 ByteBuffer,还有其他的一些缓冲区,事实上,每一种Java基本类型(除了 Boolean
类型)都对应有一种缓冲区,具体如下。
o Byte Buffer:字节缓冲区
CharBuffer:字符缓冲区
◎ Short Buffer:短整型缓冲区
◎ Int Buffer:整形缓冲区
o Long Buffer:长整形缓冲区
Float Buffer:浮点型缓冲区
◎ Doublebuffer:双精度浮点型缓冲区
缓冲区的类图继承关系如图2-8所示。
25Net!y权威指南第2版
Buffer
pacity: int
limit;int≥0
lear(): Butler
flipo: Buffer
ByteButter
CharBufter
DoubleBuffer
Float Buffer
IntBuffer
onabufer'
ShortBuffer
MappedByteBuffer
图2-8 Buffer继承关系图
每一个 Buffer类都是 Buffer接口的一个子实例。除了 Byte Buffer,每一个 Buffer类都
有完全一样的操作,只是它们所处理的数据类型不一样。因为大多数标准LO操作都使用
Byte Buffer,所以它在具有一般缓冲区的操作之外还提供了一些特有的操作,以方使网络
读写。
2.通道 Channe
Channel是一个通道,它就像自来水管一样,网络数据通过 Channel读取和写入。通
道与流的不同之处在于通道是双向的,流只是在一个方向上移动(一个流必须是
InputStream或者 OutputStream的子类),而通道可以用于读、写或者二者同时进行。
因为 Channel是全双工的,所以它可以比流更好地映射底层操作系统的API。特别是
在UNIX网络编程模型中,底层操作系统的通道都是全双工的,同时支持读写操作。
Channel的类图继承关系如图2-9所示。
自顶向下看,前三层主要是 Channel接口,用于定义它的功能,后面是一些具体的功
能类(抽象类)。从类图可以看出,实际上 Channel可以分为两大类:用于网络读写的
Selectablechannel和用于文件操作的 FileChannel
26·第2章NO入门
本书涉及的 Server Socketchannel和 Socketchannel都是 Selectable Channel的子类,它
们的具体用法将在后续的代码中体现。
O Channel
Rym国we元ma
0 InterruptibleChannel
T ByteChannel
G AbstractSelectable Chame!
a DrtagramChanel
C Socketcharnel
senay sochetchemel
图29 Channel继承关系类图
3.多路复用器 Selector
在本节中,我们将探索多路复用器 Selector,它是 Java nio编程的基础,熟练地掌握
Selector对于NIO编程至关重要。多路复用器提供选择已经就绪的任务的能力。简单来讲,
Selector会不断地轮询注册在其上的 Channel,如果某个 Channel上面发生读或者写事件,
这个 Channel就处于就绪状态,会被 Selector轮询岀来,然后通过 Selection Key可以获取
就绪 Channel的集合,进行后续的IO操作。
一个多路复用器 Selector可以同时轮询多个 Channel,由于JDK使用了 pollo代替传
统的 select实现,所以它并没有最大连接句柄1024/2048的限制。这也就意味着只需要
个线程负责 Selector的轮询,就可以接入成千上万的客户端,这确实是个非常巨大的进步
下面,我们通过NO编程的序列图和源码分析来熟悉相关的概念,以便巩固前面所学
的NIO基础知识。
·27·Net!权威指南(第2版)
2.32NO服务端序列图
NIO服务端通信序列图如图2-10所示。
NioServer
Reactor Thread
1打开 ServerSocketchannel
2绑定监听地址 InetSocketAddress
3创建 Selector,启动线程
4将 ServerSocketchannel注册到
5 Selector轮询就绪的Key
Selector,监听
7设置新建客户端
八D(处理新的客
6 handleR cce
端接入
连接的
参数
8向 Sector注册监听读操作
Key OP READ
9 handlead异步读请求消
息到 Byte Buffer
I1异步写 Byte Buffer到
0 decode请求消息
Socketchannel
图2-10NIO服务端通信序列图
下面,我们对NIO服务端的主要创建过程进行讲解和说明,作为NIO的基础入门,
这里将忽略掉一些在生产环境中部署所需要的特性和功能。
步骤一:打开 Server Socketchannel,用于监听客户端的连接,它是所有客户端连接的
父管道,示例代码如下。
Server Socketchannel acceptor Svr Server Socketchannel open()i
步骤二:绑定监听端口,设置连接为非阻塞模式,示例代码如下。
acceptorSvr. socket(). bind(new
InetsocketAddress (InetAddress getByName ("IP"), port))i
acceptorSvr. configureBlocking(false)i
步骤三:创建 Reactor线程,创建多路复用器并启动线程,示例代码如下。
Selector selector= Selector. open()i
New Thread (new Reactorrask()). start()i
·28第2章NO入门
步骤四:将 ServerSocketchannel注册到 Reactor线程的多路复用器 Selector上,监听
ACCEPT事件,示例代码如下。
Selectionkey key= acceptorSvr, register( selector, Selectionkey OP ACCEPT,
chAndler)i
步骤五:多路复用器在线程run方法的无限循环体内轮询准备就绪的Key,示例代码
如下。
int num selector select ();
Set selectedkeys selector. selectedKeys()i
Iterator it= selectedKeys iterator()i
while (it. hasNext())I
Selectionkey key =(SelectionKey)it next()
deal with I/o event
步骤六:多路复用器监听到有新的客户端接入,处理新的接入请求,完成TCP三次
握手,建立物理链路,示例代码如下。
SocketChannel channel= svrChannel accept(
步骤七:设置客户端链路为非阻塞模式,示例代码如下。
channel. configureBlocking(false)i
channel socket(). setReuseAddress(true);
步骤八:将新接入的客户端连接注册到 Reactor线程的多路复用器上,监听读操作,
读取客户端发送的网络消息,示例代码如下。
Selectionkey key=socketchannel, register( selector, SelectionKey OP READ,
chAndler)i
步骤九:异步读取客户端请求消息到缓冲区,示例代码如下。
int readNumber= channel. read(receivedBuffer);
步骤十:对 Byte Buffer进行编解码,如果有半包消息指针 reset,继续读取后续的报文,
将解码成功的消息封装成Task,投递到业务线程池中,进行业务逻辑编排,示例代码如下
Object message null;
while(buffer. hasRemain())
·29·Netty权威指南(第2版)
byteBuffer. mark()i
Object message decode (byteBuffer)i
if (message
nu11)
byteBuffer reset()i
breaki
messageList. add (message )i
if (!byteBuffer. hasRemain ())
byteBuffer clear()i
else
byteBuffer compact()i
if (messageList ! null & messageList isEmpty())
for(Object message messageList)
handlerTask(message)i
步骤十一:将POJO对象 encode成 Byte Buffer,调用 Socketchannel的异步 write接口,
将消息异步发送给客户端,示例代码如下。
socketChannel, write(buffer)i
注意:如果发送区TCP缓冲区满,会导致写半包,此时,需要注册监听写操作位,
循环写,直到整包消息写入TCP缓冲区。对于这些内容此处暂不赘述,后续Net源码分
析章节会详细分析Nety的处理策略。
在了解创建NIO服务端的基本步骤之后,下面我们将前面的时间服务器程序通过NIO
重写一遍,让大家能够学习到完整版的NIO服务端创建。
2.3.3N|O创建的 Time Server源码分析
我们将在 Time Server例程中给出完整的NIO创建的时间服务器源码。
代码清单2-8NIO时间服务器 Timeserver
public class TimeServer t
10
11
·30第2章NO入门
12
k Param args
13
throws IOException
14
15
public static void main(String[] args) throws IOException t
16
int port =8080
17
if (args ! null & argslength >0)i
18
try
19
port Integer valueof(args[0])i
20,
t catch (Number FormatException e) t
//采用默认值
22.
23
24
MultiplexerTime Server timeServer
new MultiplexerTime Server
(port)i
25
New Thread(timeserver,NIO-MultiplexerTimeserver-001)start()i
26
27,
下面对NIO创建的 Time server进行简单分析。第16~23行跟之前的一样,设置监听
端口。第24~25行创建了一个被称为 MultiplexerTime Server的多路复用类,它是个一个
独立的线程,负责轮询多路复用器 Seletar,可以处理多个客户端的并发接入。现在我们继
续看 Multiplexer TimeServer的源码。
代码清单2-8NO时间服务器 Multiplexer Time Server
17. public class MultiplexerTime Server implements Runnable
18.
19
private Selector selector:
20,
21
private ServerSocketchannel servChanneli
22
23
private volatile boolean stop;
24
25.
26
初始化多路复用器,绑定监听端口
27,
28
param port
29
30. public MultiplexerTimeServer(int port) i
31
tr
y
32,
selector= Selector. open()i
33
servChannel= ServerSocketChannel, open()i
31Ney权威指南(第2版)
34
servChannel. configureBlocking(false);
35
servChannel. socket(). bind(new InetSocketAddress(port), 1024)i
36
servChannel. register (selector, SelectionKey OP ACCEPT)i
37
System, out. println("The time server is start in port port)
38
1 catch (IOException e)[
39.
e printstackTrace()i
40
ystem. exit(1)i
41
42
43
44,
public void stop()
45.
this stop
true:
46
47
48,
49
*(non-Javadoc)
50
51
asee java. lang Runnable#run ()
52
53,
@override
54
public void run()[
55
while (! stop) i
56
try t
57
selector. select(1000);
58
Set<selectionkey> selectedReys selector selectedkeys()i
59
Iterator<selectionKey> it=selectedKeys iterator()i
60
selectionkey key nulli
61,
while (it. hasNext())t
62
key = it next(i
63
it, remove()i
64
try t
65
handleInput (key)i
66
I catch (Exception e) I
67
if (key ! null) I
68
key cancel()i
69
if (key channel():= null
70
key channel(). close()i
71
72
73
t catch (Throwable t)
32第2章NO入门
75
t printstackTrace()
76
77,
78
79,
/多路复用器关闭后,所有注册在上面的 Channe1和pipe等资源都会被自动去注册
并关闭,所以不需要重复释放资源
80
if (selector != null
81
try i
82
selector. close();
83
g catch (IOException e) i
84,
e printstackTrace()i
85
86
87
88
private void handleInput(SelectionKey key) throws IOException i
89.
90.
if (key isValid())t
91,
//处理新接入的请求消息
92
if (key. isAcceptable())(
93
/ Accept the new connection
94,
Server Socket Channel ssc=(ServerSocketChannel) key, channel()i
95
SocketChannel Sc- ssc accept()i
96
sC.configureBlocking(false)i
97,
/ Add the new connection to the selector
98
sc register(selector, Selectionkey OP READ)i
99
100
if (key. isReadable())
101,
/ Read the data
102,
Socketchannel sc =(SocketChannel, key channel()i
103,
ByteBuffer readBuffer ByteBuffer allocate(1024)i
104
int readBytes = sc read(readBuffer)i
105
if (readBytes > 0)[
106
readBuffer, flip()i
107
byte[l bytes new byte [readBuffer remaining()i
108.
readBuffer. get(bytes)i
109,
String body new String (bytes, " UTF-8")i
110.
System. out. println("The time server receive order
111
t body )i
112,
String currentTime =QUERY TIME ORDER"
113
equalsIgnoreCase(body) new java util. Date(
114.
System currentTimeMillis()). tostring()
115
BAD ORDER;
33Netty权威指南(第2版)
116
doWrite(sc, currentTime)i
117
i else if (readBytes 0)(
118,
/对端链路关闭
119
key cancel();
120,
sc close(i
121.
else
122.
;/′读到0字节,忽略
123
124,
125
126
127
private void dowrite(socket channel channel, String response
128
throws IOException
129
if (response ! null & response trim().length()>0)I
130,
byte[] bytes= response getBytes(i
131,
ByteBuffer writeBuffer= ByteBuffer allocate(bytes, length)i
132
writeBuffer put (bytes)i
133.
writeBuffer. flip()
134
channel, write(writeBuffer)i
135
136
137
由于这个类相比于传统的 Socket编程会稍微复杂一些,在此展开进行详细分析,从如
下几个关键步骤来讲解多路复用处理类。
1)30~42行为构造方法,在构造方法中进行资源初始化。创建多路复用器 Selector、
Server Socketchannel,对 Channel和TCP参数进行配置。例如,将 ServerSocketchannel设
置为异步非阻塞模式,它的 backlog设为1024。系统资源初始化成功后,将 ServerSocket
Channel注册到 Selector,监听 SelectionKey OP ACCEPT操作位。如果资源初始化失败(例
如端口被占用),则退出。
(2)55~77行是在线程的run方法的 while循环体中循环遍历 selector,它的休眠时间
为1s。无论是否有读写等事件发生, selector每隔1s都被唤醒一次。 selector也提供了
个无参的 select方法:当有处于就绪状态的 Channel时, selector将返回该 Channel的
Selection Key集合。通过对就绪状态的 Channel集合进行迭代,可以进行网络的异步读写
操作。
〈3)92~99行处理新接入的客户端请求消息,根据 SelectionKey的操作位进行判断即
可获知网络事件的类型,通过 Server Socketchannel的 accept接收客户端的连接请求并创
34·第2章NO入门
建 Socketchannel实例。完成上述操作后,相当于完成了TCP的三次握手,TCP物理链路
正式建立。注意,我们需要将新创建的 Socketchannel设置为异步非阻塞,同时也可以对
其TCP参数进行设置,例如TCP接收和发送缓冲区的大小等。但作为入门的例子,以上
例程没有进行额外的参数设置。
(4)100~125行用于读取客户端的请求消息。首先创建一个 Byte Buffer,由于我们事
先无法得知客户端发送的码流大小,作为例程,我们开辟一个1MB的缓冲区。然后调用
Socketchannel的read方法读取请求码流。注意,由于我们已经将 Socketchannel设置为异
步非阻塞模式,因此它的read是非阻塞的。使用返回值进行判断,看读取到的字节数,返
回值有以下三种可能的结果。
◎返回值大于O:读到了字节,对字节进行编解码;
◎返回值等于0:没有读取到字节,属于正常场景,忽略
◎返回值为-1:链路已经关闭,需要关闭 Socketchannel,释放资源
当读取到码流以后,进行解码。首先对 read Buffer进行fip操作,它的作用是将缓冲
区当前的 limit设置为 position, position设置为0,用于后续对缓冲区的读取操作。然后根
据缓冲区可读的字节个数创建字节数组,调用 Byte Buffer的get操作将缓冲区可读的字节
数组复制到新创建的字节数组中,最后调用字符串的构造函薮创建请求消息体并打印。如
果请求指令是" QUERY TIME ORDER",则把服务器的当前时间编码后返回给客户端。下
面我们看看异步发送应答消息给客户端的情况。
(5)127~135行将应答消息异步发送给客户端。我们看下关键代码,首先将字符串编
码成字节数组,根据字节数组的容量创建 Byte Buffer,调用 Byte Buffer的put操作将字节
数组复制到缓冲区中,然后对缓冲区进行fip操作,最后调用 Socketchannel的 write方法
将缓冲区中的字节数组发送出去。需要指出的是,由于 Socketchannel是异步非阻塞的,
它并不保证一次能够把需要发送的字节数组发送完,此时会出现“写半包”问题。我们需
要注册写操作,不断轮询 Selector将没有发送完的 Byte Buffer发送完毕,然后可以通过
Byte Buffer的 hasremaino方法判断消息是否发送完成。此处仅仅是个简单的入门级例程,
没有演示如何处理“写半包”场景,后续的章节会有详细说明。
使用NO创建 TimeServer服务器完成之后,我们继续学习如何创建NIO客户端。首
先还是通过时序图了解关键步骤和过程,然后结合代码进行详细分析。
·35·Nety权威指南(第2版)
234NO客户端序列图
NIO客户端创建序列图如图2-11所示。
NioClient
Reactor thread
ChAndler
1打开 Socketchannel
2设置 Socketchanne为非阻
塞模式,同时设置TCP参数
卡 Server
3异步连接服务端
4判断连接结果,如果连接成
功,调到步骤10,否则执行步
骤5
6创建 Selector,启动线
5向 Reactor线程的多路复用器注
程
册 OP CONNECT事件
7 Selector轮询就绪的
K
8 handerConnect(
9判断连接是
否完成,完成执
10向多路复用器注册读
行步骤10
件 OP READ
I handle reado异步读请
求消息到 Byte Buffer
13异步写 Byte Buffer到
12 decode请求
Socketchannel
消息
图2-11N1O客户端创建序列图
步骤一:打开 SocketChannel,绑定客户端本地地址(可选,默认系统会随机分配」
个可用的本地地址),示例代码如下。
Socketchannel clientchannel SocketChannel, open():
步骤二:设置 Socketchannel为非阻塞模式,同时设置客户端连接的TCP参数,示例
代码如下。
clientchannel. configureBlocking (false)i
socket. setReuseAddress(true)i
socket setReceiveBuffersize(BUFFER SIZE)
socket, setSendBuffersize (BUFFER SIZE);
36·第2章NO入门
步骤三:异步连接服务端,示例代码如下。
boolean connected=clientChannel connect (new Inet SocketAddress(ip", port))i
步骤四:判断是否连接成功,如果连接成功,则直接注册读状态位到多路复用器中,
如果当前没有连接成功(异步连接,返回 false,说明客户端已经发送sync包,服务端没
有返回ack包,物理链路还没有建立),示例代码如下。
if (connected)
client Channel register( selector, SelectionKey OP READ, ioHandler)i
else
client Channel, register( selector, Selectionkey OP CONNECT, ioHandler)i
步骤五:向 Reactor线程的多路复用器注册 OP CONNECT状态位,监听服务端的TCP
ACK应答,示例代码如下。
clientchannel register( selector, Selectionkey OP CONNECT, ioHandler)i
步骤六:创建 Reactor线程,创建多路复用器并启动线程,代码如下。
Selector selector- Selector. open()i
New Thread (new ReactorTasko)start(i
步骤七:多路复用器在线程run方法的无限循环体内轮询准备就绪的Key,代码如下。
int num selector select()i
Set selectedKeys selector. selectedKeys()i
Iterator it selectedKeys, iterator()i
while (it. hasNext())1
Selectionkey key =(Selectionkey)it next()i
//,,. deal with I/o event
步骤八:接收 connect事件进行处理,示例代码如下。
if (key. isConnectable())
//handlerConnect();
步骤九:判断连接结果,如果连接成功,注册读事件到多路复用器,示例代码如下。
·37·Nety权威指南(第2版)
(channel. finishConnect())
registerEd()i
步骤十:注册读事件到多路复用器,示例代码如下。
clientchannel register( selector, SelectionKey, OP READ, ioHandler)i
步骤十一:异步读客户端请求消息到缓冲区,示例代码如下
int readNumber
channel. read(receivedBuffer);
步骤十二:对 ByteBuffer进行编解码,如果有半包消息接收缓冲区 Reset,继续读取
后续的报文,将解码成功的消息封装成Task,投递到业务线程池中,进行业务逻辑编排,
示例代码如下
Object message nulli
while(buffer. hasRemain ())
byteBuffer. mark()i
Object message decode(byteBuffer)i
if (message = null
byteBuffer reset ()i
breaki
messagelist. add(message )i
if ( byteBuffer hasRemain())
byteBuffer clear()i
else
byteBuffer compact ()i
if (messageList I-null & messageList isEmpty ()
for(Object message messagelist)
handlerTask(message);
步骤十三:将POJO对象 encode成 Byte Buffer,调用 Socketchannel的异步 write接口,
将消息异步发送给客户端。示例代码如下。
socketchannel. write(buffer)i
·38·第2章NO入门
通过序列图和关键代码的解说,相信大家对创建NIO客户端程序已经有了一个初步的
了解。下面,就跟随着我们的脚步,继续看看如何使用NIO改造之前的时间服务器客户端
Time Client吧。
2.3.5N|O创建的 Time client源码分析
我们首先还是看下如何对 TimeClient进行改造
代码清单2-9NIO时间服务器客户端 Timeclient
16
if (args null & args length > 0)[
17
try i
18
port Integer valueof(args[o])i
19,
t catch (NumberFormatException e) t
20
//采用默认值
21
22
23
new Thread(new TimeClientHandle("127.0.0.1", port),"Time Client-
001")
24.
.start()i
25
26.
与之前唯一不同的地方在于通过创建 Time client handle线程来处理异步连接和读写操
作,由于 TimeClient非常简单且变更不大,这里重点分析 Time Clienthandle,代码如下。
代码清单2-10NIO时间服务器客户端 Time ClientHandle
1. package com.pheinetty nioi
2. import java. io. IOExceptioni
3. import java. net. Inet SocketAddress;
4. import java nio. ByteBufferi
5. import java nio channels. Selectionkeyi
6, import java, nio, channels, Selector
7. import java nio channels. Socketchannel
8. import java.util.Iterator;
9. import java. util. Seti
10
11,/
12. author Administrator
adate2014年2月16日
39Netty权威指南(第?版
14.大@ verson1,0
15.*/
16. public class TimeClientHandle implements Runnable t
17
private string hosti
18
private int porti
19.
private Selector selector;
20.
private SocketChannel socketChanneli
21.
private volatile boolean stop;
22
23
public TimeClientHandle(String host, int port) i
24,
this, host host = nu11? "127.0.0,1" hosti
25,
this port porti
26
t工
27
selector Selector open()
28
socketchannel Socket channel open ()i
29
socketChannel, configureBlocking(false)i
30
I catch (IOException e)[
31,
e, printstackTrace()i
32
System, exit(1)i
33
34
35
36
大
37
(non-Javadoc)
38
39
@see java. lang. Runnabletrun (
40
41
override
42
public void run()f
43
try
44,
doConnectoi
45
1 catch (IOException e
46
e printstackTrace()i
47
System. exit(1)i
48
49
while ( stop) i
50
try i
51
selector, select(1000);
52
Set<selectionKey> selectedKeys selector selectedKeys()i
53
Iterator<selectionkey> it= selectedKeys iterator()i
54,
SelectionKey key= nulli
·40·第2章N|O入门
55
while (it. hasNext())[
56
key it next()
57
it remove(i
58
try t
59
handleInput(key)
60
I catch (Exception e) I
61
if (key ! null) t
62
key cancel();
63
if (key channel()!= null
64
ey channel(). close()i
65
66
67
68
t catch (Exception e)[
69
eprintstackTrace()i
70
System. exit(1)i
71
72
73
74,
//多路复用器关闭后,所有注册在上面的 Channe1和pipe等资源都会被自动去注册
并关闭,所以不需要重复释放资源
75
if (selector ! null
76
try t
77
elector. close()i
78.
I catch (IOException e) t
79
e printstackTrace()i
80
81
82
33
private void handleInput (Selectionkey key) throws IOException
84
85,
if (key isvalid())i
86,
//判断是否连接成功
SocketChannel sc =(Socketchannel) key channel()i
88
if (key. isconnectable())i
89
if (sc. finishConnect())
90
sc register(selector, SelectionKey OP READ);
91
dowrite(sc)i
F else
93
System,eκit(1);//连接失败,进程退出
41·Netty权威指南(第2版
95
if (key. isReadable())
96
ByteBuffer readBuffer ByteBuffer allocate(1024)i
97
int readBytes sc read(readBuffer)i
98
if (readBytes > 0)I
99
readBuffer. flip()i
100.
byte[] bytes new byte[readBuffer remaining()]i
101
readBuffer. get(bytes)i
102.
String body= new String(bytes, "UTF-8")i
103
System. out. println("Now is body )i
104
this stop =true;
105,
s else if (readBytes < 0)t
106
//对端链路关闭
107
key cancel()i
108
SC close(i
109
t else
110.
;//读到0字节,忽略
111
112,
113
114
115
116
private void doConnect() throws IOException
117
/如果直接连接成功,则注册到多路复用器上,发送请求消息,读应答
118,
if(socket Channel, connect (new InetSocketAddress(host, port)))t
socketchannel.register(selector, Selectionkey OP READ)i
120
doWrite(socketChannel);
121
t else
122,
socketchannel. register(selector,
SelectionKey OP CONNECT)i
123
124
125
private void doWrite(Socket Channel sc) throws IOException I
126
byte[] req ="QUERY TIME ORDER". getBytes()i
127
ByteBuffer writeBuffer- ByteBuffer, allocate(reg. length)i
128.
writeBuffer put (reg)i
129,
writeBuffer. flip()i
130.
sc write(writeBuffer);
131
if ( writeBuffer. hasRemaining())
132.
System, out, println("Send order 2 server succeed. ")i
133
134,
·42·第2章NO入门
与服务端类似,接下来我们通过对关键步骤的源码进行分析和解读,让大家深入了解
如何创建NIO客户端以及如何使用NIO的API。
(1)23~34行构造函数用于初始化NIO的多路复用器和 Socketchannel对象。需要
注意的是,创建 Socketchannel之后,需要将其设置为异步非阻塞模式。就像在2.3.3小
节中所讲的,我们可以设置 Socketchannel的TCP参数,例如接收和发送的TCP缓冲区
大小。
(2)43~48行用于发送连接请求,作为示例,连接是成功的,所以不需要做重连操作
因此将其放到循环之前。下面我们具体看看 doconnect的实现,代码跳到第116-123行,
首先对 Socketchannel的 connecto操作进行判断。如果连接成功,则将 SocketChannel注册
到多路复用器 Selector上,注册 SelectionKey. OP READ;如果没有直接连接戌功,则说明
服务端没有返回TCP握手应答消息,但这并不代表连接失败。我们需要将 Socketchannel
注册到多路复用器 Selector上,注册 SelectionKey OP CONNECT,当服务端返回TCP
syn-ack消息后, Selector就能够轮询到这个 Socketchannel处于连接就绪状态
3)49~72行在循环体中轮询多路复用器 Selector。当有就绪的 Channe时,执行第
59行的 handleInput(key)方法。下面我们就对 handleInput方法进行分析
(4)跳到第83行,我们首先对 SelectionKey进行判断,看它处于什么状态。如果是
处于连接状态,说明服务端已经返回ACK应答消息。这时我们需要对连接结果进行判断,
调用 Socketchannel的 finishconnect(方法。如果返回值为true,说明客户端连接成功:如
果返回值为 false或者直接抛岀 IOException,说明连接失败。在本例程中,返回值为true,
说明连接成功。将 Socketchannel注册到多路复用器上,注册 SelectionKey. OP READ操作
位,监听网络读操作,然后发送请求消息给服务端。
下面我们对 do write(s)进行分析。代码跳到第125行,我们构造请求消息体,然后对
其编码,写入到发送缓冲区中,最后调用 Socketchannel的 write方法进行发送。由于发送
是异步的,所以会存在“半包写”问题,此处不再赘述。最后通过 hasRemaining(方法对
发送结果进行判断,如果缓冲区中的消息全部发送完成,打印" Send order2 server succeed."
5)返回代码第95行,我们继续分析客户端是如何读取时间服务器应答消息的。如
果客户端接收到了服务端的应答消息,则 Socketchannel是可读的,由于无法事先判断应
答码流的大小,我们就预分配1MB的接收缓冲区用于读取应答消息,调用 Socketchannel
的 reado方法进行异步读取操作。由于是异步操作,所以必须对读取的结果进行判断,这
部分的处理逻辑已经在2.3.3小节详细介绍过,此处不再赘述。如果读取到了消息,则对
43Netty权威指南(第2版)
消息进行解码,最后打印结果。执行完成后将stop置为true,线程退出循环。
(6)线程退出循环后,我们需要对连接资源进行释放,以实现“优雅退出”。75~80
行用于多路复用器的资源释放,由于多路复用器上可能注册成千上万的 Channel或者pipe,
如果一一对这些资源进行释放显然不合适。因此,JDK底层会自动释放所有跟此多路复用
器关联的资源,JDK的 API DOC如图2-12所示。
到此为止,我们已经通过NIO对时间服务器完成了改造,并对源码进行了分析和解读,
下面分别执行时间服务器的服务端和客户端,看看执行结果。
idj1·. channels. selector.山le0 thats ore电ti
Closes this selector
If a thread is currently blocked in one of this selector s selection nethods then it is interrupted as if by invoking the select s wakeup method
Any uncancelled keys still associated with this selector are invalidated their channels are deregistered and any other resources associated with this
selector are released
If this selector is arealy closed then invoking this methed has no effect
After i elector is closed any further attempt to use it except by invoking this nethod or the wakeup nethod will canse s ClenedsalecrorExcention to
be thr wa
specified by: slos+0 ia losable
Thres
IOExeeption-If an I/0 error secrs
图2-12多路复用器 Selector的资源释放
服务端执行结果如图2-13所示。
上 Problams@ Javadoc B Declaratiom .Search目Cm8sr
H
如 minated) Tim eServer ()口 ara Aplication]Prog≌" iles\avaljdkl705 binjai。四014年2月16日下午4:41
The time server 1s start in port 80B0
The time server receive order QUERY TIME ORDER
图2-13NIO时间服务器服务端执行结果
客户端执行结果如图2-14所示。
Problams s Javadoc B DeelaratienSeurch日 Console2r的
terminat) Tiseclient C1)[ a Application1rgFi1+!1.0451hin“←←(014年2月1日下午44129
Send order 2 server succeed
Now 18. Sun Feb 1616:41:29 CsT 2014
图2-14NIO时间服务器客户端执行结果
通过源码对比分析,我们发现NIO编程的难度确实比同步阻塞BIO的大很多,我们
的NIO例程并没有考虑“半包读”和“半包写”,如果加上这些,代码将会更加复杂。NIO
44·第2章NO入门
代码既然这么复杂,为什么它的应用却越来越广泛呢?使用NIO编程的优点总结如下。
(1)客户端发起的连接操作是异步的,可以通过在多路复用器注册 OP CONNECT等
待后续结果,不需要像之前的客户端那样被同步阻塞。
(2) SocketChannel的读写操作都是异步的,如果没有可读写的数据它不会同步等待,
直接返回,这样lo通信线程就可以处理其他的链路,不需要同步等待这个链路可用
(3)线程模型的优化:由于JDK的 Selector在 Linux等主流操作系统上通过 epoll实
现,它没有连接句柄数的限制(只受限于操作系统的最大句柄数或者对单个进程的句柄限
制),这意味着一个 Selector线程可以同时处理成千上万个客户端连接,而且性能不会随
着客户端的增加而线性下降。因此,它非常适合做高性能、高负载的网络服务器。
JDK1.7升级了NIO类库,升级后的NIO类库被称为NIO2.0。引人注目的是,Java
正式提供了异步文件IO操作,同时提供了与UNIX网络编程事件驱动IO对应的AIO。
下面的2.4节我们将学习如何利用NIO2.0编写AIO程序,依旧以时间服务器为例进行讲
解
2.4AIo编程
NIO2.0引入了新的异步通道的概念,并提供了异步文件通道和异步套接字通道的实
现。异步通道提供以下两种方式获取获取操作结果。
通过 javautil. concurrent. Future类来表示异步操作的结果;
◎在执行异步操作的时候传入一个 Java. n1o. channels
Completion Handler接口的实现类作为操作完成的回调。
NIO2.0的异步套接字通道是真正的异步非阻塞LO,对应于UNIX网络编程中的事件
驱动ⅠO(AO)。它不需要通过多路复用器( Selector)对注册的通道进行轮询操作即可实
现异步读写,从而简化了NIO的编程模型。
下面通过代码来熟悉NIO20AIO的相关类库,仍旧以时间服务器为例程进行讲解。
45Nety权威指南(第2版)
2.4.1A|O创建的 Time Server源码分析
首先看下时间服务器的主函数。
代码清单2-11AIO时间服务器服务端 TimeClienthandle
10. public class Time server i
11
12
13.
Param args
d throws IOException
15
16
public static void main(String[] args) throws IOException
17.
int port =8080;
18
if (args ! null & args length >0)[
19
try i
20,
port Integer valueof(args[o])i
21
catch (Number FormatException e) i
22.
/采用默认值
23.
24
25
AsyncTimeServerHandler time=new AsyncTime ServerHandler (port)i
26
new Thread(timeserver, "AIO-AsyncTimeServerHandler-001").start()i
27
28.}
我们直接从第25行开始看,首先创建异步的时间服务器处理类,然后启动线程将
AsyncTime ServerHandler拉起,代码如下
代码清单2-12AIO时间服务器服务端
13. public class AsyncTimeServerHandler implements Runnable i
14
15
private int porti
16,
17,
Count Downlatch latch
18
Asynchronous ServerSocketChannel asynchronous Server Socket channel
1
20
public AsyncTimeServerHandler (int port)
21
this port
orti
22
try i
23
asynchronous Server Channel= Asynchronous Server Socketchannel
24
open()i
·46·第2章NO入门
25
asynchronousServer Socket Channel. bind (new
InetSocketAddress(port))i
26
System. out. println("The time server is start in port port)i
27
catch (IOException e) I
28
e printstackTrace()i
29.
30
32
33.
(non-Javadoc)
34
35
x @see java, lang, Runnabletrun (
36
37
override
38,
public void run()t
39,
40
latch new Count DownLatch(1)i
41
doAccept()i
42
try i
43
latch await (i
44
s catch (InterruptedException e) t
45
eprintstackTrace()i
46,
47
8
49
public void doAccept() I
50
asynchronousServerSocketchannel accept(this
51
new Accept CompletionHandler())i
52
我们重点对 AsyncTimeServerHandler进行分析。首先看第20~27行,在构造方法中,
首先创建一个异步的服务端通道 AsynchronousServer Socket Channel,然后调用它的bind方法
绑定监听端口。如果端口合法且没被占用,则绑定成功,打印启动成功提示到控制台。
在线程的run方法中,第40行初始化 CountDownLatch对象,它的作用是在完成一组
正在执行的操作之前,允许当前的线程一直阻塞。在本例程中,我们让线程在此阻塞,防
止服务端执行完成退出。在实际项目应用中,不需要启动独立的线程来处理
Asynchronous Server Socket Channel,这里仅仅是个demo演示。
第41行用于接收客户端的连接,由于是异步操作,我们可以传递一个 Completion Handler
< Asynchronous SocketChannel,? super A>类型的 handler实例接收 accept操作成功的通知消
47·Nety权威指南(第2版)
息。在本例程中我们通过 AcceptCompletion Handler实例作为 handler来接收通知消息,下
面继续对 Accept Completion Handler进行分析。
代码清单2-13AIO时间服务器服务端 Accept Handler
14
15
oVerride
16. public void completed(Asynchronous Socketchannel result
17,
AsyncTimeServerHandler attachment) i
18
attachment. asynchronous ServerSocketchannel, accept(attachment,
this)i
19
ByteBuffer buffer ByteBuffer allocate(1024);
20.
result. read(buffer, buffer, new ReadCompletionHandler(result));
21
22
23
override
24
public void failed(Throwable exc, AsyncTime ServerHandler attachment)(
25
exc printstackTrace()
26
attachment latch. countDown()i
28.
Completion Handler有两个方法,分别如下。
o public void completed( Asynchronous Socket Channel result, Async Time ServerHandler
attachment);
public void failed(Throwable exc, Async Time ServerHandler attachment)
下面分别对这两个接口的实现进行分析。首先看 completed接口的实现,代码第18~20行,
我们从 attachment获取成员变量 Asynchronous Server SocketChannel,然后继续调用它的
accept方法。有的读者可能会心存疑惑:既然已经接收客户端成功了,为什么还要再次调用
accept方法呢?原因是这样的:调用 Asynchronous Server SocketChannel的acet方法后,
如果有新的客户端连接接入,系统将回调我们传入的 Completion Handler实例的 completed
方法,表示新的客户端已经接入成功。因为一个 Asynchronous Server Socket Channel可以接
收成千上万个客户端,所以需要继续调用它的 accept方法,接收其他的客户端连接,最终
形成一个循环。每当接收一个客户读连接成功之后,再异步接收新的客户端连接。
链路建立成功之后,服务端需要接收客户端的请求消息,在代码第19行创建新的
ByteBuffer,预分配1MB的缓冲区。第20行通过调用 Asynchronous Socket Channel的read
48·第2章NO入门
方法进行异步读操作。下面我们看看异步read方法的参数。
◎ Byte Buffer dst:接收缓冲区,用于从异步 Channel中读取数据包;
◎ A attachment:异步 Channel携带的附件,通知回调的时候作为入参使用
Completion Handler< Integer,? super A>:接收通知回调的业务 Handler,在本例程
中为 ReadCompletion Handler
下面我们继续对 Read CompletionHandler进行分析。
代码清单2-14AIO时间服务器服务端 ReadCompletion Handler
8
9
10
Author lilinfeng
edate2014年2月16日
12,
eversion 1.0
13.*/
14. public class ReadCompletionHandler implements
15
CompletionHandler<Integer ByteBuffer>
16
17
private Asynchronous Socketchannel channel
18
19. public ReadcompletionHandler (Asynchronous SocketChannel channel)
20,
if (this channel = null
21
this channel= channel:
22,
23
24
override
25
public void completed(Integer result, ByteBuffer attachment) I
26
attachment. flip();
27,
byte[] body new byte [attachment. remaining()]:
28.
attachment. get (body )i
29
try i
30
String reg= new String(body, UTF-8)i
31
System, out. println("The time server receive order reg)i
32
String currentTime="QUERY TIME ORDER".equalsIgnoreCase(reg)
new java. util. Date
33
System currentTimeMillis().tostring(): "BAD ORDER";
34
doWrite( currentTime)i
35
s catch (UnsupportedEncodingException e) 1
36
e printstackTrace():
49Netty权威指南(第2版)
37
38,
39
40,
private void doWrite(String currentTime)
41
if (currentTime !=null & currentrime trim().length()>0)(
42,
byte[] bytes -(currentTime ). getBytes()i
43,
ByteBuffer writeBuffer ByteBuffer allocate(bytes length)i
44
writeBuffer put(bytes)i
45
writeBuffer. flip()i
46
channel. write (writeBuffer, writeBuffer,
47
new CompletionHandler<Integer, ByteBuffer>()[
48
@Override
49
public void completed(Integer result, ByteBuffer buffer)
50
/如果没有发送完成,继续发送
if (buffer. hasRemaining ()
52
channel,write(buffer, buffer, this)i
53
54
55
Override
56
public void failed(Throwable exc, ByteBuffer attachment) t
57
try f
58
channel close()i
59
t catch (IOException e)(
60
// ingnore on close
61,
62.
63.
});
64
65
66
67,
@override
68
public void failed(Throwable exc, ByteBuffer attachment
69
try
70
this channel closed
t catch (IOException e)i
72
e printstackTrace()i
73
75.}
50第2章N|O入门
首先看构造方法。我们将 Asynchronous Socket Channel通过参数传递到 Readcompletion
Handler中,当作成员变量来使用,主要用于读取半包消息和发送应答。本例程不对半包
读写进行具体说明,对此感兴趣的读者可以关注后续章节对 Netty半包处理的专题介绍。
继续看代码,第25~38行是读取到消息后的处理。首先对 attachment进行fijp操作,为
后续从缓冲区读取数据做准备。根据缓冲区的可读字节数创建byte数组,然后通过new
String方法创建请求消息,对请求消息进行判断,如果是" QUERY TIME ORDER"则获取当
前系统服务器的时间,调用 do write方法发送给客户端。下面我们对 dowrite方法进行详
细分析。
跳到代码第41行,首先对当前时间进行合法性校验,如果合法,调用字符串的解码
方法将应答消息编码成字节数组,然后将它复制到发送缓冲区 write Buffer中,最后调用
Asynchronous SocketChannel的异步 write方法。正如前面介绍的异步read方法一样,它也
有三个与read方法相同的参数,在本例程中我们直接实现 write方法的异步回调接口
Completion Handler。代码跳到第51行,对发送的 write Buffer进行判断,如果还有剩余的
字节可写,说明没有发送完成,需要继续发送,直到发送成功。
最后,我们关注下 failed方法,它的实现很简单,就是当发生异常的时候,对异常
Throwable进行判断:如果是O异常,就关闭链路,释放资源:如果是其他异常,按照
业务自己的逻辑进行处理。本例程作为简单的demo,没有对异常进行分类判断,只要发生
了读写异常,就关闭链路,释放资源。
异步非阻塞IO版本的时间服务器服务端已经介绍完毕,下面我们继续看客户端的实
现
2.4.2A|o创建的 Time Client源码分析
首先看下客户端主函数的实现。
代码清单2-15AIO时间服务器客户端 Timeclient
16
try t
17
port
Integer, valueof(args[o])i
18
y catch (Number FormatException e)
19
//采用默认值
20
21
22
new Thread(new AsyncTimeclientHandler("127.0.0.1", port),
51Nety权威指南(第2版l
23.
"AIO-AsyncTimeClientHandler-001)start()i
24
25
26.}
第22行通过一个独立的1/O线程创建异步时间服务器客户端 Handler在实际项目中,
我们不需要独立的线程创建异步连接对象,因为底层都是通过JDK的系统回调实现的,
在后面运行时间服务器程序的时候,我们会抓取线程调用堆栈给大家展示
继续看代码, Async TimeClientHandler的实现类源码如下。
代码清单2-16AIO时间服务器客户端 Async Time ClientHandler
1. package com. phei netty. aio;
3. import java. 10. IOException;
4. import java. io, UnsupportedEncodingExceptioni
5. import java. net. InetSocketAddress;
6. import java nio, ByteBufferi
7. import java nio channels, Asynchronous Socket channeli
8. import java nio channels. CompletionHandler
9. import java. util. concurrent. CountDownLatch;
10
11./*★
12,
@author Administrator
13,*date2014年2月16日
14
aversion 1.0
15
16. public class AsyncTimeClientHandler implements
17
CompletionHandler<void, AsyncTimeClientHandler>, Runnable i
18
19
private AsynchronousSocket Channel clienti
20
private String host;
21
private int porti
22.
private CountDownLatch latchi
23
24
public AsyncTimeclientHandler (string host, int port) i
25
this host= host
26.
this port porti
27
try i
28,
Client Asynchronous Socketchannel, open()i
29.
I catch (IOException e) i
52·第2章NO入门
30
e printstackTrace()i
31
32
33
34.
@Override
35. public void run() t
36
latch new Count DownLatch(1)i
37
client connect (new InetSocketAddress(host, port), this, this)i
38
try i
39
latch, await(
40
J catch (InterruptedException e1) t
41
el printstackTrace()i
42
43
try i
44
client. close()i
45
catch (IOException e) i
46
e printstackTrace()i
47
48
49
50
override
51
public void completed(Void result, AsyncTimeclientHandler
attachment) I
52
byte[] reg =QUERY TIME ORDER".getBytes()i
53
ByteBuffer writeBuffer ByteBuffer allocate(reg. length)i
54,
writeBuffer put(req)i
55,
writeBuffer. flip()i
56
client write(writeBuffer, writeBuffer,
57.
new CompletionHandler<Integer, ByteBuffer>() t
58
override
59
public void completed (Integer result, ByteBuffer buffer) i
60
if (buffer. hasRemaining())t
61
lient, write(buffe
buffer this)
62
t else
63
ByteBuffer readBuffer ByteBuffer allocate(1024)i
64
client, read(
65
readBuffer
66
readBuffer
67
new CompletionHandler<Integer, ByteBuffer>() I
68
override
69
public void completed(Integer result
·53·Net￥y权威指南(第2版)
70
ByteBuffer buffer) t
buffer. flip()i
72.
byte[] bytes new byte [buffer
73
remaining()]i
74,
buffer. get (bytes)i
75
String bodyi
tr
77
body new String (bytes,
78
"UTF-8");
79
System, out, printin(Now is
80
body )i
81
latch count Down();
82
s catch (UnsupportedEncodingException e)t
83
e printstackTrace()i
888
456
87
@override
88
public void failed( Throwable exc,
89
ByteBuffer attachment) f
9
try t
9
01
client, close(;
92
latch count Down();
93
1 catch (IOException e) t
94.
// ingnore on close
99
5
b
999
});
7890
0
101
override
102.
public void failed(Throwable exC, ByteBuffer attachment)i
1
1
00
34
try t
lient close(i
105,
latch, count Down()i
106
I catch (IOException e)[
107
/ ingnore on close
001
8
111
90
54·第2章NO入门
111
112
113.
override
114,
public void failed(Throwable exc, AsyncTimeClientHandler
attachment) t
115
exc, printstackTrace()
116
try t
117
client, close(i
118.
latch count Down ():
119
I catch (IOException e)f
120
e printstackTrace()i
121
122
123
由于在 Async Time ClientHandler中大量使用了内部匿名类,所以代码看起来稍微有些
复杂,下面我们就对主要代码进行详细讲解。
第24~32行是构造方法,首先通过 Asynchronous SocketChannel的open方法创建
个新的 Asynchronous SocketChannel对象。然后跳到第36行,创建 CountDownlatch进行
等待,防止异步操作没有执行完成线程就退出。第37行通过 connect方法发起异步操作,
它有两个参数,分别如下。
A attachment: Asynchronous Socket Channel的附件,用于回调通知时作为入参被
传递,调用者可以自定义
CompletionHandler<woid,? super A> handler:异步操作回调通知接口,由调用者实现。
在本例程中,这两个参数都使用 AsyncTimeClientHandler类木身,因为它实现了
CompletionHandler接口。
接下来我们看异步连接成功之后的方法回调— completed方法。代码第52行,我们
创建请求消息体,对其进行编码,然后复制到发送缓冲区 write Buffer中,调用 Asynchronous
Socketchannel的 write方法进行异步写。与服务端类似,我们可以实现 CompletionHandler
< nteger, Byte Buffer>接口用于写操作完成后的回调。代码第60~62行,如果发送缓冲区
中仍有尚未发送的字节,将继续异步发送,如果已经发送完成,则执行异步读取操作
代码第64~97行是客户端异步读取时间服务器服务端应答消息的处理逻辑。代码第
64行调用 Asynchronous Socket Channel的read方法异步读取服务端的响应消息。由于read
55Nety权威指南(第2版)
操作是异步的,所以我们通过内部匿名类实现 Completion handler< iNteger, Byte Buffer接
口,当读取完成被JDK回调时,构造应答消息。第71~78行从 Completion Handler的
ByteBuffer中读取应答消息,然后打印结果。
第102~111行,当读取发生异常时,关闭链路,同时调用 CountDownlatch的
count Down方法让 AsyncTime ClientHandler线程执行完毕,客户端退出执行。
需要指出的是,正如之前的NIO例程,我们并没有完整的处理网络的半包读写,在对
例程进行功能测试的时候没有问题。但是,如果对代码稍加改造,进行压力或者性能测试,
就会发现输出结果存在问题。
由于半包读写会作为专门的小节在Nety的应用和源码分析章节进行详细讲解,在NIO
的入门章节就不详细展开介绍了,以便读者能够将注意力集中在NIO的入门知识上来。
在下面的小节中我们会运行AIO版本的时间服务器程序,并通过打印线程堆栈的方式
看下JDK回调异步 Channel Completion Handler的调用情况。
2.4.3AO版本时间服务器运行结果
执行 Time server,运行结果如图2-15所示。
BFlm.6w4elm平sd日Cmsl8同圈x翻日
TimeServer)[ ava Appli on]E:1 rogan Fi1 savaii17.0451 banjar,ee4中2月17日下平1:0219)
The time server is start in port 8080
The time server receive order QUERY TIME ORDER
图2-15AO时间服务器服务端运行结果
执行 Timeclient,运行结果如图2-16所示。
rl,@ Javadoc, Declarati on A seur回 Cons ol.吗P
terminated> TimeC1ient②2)[ ava ApplicationI E: rogram Files\Java\ dk17045 binjai,ee(2014年2月17日下午11
NoT 13: Mon feb 17 23:02: 28 CST 2014
图2-16AIO时间服务器客户端运行结果
下面继续看下JDK异步回调 Completion Handler的线程执行堆栈。
56·第2章NO入门
AI0-AsyncTimeCli entHander-001pri0=6 ti d=0x16c64400 nid=0xa26 waiting on condi ti on [oxl719E000]
java. lang. Thread State: WAITIIG (parking
at sun mist. Unsafe park (Native Methodl
parking to wait for ( x06061b30> (a java, util. concurrent, CountDeanLatchSyne)
at java util eomeurrent. loeks, LockSupport park oclsupport, java. 186)
at java util concurrent locks. AbstractQueue sYnchronizer parkAndcheckInterrupt (AbstractQueuedsynchronizer Java: 834)
at java ut:l concurrent locks Abstractqeene asynchron ter doAcquireSharedinterrup ti bly (bstractqueuedSynchroni rer java. 994)
at jiva. util concurrent. locks. Abstractquene sYnchroni zer. acquireShar edInterruptibly (Abstractqueue rer java 1303)
at java atil. concurrent CountDoenLatch. await(Count DowrL atch j4*: 235)
at con phei. netty aio. AsyneTineCli enthamder run (AsyncTimeClientHander. java: 55)
at jwg lang Thr ead run(Thread java. T44)
Locked ownable sync
M数e
Thread-2 daemon prio=6 tid=Oxl 6c62000 ni d=0 +70 at breakpoint [Ox1714 f000)
Java lang Thread State: RUNNABLE
at com phei netty. aio. AsyncTimeClientHandlerfI completed (AsyncTimeClientHandler. jawa: 80)
at com phel netty ai o. AsyneTimeClientHandlers1 completed(AsyncTimeClient Handler java: 1)
at sun nio ch Invoker, invokeUncheeked (maker Java: 126
at sun nio ch Invoker. invokeUnchecked invoker 137a 269)
it sunnio. ch Windowshsynchr onoussocket ChannelImplsfritelask completed WfindowsAsynchr onou SocketChannelInpl java 815)
at sun nio. ch IocpsEventHandl Task run (ocp java 397)
at sun. nie, ch Asynchr onousCharnelGroupIaplsI. run (Asynchr onousCharnelGr oupIspl. jeva 112)
at Java util. concurrent, ThreadPoolExecutor runYorker ThreadPoolExecutor Java 1145)
at java util concurrent. ThresdPoolExeeutorSWorker rum CThresdFodl Ex. java 615)
图2-17AIO时间服务器异步回调线程堆栈
从“ Thread-2”线程堆栈中可以发现,JDK底层通过线程池 Thread Pooleκ ector来执
行回调通知,异步回调通知类由 sun. n1o.ch, Asynchronous ChannelGrouplmpl实现,它经过
层层调用,最终回调com. phei netty.aio. Async Time ClientHandler$1. completed方法,完成回
调通知。由此我们也可以得出结论:异步 Socket channel是被动执行对象,我们不需要像
NO编程那样创建一个独立的1O线程来处理读写操作。对于 Asynchronous Server Socket
Channel和 Asynchronous Socket Channel,它们都由JDK底层的线程池负责回调并驱动读写
操作。正因为如此,基于NⅠO2.0新的异步非阻塞 Channel进行编程比NIO编程更为简单。
本小节我们讲解了JDK1.7提供的新异步非阻塞IO(AIO)的用法,由于国内商用的
主流Java版本仍然是JDK1.6,因此,本小节不再详细介绍NO2.0其他新增的特性,如
果大家对NIO2.0的异步文件操作等特性感兴趣,可以选择阅读JDKL.7的相关书籍或者
查看甲骨文发布的JDK1.7白皮书。
下个小节我们对本章列举的各种IO进行概念澄清和比较,让大家从整体上掌握这些
IO模型的差异,以便在未来的工作中能够根据产品的实际情况选择合适的1O模型。
57Netty权威指南(第2版)
2.54种IO的对比
2.5.1概念澄清
为了防止由于对一些技术概念和术语的理解或者叫法不一致而引起歧义,本小节特意
对本书中的专业术语或者技术用语做下声明:如果它们与其他一些技术书籍的称呼不
致,请以本小节的解释为准。
1.异步非阻塞|O
很多人喜欢将JDK1.4提供的NO框架称为异步非阻塞IO,但是,如果严格按照UNIX
网络编程模型和JDK的实现进行区分,实际上它只能被称为非阻塞IO,不能叫异步非阻
塞ⅣO。在早期的JDK1.4和1.5 update0版本之前,JDK的 Selector基于 select/po模型
实现,它是基于LO复用技术的非阻塞IO,不是异步O。在JDK1.5 update0和 Linux
core2.6以上版本,sun优化了 Sector的实现,它在底层使用 epoll替换了 select/poll,上
层的API并没有变化,可以认为是 JDK NIO的一次性能优化,但是它仍旧没有改变IO
的模型。相关优化的官方说明如图2-18所示
changes in 1.5.0_10
The full internal version number for this update release is 1.5.0_10-b03(where"b"means"build")
The external version number is 5. ou10
support for epoll
The Linux downloads of this update release include an implementation of
avaniochannels. api. SelectorProvider that is based on the epoll 1o event notification facility. The
epoll facility is available in the Linux 2.6 kernel and is more scalable than the traditional poll system
call. This epoll-based implementation may improve the performance of server applications that use
the New O APl and that register hundreds of channels with a selector. For more information. refer to
ne epoll(4)and poll(2)man page
The epoll-based implementation of Selector Provider is not selected by default. To select it, specify a
property value from the command line as follows
Lava -Djava nio channels. spi. SelectorProvider=sun nio. ch. EPollselectorProvider
图2-18JDK1.5 update10支持epol
由JDK1.7提供的NO2.0新增了异步的套接字通道,它是真正的异步IO,在异步1O
操作的时候可以传递信号变量,当操作完成之后会回调相关的方法,异步1O也被称为AIO。
NIO类库支持非阻塞读和写操作,相比于之前的同步阻塞读和写,它是异步的,因此
很多人习惯于称NO为异步非阻塞ⅣO,包括很多介绍NO编程的书籍也沿用了这个说法
为了符合大家的习惯,本书也会将NIO称为异步非阻塞IO或者非阻塞IO,请大家理解,
不要过分纠结在一些技术术语的咬文嚼字上。
58第2章NO入门
2.多路复用器 Selector
几乎所有的中文技术书籍都将 Selector翻译为选择器,但是实际上我认为这样的翻译
并不恰当,选择器仅仅是字面上的意思,体现不出 Selector的功能和特点。
在前面的章节我们介绍过 Java Nio的实现关键是多路复用IAO技术,多路复用的核心
就是通过 Selector来轮询注册在其上的 Channel,当发现某个或者多个 Channel处于就绪状
态后,从阻塞状态返回就绪的 Channel的选择键集合,进行IO操作。由于多路复用器是
NIO实现非阻塞IO的关键,它又是主要通过 Selector实现的,所以本书将 Selector翻译
为多路复用器,与其他技术书籍所说的选择器是同一个东西,请大家了解。
3.伪异步O
伪异步IO的概念完全来源于实践。在⑩DKNO编程没有流行之前,为了解决 Tomcat
通信线程同步IO导致业务线程被挂住的问题,大家想到了一个办法:在通信线程和业务
线程之间做个缓冲区,这个缓冲区用于隔离IO线程和业务线程间的直接访问,这样业务
线程就不会被lO线程阻塞。而对于后端的业务侧来说,将消息或者Task放到线程池后就
返回了,它不再直接访问IO线程或者进行IO读写,这样也就不会被同步阻塞。类似的
设计还包括前端启动一组线程,将接收的客户端封装成Task,放到后端的线程池执行,用
于解决一连接一线程问题。像这样通过线程池做缓冲区的做法,本书中习惯于称它为伪异
步IO,而官方并没有伪异步IO这种说法,请大家注意。
下面的小节我们对几种常见的I/O进行对比,以便大家能够理解它们的差异。
2.5.2不同ⅣO模型对比
不同的IO模型由于线程模型、API等差别很大,所以用法的差异也非常大。由于之
前的几个小节已经集中对这几种1O的APⅠ和用法进行了说明,本小节会重点对它们进行
功能对比。如表2-1所示。
表2-1几种DO模型的功能和特性对比
同步阻塞l(B|Q)
伪异步|O
非阻塞o(NO)
异步|O(A|O)
M:N(其中M可M:1(1个LO线程处理M20(不需要启动额外
客户端个数:1O线程1:1
以大于N)
多个客户端连接
的IO线程,被动回调)
O类型(阻塞)
阻塞O
阻塞O
非阻塞O
非阻塞I/O
·59·Netty权威指南「第2版)
续表
同步阻塞o(BO)
伪异步o
非阻塞|O(No)
异步|o(A|O)
O类型(同步
同步1O
同步LO
同步LO(O多路复用)异步1
API使用难度
简单
简单
非常复杂
复杂
调试难度
简单
简单
复杂
复杂
叮靠性
非常差
差
高
高
吞吐量
低
高
高
尽管本书是专门介绍NO框架Nety的,但是,并不意味着所有的Java网络编程都
必须要选择NIO和 Netty,具体选择什么样的IO模型或者NO框架,完全基于业务的实
际应用场景和性能诉求,如果客户端并发连接数不多,周边对接的网元不多,服务器的负
载也不重,那就完全没必要选择NIO做服务端;如果是相反情况,那就要考虑选择合适的
NIO框架进行开发。
对比完Java的几种主流I/O模型之后,我们继续看下为什么要选择Ne!进行NIO开
发,而不是直接使用JDK的N1O原生类库。
2.6选择 Netty的理由
在开始本节之前,我先讲一个亲身经历的故事:曾经有两个项目组同时用到了NIO编
程技术,一个项目组选择自己开发NIO服务端,直接使用JDK原生的API,结果两个多
月过去了,他们的NIO服务端始终无法稳定,问题频出。由于NIO通信是它们的核心组
件之一,因此项目的进度受到了严重的影响。另一个项目组直接使用Nety作为NO服务
端,业务的定制开发工作量非常小,测试表明,功能和性能都完全达标,项目组几乎没有
在NO服务端上花费额外的时间和精力,项目进展也非常顺利。
这两个项目组的不同遭遇告诉我们:开发出高质量的NO程序并不是一件简单的事
情,除去NO固有的复杂性和BUG不谈,作为一个NIO服务端,需要能够处理网络的闪
断、客户端的重复接入、客户端的安全认证、消息的编解码、半包读写等情况,如果你没
有足够的NIO编程经验积累,一个NIO框架的稳定往往需要半年甚至更长的时间。更为
槽糕的是,一旦在生产环境中发生问题,往往会导致跨节点的服务调用中断,严重的可能
会导致整个集群环境都不可用,需要重启服务器,这种非正常停机会带来巨大的损失。
从可维护性角度看,由于NO采用了异步非阻塞编程模型,而且是一个IO线程处理
60第2章N|O入门
多条链路,它的调试和跟踪非常麻烦,特别是生产环境中的问题,我们无法进行有效的调
试和跟踪,往往只能靠一些日志来辅助分析,定位难度很大。
2.6.1不选择Java原生N|o编程的原因
现在我们总结一下为什么不建议开发者直接使用JDK的NIO类库进行开发,具体原
因如下。
(1)NIO的类库和API繁杂,使用麻烦,你需要熟练掌握 Selector、 ServerSocketchannel、
Socketchannel、 Byte Buffer等
2)需要貝备其他的额外技能做铺垫,例如熟悉Java多线程编程。这是因为NO编程涉
及到 Reactor模式,你必须对多线程和网路编程非常熟悉,才能编写出高质量的NIO程序。
3)可靠性能力补齐,工作量和难度都非常大。例如客户端面临断连重连、网络闪断
半包读写、失败缓存、网络拥塞和异常码流的处理等问题,NO编程的特点是功能开发相
对容易,但是可靠性能力补齐的工作量和难度都非常大
(4) IDK NIO的BUG,例如臭名昭著的 epoll bug,它会导致 Selector空轮询,最终导
致CPU100%。官方声称在JDK1.6版本的 update I8修复了该问题,但是直到JDK17版
本该问题仍旧存在,只不过该BUG发生概率降低了一些而已,它并没有得到根本性解决。
该BUG以及与该BUG相关的问题单可以参见以下链接内容。
http://bugs.java.com/bugdatabase/viewbugdo?bugid=6403933
ohttp://bugs.java.com/bugdatabase/viewbug.do?bugid=2147719
异常堆栈如下。
java. lang Thread State: RUNNABLE
at sun nio ch. EPoIlArraywrapper epoliwait(Native Method)
at sun nio ch. EPoIlArrayWrapper Poll(EPoIlArrayWrapper java: 210)
at sun nio, ch, EPoLLSelectorlmpl, do select(EpoIlselectorImpl java: 65)
at sun nio ch. SelectorImpl lockAndDoSelect(SelectorImpl java: 69)
1 ocked<0x0000000750928190>(asun.nio.ch.Uti152)
locked <0x00000007509281a8>(a java, util. Collectionss
Unmodifiableset)
locked <0x0000000750946098>(a sun, nio, ch. EPollSelectorImpl
at sun nio ch. SelectorImpI, select(SelectorImpI java: 80)
61Netty权威指南(第2版)
net spy. memcached. MemcachedConnection. handleIo(Memcached
Connection. java: 217)
at net, spy. memcached. Memcachedconnection, run (Memcachedconnection
Java: 836)
由于上述原因,在大多数场景下,不建议大家直接使用JDK的NIO类库,除非你精
通NO编程或者有特殊的需求。在绝大多数的业务场景中,我们可以使用NIO框架Nety
来进行NIO编程,它既可以作为客户端也可以作为服务端,同时支持UDP和异步文件传
输,功能非常强大
下个小节我们就看看为什么选择Net!y作为基础通信框架。
2.6.2为什么选择 Netty
Net!y是业界最流行的NIO框架之一,它的健壮性、功能、性能、可定制性和可扩展
性在同类框架中都是首屈一指的,它已经得到成百上千的商用项目验证,例如 Hadoop的
RPC框架Avro就使用了Nety作为底层通信框架,其他还有业界主流的RPC框架,也使
用 Netty来构建高性能的异步通信能力。
通过对 Netty的分析,我们将它的优点总结如下。
◎API使用简单,开发门槛低
⑧功能强大,预置了多种编解码功能,支持多种主流协议;
◎定制能力强,可以通过 Channelhandler对通信框架进行灵活地扩展;
◎性能高,通过与其他业界主流的NO框架对比, Netty的综合性能最优
◎成熟、稳定, Netty修复了已经发现的所有 JDK NIO BUG,业务开发人员不需要
再为NIO的BUG而烦恼;
社区活跃,版本迭代周期短,发现的BUG可以被及时修复,同时,更多的新功
能会加入
◎经历了大规模的商业应用考验,质量得到验证。Net!y在互联网、大数据、网络
游戏、企业应用、电信软件等众多行业已经得到了成功商用,证明它已经完全能
够满足不同行业的商业应用了
正是因为这些优点,Net!逐渐成为了 Java NIO编程的首选框架
62第2章N|O入门
27总结
本章通过一个简单的demo开发,即时间服务器程序,让大家熟悉传统的同步阻塞l/O、
伪异步IO、非阻塞IO(NO)和异步IO(AIO)的编程和使用差异,然后对比了各自
的优缺点,并给出了使用建议。
最后,我们详细介绍了为什么不建议读者朋友们直接使用JDK的NIO原生类库进行
异步IO的开发,同时对 Netty的优点进行分析和总结,给出使用Nety进行NO开发的
理由
相信学完本章之后,大家对Java的网络编程已经有了初步的认识,从下一个章节开
始,我们正式进入Nett的世界,学习基于 Netty的网络开发。
63入门篇
Netty nio开发指南
第3章Nety入门应用
第4章TCP粘包/拆包问题的解决之道
第5章分隔符和定长解码器的应用第3章
Nety门应用
作为Nety的第一个应用程序,我们依然以第2章的时间服务器为例进行开发,通过
Ney版本的时间服务器的开发,让初学者尽快学到如何搭建Net!y开发环境和运行Nety
应用程序。
如果你已经熟悉 Netty的基础应用,可以跳过本章,继续后面知识的学习。
本章主要内容包括
◎Net!y开发环境的搭建
◎服务端程序 Time server开发
◎客户端程序 Time client开发
时间服务器的运行和调试
3.1 Netty开发环境的搭建
首先假设你已经在本机安装了JDK1.7,配置了JDK的环境变量path,同时下载并正
确启动了1DE工具 Eclipse。如果你是个Java初学者,从来没有在本机搭建过Java开发环
境,建议你先选择一本Java基础入门的书籍或者课程进行学习。第3章Ney入门应用
假如你习惯于使用其他IDE工具进行Java开发,例如 Net Beans IDE,也可以运行本
节的入门例程。但是,你需要根据自己实际使用的IDE进行对应的配置修改和调整,本书
统一使用 eclipse-jee- kepler-SRI-win32作为Java开发工具。
下面我们开始学习如何搭建Net!y的开发环境。
31.1下载Nett的软件包
访问Ney的官网ht: netty.10,从【 Downloads】标签页选择下载50.0. Alpha1安装
包,安装包不大,8.95MB左右,下载之后的安装包如图3-1所示。
0
大小
上y50PAb
17成A压只伸2014-14205
图3-1Nety5.0压缩包
通过解压缩工具打开压缩包,目录如图3-2所示
2国netr5.0. Alphal tar bra2lntr500. Alphal \yar-TABr压缩文件,解包大小为10.20.769字节
大小压后大小英型
Dall-arana
许高
LHnattybuffer-50 0Alphal.jMe
154.950
曰tab1*J2013-1222
Lfrnattybuffar.0. 0. AIpbal-seuresl Jur
L00.234
工G回上1着Jar
如013-12-2
fnettrcodee-5, 0.0 Alphal, ju
41,
ec1丁2013-12-22
fn nettrcodec 5.0.0. Alphal-sowcesjs
12,7
7Eb着Jar
013-1222
yE一战.0.0.Aph.j
JH4-04
i Lieut able ar
2013=12=22
anettrendeehttp-5.0.0.aphat-woureasj
30,4
hJar2013-12-22
Nnettresdec-sackr-5.. 0. Alphal Ju
47. 06T
Executable ar 2013-12-22
fnettyeadee-sockr-5.0, 0. Alpha]+s, jar
29.g8
Execu山k1*Jar
2013-12-22
nettyeamser5.0.0.Alphat.jar
Execut able Jar 2013-12-27
已amn500.p-me
247M6
7 Executable Jar 2013-12-22
Lmttysmplr5. 0,0, Alphat.jar
30.?
201-12-2
B!-p1450.0.Aph!-1m
190.68
?utah1Jar2013-12-2
nittyhahder-5.0.0. Alphal. jar
74.
g Executable Tar
2013-12-2
netty hander500.p“j
53.11
7 Executable jar
013-12-2
Einettytranspsrt-5.0, 0, Alphal. jar
30592
Executable Tar. 2013-12-22
面 Mttytramspert5.0.0.phl的 rest.ar
220,498
2 Execut able Jar
013-122
t!rU印矿tTtx5.0.0.p品a!j4
1T.239
Execut able ar 2013-12-22
Fatty transport 00. Alphal"seurces, ju
.1T8
7 ExecutabLe Jar
如013=122
Feaatty-tr anspert-stp-5.0.0. Alphal jur
44.130
Executable Ju
20l3-12-22
Henettrtranspart-setr-50,0,Alphsl-seureesjar
43,14A
Executable a. 2013-12-22
icaattrtanrpartudt-5.0.0.Alphaljar
3250
7王 cuiaba和Ja201312-22
daxttrtruapsrt-udt-5.0.0.Alpbal-apuresaju
Executable Je
2013-1-22
图3-2Nety5.0压缩包内部目录
这时会发现里面包含了各个模块的jar包和源码,由于我们直接以二进制类库的方式
使用 Netty,所以只需要获取net!y-ll5.0.0. Alphal.jar即可。
3.1.2搭建 Netty应用工程
使用 Eclipse创建普通的Java工程,同时创建Java源文件的 package,如图3-3所示。
67Netty权威指南(第2版
由
由申由由田
H= JRE Systen Library [dl 7 0 451
图3-3 Netty应用工程
创建第三方类厍存放文件夹lib,同时将nety-al-.0.0. Alphal. jar复制到lib目录下,
如图3-4所示
H book
sr己
由ca.phe.aety
国 JRE System Library [dk70.45
d] nettyall-5.0: 0. Alphal.jar
图3-4配置引用的 Netty Jar包
右键单击 netty-ll-0.0. Alphal. jar,在弹出的菜单中,选择将jar包添加到 Build Path
中,操作如图3-5所示
Ha Copy qualified Nne
Cirl
e】ete
Delete
Semena tro center
1+a11+5h:f+1oa
日 arE n Tanoak
CirlTAlt: EtTi
Fuild Fath
回 Add te Build Path
Re factor
Alt+Shift+T
超 Configure Build Path
a Import
play at this time
图3-5将 Netty Jar包添加到 ClassPath中
到此,Nety应用开发环境已经搭建完成,下面的小节将演示如何基于 Netty开发时间
服务器程序
3.2Nety服务端开发
作为第一个 Netty的应用例程,为了让读者能够将精力集中在 Netty的使用上,我们
68第3章Nety入门应用
依然以第2章的时间服务器为例进行源码开发和代码讲解。
在开始使用Nety开发 Time server之前,先回顾一下使用NO进行服务端开发的步骤。
(1)创建 Server SocketChannel,配置它为非阻塞模式;
(2)绑定监听,配置TCP参数,例如 backlog大小;
(3)创建一个独立的1O线程,用于轮询多路复用器 Selector
(4)创建 Selector,将之前创建的 Server Socketchannel注册到 Selector上,监听
SelectionKey. ACCEPT
(5)启动IO线程,在循环体中执行 Selector. select()方法,轮询就绪的 Channel
6)当轮询到了处于就绪状态的 Channel时,需要对其进行判断,如果是 OP ACCEPT
状态,说明是新的客户端接入,则调用 Server Socketchannel. accept(方法接受新的客户端
7)设置新接入的客户端链路 Socketchannel为非阻塞模式,配置其他的一些TCP参数
(8)将 Socketchannel注册到 Selector,监听 OP READ操作位;
(9)如果轮询的 Channel为 OP READ,则说明 SocketChannel中有新的就绪的数据包
需要读取,则构造 Byte Buffer对象,读取数据包
(10)如果轮询的 Channel为 OP WRITE,说明还有数据没有发送完成,需要继续发送。
个简单的NO服务端程序,如果我们直接使用JDK的NIO类库进行开发,竟然需
要绎过烦琐的十多步操作才能完成最基本的消息读取和发送,这也是我们要选择 Netty等
NO框架的原因了,下面我们看看使用Net!y是如何轻松搞定服务端开发的。
代码清单3-1Nety时间服务器服务端 Timeserver
16. public class Time Server t
17
18.
public void bind(int port) throws Exception i
19
//配置服务端的NIo线程组
20
EventLoopGroup bossGroup- new NioEventLoopGroup()i
21
EventLoopGroup workerGroup new NioEventloopGroup ()
22
try
23
ServerBootstrap b= new ServerBootstrap(
24
b group(bossGroup, workerGroup)
25
channel(NioserverSocket Channel class)
option(ChannelOption. SO BACKLOG, 1024)
69·Ne!权威指南〔第2版)
27
childHandler (new Chilachannelhandler()i
28
/绑定端口,同步等待成功
29
ChannelFuture f= bbind(port). sync ()i
30
/等待服务端监听端口关闭
32
f channel().closeFuture(). sync ()i
33
finally i
34
//优雅退出,释放线程池资源
bossGroup. shutdownGracefully(i
36,
workerGroup, shutdownGracefully()i
37
38
39
40,
private class ChildchannelHandler extends ChannelInitializer
<Socketchannel> f
41
@override
42
protected void initchannel (Socket Channel argo) throws Exception
43
argo. pipeline(). addLast(new Time ServerHandler())i
44
45
46,
47
48
49
k param args
50
throws Exception
51
52.
public static void main(String [ args)throws Exception i
53
int port =80807
54
if (args ! null & args length >0) I
55
try t
56.
port Integer valueOf (args[01);
57
g catch (NumberFormatException e)
58,
//采用默认值
59
60
61,
new Time Server().bind(port)i
62.
63
由于本章的重点是讲解Nety的应用开发,所以对于一些Nety的类库和用法仅仅做
基础性的讲解,我们从黑盒的角度理解这些概念即可。后续源码分析章节会专门对Nety
·70第3章 Netty入门应用
核心的类库和功能进行分析,感兴趣的同学可以跳到源码分析章节进行后续的学习
我们从bind方法开始学习,在代码第20~21行创建了两个 NioEvent Loop Group实例
NioEvent Loop Group是个线程组,它包含了一组NIO线程,专门用于网络事件的处理,实
际上它们就是 Reactor线程组。这里创建两个的原因是一个用于服务端接受客户端的连接,
另一个用于进行 Socketchanne的网络读写。第23行创建 Server bootstrap对象,它是Nety
用于启动NIO服务端的辅助启动类,目的是降低服务端的开发复杂度。第24行调用
Server Bootstrap的 group方法,将两个NO线程组当作入参传递到 Server Bootstrap中。接
着设置创建的 Channel为 NioServer SocketChannel,它的功能对应于 JDK NIO类库中的
ServerSocketchannel类。然后配置 NioServer Socketchannel的TCP参数,此处将它的 backlog
设置为1024,最后绑定IO事件的处理类 Childchannelhandler,它的作用类似于 Reactor
模式中的 Handler类,主要用于处理网络l○事件,例如记录日志、对消息进行编解码等。
服务端启动辅助类配置完成之后,调用它的bind方法绑定监听端口,随后,调用它
的同步阻塞方法syne等待绑定操作完成。完成之后 Netty会返回一个 Channelfuture,它
的功能类似于JDK的 javautil. concurrent. Future,主要用于异步操作的通知回调。
第32行使用 f channel(. close future(. synco方法进行阻塞,等待服务端链路关闭之后
main函数才退出。
第34~36行调用NIO线程组的 shutdown Gracefully进行优雅退出,它会释放跟
shutdownGracefully相关联的资源。
下面看看 Time Serverhandler类是如何实现的
代码清单3-2Nety时间服务器服务端 TimeServerHandler
12. public class TimeServerHandler extends ChannelHandlerAdapter i
13
14
oVerride
15
public void channelRead (ChannelHandlerContext ctx, Object msg)
16
throws Exception I
17
ByteBuf buf =(ByteBuf) msgi
18
byte[] reg= new byte [buf. readableBytes()]i
19
buf readBytes(reg)i
20
String body= new String (req, UTF-8")
21
System.out.printin("The time server receive order body)i
22
String currentTime="QUERY TIME ORDER".equalsIgnoreCase(body ) new
java. util. Date(
23
System currentTimeMillis()). tostring():BAD ORDER"i
71·Ney权威指南(第2版)
24
ByteBuf resp Unpooled copiedBuffer(currentTime, getBytes())i
25
ctx. write (resp)i
26
27
28,
oVerride
29
public void channelReadComplete( ChannelHandlerContext ctx) throws
Exception I
30.
ctx. flush();
31,
32,
33.
OVerride
34
public void exceptionCaught( ChannelHandlerContext ctx, Throwable
cause) I
35
ctx. close()i
36
37.
Time Server Handler继承自 ChannelHandlerAdapter,它用于对网络事件进行读写操作,
通常我们只需要关注 channelled和 exceptionCaught方法。下面对这两个方法进行简单说明。
第17行做类型转换,将msg转换成Nety的 Byte Buf对象。 ByteBuf类似于JDK中的
Java. no. Byte Buffer对象,不过它提供了更加强大和灵活的功能。通过 ByteBuf的
readableBytes方法可以获取缓冲区可读的字节数,根据可读的字节数创建bye数组,通过
Byte Buf的 read Bytes方法将缓冲区中的宇节数组复制到新建的byte数组中,最后通过new
String构造函数获取请求消息。这时对请求消息进行判断,如果是" QUERY TIME ORDER"
则创建应答消息,通过 Channelhandlercontext的 write方法异步发送应答消息给客户端。
第30行我们发现还调用了 ChannelHandlerContext的fush方法,它的作用是将消息
发送队列中的消息写入到 Socketchannel中发送给对方。从性能角度考虑,为了防止频繁
地唤醒 Selector进行消息发送,Nety的wrie方法并不直接将消息写入 Socketchannel中,
调用 write方法只是把待发送的消息放到发送缓冲数组中,再通过调用nush方法,将发送
缓冲区中的消息全部写到 SocketChannel中。
第35行,当发生异常时,关闭 Channelhandlercontext,释放和 ChannelhandlerContext
相关联的句柄等资源
通过对代码进行统计分析可以看出,不到30行的业务逻辑代码,即完成了NIO服务
端的开发,相比于传统基于 JDK NIO原生类库的服务端,代码量大大减少,开发难度也
降低了很多。
·72·第3章Nety入门应用
下面我们继续学习客户端的开发,并使用Net!改造 Time Client.
3.3 Netty客户端开发
Nety客户端的开发相比于脹务端更简单,下面我们就看卜客户端的代码如何实现。
代码清单3-3 Netty时间服务器客户端 Timeclient
16. public class TimeClient t
17
public void connect (int port, String host) throws Exception i
19
/配置客户端MIo线程组
20
EventLoopGroup group new NioEventLoopGroup()i
21
try
22.
Bootstrap b= new Bootstrap()i
23
b group(group). channel(NioSocketchannel class
24
option(ChannelOption TCP NODELAY, true)
25.
handler (new ChannelInitializerssocketchannel>()
26,
override
27
public void initchannel(Socketchannel ch)
28
throws Exception i
29,
ch pipeline(). addLast (new TimeClientHandler())i
30
31
});
32
33
//发起异步连接操作
34,
Channelfuture f= b connect (host, port). sync(;
35
36
/等待客户端链路关闭
37
f, channel(), closeFuture(). sync ()i
38
I finally 1
39
//优雅退出,释放NI线程组
40
group. shutdownGracefully()i
41
42,
43
44
45
param args
46,
throws Exception
47
73·Netty权威指南(第2版)
48. public static void main(String[l args) throws Exception
49.
int port =8080;
50.
if (args .=null & args length >0)
51
try i
52,
port Integer, valueof(args[o])i
53
I catch (Number FormatException e)
54
//采用默认值
55
56
57
new TimeClient(). connect(portr12700.1")i
58
59.}
我们从 connect方法讲起,在第20行首先创建客户端处理IO读写的 NioEventLoop
Group线程组,然后继续创建客户端辅助启动类 Bootstrap,随后需要对其进行配置。与服
务端不同的是,它的 Channel需要设置为 NioSocketchannel,然后为其添加 Handler。此处
为了简单直接创建匿名内部类,实现 init channel方法,其作用是当创建 NioSocketchannel
成功之后,在进行初始化时,将它的 Channelhandler设置到 ChannelPipeline中,用于处理
网络IO事件
客户端启动辅助类设置完成之后,调用 connect方法发起异步连接,然后调用同步方
法等待连接成功。
最后,当客户端连接关闭之后,客户端主函数退出,退出之前释放NIO线程组的资源。
下面我们继续看 Time Clienthandler的代码如何实现。
代码清单3-4Nety时间服务器客户端 Time Clienthandler
14. public class TimeclientHandler extends ChannelHandlerAdapter f
15
16
private static final Logger logger= Logger
17
getLogger(TimeclientHandler class getName());
18
19
private final ByteBuf firstMessage;
20
21
22
Creates a client-side handler
23
24
public TimeClientHandler () t
25
byte [] req -"QUERY TIME ORDER", getBytes()i
26
firstMessage Unpooled buffer(reg.length)i
·74·第3章 Netty入门应用
27,
firstMessage, writeBytes(reg)i
28
30.
31
OVerride
32
public void channelActive( ChannelHandlerContext ctx) I
33
ctx. writeAndFlush(firstMessage)i
34
35
36
OVerride
37
public void channelRead(ChannelHandlerContext ctx, Object msg)
38,
throws Exception I
39,
ByteBuf buf =(ByteBuf)msg;
40
byte[ reg= new byte [buf. readableBytes ()]i
buf. readBytes(req)氵
42
String body new String(reg, " UTE-8"):
43
System, out, println(Now is : body )i
44,
45
46
override
47
public void exceptionCaught( ChannelHandlerContext ctx, Throwable
cause)
48
//释放资源
49
logger, warning( "Unexpected exception from downstream:
50
cause, getMessage())i
51,
ctx. close()i
52
53.
这里重点关注三个方法: channelactive、 channelread和 exception Caught。当客户端
和服务端TCP链路建立成功之后, Netty的NIO线程会调用 channelActive方法,发送查
询时间的指令给服务端,调用 ChannelhandlerContext的 write AndFlush方法将请求消息发
送给服务端。
当服务端返回应答消息时, channelread方法被调用,第39~43行从Nett的 ByteBuf
中读取并打印应答消息。
第47~52行,当发生异常时,打印异常日志,释放客户端资源。
75Nety权威指南(第2版)
34运行和调试
3.4.1服务端和客户端的运行
在 Eclipse开发环境中运行和调试Java程序非常简单,下面我们看下如何运行 Time server
将光标定位到 Time Server类中,单击右键,在弹出菜单中选择 Run as→ Java Application
或者直接使用快捷键AIt+ Shift+X执行,如图3-6所示。
TimC1主a是,v
D Timeserver java 23 TimacliantHandlaryjsvu
beek{·sep母em,ph. netty. basi+@ TimeServer P
曲二epom
s ur.
Ctx⊥+2
usart t1⊥a
1。 EvantLOoPGroup()
工+
NoEveneLoopGroup c)=
口peD1axt盖om
些上日口口E上P()
Open Type Hi er archy
Fa
1卫)
Opan call Hierarehy
ekeeChanre⊥-⊥a
42
Shew in Bresderwm b
Ali+sh fi+H
n.s。丑 a cOg,1D24
日 all ck outline
匚t1-口
⊥ dc Hanne lanc⊥e(3
口 rke Typ b1 Parch工-T
Oam曾⊥上
上置工重
真1,4上重E+W
RsEV
IHEI+h
C。P￥日uLE1AN“m
C,r1+矿
a Fotl.a
上型t
E FreuT Is
Timeserver
Hui ck FEs
Ctrl+t
TD4bn'i·vm,+x·四014年2月19日下年4
T直ee⊥m吧
真1t+ Shi ftts
DER
且巴土心上
真1+S上直Et鲁士
R玉扩当熟已告雪
Deelarati ons
Ad4t。Sn1FFat,,
卫←b≤
a L Tava Applicatior
Att上主E十x
ymdm无
Rum Cen,xu七你s
图3-6运行 Time Server
客户端的执行类似,可以看到以下执行结果
服务端运行结果如图3-7所示。
H Problens a Javadoc B, Declaration 4 Search B Console x-8 Promess B* ael
TimeServer(4)[ Tava Application]E: Progrsm Fi1 es java\4kl1.7.0451 binjavaw.exe②2014年2月19日下午4:52:45)
The time server receive order QUERY TIHE ORDER
图3-7 Time Server运行结果
客户端运行结果如图3-8所示。
76·第3章 Netty入门应用
R Problems Javadoc e
Deelaration
今suh日cosa2=r
r器es
算四日
TimeLiest03)[ Java Application]E:' ogra FI1 esta4jdk1.7.0.451 binjai",exe(2014年2月19日下午8:27:24)
Now i3: Wed Feb 19 20:27:25 CsT 2014
图3-8 TimeClient运行结果
运行结果正确。可以发现,通过Net!开发的NIO服务端和客户端非常简单,短短几
卜行代码,就能完成之前NIO程序需要几百行才能完成的功能。基于 Netty的应用开发不
但APⅠ使用简单、开发模式固定,而且扩展性和定制性非常好,后面,我们会通过更多应
用来介绍Nett的强大功能。
需要指出的是,本例程依然没有考虑读半包的处理,对于功能演示或者测试,上述程
序没有冋题,但是稍加改造进行性能或者压力测试,它就不能正确地工作了。在下一个章
节我们会给出能够正确处理半包消息的应用实例。
34.2打包和部署
基于 Netty开发的都是非web的Java应用,它的打包形态非常简单,就是一个普
通的jar包,通常情况下,在正式的商业开发中,我们会使用三种打包方式。
(1) Eclipse提供的导出功能。它可以将指定的Java工程或者源码包、代码输岀成指
定的jar包,它属于手工操作,在项目模块较多时非常不方便,所以一般不使用这种方式;
(2)使用ant脚本对工程进行打包。将Net的应用程序打包成指定的jar包,一般会
输出一个软件安装包: xxxx install. gz
(3)使用 Maven进行工程构建。它可以对模块间的依赖进行管理,支持版本的自动化
测试、编译和构建,是目前主流的项目管理工具。
35总结
本章节讲解了Nety的入门应用,通过使用Nety重构时间服务器程序,可以发现相
比于传统的NIO程序,Net!y的代码更加简洁、开发难度更低,扩展性也更好,非常适合
作为基础通信框架被用户集成和使用
77Net!y权威指南(第2版
在介绍Nety服务端和客户端时,简单地对代码进行了讲解,由于后续会有专门章节
对Nety进行源码分析,所以在Nety应用部分我们不进行详细的源码解读和分析。
第4章会讲解一个稍微复杂的应用,它利用Nety提供的默认编解码功能解决了之前
没有解决的读半包问题。事实上,对于读半包问题,Nety提供了很多种好的解决方案。
下面一起学习一下如何利用Net!y默认的编解码功能解决半包读取问题。
·78第4章
TCP粘包/拆包问题的解决之道
熟悉TCP编程的读者可能都知道,无论是服务端还是客户端,当我们读取或者发送
消息的时候,都需要考虑TCP底层的粘包/拆包机制。本章开始我们先简单介绍TCP粘包
/拆包的基础知识,然后模拟一个没有考虑TCP粘包/拆包导致功能异常的案例,最后,通
过正确例程来探讨 Netty是如何解决这个问题的。
如果你已经熟悉了TCP粘包和拆包的相关知识,建议直接跳到代码讲解小节,看Nety
是如何解决这个问题的。
本章主要内容包括:
◎TCP粘包拆包的基础知识
◎没考虑TCP粘包/拆包的问题案例
使用Nety解决读半包问题
4.1TCP粘包/拆包
TCP是个“流”协议,所谓流,就是没有界限的一串数据。大家可以想想河里的流水,
它们是连成一片的,其间并没有分界线。TCP底层并不了解上层业务数据的具体含义,它
会根据TCP缓冲区的实际情况进行包的划分,所以在业务上认为,一个完整的包可能会Net!y权威指南(第2版)
被TCP拆分成多个包进行发送,也有可能把多个小的包封装成一个大的数据包发送,这
就是所谓的TCP粘包和拆包问题。
4.1.1TCP粘包/拆包问题说明
我们可以通过图解对TCP粘包和拆包问题进行说明,粘包问题示例如图4-1所示。
Client
Server
D2
DI
D2
DI
D22
D21
DI
D2D12
DII
图4-lTCP粘包/拆包问题
假设客户端分别发送了两个数据包D1和D2给服务端,由于服务端一次读取到的字
节数是不确定的,故可能存在以下4种情况。
(1)服务端分两次读取到了两个独立的数据包,分别是D1和D2,没有粘包和拆包
(2)服务端一次接收到了两个数据包,D1和D2粘合在一起,被称为TCP粘包;
(3)服务端分两次读取到了两个数据包,第一次读取到了完整的DI包和D2包的部
分内容,第二次读取到了D2包的剩余内容,这被称为TCP拆包;
(4)服务端分两次读取到了两个数据包,第一次读取到了D1包的部分内容D11,第
二次读取到了DI包的剩余内容D2和D2包的整包。
如果此时服务端TCP接收滑窗非常小,而数据包Dl和D2比较大,很有可能会发生
第5种可能,即服务端分多次才能将D1和D2包接收完全,期间发生多次拆包。
4.1.2TCP粘包/拆包发生的原因
问题产生的原因有三个,分别如下。
80·第4章TCP粘包/拆包问题的解决之道
(1)应用程序 write写入的字节大小大于套接口发送缓冲区大小;
(2)进行MSS大小的TCP分段;
(3)以太网帧的 payload大于MTU进行IP分片。
图解如图4-2所示。
应用进程
应用进程缓冲区(任意大小)
write
用户进程
TCP
套接口发送缓冲区( SO SNDBUF)内核
MMS大小的TCP分节
通常MSS≤MTU-40(P4)或MTU60(Pv6)
MTU大小的Pv4或Pv6分组
匚输出队列
数据链路
图4-2TCP粘包/拆包问题原因
4.1.3粘包问题的解决策略
由于底层的TCP无法理解上层的业务数据,所以在底层是无法保证数据包不被拆分
和重组的,这个问题只能通过上层的应用协议栈设计来解决,根据业界的主流协议的解决
方案,可以归纳如下。
(1)消息定长,例如每个报文的大小为固定长度200字节,如果不够,空位补空格
(2)在包尾增加回车换行符进行分割,例如FTP协议;
(3)将消息分为消息头和消息体,消息头中包含表示消息总长度(或者消息体长度)
的字段,通常设计思路为消息头的第一个字段使用int32来表示消息的总长度;
(4)更复杂的应用层协议。
介绍完了TCP粘包/拆包的基础知识,下面我们就通过实际例程来看看如何使用 Netty
提供的半包解码器来解决TCP粘包/拆包问题。
81·Net!y权威指南(第2版)
4.2未考虑TCP粘包导致功能异常案例
在前面的时间服务器例程中,我们多次强调并没有考虑读半包问题,这在功能测试时
往往没有问题,但是一旦压力上来,或者发送大报文之后,就会存在粘包/拆包问题。如
果代码没有考虑,往往就会岀现解码错位或者错误,导致程序不能正常工作。下面我们以
3.节的代码为例,模拟故障场景,然后看看如何正确使用Nety的半包解码器来解决TCP
粘包拆包问题。
4.2.1 Time server的改造
代码清单4-1Nety时间服务器服务端 Time Serverhandler
12. public class Time ServerHandler extends ChannelHandlerAdapter
13.
14
private int counter;
15,
16
OVerride
17
public void channelRead (ChannelHandler Context ctx, Object msg)
18.
throws Exception i
19. ByteBuf buf =(ByteBuf) msgi
20. byte[] reg= new byte [buf. readableBytes()]i
21. buf readBytes(reg)i
22. String body new String (regrUTE-8"), substring(0, reg. length
23
System getProperty("line separator").length())i
24. System. out. println( The time server receive order : body
25
+i the counter is ++counter)i
26. String currentrime-"QUERY TIME ORDER".equalsIgnoreCase(body)? new
java, util. Date(
27.
System currentTimeMillis()), toString():"BAD ORDER";
28. currentTime currentTime System getProperty(line separator");
29. ByteBuf resp= Unpooled. copiedBuffer(currentTime getBytes());
30. ctx. writeAndFlush(resp)i
31
32
33.
@override
34
public void exceptioncaught (ChannelHandlerContext ctx, Throwable
cause) i
82第4章TcP粘包/拆包问题的解决之道
35. ctx. close(i
36
37,}
每读到一条消息后,就计一次数,然后发送应答消息给客户端。按照设计,服务端接
收到的消息总数应该跟客户端发送的消息总数相同,而且请求消息删除回车换行符后应该
为" QUERY TIME ORDER"。下面我们继续看下客户端的改造。
42.2 Time Client的改造
代码清单4-2Net!y时间服务器客户端' Time ClientHandler
14. public class TimeClientHandler extends ChannelHandlerAdapter
15,
16
private static final Logger logger= logger
17
getLogger (TimeClientHandler class getName())i
18.
19.
private int counter
20.
21,
private byte[] regi
22.
23
24
Creates a client-side handler
25,
26
public TimeclientHandler()i
27. req =("QUERY TIME ORDER"+ System. get Property("line separator")
28,
getBytes ()i
29
30
31
override
32
public void channelActive(ChannelHandlercontext ctx) i
33. ByteBuf message
null
34. for (int i=0;1<100:i++)
35
message- Unpooled buffer(req. length)i
36
message.writeBytes(reg)i
37
ctx. writeAndFIush(message)i
38.}
39
40
@Override
83Net!y权威指南(第2版)
42.
public void channelRead( ChannelHandlerContext ctx, Object msg)
43
throws Exception t
44. ByteBuf buf =(ByteBuf) msgi
45. byte[] req =new byte [buf. readableBytes ()1i
46. buf readBytes(req)i
47. String body new String (req,"UTF-8");
48. System. out. printin(NoW is : body +i the counter is:
49,
t ++counter)i
50,
51.
52.
OVerride
53
public void exceptionCaught ( ChannelHandlerContext ctx, Throwable
cause)
54,//释放资源
55. logger warning("Unexpected exception from downstream
56
cause getMessage())i
57. ctx. close()
58
59.}
主要的修改点就是代码第33~38行,客户端跟服务端链路建立成功之后,循环发送
100条消息,每发送一条就刷新一次,保证每条消息都会被写入 Channel中。按照我们的
设计,服务端应该接收到100条查询时间指令的请求消息。
第48~49行,客户端每接收到服务端一条应答消息之后,就打印一次计数器。按照
设计初衷,客户端应该打印100次服务端的系统时间。
下面的小节就来看下运行结果是否符合设计初衷。
4.2.3运行结果
分别执行服务端和客户端,运行结果如下
服务端运行结果如下。
The time server receive order: QUERY. TIME ORDER
此处省略55行 QUERY TIME ORDER
QUERY TIME ORD i the counter is 1
The time server receive order
此处省略42行 QUEERY TIME ORDER
·84·第4章TCP粘包/拆包问题的解决之道
QUERY TIME ORDER the counter is: 2
服务端运行结果表明它只接收到了两条消息,第一条包含57条“ QUERY TIME
ORDER”指令,第二条包含了43条“ QUERY TIME ORDER”指令,总数正好是100条。
我们期待的是收到100条消息,每条包含一条“ QUERY TIME ORDER”指令。这说明发
生了TCP粘包。
客户端运行结果如下
NOW 1S: BAD ORDER
BAD ORDER
the counter is 1
按照设计初衷,客户端应该收到100条当前系统时间的消息,但实际上只收到了一条。
这不难理解,因为服务端只收到了2条请求消息,所以实际服务端只发送了2条应答,由
于请求消息不满足查询条件,所以返回了2条“ BAD ORDER”应答消息。但是实际上客
户端只收到了一条包含2条“ BAD ORDER”指令的消息,说明服务端返回的应答消息也
发生了粘包。
由于上面的例程没有考虑TCP的粘包拆包,所以当发生TCP粘包时,我们的程序就
不能正常工作。
下面的章节将演示如何通过Netl的 Line based rame Decoder和 StringDecoder来解决
TCP粘包问题
4.3利用 Line based frame Decoder解决TCP粘包问题
为了解决TCP粘包/拆包导致的半包读写问题,Net默认提供了多种编解码器用于处
理半包,只要能熟练掌握这些类库的使用,TCP粘包问题从此会变得非常容易,你甚至不
需要关心它们,这也是其他NO框架和JDK原生的NOAP所无法匹敌的。
下面我们就以修正时间服务器为目标进行开发和讲解,通过对实际代码的讲解让大家
能够尽快熟悉和掌握半包解码器的使用
85·Netty权威指南(第2版)
4.3.1支持TCP粘包的 Time Server
直接看代码,然后对 LineBased frame Decoder和 String Decoder的API进行说明。
代码清单4-3Nety时间服务器服务端 Time Server
18. public class Time Server
19
20
public void bind(int port) throws Exception i
21.//配置服务端的o线程组
22. EventLoopGroup bossGroup new NioEventLoopGroup()i
23. EventLoopGroup wor kerGroup new NioEventLoopGroup()i
24. try i
25
ServerBootstrap b= new ServerBootstrap():
26.
b group(bossGroup, workerGroup)
27
channel(NioServerSocketchannel, class)
28
option Channeloption, SO BACKLOG, 1024)
29.
childHandler(new ChildchannelHandler());
30
//绑定端口,同步等待成功
31.
Channelfuture f= b. bind(port), sync():
32,
33
//等待服务端监听端口关闭
34
f channel(). closeFuture(). sync()i
35. finally t
36
′优雅退出,释放线程池资源
37
bossGroup. shutdownGracefully()i
38,
workerGroup. shutdownGracefully ()i
39.
40.
41
42
private class ChildchannelHandler extends ChannelInitializer
<Socket Channel> t
43. @override
44. protected void initchannel (Socketchannel argo) throws Exception i
45.
argo. pipeline(). addLast(new LineBasedFrame De coder(1024))i
46
argo. pipeline(). addLast (new StringDecoder())i
47
argo. pipeline(). addLast (new Time ServerHandler())i
48.}
49,
50
51
52
param args
·86·第4章TCP粘包/拆包问题的解决之道
53
@throws Exception
54.
55
public static void main(String[] args) throws Exception t
56. int port=8080
57. if (args : null & args length >0)I
58.
try
59
port Integer valueof(args[01):
60.
1 catch (NumberFormatException e)
61.
//采用默认值
62
64. new TimeServer().bind(port)
65
66}
重点看45~47行,在原来的 TimeServerhandler之前新增了两个解码器:
Line based frame Decoder和 String Decoder。这两个类的功能后续会进行介绍,下面继续看
TimeServerhandler的代码修改。
代码清单4-4Net!时间服务器服务端 Time ServerHandler
12. public class TimeServerHandler extends ChannelHandlerAdapter t
13
14,
private int counter;
15
16
oVerride
17
public void channelRead( ChannelHandlerContext ctx, Object msg)
18
throws Exception I
19. String body =(String)msg.
20. System. out. printIn("The time server receive order + body
21
i the counter is :# ++counter)i
22. String currentTime ="QUERY TIME ORDER. equalsIgnoreCase(body)? new
java, util. Date(
23.
ystem currentTimeMillis()). tostring():"BAD ORDER"i
24. currentTime= currentTime System, getProperty("line, separator")
25. ByteBuf resp- Unpooled. copiedBuffer(currentTime getBytes())i
26. ctx. writeAndFlush(resp)i
27,
28
29.
override
30,
public void exceptioncaught(ChannelHandlercontext ctx, Throwable
cause) I
31. ctx. close()i
87Ne权威指南(第2版)
32
33
直接看19-21行,可以发现接收到的msg就是删除回车换行符后的请求消息,不需
要额外考虑处理读半包问题,也不需要对请求消息进行编码,代码非常简洁。读者可能会
质疑这样是否可行,不着急,我们先继续看看客户端的类似改造,然后运行程序看执行结
果,最后再揭开其中的奥秘。
4.3.2支持TCP粘包的 Time client
支持TCP粘包的客户端修改起来也非常简单,代码如下。
代码清单4-5Nety时间服务器客户端 Timeclient
18. public class TimeClient t
20
public void connect (int port, String host) throws Exception i
21.//配置客户端NIO线程组
22. EventLoopGroup group new NioEventLoopGroup()i
23. try
24
Bootstrap b= new Bootstrap()i
25
b group(group). channel(NioSocketchannel class)
26
option( ChannelOption TCP NODELAY, true)
27
handler (new ChannelInitializerssocketChanne1>0
28
OVerride
29.
public void initchannel(Socketchannel ch)
30.
throws Exception I
31
ch pipeline().addlast(
32
new LineBasedFrame Decoder (1024))i
33
ch pipeline (). addLast (new StringDecoder())i
34
ch pipeline(). addLast (new TimeclientHandler())i
35
36
37
38
/发起异步连接操作
39
ChannelFuture f=b connect (host, port). sync()i
40
41
/等待客户端链路关闭
42
f channel().closeFuture(). sync()
43. 1 finally
88·第4章TCP粘包/拆包问题的解决之道
44.//优雅退出,释放NIo线程组
group. shutdownGracefully()i
46,}
47
48
49
k★
50
param args
51
k @throws Exception
52.
53.
public static void main(String[] args) throws Exception f
54. int port = 8080;
55. if (args !=null & args length 0)
56
try t
57
port Integer valueof (args[o])i
58
catch (NumberFormatException e)
59
//采用默认值
60.
61,}
62. new Time Client(). connect(port, 127.0.0.1")i
63.
64.
31~34行与服务端类似,直接在 TimeClienthandler之前新增 Line Based frame Decoder
和 String Decoder解码器,下面我们继续看 TimeClient handler的代码修改。
代码清单4-6Nety时间服务器客户端 Time ClientHandler
14. public class TimeClientHandler extends ChannelHandlerAdapter
15
16
private static final Logger logger - Logger
17
getLogger(TimeClientHandler. class, getName())i
18
19
private int counter:
20
21
private byte[l regi
22
23
24,
creates a client-side handler
25
26
public TimeClientHandler()(
27. req=(" QUERY TIME ORDER"+ System, getProperty("line separator"))
28
getBytes(
·89Netty权威指南(第2版)
29
30
31
oVerride
32,
public void channelActive(ChannelHandlerContext ctx)
33. ByteBuf message nulli
34.for(inti=0;i<100:i++)
35,
message Unpooled buffer(reg. length)i
36,
message.writeBytes(req)i
37
ctx. writeAndF lush(message)i
38,}
39
40
41
OVerride
42
public void channelRead(ChannelHandlercontext ctx, Object msg)
43
throws Exception t
44. String body =(String)msgi
45. System. out. printin(Now is :" body i the counter is:
46.
+++counter)i
47
48
49
override
50.
public void exceptionCaught( ChannelHandlerContext ctx, Throwable
cause)(
51.//释放资源
52, logger warning ("Unexpected exception from downstream
53
cause getMessage ());
54. ctx. close(:
55
56.}
第44~46行拿到的msg已经是解码成字符串之后的应答消息了,相比于之前的代码
简洁了很多。
下个小节我们运行重构后的时间服务器服务端和客户端,看看它能否像设计预期那样
正常工作。
4.3.3运行支持TCP粘包的时间服务器程序
分别运行 Time server和 Time client,执行结果如下。
服务端执行结果如下。
90第4章TCP粘包/拆包问题的解决之道
The time server receive order QUERY TIME ORDER i the counter is :1
//此处省路2-99行 sThe time server receive order
The time server receive order QUERY TIME ORDER the counter is 100
客户端运行结果如下
Now is Thu Feb 2000:00: 14 Csr 2014 the counter is 1
/此处省略2-99行 NOW IS: Thu Feb2000:00:14CsT2014
Now is Thu Feb 20 00: 00:14 cst 2014 the counter is 100
程序的运行结果完全符合预期,说明通过使用 Line based frame Decoder和 Stringlecoder
成功解决了TCP粘包导致的读半包问题。对于使用者来说,只要将支持半包解码的 Handler
添加到 ChannelPipeline中即可,不需要写额外的代码,用户使用起来非常简单。
下个小节,我们就对添加 Line based frame Decoder和 String Decoder之后就能解决TCP
粘包导致的读半包或者多包问题的原因进行分析。
4.3.4 Line based frame decoder和 String Decoder的原理分析
Line Based frame Decoder的工作原理是它依次遍历 ByteBuf中的可读字节,判断看是
否有“in”或者“rin”,如果有,就以此位置为结束位置,从可读索引到结束位置区间的
字节就组成了一行。它是以换行符为结東标志的解码器,支持携带结束符或者不携带结束
符两种解码方式,同时支持配置单行的最大长度。如果连续读取到最大长度后仍然没有发
现换行符,就会抛出异常,同时忽略掉之前读到的异常码流。
StringDecoder的功能非常简单,就是将接收到的对象转换成字符串,然后继续调用后
面的 Handler。 Line Based frame Decoder+ String Decoder组合就是按行切换的文本解码器
它被设计用来支持TCP的粘包和拆包
可能读者会提出新的疑问:如果发送的消息不是以换行符结束的,该怎么办呢?或者
没有回车换行符,靠消息头中的长度字段来分包怎么办?是不是需要自己写半包解码器?
答案是否定的,Nety提供了多种支持TCP粘包/拆包的解码器,用来满足用户的不同诉求。
第5章我们将学习分隔符解码器,由于它在实际项目中应用非常广泛,所以单独用一
章对其用法和原理进行讲解。
·91Nety权威指南(第2版)
44总结
本章首先对TCP的粘包和拆包进行了讲解,给出了解决这个问题的通用做法。然后
我们对第3章的时间服务器进行改造和测试,首先验证没有考虑TCP粘包/拆包导致的问
题。随后给出了解决方案,即利用 Line based frame decoder+ String Decoder来解决TCP的
粘包拆包问题。
·92·第5章
分隔符和定长解码器的应用
TCP以流的方式进行数据传输,上层的应用协议为了对消息进行区分,往往采用如下
4种方式。
1)消息长度固定,累计读取到长度总和为定长LEN的报文后,就认为读取到了一
个完整的消息;将计数器置位,重新开始读取下一个数据报
(2)将回车换行符作为消息结束符,例如FTP协议,这种方式在文本协议中应用比较
广泛;
(3)将特殊的分隔符作为消息的结束标志,回车换行符就是一种特殊的结束分隔符
(4)通过在消息头中定义长度字段来标识消息的总长度。
Nety对上面4种应用做了统一的抽象,提供了4种解码器来解决对应的问题,使用
起来非常方便。有了这些解码器,用户不需要自己对读取的报文进行人工解码,也不需要
考虑TCP的粘包和拆包。
第4章我们介绍了如何利用 Linebased frame Decoder解决TCP的粘包问题,本章我们继
续学习另外两种实用的解码器— Delimiter Based Frame Decoder和 Fixed Length Frame Decoder,
前者可以自动完成以分隔符做结束标志的消息的解码,后者可以自动完成对定长消息的解
码,它们都能解决TCP粘包/拆包导致的读半包问题。Net!y权威指南(第2版)
本章主要内容包括
◎ Delimiter Based Frame Decoder服务端开发
◎ Delimiter Based Frame Decoder客户端开发
◎运行 Delimiter Based Frame Decoder服务端和客户端
o Fixed Length FrameDecoder服务端开发
通过 telnet命令行调试 FixedLength FrameDecoder服务端
51 Delimiter Based Frame Decode应用开发
通过对 Delimiter Based Frame Decoder的使用,我们可以自动完成以分隔符作为码流结束
标识的消息的解码,下面通过一个演示程序来学习下如何使用 Delimiter Based Frame Decoder
进行开发。
演示程序以经典的Echo服务为例。 EchoServer接收到 Echoclient的请求消息后,将
其打印出来,然后将原始消息返回给客户端,消息以“$”作为分隔符
5.1.1 Delimiter Based Frame Decoder服务端开发
下面我们直接看 Echoserver的源代码
代码清单5-1 Echoserver服务端 Echoserver
22. public class EchoServer i
23,
public void bind(int port) throws Exception i
24
//配置服务端的NIO线程组
25
EventLoopGroup bossGroup new NioEventLoopGroup():
26,
EventLoopGroup workerGroup new NioEventLoopGroup()i
27
try
28
ServerBootstrap b= new ServerBootstrap ()i
29,
b group(bossGroup, workerGroup)
30.
channel(Nioserversocketchannel class
31.
option( Channeloption SO BACKLOG, 100)
32
handler(new LoggingHandler(logLevel. INFO))
33
childHandler(new ChannelInitializer<socket Channel>()[
94第5章分隔符和定长解码器的应用
34
oVerride
35
public void initchannel(Socket Channel ch)
36
throws Exception t
37
ByteBuf delimiter Unpooled. copiedBuffer("s
38,
retBytes())7
39.
ch pipeline (). adaLat(
40
new DelimiterBasedFrame Decoder (1024
delimiter))i
42
ch, pipeline(). addLast(new String Decoder())i
43
ch pipeline().addLast(new EchoserverHandler())i
44
45
})
47
//绑定端口,同步等待成功
48
Channelfuture f=b.bind (port). sync()i
49
50
/等待服务端监听端口关闭
51.
f channel(). closeFuture(). sync()i
52
k finally i
53
//优雅退出,释放线程池资源
54
bossGroup, shutdownGracefully()i
55
workerGroup, shutdownGracefully()i
56
57
58.
59.
public static void main(String[] args) throws Exception f
60
int port = 8080;
61.
if (args != null & args length >0)(
62
try t
63
port= Integer valueof (args [o]);
64
t catch (Number FormatException e)[
65
//采用默认值
66
67
68
new EchoServer(). bind (port)i
70.
我们重点看37~41行,首先创建分隔符缓冲对象 ByteBuf,本例程中使用“S”作为
分隔符。第40行,创建 Delimiterbased frame decoder对象,将其加入到 ChannelPipeline
中。 Delimiter Based frame Decoder有多个构造方法,这里我们传递两个参数:第一个1024
95·Net!y权威指南(第2版〕
表示单条消息的最大长度,当达到该长度后仍然没有查找到分隔符,就抛出 TooLong frame
Exception异常,防止由于异常码流缺失分隔符导致的内存溢出,这是 Netty解码器的可靠
性保护;第二个参数就是分隔符缓冲对象。
下面继续看 Echoserverhandler的实现
代码清单5-2 EchoServer服务端 EchoServerHandler
13. @Sharable
14. public class EchoServerHandler extends ChannelHandlerAdapter
15
16
int counter =0
17
18
@override
19.
public void channelRead(ChannelHandlerContext ctx, Object msg)
20
throws Exception i
21,
String body =(String)msgi
22.
System. out. printIn(This is +++counter times receive client :["
23
+body+")");
24
body+="$";
25
ByteBuf echo= Unpooled. copiedBuffer(body. getBytes())i
26.
ctx. wri teAndFIush (echo)
27
28
29
override
30
public void exceptionCaught(ChannelHandlerContext ctx, Throwable
cause) f
31
cause printstackTrace ();
32
ctx, close()://发生异常,关闭链路
33
34,}
第21~23行直接将接收的消息打印出来,由于 Delimiter Based Frame Decoder自动对请
求消息进行了解码,后续的 Channelhandler接收到的msg对象就是个完整的消息包;第二
个 ChannelHandler是 String Decoder,它将 Byte Buf解码成字符串对象;第三个
Echo Server Handler接收到的msg消息就是解码后的字符串对象。
由于我们设置 Delimiter Based frame Decoder过滤掉了分隔符,所以,返回给客户端
时需要在请求消息尾部拼接分隔符“S_”,最后创建 Byte Buf,将原始消息重新返回给
客户端。
·96·第5章分隔符和定长解码器的应用
下面我们继续看下客户端的实现。
5.1.2 Delimiter Based frame Decoder客户端开发
首先看下 Echoclient的实现。
代码清单5-3 EchoClient客户端 Echoclient
20. public class Echoclient i
21
22
public void connect(int port, string host) throws Exception
23
//配置客户端NIO线程组
24
EventLoopGroup group= new NioEventloopGroup()i
25
try i
26
Bootstrap b= new Bootstrap()i
27
b group(group). channel(NioSocket Channel class)
28
option(ChannelOption TCP NODELAY, true)
29
handler (new Channelinitiallzer<soc ketchanneI>((
30,
override
31
public void initChannel(Socketchannel ch)
32
throws Exception I
33
ByteBuf delimiter- Unpooled. copiedBuffer("s
34
getBytes())i
35
ch pipeline(). addlast(
36
new DelimiterBasedFrame Decoder(I024
37,
delimiter))i
8
ch pipeline () addLast (new StringDecoder())i
39
ch pipeline(). addLast(new EchoclientHandler())i
40.
41.
});
42,
43,
/发起异步连接操作
44
ChannelFuture f-b connect(host port).sync()i
45
46
/等待客户端链路关闭
47,
f channel(). closeFuture(), sync()i
48
I finally i
49
//优雅退出,释放NIO线程组
50
group. shutdownGracefully();
51
52
·97·Netty权威指南(第2版)
54
55
k param args
56
throws Exception
57
58
public static void main(String[] args) throws Exception i
59
int port =8080;
60,
if (args null & args, length > 0)1
61
try i
62
port Integer valueof (args[OJ);
63
1 catch (Number FormatException e)i
64,
//采用默认值
65,
66
67
new EchoClient (). connect(port, 127.0.0.1")i
68
69.}
与服务端类似,分别将 Delimiter Based Frame Decoder和 String Decoder添加到客户端
ChannelPipeline中,最后添加客户端IO事件处理类 Echoclienthandler,下面继续看
EchoClientHandler的实现。
代码清单5-4 EchoClient客户端 EchoClienthandler
11. public class EchoClientHandler extends ChannelHandlerAdapter
12,
13.
private int counter;
14,
static final String ECho REQ="Hi, Lilinfeng. Welcome to Netty. $"i
16
17,
18
Creates a client-side handler
19.
20.
public EchoclientHandler ()
21
22
23
@Override
24.
public void channelActive(ChannelHandler Context ctx)I
25
for (int i= i<107 1++)(
ctx. writeAndFlush(Unpooled. copiedBuffer(ECHO REQ. getBytes())/i
26
27
·98·第5章分隔符和定长解码器的应用
28.
29.
override
3
public void channelRead(ChannelHandlerContext ctx, Object msg)
31
throws Exception
32,
System, out. printin(This is +++counter t times receive server /
33
+msg+"");
34
35
36.
override
37
public void channelReadcomplete( ChannelHandlerContext ctx) throws
Exception I
38
ctx. flush();
39,
40
41
override
42
public void exceptionCaught( ChannelHandlerContext ctx, Throwable
cause) t
43,
cause printstackTrace()i
44
ctx. close(:
45
46.}
第25~26行在TCP链路建立成功之后循环发送请求消息给服务端,第32~33行打
印接收到的服务端应答消息同时进行计数。
下个小节,运行上面开发的服务端和客户端,看看运行结果是否正确。
5.1.3运行 De limiter Based Frame Decoder服务端和客户端
服务端运行结果如下。
This is 1 times receive client [Hi, Lilinfeng, Welcome to Netty. I
This is 2 times receive client [Hi, Lilinfeng. Welcome to Netty. I
This is 3 times receive client [Hi, Lilinfeng. Welcome to Netty. I
This is 4 times receive client [Hi, Lilinfeng. Welcome to Netty. I
This is 5 times receive client [Hi, Lilinfeng. Welcome to Netty. I
This is 6 times receive client [Hi, Lilinfeng, Welcome to Netty
This is 7 times receive client [Hi, Lilinfeng. Welcome to Netty. I
This is 8 times receive client [Hi, Lilinfeng. Welcome to Netty. J
This is 9 times receive client [Hi, Lilinfeng. Wel come to Netty. J
This is 10 times receive client [Hi, Lilinfeng. Welcome to Netty. I
99Netty权威指南(第2版
客户端运行结果如下。
This is 1 times receive server [Hi, Lilinfeng. Welcome to Netty. I
This is 2 times receive server [Hi, Lilinfeng. Welcome to Netty. l
This is 3 times receive server [Hi, Lilinfeng. We l come to Netty. I
This is 4 times receive server [Hi, Lilinfeng. Welcome to Netty
This is 5 times receive server [Hi, Lilinfeng. Welcome to Netty. I
This is 6 times receive server [Hi, Lilinfeng. Welcome to Netty
This is 7 times receive server [Hi, Lilinfeng. Welcome to Netty. j
This is 8 times receive server [Hi, Lilinfeng. Welcome to Netty.
This is g times receive server [Hi, Lilinfeng. Welcome to Netty,
This is 10 times receive server (Hi, Lilinfeng. Welcome to Netty. I
服务端成功接收到了客户端发送的10条“Hi,Li1 intend. Welcome to Netty.”
请求消息,客户端成功接收到了服务端返回的10条“Hi, Lilinfeng. Welcome to
Netty.”应答消息。测试结果表明使用 Delimiter Based Frame Decoder可以自动对采用分
隔符做码流结束标识的消息进行解码
本例程运行10次的原因是模拟TCP粘包/拆包,在笔者的机器上,连续发送10条Echo
请求消息会发生粘包,如果没有 Delimiter BasedFrame Decoder解码器的处理,服务端和客
户端程序都将运行失败。下面我们将服务端的 Delimiter based frame Decoder注释掉,最终
代码如图5-1所示。
public void initchannel(Socketchannel ch)
throws Exception
ByteBuf delimiter Unpooled copied Buffer"S
getBytes()
/ch pipe line(. addLast
N new Delimiter BasedFrame Decoder(1024,
N delimiter):
ch pipeline(). addLast(new String Decoder)
ch pipeline(). addLast(new EchoServerHandler()
图5-1删除掉 Delimiter Based Frame Decoder后的服务端代码
服务端运行结果如下
This is 1 times receive client [Hi, Lilinfeng. We l come to Nettys Hi
Lilinfeng. Welcome to Nettys Hi, Lilinfeng. Welcome to Netty s Hir Lilinfeng
Welcome to Netty s Hi, Lilinfeng. Welcome to Netty s Hi, Lilinfeng. Welcome to
Netty s Hi, Lilinfeng. Welcome to Netty s Hi, Lilinfeng. We l come to Netty s Hi,
Lilinfeng. Welcome to Netty s Hi, Lilinfeng. Welcome to Nettys J
由于没有分隔符解码器,导致服务端一次读取了客户端发送的所有消息,这就是典型
的没有考虑TCP粘包导致的问题
·100·第5章分隔符和定长解码器的应用
5.2 FixedLength Frame Decoder应用开发
Fiⅸ edLength frame Decoder是固定长度解码器,它能够按照指定的长度对消息进行自
动解码,开发者不需要考虑TCP的粘包/拆包问题,非常实用。下面我们通过一个应用实
例对其用法进行讲解。
521 Fixed Length Frame Decoder服务端开发
在服务端的 ChannelPipeline中新增 FixedLength Frame Decoder,长度设置为20,然后
再依次增加字符串解码器和 EchoServerhandler,代码如下。
代码清单5-5 Echoserver服务端 Echoseryer
20. public class Echoserver I
21
public void bind(int port) throws Exception t
22.
//配置服务端的NIo线程组
23.
EventLoopGroup bossGroup new NioEventLoopGroup()i
24
EventloopGroup workerGroup new NlOEventloopGroup();
25,
try
26
ServerBootstrap b= new ServerBootstrap()
27,
b, group(boss Group, worker Group
28,
channel (nioserverSocketchannel class
29.
option (ChannelOption SO BACKLOG, 100)
30
handler(new LoggingHandler (LogLevel. INFO))
31
childHandler(new ChannelInitializer<socketchannel>()(
@Override
public void initchannel(Socketchannel ch)
34.
throws Exception I
35
ch pipeline(). addLast(
36,
new FixedLengthFrame Decoder(20))F
37
ch pipeline(), addLast(new stringDecoder ())
38.
ch pipeline(). addLast(new EchoServerHandler())
39.
40
);
41
42
/绑定端口,同步等待成功
43
ChannelFuture f= b. bind(port). sync ()i
44
·101●Netty权威指南(第2版)
45
/等待服务端监听端口关闭
46
f channel(). closefuture(). sync ();
47
finally I
48
//优雅退出,释放线程池资源
49
bossGroup. shutdownGracefully()i
50.
workerGroup. shutdownGracefully()i
51.
52
53
54.
public static void main(String[] args) throws Exception
55
int port =8080;
56
if (args ! null & argslength >0)I
57
try I
58
port Integer valueof (args[0])i
59,
catch (Number FormatException e)(
60
/采用默认值
61
62
63
new EchoServer (). bind (port)i
64
65.}
EchoServerHandler的功能比较简单,直接将读取到的消息打印出来,代码如下。
代码清单5-6 Echoserver服务端 EchoServer Handler
11.@ Sharab⊥e
12. public class EchoServerHandler extends ChannelHandlerAdapter
13
14.
Override
15,
public void channelRead( ChannelHandlerContext ctx, Object msg)
16
throws Exception i
17,
System. out. printIn("Receive client [ msg +)i
18
19
20,
override
21
public void exceptionCaught(ChannelHandlerContext ctx, Throwable
cause)
22
cause printstackTrace()i
23
ctx. close();//发生异常,关闭链路
24
25.}
102·第5章分隔符和定长解码器的应用
利用 FixedLength Frame Decoder解码器,无论一次接收到多少数据报,它都会按照构
造函数中设置的固定长度进行解码,如果是半包消息, FixedLength Frame Decoder会缓存
半包消息并等待下个包到达后进行拼包,直到读取到一个完整的包。
下面的章节我们通过 telnet命令行来测试 EchoServer服务端,看它能否按照预期进行
工作。
522利用 telnet命令行测试 Echo Server服务端
由于客户端代码比较简单,所以这次我们通过 telnet命令行对服务端进行测试
测试场景:在 Windows操作系统上打开CMD命令行窗口,通过 telnet命令行连接服
务端,在控制台输入如下内容。
Lilinfeng welcome to Netty at Nanjing
然后看服务端打印的内容,预期输出的请求消息为“ Lilinfeng welcome to”
下面我们就具体看下详细的测试步骤
(1)在【运行】菜单中输入cmd命令,打开命令行窗口,如图5-2所示。
运行
请键入程序
称, indow
成 Internet资的名
您打开它。
打开@
图5-2通过cmd命令打开CMD窗口
(2)在命令行中输入“ telnet localhost8080”,通过 telnet连接服务端,如图5-3所示。
k C: \UINDovS\system32\end. exe
NDocuments and Setting \Administrator>
\Documents and Settings Administrator>telnet localhost 8980
图5-3通过 telnet命令连接服务端
103中级篇
Nety编解码开发指南
第6章编解码技术
第7章 MessagePack编解码
第8章 Google Protobuf编解码
第9章 J Boss marshalling编解码第6章
编解码技术
基于Java提供的对象输入/输出流 ObjectInputStream和 ObjectOutputStream,可以直接
把Java对象作为可存储的字节数组写入文件,也可以传输到网络上。对程序员来说,基
于JDK默认的序列化机制可以避免操作底层的字节数组,从而提升开发效率。
Java序列化的目的主要有两个:
◎网络传输
◎对象持久化
由于本书主要介绍基于Nety的NlO网络开发,所以我们重点关注网络传输。当进行
远程跨进程服务调用时,需要把被传输的Java对象编码为字节数组或者 Byte Buffer对象。
而当远程服务读取到 Byte Buffer对象或者字节数组时,需要将其解码为发送时的Java对
象。这被称为Java对象编解码技术。
Java序列化仅仅是Java编解码技术的一种,由于它的种种缺陷,衍生出了多种编解
码技术和框架,后续的章节我们会结合Net!y介绍几种业界主流的编解码技术和框架,看
看如何在Nety中应用这些编解码框架实现消息的高效序列化。
本章主要内容包括:
◎Java序列化的缺点
业界流行的几种编解码框架介绍第6章编解码技术
61Java序列化的缺点
Java序列化从JDK1.1版本就已经提供,它不需要添加额外的类厍,只需实现
Java. 1o. Serializable并生成序列ID即可,因此,它从诞生之初就得到了广泛的应用。
但是在远程服务调用(RPC〕时,很少直接使用Java序列化进行消息的编解码和传输,
这又是什么原因呢?下面通过分析Java序列化的缺点来找出答案。
6.1.1无法跨语言
无法跨语言,是Java序列化最致命的问题。对于跨进程的服务调用,服务提供者可
能会使用C艹+或者其他语言开发,当我们需要和异构语言进程交互时,Java序列化就难以
胜任。
由于Java序列化技术是Java语言内部的私有协议,其他语言并不支持,对于用户来
说它完全是黑盒。对于Java序列化后的字节数组,别的语言无法进行反序列化,这就严
重阻碍了它的应用。
事实上,目前几乎所有流行的 Java RCP通信框架,都没有使用Java序列化作为编解
码框榘,原因就在于它无法跨语言,而这些RPC框架往往需要支持跨语言调用
6.1.2序列化后的码流太大
下面我们通过一个实例看下Java序列化后的字节数组大小。
代码清单6-1Java序列化代码POJO对象类 UserInfo
10. public class UserInfo implements Serializable i
11
12
大★
13
默认的序列号
14
15
private static final long serialversionUID= ILi
16.
17
private string userName
18.
107Nett权威指南(第2版
19
private int userID
0
21
public UserInfo buildUserName(String userName) I
22
this userName userName;
23.
return this
24,
25
26
public UserInfo buildUserID(int userID)[
27
this userid userId;
28.
return this
2
30,
32,
k areturn the userName
33
34. public final String getUserName()[
35
return userName i
36
37
38,
39
param userName
40
the userName to set
41
42
public final void setUserName (String userName) I
this, userName userName
44,
45
46
47
★ return the userid
48
4
public final int getUserID( i
50,
return userID
51
52
53
54
param userID
55,
the userid to set
56
57
public final void setUserID(int userID)
58
this userid= userid:
59
108·第6章编解码技术
60
61
public byte[] codeC() t
62
ByteBuffer buffer ByteBuffer allocate (1024)i
63.
byte[] value= this, userName, getBytes()i
64
buffer. putIn(value length)i
65
buffer put(value)i
66
buffer. putIn(thisuserID)i
67
buffer. flip(i
68.
value null
69
byte[ result new byte [buffer, remaining()i
70,
buffer. get(result)i
71
return result
72,
73.}
UserInfo对象是个普通的POJO对象,它实现了 Java.10. Serializable接口,并且生成了
一个默认的序列号 serial VersionUID=1L。这说明 UserInfo对象可以通过JDK默认的序列
化机制进行序列化和反序列化。
第61~72行使用基于 Byte Buffer的通用二进制编解码技术对 UserInfo对象进行编码,
编码结果仍然是byte数组,可以与传统的JDK序列化后的码流大小进行对比。
下面写一个测试程序,先调用两种编码接口对P○JO对象编码,然后分别打印两者编码
后的码流大小进行对比。
代码清单6-2JaⅦa序列化代码编码测试类 TestuserInfo
11. public class Tes uSeriNfo
12
13
14
param args
15
throws IOException
16
17
public static void main(String[] args) throws IOException
18.
UserInfo info new UserInfo(;
19.
info. buildUserID(100).buildUserName("Welcome to Netty)i
20.
ByteArrayOutputstream bos new ByteArrayoutputstream ()i
21
Objectoutputstream os= new Objectoutputstream (bos)i
22,
os, writeObject(info)i
23.
Os. flush(i
24
Os.close()i
25
byte[] b= bos. toByteArray()
109Ne!权威指南(第2版
26
System. out. println("The jak serializable length is " b, length)i
27
bos. close()i
28
System. out. println(
29.
System. out. printIn("The byte array serializable length is "
30
t info. codeC().length)i
31
32
33
测试结果如图6-1所示。
E Feebler Javadoc DE Deeluati om / Sourch B console 2 sfress
<terminated)TestUserInfo Wava Applicati on] E: \Progran Files\Jawa\jdk, 7 0_45ibin\js
The jdk serializable length ia 127
The byte array serial12ah⊥e⊥ ength:24
图6-1JDK序列化机制和通用二进制编码测试结果
测试结果令人震惊,采用JDK序列化机制编码后的二进制数组大小竟然是二进制编
码的529倍。
我们评判一个编解码框架的优劣时,往往会考虑以下几个因素。
◎是否支持跨语言,支持的语言种类是否丰富:
◎编码后的码流大小:
◎编解码的性能
◎类库是否小巧,API使用是否方便;
◎使用者需要手工开发的工作量和难度
在同等情况下,编码后的字节数组越大,存储的时候就越占空间,存储的硬件成本就
越髙,并且在网络传输时更占带宽,导致系统的吞吐量降低。Java序列化后的码流偏大也
直被业界所诟病,导致它的应用范围受到了很大限制。
6.1.3序列化性能太低
下面我们从序列化的性能角度看下JDK的表现如何。将之前的例程代码稍做修改,
改造成性能测试版本,如图6-2所示。
110·第6章编解码技术
public bytel code C(Byte Buffer buffer)(
buffer clear(
byte[ value =this userName getBytes()
buffer. putIn(value, length).
buffer. putIn( this userID):
buffer. flip(:
due null
byte[] result= new byte[buffer. remaining
buffer. get(result)
return result
图6-2 UserInfo性能测试版本修改
对 UserInfo进行改造,新增上图所示的方法,再创建一个性能测试版本的 UserInfo
测试程序,代码如下
代码清单6-3Java序列化代码编码性能测试类 Perform TestUserInfo
12. public class PerformTestUserInfo i
13
14
15.
Param args
16,
@throws IOException
17,
18. public static void main(string[ args) throws IOException t
19
UserInfo info new UserInfo(i
20
info. builduserID(100).buildUserName("Welcome to Netty )i
21,
int1oop=1000000;
22.
ByteArrayOutputStream bos- null
23
ObjectOutputstream os= null;
24
long startTime= system. currentTimeMillis()i
25
for (int 1 =0; 1 loop; i++)t
26,
b
s
new ByteArrayoutputstream()i
os new Objectoutputstream(bos)i
os.writeobject(info)i
29
S flush()i
30
Os. close()i
31
byte[] b= bos. toByteArray ()i
bos. close()
33
34
long endTime- System. currentTimeMillis()i
35
System. out. println("The jdk serializable cost time is
36.
+(endTime starttime)+ms)i
37
38.
System. out. printlnNety权威指南(第2版)
40
ByteBuffer buffer= ByteBufferallocate(1024)i
41
startTime System currentTimeMillis()i
42.
for (int i=0: i loop: 1++)
43,
byte[ b- info codeC (buffer)i
44
45
endTime System currentTimeMillis()i
46
System, out. printin("The byte array serializable cost time is
47
t(endTime startTime)+ms )i
48
49.}
对Java序列化和二进制编码分别进行性能测试,编码100万次,然后统计耗费的总
时间,测试结果如图6-3所示
R Problems Javadoc B, Deelerati on Seareh B Console 23=pRogress
<terminated> PerformTestUserInfo [Java Application] E: \Program Files\Java\jdk. 7. 0_45\bin\ javaw. exe
The idle serializable cost time is 7344 ms
The byte array serializable cost time 1s 453s
图6-3 UserInfo编码性能测试结果
这个结果也非常令人惊讶:Java序列化的性能只有二进制编码的6.17%左右,可见Java
原生序列化的性能实在太差。
下面我们结合编码速度,综合对比一下Java序列化和二进制编码的性能差异,如图6-4
所示
140r
HunT Tnn
120
100
80
序列化码流大小(字节)
■序列化耗时(秒)
40
----+-+-“++++““-+-------++++“--+--++-++----“--
20
Java序列化
二进制编解码
图6-4序列化性能对比图
·112·第6章编解码技术
从图6-4可以看出,无论是序列化后的码流大小,还是序列化的性能,JDK默认的序
列化机制表现得都很差。因此,我们通常不会选择Java序列化作为远程跨节点调用的编
解码框架。
但是不使用JDK提供的默认序列化框架,自己开发编解码框架又是个非常复杂的工
作,怎么办呢?不用着急,业界有很多优秀的编解码框架,它们在克服了JDK默认序列
化框架缺点的基础上,还増加了很多亮点,下面让我们继续了解并学习业界流行的几款编
解码框架
6.2业界主流的编解码框架
由于Java的编解码框架五花八门,穷举学习显然不是一个妤的策略,本节挑选了
些业界主流的编解码框架和编解码技术进行介绍,希望读者在了解这些框架特性的基础
上,做出合理的选择。
62.1 Google的 Protobuf介绍
Protobuf全称 Google Protocol Buffers,它由谷歌开源而来,在谷歌内部久经考验。它
将数据结构以 proto文件进行描述,通过代码生成工具可以生成对应数据结构的POJO对
象和 Protobuf相关的方法和属性。
它的特点如下。
◎结构化数据存储格式(XML,JSON等)
◎高效的编解码性能
◎语言无关、平台无关、扩展性好
◎官方支持Java、C++和 Python三种语言。
首先我们来看下为什么不使用ⅹML,尽管XML的可读性和可扩展性非常好,也非常
适合描述数据结构,但是ⅹML解析的时间开销和ⅹML为了可读性而牺牲的空间开销都
非常大,因此不适合做高性能的通信协议。 Protobuf使用二进制编码,在空间和性能上具
有更大的优势。
113Net!y权威指南(第2版)
Protobuf另一个比较吸引人的地方就是它的数据描述文件和代码生成机制,利用数据
描述文件对数据结构进行说明的优点如下。
◎文本化的数据结构描述语言,可以实现语言和平台无关,特别适合异构系统间的
集成
◎通过标识字段的顺序,可以实现协议的前向兼容
自动代码生成,不需要手工编写同样数据结构的C++和Java版本;
方便后续的管理和维护。相比于代码,结构化的文档更容易管理和维护,
下面我们看下 Protobuf编解码和其他几种序列化框架的性能对比数据,如图6-5、图
-6所
hession2压f
150000
Sealane
xStream
100000
xstresmi
50000
d seion
Protobuf
Protobut
产列化
反序列化
图6-5 Protobuf编解码和其他几种序列化框架的响应时间对比
b比
t000
Serializable
Xstream
hession
hess ion?
hession2玉
图6-6 Protobuf和其他几种序列化框架的字节数对比
114第6章编解码技术
从图6-5和图6-6两幅对比图可以发现, Protobuf的编解码性能远远高于其他儿种序
列化框架的序列化和反序列化,这也是很多RPC框架选用 Protobuf做编解码框架的原因。
62.2 Facebook的 Thrift介绍
Thrift源于 Facebook,在2007年 Facebook将 Thrift作为一个开源项目提交给了 Apache
基金会。对于当时的 Facebook来说,创造 Thrift是为了解决 Facebook各系统间大数据量
的传输通信以及系统之间语言环境不同需要跨平台的特性,因此 Thrift可以支持多种程序
语言,如C++、C#、 Cocoa、 Erlang、 Haskell,、Java、 Cami、Perl、PHP、 Python、Ruby
和 Smalltalk。
在多种不同的语言之间通信, Thrift可以作为高性能的通信中间件使用,它支持数据
(对象)序列化和多种类型的RPC服务。 Thrift适用于静态的数据交换,需要先确定好它
的数据结构,当数据结构发生变化时,必须重新编辑IDL文件,生成代码和编译,这一点
跟其他IDL工具相比可以视为是 Thrift的弱项。 Thrift适用于搭建大型数据交换及存储的
通用工具,对于大型系统中的内部数据传输,相对于JSON和XML在性能和传输大小上
都有明显的优势。
Thrift主要由5部分组成。
1)语言系统以及IDL编译器:负责由用户给定的IDL文件生成相应语言的接口代码;
(2) PRotocol:RPC的协议层,可以选择多种不同的对象序列化方式,如JSON和 Binary;
3) TTransport:RPC的传输层,同样可以选择不同的传输层实现,如 socket、NlO
Memory Buffer等
(4) PRocessor:作为协议层和用户提供的服务实现之间的纽带,负责调用服务实现
的接口;
(5) SErver:聚合 PRotocol、 TTransport和 PRocessor等对象
我们重点关注的是编解码框架,与之对应的就是 PRotocol。由于 Thrift的RPC服务
调用和编解码框架绑定在一起,所以,通常我们使用τhrit的时候会采取RPC框架的方式。
但是,它的 PRotocol绵解码框架还是可以以类库的方式独立使用的。
与 Protobuf比较类似的是, Thrift通过IDL描述接口和数据结构定义,它支持8种Java
基本类型、Map、Set和List,支持可选和必选定义,功能非常强大。因为可以定义数据结
115·Net!y权威指南(第2版
构中字段的顺序,所以它也可以支持协议的前向兼容
Thrift支持三种比较典型的编解码方式。
◎通用的二进制编解码;
◎压缩二进制编解码;
优化的可选字段压缩编解码
由于支持二进制压缩编解码, Thrift的编解码性能表现也相当优异,远远超过Java序
列化和RMI等,图6-7展示了同等测试条件下的编解码耗时信息。
Thrdt-TCompactProtocol
Protoc ol
Protocol Buffers
RM
REST-ISON
REST-XM
00A3
0126
0210
0336
019
0502
056
g wal
图6-7 Thrift性能测试对比图
6.2.3 JBoss Marshalling
介绍
J Boss Marshalling是一个Java对象的序列化API包,修正了JDK自带的序列化包的
很多问题,但又保持跟 Java. Io. Serializable接口的兼容。同时,增加了一些可调的参数和
附加的特性,并且这些参数和特性可通过工厂类进行配置。
相比于传统的Java序列化机制,它的优点如下。
◎可插拔的类解析器,提供更加便捷的类加载定制策略,通过一个接口即可实现
定制
可插拔的对象替换技术,不需要通过继承的方式;
可插拔的预定义类缓存表,可以减小序列化的字节数组长度,提升常用类型的对
116第6章编解码技术
象序列化性能
◎无须实现 Java.10. Serializable接口,即可实现Java序列化;
◎通过缓存技术提升对象的序列化性能。
相比于前面介绍的两种编解码框架, J Boss Marshalling更多是在 JBoss内部使用,应
用范围有限。
JBoss Marshalling的使用非常简单,后续在介绍 Netty的 Marshalling解码器时会给
出例程
63总结
本章首先对Java的序列化技术进行了介绍,对Java序列化的缺点进行了总结说明,
在此基础上引出了几款业界主流的编解码框架。由于编解码框架种类繁多,无法一一枚举,
所以重点介绍了当前最流行的几种编解码框架。在后续的章节中我们会对这些编解码框架
的使用进行说明,并给出具体的示例,同时,讲解如何在Nety中应用这些编解码框架。
117第/章
Message Pack编解码
MessagePack是一个高效的二进制序列化框架,它像JSON一样支持不同语言间的数
据交换,但是它的性能更快,序列化之后的码流也更小
由于 Message Pack在业界得到了非常广泛的应用,因此本章将介绍如何利用Net的
Codec框架新增对 Message Pack的支持。
木章主要内容包括:
Message Pack介绍
◎ Message Pack编码器和解码器开发
◎粘包/半包支持
71 Message Pack介绍
Message Pack的特点如下:
◎编解码高效,性能高;
◎序列化之后的码流小;第7章 Message Pack编解码
◎支持跨语言
7.1.1 Message Pack多语言支持
衡量序列化框架通用性的一个重要指标就是对多语言的支持,因为数据交换的双方很
难保证一定采用相同的语言开发,如果序列化框架和某种语言绑定,它就很难跨语言,例
如Java的序列化机制。
MessagePack提供了对多语言的支持,官方支持的语言如下:Java、 Python、Ruby、
maskell, C#、OCam、Lua、Go、C、C++等。更详细的支持列表可以参见它的官网:
http://msgpack,orgo
7.1.2 MessagePack Java AP|介绍
如果使用 Maven工程开发,在你的pom.xml中配置 MessagePack的坐标,如下。
<dependency>
<groupIdorg. msgpack</groupId>
<artifact Id>msgpack</artifactId>
<version>simsgpack version)</version>
</dependency>
它的API使用起来非常简单,编码和解码开发示例如下。
// Create serialize objects
List<string> src= new Arraylist<string>()i
src. add('msgpack")i
srC. add("'kumofs");
src. add( viver )i
MessagePack msgpack new MessagePack()i
/ Serialize
byte[] raw msgpack write(src)i
// Deserialize directly using a template
List<string>dstl= msgPack read(raw, Templates. tList(Templates. TString))i
System. out. printin(astl get(0))i
System. out. printIn(dstl. get(1))i
System, out. println(dstl. get(2))i
Q●Net权威指南(第2版)
7.13 Message Pack开发包下载
Message Pack开发包的下载路径如下,用户可以根据实际情况选择合适的版本。
https://github.com/msgpack/msgpack-java/releases
72 Message Pack编码器和解码器开发
利用Nety的编解码框架可以非常方便地集成第三方序列化框架,Net!y预集成了几种
常用的编解码框架,用户也可以根据自己项目的实际情况集成其他编解码框架,或者进行
自定义。
7.21 Message Pack编码器开发
首先将 msgpack0.6.6jar和 Javassist-3.9.0jar加入到第三方类库中,然后新建
/io/ netty/handler/codec/msgpack目录,代码结构如图7-1所示。
book
A母src
com. phei nett
E io netty handler codec. msgpack
DO Msgpack.javal
package-Into java
E JRE System Library [dk1.7.0_67
DE Referenced Libraries
b e lib
图7- I msgpack编解码框架代码结构
接下来我们看下 msgpack编码器的开发,代码如下。
代码清单7-1 msgpack编码器 Msgpack Encoder
public class MsgpackEncoder extends MessageToByteEncoder<object> I
@override
protected void encode( ChannelHandlerContext argO, Object argl, ByteBuf
arg2)
throws Exception I
120第7章 Message Pack编解码
MessagePack msgpack new MessagePack()i
/ Serialize
byte [] raw msgpack write (arg1)i
arg2, writeBytes(raw)i
MsgpackEncoder继承 Message ToByteEncoder,它负责将 Object类型的POJo对象编
码为byte数组,然后写入到 Byte Buf中。
7.22 MessagePack解码器开发
完成编码器开发之后,下面我们继续看解码器如何编写,代码如下
代码清单72 msgpack解码器 Msgpack Decoder
public class MsgpackDecoder extends MessageToMessage Decoder<ByteBuf>
oVerride
protected void decode( ChannelHandlerContext argo, ByteBuf argl
List<object> arg2)throws Exception I
final byte[] array
final int length argl. readableBytes()i
rray new byte [length]i
argl getBytes(argl. readerIndex(), array, 0, length)i
MessagePack msgpack new MessagePack();
arg2. add (ms gpack, read (array));
首先从数据报argl中获取需要解码的byte数组,然后调用 MessagePack的read方法
将其反序列化为 Object对象,将解码后的对象加入到解码列表arg2中,这样就完成了
MessagePack的解码操作
7.2.3功能测试
完成编解码器开发之后,我们以Nett原生的Echo程序为例,进行测试。对Echo进
行简单改造,传输的对象由字符串修改为POJO对象,利用 MessagePack对POJO对象进
行序列化
121Ne权威指南(第2版)
客户端代码清单如下。
代码清单7-3 Echoclient
public class Echoclient i
private final String hosti
private final int port;
private final int sendNumberi
public Echoclient(String host, int port, int sendNumber)
this host hosti
this port porti
this. sendNumber sendNumberi
public void run() throws Exception I
/ Configure the client
EventLoopGroup group new NioEventLoopGroup ()i
try t
Bootstrap b= new Bootstrap()i
b group(group). channel(NioSocket Channel class)
option(ChannelOption. TCP NODELAY, true)
option( ChannelOption. CONNECT TIMEOUT MILLIS, 3000)
handler(new ChannelInitializer<socket Channel>()(
@Override
public void init Channel(Socketchannel ch)
thr。 wS Exception t
ch pipeline().addLast("msgpack decoder",new
MsgPackDecoder())i
chpipeline (). addLast("msgpack encoder", new
MsgPackEncoder())
chpipeline(), addLast
new EchoclientHandler(sendNumber))i
});
/代码省略
代码清单7-4 Echoclienthandler
public class EchoClientHandler extends ChannelHandlerAdapter I
private final int sendNumber
public EchoclientHandler(int sendNumber) i
this. sendNumber sendNumber
122·第7章 Message Pack编解码
oVerride
public void channelActive( ChannelHandlercContext ctx)(
UserInfo [ infos UserInfo()i
for (UserInfo infoE infos)
ctx. write (infoe)i
ctx, flush();
private UserInfo [l UserInfo()
UserInfo [i userInfo new UserInfo [sendNumber];
UserInfo userInfo null:
for (int i =0; i< sendNumber ii++)
userInfo new UserInfo ()i
userinfo。. staGe(i)
userInfo setName("ABCDEFG --->"t i)i
userInfos [i] userInfo;
return userInfo
oVerride
public void channelRead(ChannelHandlerContext ctx, Object msg)
throws Exception I
System. out. println(Client receive the msgpack message msg)i
ctx. write(msg);
override
public void channelReadcomplete( ChannelHandlerContext ctx) throws
Exception t
ctx. flush()i
服务端代码与客户端类似,请参考书中附带的源码。
客户端运行结果如图7-2所示。
123·Net!y权威指南(第2版)
<terminated Echoclient [Java Application] C\Program Filesvavaldk170-67
Client receive the sgpack message: [0, ABCDEF6---0"]
Client receive the msBpack message [e,"ABCDEFG
Client receive the msgpack message [0, ABCDEFG --->0
Client receive the msgpack message [0, ABCDEFG---)0"]
client receive the msgpack message [0,ABCDEFG--->0"]
Client receive the msgpack message [a, ABCDEFG---)0
图7-2客户端运行结果
服务端运行结果如图7-3所示。
<terminated- Echo Server Dava Application] C Program Files avajdk1 7.06
Server receive the msgpack message [O,"ABCDEFG--->0"
Server receive the msgpack message [0, "ABCDEFG--->0"
Server receive the sgpack message [0, ABCDEFG--->0
Server receive the msgpack message [0, ABCDEFG -)a"1
Server receive the msgpack message [e,"ABCDEFG ->e
Server receive the msgpack message [e,"ABCDEFG
图7-3服务端运行结果
至此, MessagePack编解码框架开发和测试完成。细心的读者可能发现了一个问题:
测试代码中并没有考虑TCP粘包和半包的处理。下面我们模拟粘包的场景,看上述测试
代码能否运行正确——链路建立成功之后,客户端批量发送1000条消息,运行结果如图
7-4所示。
however plava4phm。 CAProgram Filesyavaljdk1706mmm(41月20日上年什121
Server receive the msgpack message [@, ABODEFG--2e1
48, 2014 11:32:56 k4 com phei netty codec. msgpack EchoserverHandler exceptioncaught
Ht Expected exception fro dowristheaa
11I0 xception:盘喔有国话还一个的确
at sun nio, ch, SacketDispatcher. reade( Native Nethod
atsn,n1o,ch。S。 ketDispatche”,red( socketDispatcher,1y43
at sun, nio, ch, IovtiL, readEntoNlative Buffer(Ioutil, iaa: 223)
at sun nio ch. IoUti l read( IDUtil.ava: 192)
at sunnio, ch. SocketchannelImpl, read (SocketchannelInpls iava: 379)
at io netty buffer. UnpooledunsafeDirectBytebuf setBytes(UnpooledUnsafeDirectEyteBuf. ava:446
at io netty buffer Abstrac tByteBut. writebytes(abstractByteBut lav:871)
at io netty channel, socket. flo. Niosocketchannel doReadaytes(Niosocketchanne 1, iava: 208)
at ia netty channel, nio. AbstractNioByteChannelsioByteUnsafe read(abstractNioBytechennel. iaa: 119)
at io, netty, channel. nfo.NioEventLoop protessSelectedkey(NiotventLoop.ava:485)
at io, netty channel nio. MioEventLoop, processselectedkeysoptisdzedoEventLogp, 10va:523
at ie, netty charnel nie. NloE Loop run(RioE ventLoop, iava: 346)
at to netty, util. concurrent, single ThreadEventExecutor45 run(single ThreadEventExecutor iava: 794)
at java. lang Thread, run(Thread. 745)
Server receive the impack message [@,ABODEFG-*2e]
Server receive the asgpack message [16,"ABODEFG---)16"1
Server receive the attack酣红:6
图7-4粘包场景下测试结果
因为没有考虑粘包/半包的处理,所以我们开发的 Message Pack编解码框架还不能正常
工作,下面的73节将利用Nety的编解码特性,提供对粘包/半包场景的支持。
7.3粘包/半包支持
在前面的章节中介绍到了粘包/半包的解决策略,其中最常用的就是在消息头中新增
124第7章 Message Pack编解码
报文长度字段,利用该字段进行半包的编解码。
下面我们就利用Net提供的 Length FieldPrepender和 Length Field Based Frame Decoder,
结合新开发的 Message Pack编解码框架,实现对TCP粘包/半包的支持
下面我们对客户端和服务端进行改造,代码如下
代码清单7-4 Echo Client2客户端代码片段
public void run () throws Exception t
/ Configure the client
EventLoopGroup group= new NioEventLoopGroup()i
try t
Bootstrap b= new Bootstrap ()i
b group(group). channel(NioSocketChannel. class)
option(Channeloption. TCP NODELAY, true
option(Channeloption, CONNECT TIMEOUT MILLIS, 3000)
handler(new ChannelInitializer<socketchanne1>()i
@Override
public void init Channel(Socket Channel ch)
throws Exception t
ch pipeline().addLast("frameDecoder",new
LengthFieldBasedFrameDecoder(65535, 0, 2,0, 2))i
h pipeline().addLast("msgpack decoder", new
MsgpackDecoder())i
chpipeline().addLast( frameEncoder,new
LengthFieldPrepender(2));
ch pipeline().addLast("msgpack encoder",new
MsgPackEncoder())i
ch pipeline().addLast(
new EchoclientHandler(sendNumber))i
})
在 MessagePack编码器之前增加 Length FieldPrepender,它将在 Byte Buf之前增加2个
字节的消息长度字段,其原理如图7-5所示。
=+================
I HELLO WORLD" I
+0xoooC HELLO, WORLD
+=--
=-+
+
图7-5 Length Field Prepender原理示意图
在 MessagePack解码器之前增加 LengthField Based Frame Decoder,用于处理半包消息,
·125·Ne权威指南(第2版)
这样后面的 Msgpack Decoder接收到的永远是整包消息。它的工作原理如图7-6所示。
BEFORE DECODE (14 bytes)
AFTER DECODE (12 bytes)
+----------------+
Length I Actual Content
Actual Content
0x00oc I"HELLO, WORLD I
I "HELLO, WORLD T
+!+
图7-6 LengthFieldBasedFrameDecoder工作原理图
EchoServer v2服务端代码改造如下:
代码清单7-5 EchoServerv2服务端代码片段
public void run() throws Exception i
/ Configure the server
EventLoopGroup acceptorGroup new NioEventLoopGroup ()i
EventLoopGroup IOGroup= new NioEventLoopGroup()i
try t
ServerBootstrap b= new ServerBootstrap()i
b, group(acceptorGroup, IOGroup)
channel(Nioserver Socket Channel. class)
option(ChannelOption SO BACKLOG, 100)
handler (new LoggingHandler(LogLevel. INEO))
childHandler(new ChannelInitializer<socketchanne1>()t
oVerride
public void initChannel(Socket Channel ch)
throws Exception
ch pipeline(), addLast("frameDecoder",new
LengthFieldBasedFrameDecoder(65535,0, 2,0, 2))i
ch pipeline(). addLast("msgpack decoder",new
MsgpackDec。dex())
ch pipeline(),addLast("frameEncoder,new
LengthFieldPrepender(2))i
ch pipeline(). addLast("msgpack encoder",new
MsgpackEncoder());
h pipeline(). addLast(
new EchoServerHandler ())i
});
再次测试下,链路链接成功之后,客户端批量发送1000条消息,服务端接收到之后
原路返回客户端,测试结果如下。
·126·第7章 MessagePack编解码
服务端运行结果如下。
Server receive the msgpack message [0,"ABCDEEG --->01
Server receive the msgpack message [l,"ABCDEFG --->11
Server receive the msgpack message [2,"ABCDEFG --->2"]
Server receive the msgpack message [3, ABCDEFG --->31
Server receive the msgpack message [4,"ABCDEFG --->4"]
Server receive the msgpack message [5,ABCDEFG --->5"J
Server receive the msgpack message [6,ABCDEFG --->6"
Server receive the msgpack message [7,"ABCDEFG--->71
Server receive the msgpack message [8, ABCDEFG --->81
//中间结果省略...
Server receive the msgpack message [8, ABCDEFG --->1000]
客户端运行结果如下。
Client receive the msgpack message [0,"ABCDEFG --->01
Client receive the msgpack message [l, ABCDEFG --->11
client receive the msgpack message [2,"ABCDEFG --->21
Client receive the msgpack message [3,"ABCDEFG --->3"]
Client receive the msgpack message :[4,"ABCDEFG --->4
Client receive the msgpack message [5,"ABCDEFG
5"]
Client receive the msgpack message [6,"ABCDEFG
>6
client receive the msgpack message [7,"ABCDEFG --->7"
Client receive the msgpack message [8,"ABCDEFG --->8"]
//中间结果省略..,,
Client receive the msgpack message [8,"ABCDEFG --->10001
测试结果表明,利用Net!y的半包编码和解码器 Length FieldPrepender和
Length Field Based FrameDecoder,可以轻松地解决TCP粘包和半包问题。
4总结
本章首先对 MessagePack序列化框架进行了讲解,然后利用Nety提供的编解码框架
扩展实现了对 MessagePack编解码的支持
最后结合Nety提供的半包编码和解码器, MessagePack编解码框架实现了对TCP粘
包和半包的支持。后续章节,我们还将专门对 LengthFieldPrepender和
Length Field Based Frame Decoder的工作原理进行详细讲解
127第8章
Google Protobuf编解码
Google的 Protobuf在业界非常流行,很多商业项目选择 Protobuf作为编解码框架,这
里一起回顾一下 Protobuf的优点。
(1)在谷歌内部长期使用,产品成熟度高;
(2)跨语言、支持多种语言,包括C++、Java和 Python
〔3)编码后的消息更小,更加有利于存储和传输:
(4)编解码的性能非常高
(5)支持不同协议版本的前向兼容;
(6)支持定义可选和必选字段
本章主要内容包括:
◎ Protobuf的入门
◎开发支持 Protobuf的Net服务端
◎开发支持 Protobuf的 Netty客户端
◎运行基于 Netty开发的 Protobuf例程第8章 Google Protobuf编解码
8.1 Protobuf的入门
Protobuf是一个灵活、高效、结构化的数据序列化框架,相比于XML等传统的序列
化工具,它更小、更快、更简单。 Protobuf支持数据结构化一次可以到处使用,甚至跨语
言使用,通过代码生成工具可以自动生成不同语言版本的源代码,甚至可以在使用不同版
本的数据结构进程间进行数据传递,实现数据结构的前向兼容。
下面我们通过一个简单的例程来学习如何使用 Protobuf对POJO对象进行编解码,然
后以这个例程为基础,学习如何在Nety中对POJO对象进行 Protobuf编解码,并在两个
进程之间进行通信和数据交换。
8.1.1 Protobuf开发环境搭建
首先下载 Protobuf的最新 Windows版本,网址如下:
http://code.googlecom/p/protobuf/downloads/detail?name-protoc-2.5.0-win32.zip&can=2&q
对下载的 protoc-2..0-win32.zip进行解压,解压后的目录如图8-1所示。
ni netty protobuf protoc-2.5.0-win32
a国 readme.txt
图8-1 Protobuf解压后的目录
S、小 rotc. exe工具主要根据 proto文件生成代码,下面我们以商品订购例程为例,定义
SubscribeReq proto和 Subscriberesp proto,数据文件定义如下。
◎ Subscribe Req proto,如图8-2所示。
5 abaerabeReq. prata记事车
文件①)编量①)格式)查看帮助
package netty:
option java package -"can phei netty. codeeprotobuF";
option java outer classname -5ubscribeReqPreto":
ssage subscribeReqt
required int32 subReqID-1:
equired string
quired string produc tHame -a:
repeated stril
图8-2 SubscribeReq proto文件定义
129Net杈威指南(第2版)
SubscribeResp proto,如图8-3所示。
文伟①编辑)格式@查看的帮助a
package netty:
ption java package -com-phei.netty, codecprotobuf"=
option jaua outer elassnane -"Sub scribe RespProte"R
酸 ssage SubscribeRs
required int32 subReqID-t
required int3 respcode-2:
required string de
图8-3 SubscribeResp proto文件定义
通过 protoc. exe命令行生成Java代码,如图8-4所示。
H: \ava\io\netty\protobuf \protoc-2.5-0-win32)
:Navanio'\netty\protobuf \protoc-25.0-win32>protoc.exe -java out- \sre.\nett
\ubscribe Reg. prot
: Gava\i" netty\protobuf" protoN-2.5,日win32》
图8-4通过 protoc.exe工具生成源代码
将生成的POJO代码 Subscribereq proto java和 SubscribeResp Proto java复制到对应的
Eclipse工程中,目录示例如图8-5所示
com. Phe1. natty
±出
由
basic
出bi
chat
日曲
由
*0SubseribeReqjava
+J SubseribeResp, java
+2 Subscri beRespProtojava
出 serializable
三母nett
t- SubReqCli ent java
D Subl
handley
D SubReqServer java
+D SubReqServerHandlarjava
+ n PerformTestUserInfo, java
①r
图8-5将生成的POJO代码复制到源工程中
130第8章 Google Protobuf编解码
我们发现代码编译出错,原因是缺少 protobuf-java-2.5.0jar包,从 Google官网下载后
将其复制到lib目录后编译到引用类库中,如图8-6所示。
日田:am.phei.net
击出
出 basic
±出cha
e eod
自 SubseribeReg javs
D SubscribeResp java
ebnf
田
B pie
JRE System Library [j
日画 Referenced libr ari电B
田回 protobuf-j250j
日色1b
anetty-al1-5.0,0, Alpha1.j
protobuf-java-2,5.0. jar
图8-6编译 Protobuf工程
到此为止, Protobuf开发环境已经搭建完毕,接下来将进行示例开发。
8.1.2 Protobuf编解码开发
Protobuf的类库使用比较简单,下面我们就通过对 Subscribereq proto进行编解码来介
绍 Protobuf的使用。
代码清单8-1 Protobuf入门 TestSubscribe Proto
12, public class Test Subscribereqproto t
13
14
private static byte[] encode( Subscribereqproto. SubscribeReq req)(
return reg. toByteArray()i
16
17
18
private static SubscribeRegProto, SubscribeReq decode(byte[l body
19
throws InvalidProtocolBufferException t
20
return SubscribeRegProto. Subscribereg parseFrom(body)i
21
22
23
private static SubscribeReqProto. SubscribeReq create SubscribeReq()t
·131·Netty权威指南(第2版)
24
SubscribereqProto. SubscribeReg Builder builder= SubscribeReqProto
Subscriberea
25
newBuilder(i
26
builder. setSubReqID (1)i
27.
builder. setUserName ("Lilinfeng")i
∠,
builder. setProductName("Netty Book")i
29.
List<string> address new ArrayList<>(i
30
address. add("NanJing YuHuaTai)i
31,
address. add("BeiJing LiuLichang")i
32
address. add("ShenZhen Hong ShuLin)i
33,
builder, addAllAddress(address)i
34,
return builder, buildoi
35
36
37
38
★@ param args
39
throws InvalidProtocolBufferException
40
41
public static void main(String[] args)
42
throws InvalidProtocolBufferException i
43
Subscribereqproto. SubscribeReg req createSubscribeReg ()i
44
System. out. println("Before encode reg toString())i
45
Subscriberegproto, Subscribereg reg2= de code(encode(reg))i
46
System, out. println(After decode : reg tostring())i
47
System. out. println("Assert equal:
+reg2equals(req))i
48
4
我们首先看如何创建 Subscribereq Proto. SubscribeReq实例,第24行通过 SubscribeR
Proto. Subscribereq的静态方法 new builder创建 Subscribereq proto. Subscribe req的 Builder
实例,通过 Builder构建器对 Subscribereq的属性进行设置,对于集合类型,通过
addAllXXXO方法可以将集合对象设置到对应的属性中
编码时通过调用 Subscribe proto. Subscribereq实例的 to ByteArray即可将
Subscribe reg编码为byte数组,使用非常方便。
解码时通过 Subscribereq proto. Subscribereq的静态方法 parse From将二进制byte数组
解码为原始的对象
由于 Protobuf支持复杂POJO对象编解码,所以代码都是通过工具自动生成,相比于
传统的POJO对象的赋值操作,其使用略微复杂一些,但是习惯之后也不会带来额外的工
·132·第8章 Google Protobu编解码
作量,主要差异还是编程习惯的不同。
Protobuf的编解码接口非常简单和实用,但是功能和性能却非常强大,这也是它流行
的一个重要原因。
下个小节我们将执行 TestSubscribe Req proto,看它的功能是否正常
8.1.3运行 Protobuf例程
我们运行上一小节编写的 TestSubscribeReq Proto程序,看经过编解码后的对象是否和
编码之前的初始对象等价,代码执行结果如图8-7所示。
Problems 6 Javadoc D, Declaration+ Search e Console 3 SSPl
<terminated) TestSubseribeReqProto [Java ApPlication] E: \Progre Files
Before encode subReqID: 1
userName:"L⊥ intenD
prague tName:"MettγBo。
address: Nanu ing YuHuaTai
address: BEijIng LiuLichang"
address: shenzhen HondshuL inF
Atter decode: surE工D:1
userName: L1linteng
productName: Netty Book
adde吕:" Nanu ing YuHuaTai王
address: BeiJing Liulichang
address: Shen Zhen HongshuLin"
ex七ec1:-->tEu
图8-7 Protobuf编解码运行结果
运行结果表明,经过 Protobuf编解码后,生成的 Subscribe proto. Subscribe Req与编
码前原始的 SubscribeReqproto. SubscribeReq等价。
至此,我们已经学会了如何搭建 Protobuf的开发和运行环境,并初步掌握了 Protobuf
的编解码接口的使用方法,而且通过实际demo的开发和运行巩固了所学的知识。从下
节开始,我们将学习使用Net!的 Protobuf编解码框架。
82Net!y的 Protobuf服务端开发
我们仍旧以商品订购例程作为demo进行学习,看看如何开发出一个 Protobuf版本的
图书订购程序
·133·Nety权威指南(第2版)
8.2.1 Protobuf版本的图书订购服务端开发
对 SubReq server进行升级,代码如下
代码清单8-2 Protobuf版本图书订购代码 SubReq server
20. public class SubReqServer
21
public void bind(int port) throws Exception i
22.
//配置服务端的ⅣIo线程组
23
EventLoopGroup bossGroup= new NioEventLoopGroup()i
24
EventloopGroup workerGroup new NioEventLoopGroup()i
25,
try
26
ServerBootstrap b= new ServerBootstrap()i
27.
b group(bossGroup, workerGroup)
28.
channel(NioServerSocketChannel. class)
29
option(Channeloption, SO BACKLOG, 100)
30
handler (new LoggingHandler(LogLevel. INFO))
31
childhandler(new ChannelInitializer<socketchanne1>()(
32
oVerride
33.
public void initchannel(Socketchannel ch)(
34
ch pipeline().addLast(
new ProtobufVarint Decoder()
ch pipeline().addLast
37
new ProtobufDecoder
38
SubscribeRegProto, SubscribeReg
39
getDefaultInstance()))i
40. ch pipeline(). addLast(
41
new protobufvarint32LengthEieldPrepender())i
42
chpipeline(). addLast (new ProtobufEncoder())i
43
ch, pipeline(), addLast(new SubReqserverHandler())i
44
45
});
46
47
/绑定端口,同步等待成功
48
Channelfuture f
bind (port), sync()i
49
50
//等待服务端监听端口关闭
f channel(). closeFuture(). sync ()i
52,
I finally i
53.
//优雅退出,释放线程池资源
54
bossGroup. shutdownGracefully(
55
workerGroup. shutdownGracefully()i
134·第8章 Google Protobuf编解码
56
7
58
59. public static void main(String[] args) throws Exception
60
int port= 8080;
61
if (args ! null & args, length > 0)i
62
try i
63
port =Integer, valueof(args[o])i
64
A catch (Number FormatException e) t
65,
/采用默认值
66
67
68
new SubReqserver().bind(port)i
69
70.}
第34行首先向 ChannelPipeline添加 Protobutvarint32 Frame Decoder,它主要用于半包处
理,随后继续添加 ProtobufDecoder解码器,它的参数是com. google protobuf. MessageLite,实
际上就是要告诉 ProtobufDecoder需要解码的目标类是什么,否则仅仅从字节数组中是无
法判断出要解码的目标类型信息的。
下面我们继续看 SubReqserver Handler的实现
代码清单8-3 Protobuf版本图书订购代码 SubReqServerHandler
11. Sharable
12. public class SubRegServerHandler extends ChannelHandlerAdapter t
13.
14
override
15
public void channelRead (ChannelHandlerContext ctx object msg)
16.
throws Exception t
SubscriberegProto. Subscribereq
red
(SubscribeReqproto
Subscribereq)msg:
18,
if ("Lilinfeng ". equalsIgnoreCase(reg. getUserName()))[
19
System. out. println("Service accept client subscribe reg:
20
+ reg. tostring()+"])i
21.
ctx. writeAndFlush(resp (reg. getSubReqID()))i
22.
23
24
private SubscribeRespProto SubscribeResp resp(int subReqID)i
26
SubscribeRespProto, SubscribeResp Builder
milder
135Netty权威指南(第2版)
SubscribeRespproto. Subscriberesp
27
newBuilder()
28.
builder. setSubReqID(subReqID)i
29.
builder. setRespCode(0)i
30
builder set Desc("Netty book order succeed, 3 days later, sent to the
designated address")i
31
return builder. build()i
32
33.
34
@Override
35
public void exceptionCaught(ChannelHandler Context ctx, Throwable
cause) I
36
cause, printstackTrace()i
37,
ctx. close();//发生异常,关闭链路
38.
39,
由于 ProtobufDecoder已经对消息进行了自动解码,因此接收到的订购请求消息可以
直接使用。对用户名进行校验,校验通过后构造应答消息返回给客户端,由于使用了
Protobufencoder,所以不需要对 SubscribeResp Proto. SubscribeRs进行手工编码。
下个小节我们继续看客户端的代码实现。
822 Protobuf版本的图书订购客户端开发
对订购请求消息使用 Protobuf进行消息编解码。
代码清单8-4 Protobuf版本图书订购代码 SubReqclient
20. public class SubRegclient
21
22
public void connect(int port, string host) throws Exception
23.
//配置客户端NIO线程组
24
EventLoopGroup group new NioEventloopGroup()i
25.
try t
26
Bootstrap b= new Bootstrap(
27
b group(group). channel(NioSocket Channel class)
28,
option( ChannelOption TCP NODELAY, true
29
handler (new ChannelInitializer<socketChannel>() f
30
override
public void initchannel(SocketChannel ch)
136·第8章 Google Protobuf编解码
32
throws Exception t
33
ch pipeline(), addlast
34
new Protobufvarint 32 Frame Decoder())i
ch pipeline(), addlast(
36
new Protobuf Decoder
37,
SubscribeRespProto. Subscriberesp
38
getDefaultInstance())i
39
ch pipeline(). addLast
40
new ProtobufVarint32LengthFieldPrepender())i
41,
ch pipeline(). addLast(new ProtobufEncoder ())i
42
chpipeline(). addLast(new SubReqclientHandler())i
43
44
});
45
46
//发起异步连接操作
47
Channelfuture f=b connect (host, port). sync(i
48
49
/等待客户端链路关闭
50.
f channel(). closeFuture(). sync()i
51
i finally i
52
/′优雅退出,释放NIo线程组
53
group. shutdownGracefully()i
54
55
56
57,
58
param args
59
@throws Exception
60
61,
public static void main(String[] args) throws Exception
62
int port =8080
63,
if (args ! null & argslength >0)
64
try
65
port Integer valueof(args[0])i
66,
1 catch (Number FormatException e)
67
//采用默认值
68
70.
new SubRegclient(). connect(port, 127.0.0.1")i
71
72.}
137Net!y权威指南(第2版)
需要指出的是客户端需要解码的对象是订购响应,所以第37~38行使用 Subscribers
Proto. Subscribers的实例做入参。
代码清单8-5 Protobuf版本图书订购代码 SubReqclient handler
13. public class SubReqclientHandler extends ChannelHandlerAdapter
14
15.
16,
Creates a client-side handler
17
18
public SubRegclientHandler() i
19
20.
21,
override
22
public void channelActive(ChannelHandlerContext ctx)i
23
for (int i=0; i<10: 1++)I
24
ctx. write(subReq(i))i
25
26
ctx flusher
27
28.
29,
private SubscribeReqProto SubscribeReq subReq(int i)
30
SubscribeRegProto. SubscribeReq Builder
builder
SubscribeReqProto. Subscribereg
31
newBuilder()i
32
builder set subReqID(i)i
33
builder. setUserName ("Lilinfeng")i
34,
builder. setProductName("Netty Book For Protobuf")i
35
List<string> address new Arraylist<>()i
36
address. add( "NanJing YuHuaTai")
37
address. add ("BeiJing Liuli chang")i
38
address. add("ShenZhen Hong ShuLin)i
39
builder. addAllAddress(address)i
40
return builder. build()
41
42
43,
override
44,
public void channelRead(Channel HandlerContext ctx, Object msg)
45
throws Exception i
46.
System. out. println("Receive server response [" msg +")i
47
48
49
@Override
·138·第8章 Google Protobuf编解码
50
public void channelReadComplete( ChannelHandlerContext ctx) throws
Exception
51
ctx. flush()
52
53
54
oVerride
55
public void exceptionCaught(ChannelHandlerContext ctx, Throwable
cause) f
56
cause printstackTrace()i
57.
ctx. close()i
58
59.
客户端接收到服务端的应答消息之后会直接打印,按照设计,应该打印10次。下面
我们就测试下 Protobuf的服务端和客户端,看它是否能正常运行。
8.2.3 Protobu版本的图书订购程序功能测试
分别运行服务端和客户端,运行结果如下
服务端运行结果如下。
Service accept client subscribe req [subReqID: 0
userName: linfeng
productName: Netty Book For protobuf
address: NanJing YuHuaTai
address:Beijing LiuLi Chang
address: "ShenZhen Hong shulin
Service accept client subscribe reg subReqID: 1
userName: "Lilinfeng
productName: " Netty Book For Protobuf
address: NanJing YuHuaTai"
address: BeiJing LiuLichang
address: ShenZhen Hong shuLin
Service accept client subscribe reg: subReq ID: 2
userName: Lilinfeng
productName: Netty book For Protobuf
address:NanJing YuHuaTai
address: "BeiJing LiuLiChang
address: "ShenZhen Hong shulin"
139·Nety权威指南(第2版)
//中间省略部分代码……
Service accept client subscribe req: subReqID: 9
userName: "Lilinfeng
productName: " Netty book For Protobuf
address:"NanJing YuHuaTai
address:" Beijing LiuLichang
address: "ShenZhen HongshuLin
客户端运行结果如下。
Receive server response [subReqID: 0
respCode: 0
desc: "Netty book order succeed, 3 days later, sent to the designated address
Receive server response subRegID: l
respCode: 0
desc: Netty book order succeed, 3 days later, sent to the designated address
Receive server response [ subReqID: 2
//中间省略部分代码…
respCode: 0
desc: " Netty book order succeed, 3 days later, sent to the designated address
Receive server response subReqID: 9
respCode: O
desc: " Netty book order succeed 3 days later, sent to the designated address
运行结果表明,我们基于Net! Protobuf编解码框架开发的图书订购程序可以正常工
作。利用Nety提供的 Protobuf编解码能力,我们在不需要了解 Protobuf实现和使用细节
的情况下就能轻松支持 Protobuf编解码,可以方便地实现跨语言的远程服务调用和与周边
的异构系统进行通信对接。
83 Protobuf的使用注意事项
ProtobufDecoder仅仅负责解码,它不支持读半包。因此,在 ProtobufDecoder前面,
一定要有能够处理读半包的解码器,有以下三种方式可以选择。
·140·第8章 Google Protobuf编解码
1)使用 Netty提供的 Protobufvarint32 Frame Decoder,它可以处理半包消息
2)继承Net!y提供的通用半包解码器 Length FieldBasedFrame Decoder;
3)继承 Byte ToMessage Decoder类,自己处理半包消息。
如果你只使用 ProtobufDecoder解码器而忽略对半包消息的处理,程序是不能正常工
作的。以前面的图书订购为例对服务端代码进行修改,注释掉 Protobufvarint32 Frame
Decoder,代码修改如图8-8所示。
bgroup(bossGroup, workerGroup)
channel(NioServerSocketchannel. class)
option〔 channe10pti。n. SO BACKLOG,169)
handler(newL。 ggingHand1er《L。 gLove1.INF0)
childHandler(new ChannelInitializer<socket Channe1>(
OVerride
ublic void initChannel(socket Channel ch)(
// ch pipeline().addLast(
// new ProtobufVarint32FrameDecoder());
chpipeline().addLastd
new ProtobufDecoder(
SubseribeReqproto Subs cribeReq
a getDefauLtInstance O)));
chpipeline(, addLast(
neh
Protobufvarint32Length FieldPrepender(),
ch pipeline(). addLast(new ProtobufEncoderO))
chpipeline(). addLast(new SubReqServerHandler())3
图8-8注释掉 Protobufvarint32 Frame Decoder
运行程序,结果如图8-9所示,运行出错
at 10.netty handler codec. Message ToHessage Decoder channe lRead( Message ToMessaeDecoder- ava: g message tag had invalid wire tYpe.
at 10, nettY channel Channe I Handler Invoker tt il. 1 nvokechanne lReadNow (Channe 1 Handler InwokerUtil java: 74)
at 10. netty channel. Default Channe lHandler Invoker invokeChannel Fead(DetaultChanne lHandlerInvoker, ieva: 130)
at 10. netty channel. DetaultChnnne I Handlercontext fireChanne l Read iDetault channe I context. ava: 320)
at 10. netey channel DetaultChenneIPipeline, tirechanne I Read (petaultchanneIPapeline-JavA: B46)
当10,ny.ch感ne⊥,n10, ahgrfRcEH1 oBytechanne15N1 Byeetnsate,Ed(是上 cEmetNioBytechanne1,1v1271
盘tie, netty. chenne1.BL⊙. NioEvenels。p,pE⊙ce图 BelectedRey( NioEveneli。oP,)u:45
at 10. metty channe L n1o. N1oEventLODp pEoceBBSelectedkeyaoptami ed INaoEvent LoOP.ava:452)
t10,ty. chann吧1,1, N1oEventLODE,un( NsaEventL·1w图:346)
at 10. nctt], util. concurrent.s1nglcThrcadEvent+5.un(sinqleThreadtventExecutoE, Java: 791)
at Java, lang- Thread. run I Thread. ]ava: 741)
Caused by: com. google. protobut IwvalldProtoco lBurrerException: Protocol message tag had invalid vice type
at com. google. protcbut IrvalidProtoco 1ButterException, imvalidtiteTypei InvnlidProtocoLButterException, ion: 99)
at comm. google. ptot cbuf. UtknovnF ieldsetsBuilder-mergeFleldFron(UaknownFieldset. ava: 498)
at con,9ogl世, protobut, Generated! essage- parseUnkne wnE1eld( Gener色d色吧,v:193
at com phei netty, codec protobuf, Subscr ibeReqProto$ Subscr ibeReq, <init>[SubscribeRegProto. lava: 119)
at com phel, betty, codec protobuf. SubgcribeReqProtof Subscr theReg einit> (subscr ibeRegproto, ava: 102)
at com phe1. netEy codec protobuf. SubseribeReqPretof Sub scr ibe Reqf 1 parsePartinlFrom(Subscr tbeRegProto, java: 181)
at com phei nettv. codee, protebuf, subseribeReqProtof subacr ibe Reaf 1-pnrsePartialFrorm(SubseribeRegProto. inua: 1
tG轴,g世,pthu,t确P面后E·PEPx忘1FE曰(上E七P色E·]va:14王)
at com. google+ procobur Abstract Parser. parseFron(AbstcactParser. avat 176
at eom. google. proobur-AbstEacEParser-parseTEom (AbatEaetParser-Java: 182
at com. google. protobut. Aha trace Parser. pareefrom(AbaGrocEParaeE. lava: 19)
at 10. netty handler codec. protobuf. Protobur Decoder decode PEotoburDecodeE. Java: 114)
at 10. netty handler. codee.protobur-Protobut Deeadier deedee (Protobut
at io netty handler codec. Hesaage ToleasageDecodet channel Read (Message ToHesaage Decoder. ava: 89)
10 fora
图8-9注释掉 Protobuf variant32 FrameDecoder运行出错
·141●Nety权威指南(第2版)
84总结
本章首先介绍了 Protobuf的入门知识,通过一个简单的样例代码开发让读者熟悉了如
何使用 Protobuf对POJo对象进行编解码;在掌握了 Protobuf的基础知识后,讲解如何使
用Nety的 Protobuf编解码框架进行客户端和服务端的开发;最后,对 Protobuf解码器的
使用陷阱进行了说明,并给出了正确的使用建议
在下一章中,我们继续学习另一种序列化技术— Jboss的 Marshalling序列化框架,
它是 Jboss内部使用的序列化框架,Nety提供了 Marshalling编码和解码器,方便用户在
Nety中使用 Marshalling。第9章适用于对 Marshalling框架感兴趣的读者,如果你想直接
学习后面的知识,也可以跳过第9章。
·142·第9章
JBoss Marshalling
编解码
JBoss Marshalling是一个Java对象序列化包,对JDK默认的序列化框架进行了优化,
但又保持跟 Java.1o. Serializable接口的兼容,同时增加了一些可调的参数和附加的特性,
这些参数和特性可通过工厂类进行配置
本章主要内容包括:
Marshalling开发环境准备
Netty的
Marshalling
服务端开发
Netty的 Marshalling客户端开发
◎运行 Marshalling例程
9.1 Marshalling开发环境准备
首先下载相关的 Marshalling类库,由于我们只是用到了它的序列化类库,因此,只
需要下载 jboss-marshalling-1.3.0和joss- marshalling- serial-1.3.0类库即可,下载网址如下:
https://www.jboss.org/jbossmarshalling/downloads
在页面上选择 JBoss Marshalling API和 JBoss Marshalling serial Protocol进行下载,如Netty权威指南(第2版)
图9-1所示。
铝●的仁
Eoss Marshaling APl
1.3.0CR9226kB2011=04-27LGPL
bosg-marshalling-1.2. 0. CR9,ja
Downloads 321
JEoFF Marshalling APIS。ue
1.3.0CR9
11=04-27
bossumarshalling-1,. 0. CR9asourees jar nl
Bownas 193
JBoss Marshalling River Protocol
1.30cR979kB2011-04-27
LGPL
知ssm由面rg=mvr=1.3.0cR9j
Downloads Ra
Boss Marshaling River Protocal Sources
130cR945kE2011-04-27LGP
boss-marshalling-tiver-1,3.0. CR9-sourees Jar
armloads 5
JBoss Marshalling Senat Protocol
130CR968k82011-04-27
boss-marshalling serial-1 3.0 CR9 jar
图9-1 Marshalling类库下载
将下载的类库buld到 classpath中,如图9-2所示。
EE JRE System Library [jdk T0 45]
B REferenced Libraries
A protobuf-java-2.5.UJar
t-ag jboss-marshalling1.3.0.CR9jar
由画 jboss marshallincserial-1.3.0.c9.ja
白@1ib
ajboss-marshalling-1.3.0.CR9jar
jboss-marshillingserial-1.3.0. CR9 jar
a netty-all-5.0.0.Alphal.jar
F protobuf-java-2.5.0.jar
图9-2将 Marshalling添加到引用类库中
Marshalling开发环境搭建完成之后,我们开始学习 Marshalling服务端的开发
92Nety的 Marshalling服务端开发
首先定义POJO对象,由于 JBoss的 Marshalling完全兼容JDK序列化,因此我们继
续使用商品订购例程中定义的 SubscribeReq和 SubscribeRs对象。通过 JBoss提供的序
列化API,对 Subscriber和 Subscribe resp进行编解码。由于Nety对JBos的编解码类
库进行了封裝,下面通过图书订购的实例看看如何使用Net!y的 Marshalling编解码类对消
息进行序列化和反序列化。
服务端开发示例
首先看下服务端启动类的开发,代码如下。
144第9章 J Boss Marshalling编解码
代码清单9-1 Marshalling版本图书订购代码 SubReq Server
18. public class SubRegServer I
19
public void bind(int port) throws Exception
20
//配置服务端的NIo线程组
21
EventLoopGroup bossGroup new NioEventLoopGroup()
22.
EventLoopGroup workerGroup- new NioEventLoopGroup()i
23
try
24
ServerBootstrap b= new ServerBootstrap();
25,
b group(bossGroup, workerGroup)
26,
channel(Nioserver Socketchannel, class)
27,
option ( Channeloption SO BACKLOG, 100)
28
handler(new LoggingHandler(LogLevel. INFO)
29.
childhandler (new Channelinitializer<socketChannel>() t
30
override
31
public void initchannel(Socket Channel ch)
32,
ch pipeline ().addlast
33.
MarshallingcodeCFactory
34
buildMarshalling Decoder ())i
35
ch pipeline(). addlast
36
Marshalling CodeCFactory
37
buildMarshallingEncoder())i
38
h pipeline(). addLast(new SubRegServerHandler())
39
40
})
41
42,
/绑定端口,同步等待成功
43
Channelfuture f =b. bind (port). sync()i
44
45
∥/等待服务端监听端口关闭
46
f channel(). closeFuture(). sync()
47
t finally I
48
//优雅退出,释放线程池资源
49
bossGroup, shutdownGracefully(
50
workerGroup. shutdown Gracefully()i
51
52
53
54
public stat
oid main(String[] args) throws Exception I
55
int port 8080;
56
if (args ! null & args length >0)(
57
try i
145Ne!y权威指南(第2版)
58.
port Integer valueof(args[o]);
59
1 catch (NumberFormatException e)
60
//采用默认值
61
62
3
new SubReqserver(), bind (port)i
64
65
第32~34行通过 Marshalling Code FActory工厂类创建了 Marshalling Decoder解码器,
并将其加入到〔 hannelPipeline中:第35~37行通过工厂类创建 Marshalling encoder编码
器,并添加到 Channelpipeline中。
下面继续看 Marshalling Code CFactory是如何实现的,代码如下。
代码清单9-2 Marshalling版本图书订购代码 Marshalling Code FActory
18. public final class MarshallingCodeCFactory I
19,
20
21
创建 JBOss Marsha1ling解码器 Marsha11 ing Decode
22
23
x areturn
24
public static Marshalling Decoder buildMarshalling Decoder()(
26
final MarshallerFactory marshallerFactory Marshalling
27,
getProvidedMarshallerFactory("serial")i
28
final
Marshalling Configuration
configuration
new
MarshallingConfiguration ()i
29
configuration. setVersion(5);
30,
Unmarshaller Providerprovider new De faul tUnmarshallerProvider(
31
marshallerFactory, configuration)i
32,
MarshallingDecoder decoder
new Marshalling Decoder(provider
1024);
33
return decoder;
34
35
36
创建 JBosS Marshalling编码器 MarshallingEncoder
38,
39
retu
40
146·第9章 J Boss Marshalling编解码
41
public static MarshallingEncoder buildMarshallingEncoder() f
42,
final Marshaller Factory marshallerFactory Marshalling
43
getProvidedMarshallerFactory("serial#)i
44
final
MarshallingConfiquration
configuration
new
MarshallingConfiguration ()i
45
configuration. setversion (5)i
46,
Marshaller Provider provider new De faultMarshallerprovider
47
marshallerFactory, configuration)i
48
MarshallingEncoder encoder new MarshallingEncoder (provider)i
49
return encoder
50
51.}
第26~27行首先通过 Marshalling工具类的 getProvidedMarshaller Factory静态方法获
取 MarshallerFactory实例,参数“ serial”表示创建的是Java序列化工厂对象,它由
jboss-marshalling- serial-1.3.0.CR9jar提供。
第28行创建了 Marshalling Configuration对象,将它的版本号设置为5,然后根据
Marshaller Factory和 Marshalling configuration创建 UnmarshallerProvider实例,最后通过构
造函数创建Net的 Marshalling Decoder对象,它有两个参数,分别是 UnmarshallerProvider
和单个消息序列化后的最大长度。
第42~45行同样是构造 MarshallerFactory和 Marshalling Configuration,第46行创建
Marshaller Provider对象,它用于创建Nety提供的 Marshalling Encoder实例,
Marshalling encoder用于将实现序列化接口的POJO对象序列化为二进制数组。
由于 SubReqserverHandler的实现与第8章例程中的 SubReq Server Handler实现完全相
同,因此这里不再给出源码。
9.3 Netty的 Marshalling客户端开发
首先由客户端发送订购请求消息,为了测试TCP粘包/拆包是否能被正确处理,采取
连续发送10条请求消息的策略。在客户端的 Channel Pipeline中添加 Marshalling Encoder
编码器对POJO对象进行编码。接收服务端应答消息的时候需要对经过 Marshalling序列化
后的码流进行解码,因此也需要添加 Marshalling Decoder,下面我们看下客户端代码的具
体实现。
147Nety权威指南(第2版)
客户端开发示例
首先看客户端启动类。
代码清单9-3 Marshalling版本图书订购代码 SubReqclient
16. public class SubRegClient f
17
public void connect (int portr string host) throws Exception i
19
/配置客户端IO线程组
20
EventLoopGroup group new NioEventLoopGroup ()i
21
try t
22.
Bootstrap b= new Bootstrap ()i
23.
b group (group). channel(NioSocketchannel, class)
24
option(Channeloption TCP NODELAY, true)
25
handler(new ChannelInitializerssocketChannel>()t
26
override
27,
public void initchannel(Socketchannel ch)
28.
throws Exception i
29
ch pipeline(). addLast
30
Marshallingcodeceactory
31
buildMarshallingDecoder()):
ch. pipeline(). addLast
33
MarshallingcodeCEactory
34
buildMarshalling Encoder())i
35
ch pipeline(). addLast(new SubReqclientHandler())i
36
37
});
38
39
//发起异步连接操作
40
ChannelFuture f =b connect (host, port). sync()i
41
42
//等待客户端链路关闭
43,
f channel().closeFuture(). sync()i
44
I finally
45
/优雅退出,释放IIo线程组
group. shutdownGracefully();
47
48
49
50
51
大@ param args
148第9章 JBoss Marshalling编解码
52
@throws Exception
53.
54
public static void main(string[] args) throws Exception i
55
int port=8080;
56
if (args ! null & args length >0)
57
try
8
port= Integer valueof(args[0])i
59
t catch (Number FormatException e)[
60
//采用默认值
61
62
63
new SubReqclient (). connect(port,127.0.0.1)i
64
65,}
第29~34行分别创建 Marshalling编码器和解码器,并将其添加到 Channelpipeline中。
SubReqclienthandler相比于第8章的例程,仅仅修改了订购应答消息的产品名称,具
体修改如图9-3所示。
private SubscribeReq subReq(int i)
SubscribeReg req new SubscribeReqo:
req. setAddress("NanJing YuHua");
reg.setPhoneNumber"138x××x。
req.setProductName("Netty Book For Marshalling ")
req. setsubReqID(
req. setUserName(Linfeng ")
return req
图9-3构造订购成功应答消息
9.4运行 Marshalling客户端和服务端例程
分别运行图书订购服务端和客户端例程,运行结果如下。
服务端运行结果如下。
Service accept client subscrib reg: SubscribeReg [ subReqID=0, userName=
Lilinfeng, productName=Netty Book For Marshalling, phoneNumber=138xXxXXxXXX
address=NanJing YuHuaTai]
Service accept client subscrib req SubscribeReq [subReqId=l, userName=
·149·Nety权威指南(第2版」
Lilinfeng, productName=Netty Book For Marshalling, phoneNumber=138xxxxXXXKX,
address=NanJing YuHuaTai]l
Service accept client suhscrib reg SubscribeReg subReqID=2, userName=
Lilinfeng, productName=Netty Book For Marshalling, phoneNumber-138xxXXXxxxX
address-NanJing YuHuaTai]]
/此处省略部分代码……
Service accept client subscrib req [Subscribereg [subReqID=9, userName=
Lilinfeng, productName=Netty Book For Marshalling, phoneNumber=138xxxXXXXXX
address=NanJing YuHuaTail
服务端共收到了10条客户端请求消息, subreqld为从0到9,与客户端发送的订购
请求消息完全一致,服务端运行结果正确。
客户端运行结果如下。
Receive server response: [ SubscribeResp [subReqID=0, respCode=0, desc=Netty
book order succeed, 3 days later, sent to the designated address]]
Receive server response SubscribeResp [subReqID-1, respCode-0, desc=Netty
book order succeed, 3 days later, sent to the designated address]]
Receive server response: SubscribeResp [subReqID=2, respCode=0, desc=Netty
book order succeed, 3 days later, sent to the designated address]
//此处省略部分代码
中南潘
Receive server response: ISubscribeResp [ subReqID=9, respCode=0, desc=Netty
book order succeed, 3 days later, sent to the designated address]l
客户端成功收到了服务端返回的10条应答消息, subreqid为从0到9,与服务端发
送的应答消息完全一致,测试表明客户端运行结果正确
由于我们模拟了TCP的粘包/拆包场景,但是程序的运行结果仍然正确,说明 Netty的
Marshalling编解码器支持半包和粘包的处理,对于开发者而言,只需要正确地将 Marshalling
编码器和解码器加入到 ChannelPipeline中,就能实现对 Marshalling序列化的支持。
利用Nety的 Marshalling编解码器,可以轻松地开发岀与 JBoss内部模块进行远程通
信的程序,而且支持异步非阻塞,这无疑降低了基于 Netty开发的应用程序与 JBoss内部
模块对接的难度。
9.5总结
本章介绍了如何使用 Netty的 Marshalling编码器和解码器对POJO对象进行序列化。
150·第9章 JBoss Marshalling编解码
通过使用Net!y的 Marshalling编解码器,我们可以轻松地开发出支持 JBoss Marshalling序
列化的客户端和服务端程序,方便地对接 JBoss的内部模块,同时也有利于对已有使用
Jboss marshalling框架做通信协议的模块的桥接和重用。
从下一章开始,我们将学习如何使用Netr的HTTP协议栈进行HTTP服务端和客户
端的开发。由于HTTP协议目前仍然是各个行业主流的系统间通信协议,因此,Netty的
HTTP协议栈的应用空间非常广泛。
·151·高级篇
Netty多协议开发和应用
第10章HTTP协议开发应用
第11章 WebSocket协议开发
第12章私有协议栈开发
第13章服务端创建
第14章客户端创建第10章
HTTP协议开发应用
HTTP(超文本传输协议)协议是建立在TCP传输协议之上的应用层协议,它的发展
是万维网协会和Internet工作小组IETF合作的结果。HTTP是一个属于应用层的面向对象
的协议,由于其简捷、快速的方式,适用于分布式超媒体信息系统。它于1990年提出,
经过多年的使用和发展,得到了不断的完善和扩展
由于HTTP协议是目前Web开发的主流协议,基于HTTP的应用非常广泛,因此,掌
握HTTP的开发非常重要。本章将重点介绍如何基于Nety的HTTP协议栈进行HTTP服
务端和客户端开发。由于Nety的HTTP协议栈是基于Netty的NO通信框架开发的,因
此,Netty的HTTP协议也是异步非阻塞的。
本章主要内容包括:
◎HTTP协议介绍
0 Netty Http服务端入门开发
◎HTTP+XML应用开发
HTTP附件处理第10章HTTP协议开发应用
101HTTP协议介绍
HTTP是一个属于应用层的面向对象的协议,由于其简捷、快速的方式,适用于分布
式超媒体信息系统。
HTTP协议的主要特点如下。
◎支持 Client/ Server模式;
◎简单——客户向服务器请求服务时,只需指定服务URL,携带必要的请求参数或
者消息体;
◎灵活——HTTP允许传输任意类型的数据对象,传输的内容类型由HTTP消息头
中的 Content-Type加以标记;
无状态——HTTP协议是无状态协议,无状态是指协议对于事务处理没有记忆能
力。缺少状态意味着如果后续处理需要之前的信息,则它必须重传,这样可能导
致每次连接传送的数据量增大。另一方面,在服务器不需要先前信息时它的应答
就较快,负载较轻
10.1.1HTTP协议的URL
Http Url(URL是一种特殊类型的URI,包含了用于查找某个资源的足够的信息)
的格式如下。
http://host[":"portllabspath
其中http表示要通过HTTP协议来定位网络资源host表示合法的Internet主机域
名或者IP地址;por指定一个端口号,为空则使用默认端口80; abs path指定请求资源
的URI,如果URL中没有给出 abs path,那么当它作为请求URI时,必须以“/”的形式
给出,通常这点工作浏览器会自动帮我们完成
10.12HTTP请求消息(Httprequest)
HTTP请求由三部分组成,具体如下。
155·Nety权威指南(第2版)
◎HTTP请求行
◎HTTP消息头;
◎HTTP请求正文。
请求行以一个方法符开头,以空格分开,后面跟着请求的URI和协议的版本,格式为:
Method Request-uri Http-veRsion Crlf
其中 Method表示请求方法, Request-URI是一个统一资源标识符, Http- Version表
示请求的HTTP协议版本,CRLF表示回车和换行(除了作为结尾的CRLF外,不允许出
现单独的CR或LF字符)。
请求方法有多种,各方法的作用如下。
◎GET:请求获取 Request-URI所标识的资源
◎POST:在 Request-URI所标识的资源后附加新的提交数据:
◎HEAD:请求获取由 Request-URI所标识的资源的响应消息报头
◎PUT:请求服务器存储一个资源,并用 Request-URI作为其标识
◎ DELETE:请求服务器删除 Request-URI所标识的资源;
◎ TRACE:请求服务器回送收到的请求信息,主要用于测试或诊断;
CONNECT:保留将来使用;
◎ OPTIONS:请求查询服务器的性能,或者查询与资源相关的选项和需求。
GET方法:以在浏览器的地址栏中输入网址的方式访问网页时,浏览器采用GET方
法向服务器获取资源。例如,我们直接在浏览器中输入http://localhost:8080/netty-5.0.0
如图10-1所示。
380安全训览器6.2
e
←分食★‖htp:// cohost:sg/ety5..0
Lhttp://ocalhost:8080/nettyx+
Failure: 404 Not Found
图10-1通过浏览器访问 Netty Http服务端
·156·第10章HTTP协议开发应用
通过服务端抓包,打印HTTP请求消息头,内容如下。
Get /netty5.0 Http/1.1
Host: localhost: 8080
Connection: keep-alive
User-Agent: Mozilla/5.0(Windows NT 5.1) AppleWebkit/537 1 (KHTML, like
Gecko) Chrome/21.0.1180.89 Safari/5371
Accept: text/html, application/xhtml+xml application/xml: q =0.9,**ig=0.8
Accept-Encoding: gzip, deflate, sdch
Accept-Language: zh-CN, zhi=0.8
Accept-Charset: GBK, utf-8:q=0.7,*;q=0.3
Content-length: 0
我们可以看到第一行请求行使用的是GET方法。
POST方法要求被请求服务器接受附在请求后面的数据,常用于提交表单。GET一般
用于获取/查询资源信息,而POST一般用于更新资源信息。GET和POST的主要区别如下。
(1)根据HTTP规范,GET用于信息获取,而且应该是安全的和幂等的;POST则表
示可能改变服务器上的资源的请求。
(2)GET提交,请求的数据会附在URL之后,就是把数据放置在请求行( request line)
中,以“?”分隔URL和传输数据,多个参数用“&”连接;而POST提交会把提交的数
据放置在HTTP消息的包体中,数据不会在地址栏中显示出来。
(3)传输数据的大小不同。特定浏览器和服务器对URL长度有限制,例如IE对URL
长度的限制是2083字节(2KB+35B),因此GET携带的参数的长度会受到浏览器的限制;
而POST由于不是通过URL传值,理论上数据长度不会受限。
(4)安全性。POST的安全性要比GET的安全性高。比如通过GET提交数据,用户
名和密码将明文出现在URL上。因为1)登录页面有可能被浏览器缓存:2)其他人查看
浏览器的历史记录,那么别人就可以拿到你的账号和密码了。除此之外,使用GET提交
数据还可能会造成 Cross-site request forgery攻击。POST提交的内容由于在消息体中传输,
因此不存在上述安全问题。
请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。常用的
请求报头如表10-1所示。
HTTP请求消息体是可选的,比较常用的HTTP+XML协议就是通过HTTP请求和响
应消息体来承载XML信息的。
·157·Net!y权威指南(第2版)
表10-1HTTP的部分请求消息头列表
名称(KEY)
作用
用于指定客户端接受哪些类型的信息,
Accept
例如: Accept: image/gif,表明客户端希望接受GF图像格式的资源
用于指定客户端接受的字符集。
Accept-Charset
例如: Accept -Charset iso-8859-1,gb2312,如果在请求消息中没有设置这个域,默认是任何字符集都
可以接受
类似于 Accept,但是它用于指定可接受的内容编码。
Accept-Encoding
例如: Accept-Encoding gzip. deflate,如果请求消息中没有设置这个域,则服务器假定客户端对各种
内容编码都可以接受
类似于 Accept,但是它用于指定一种自然语言。
Accept-Language
例如: Accept-Language;zh-cn,如果请求消息中没有设置这个报头域,则服务器假定客户端对各种语
言都可以接受
主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时,如果收到服务器的响应代码为401
Authorization
未授权).可以发送一个包含 Authorization请求报头域的请求,要求服务器对其进行认证
发送请求时,该报头域是必需的,用于指定被请求资源的Internet主机和端口号,它通常是从HTTP
Host
URL中提取出来的
User-Agent
允许客户端将它的操作系统、浏览器和其他属性告诉服务器
Content-Length
请求消息体的长度
表示后面的文档属于什么MME类型。 Servlet默认为 text/plain,但通常需要显式地指定为 text/htm。
Content-T
由于经常要设置 Content-Type,因此 HttpservletresPonse提供了一个专用的方法 setContentType
Connection
连接类型
10.13HTTP响应消息(Httpresponse)
处理完HTTP客户端的请求之后,HTTP服务端返回响应消息给客户端,HTTP响应
也是由三个部分组成,分别是:状态行、消息报头、响应正文。
状态行的格式为: Http-verSion status- Code reason- Phrase CRLF,其中 Http- vErsion
表示服务器HTTP协议的版本,Status-Code表示服务器返回的响应状态代码,
状态代码由三位数字组成,第一个数字定义了响应的类别,它有5种可能的取值。
·158·第10章HTTP协议开发应用
(1)1xx:指示信息。表示请求已接收,继续处理;
2)2xx:成功。表示请求已被成功接收、理解、接受;
(3)3xx:重定向。要完成请求必须进行更进一步的操作;
(4)4xx:客户端错误。请求有语法错误或请求无法实现;
(5)5Xx:服务器端错误。服务器未能处理请求
常见的状态代码、状态描述如表10-2所示。
表10-2HTTP响应状态代码和描述信息
状态码
状态描述
200
OK:客户端请求成功
400
Bad Request:客户端请求有语法错误,不能被服务器所理解
401
Unauthorized:请求未经授权,这个状态代码必须和WwW- Authenticate报头域一起使用
403
Forbidden;服务器收到请求,但是拒绝提供服务
404
Not found:请求资源不存在
500
Internal Server Error:服务器发生不可预期的错误
503
Server Unavailable:服务器当前不能处理客户端的请求,一段时间后可能恢复正常
响应报头允许服务器传递不能放在状态行中的附加响应信息,以及关于服务器的信息
和对 Request-UR所标识的资源进行下一步访问的信息。常用的响应报头如表10-3所示。
表10-3常用的响应报头
名称(KEY)
作用
Location
用于重定向接收者到一个新的位置, Location响应报头域常用于更换域名的时候
Server
包含了服务器用来处理请求的软件信息,与User- Agent请求报头域是相对应的
必须被包含在401(未授权的)响应消息中,客户端收到401响应消息,并发送 Authorization
WWw-Authenticate
报头域请求服务器对其进行验证时,服务端响应报头就包含该报头域
102 Netty Http服务端入门开发
从本节开始我们学习如何使用Netty的HTTP协议栈开发HTTP服务端和客户端应用
159·Nety权威指南(第2版
程序。由于Netty天生是异步事件驱动的架构,因此基于NIOTCP协议栈开发的HTTP协
议栈也是异步非阻塞的。
Nety的HTTP协议栈无论在性能还是可靠性上,都表现优异,非常适合在非Web容
器的场景下应用,相比于传统的 Tomcat、Jety等web容器,它更加轻量和小巧,灵活性
和定制性也更好。
10.2.1HTTP服务端例程场景描述
我们以文件服务器为例学习Nety的HITP服务端入门开发,例程场景如下:文件服
务器使用HTTP协议对外提供服务,当客户端通过浏览器访问文件服务器时,对访问路径
进行检査,检查失败时返回HTTP403错误,该页无法访问;如果校验通过,以链接的方
式打开当前文件目录,每个目录或者文件都是个超链接,可以递归访问。
如果是目录,可以继续递归访问它下面的子目录或者文件,如果是文件且可读,则可
以在浏览器端直接打开,或者通过【目标另存为】下载该文件。
介绍完了样例程序的开发场景,下面我们一起看看如何开发一个基于Nety的HTTP
程序。
10.2.2HTTP服务端开发
首先看下HTTP文件服务器的启动类是如何实现的。
代码清单10-1HTTP文件服务器启动类HttpFileserver
19. public class Httpfileserver t
20.
21
private static final String DEFAULT URL ="/src/com/phei/netty/";
22
23
public void run(final int port, final String url) throws Exception i
24
EventLoopGroup bossGroup new NioEventLoopGroup()i
25
EventLoopGroup wor kerGroup- new NioEventloopGroup()i
26
try i
27
ServerBootstrap b= new ServerBootstrap()i
28,
bgroup(bossGroup, workerGroup)
29
channel(nioserverSocket channel class)
chilaHandler(new ChannelInitializer<socketChannel>()[
160·第10章HTTP协议开发应用
31,
@override
32
protected void initChannel(Socketchannel ch)
33
throws Exception t
34
ch.pipeline().addlast("http-decoder",
35,
new Httprequestdecoder())i
36
ch.pipeline(),addlast(http-aggregator',
37,
new Httpobjectaggregator(65536))i
38
ch.pipeline().addlast("http-Encoder
new HttpresponseencodeR()i
40
ch.pipeline().adalast(http-cHunked",
41
new ChunkedWritehandler())i
42
ch pipeline().addLast ("fileserverHandler
new HttpeileserverhanDler(url))i
44,
45
});
46
Channelfuture future b bind(192.168.1. 102", port). sync()i
47,
System,out, printin("HTP文件目录服务器启动,网址是
whttp://192.168.1.102:
48
+ port url)i
49
future, channel(). closefuture(). sync()i
50
finally i
51
bossGroup. shutdownGracefully()i
52
workerGroup. shutdownGracefully()i
53
54
55
56
public static void main(String[] args) throws Exception
57
int port =8080
58
if (args length > 0)
59
tr
y
60,
port= Integer parseInt(args[o])i
61
t catch (NumberFormatException e) i
62
e printstackTrace()i
63.
64
65
String url= DEFAULT URL
66
if (args length >1
67
url= args[l];
68.
new Httpfileserver().ruN(port, url)i
69
70.}
·161·Netty权威指南(第2版)
首先我们看main函数,它有两个参数:第一个是端口,第二个是HTTP服务端的URL
路径。如果启动的时候没有配置,则使用默认值,默认端口是8080,默认的URL路径是
/src/com/phei/netty/
重点关注第34~43行,首先向Channelpipeline中添加HTTP请求消息解码器,随后,
又添加了 HttpobjectaggreGator解码器,它的作用是将多个消息转换为单一的
FullhttpRequest或者FullhttprespoNse,原因是HTTP解码器在每个HTTP消息中会生成
多个消息对象。
(1) Httprequest/ Http Response
(2)httpcontent:
(3)lasthttpContento
第38~39行新增HTTP响应编码器,对HTTP响应消息进行编码;第40~41行新增
Chunked handler,它的主要作用是支持异步发送大的码流(例如大的文件传输),但不占
用过多的内存,防止发生Java内存溢出错误。
最后添加 Http File Serverhandler,用于文件服务器的业务逻辑处理。下面我们具体看
看它是如何实现的
代码清单10-2HTTP文件服务器处理类HttpfileserverHandler
47. public class HttpfileserverhanDler extends
48,
Simplechannelinboundhandler<fullhttprequest>i
55
override
56
public void messageReceived(ChannelHandlerContext ctx
EullhttprequestrequestthrowsExceptionI
58.
if(! request. get DecoderResult() is Success())t
59
sendError(ctx, BAD REqUEST);
60,
returni
61
62,
if (request. getMethod()!= GET) f
63
sendError(ctx, METHOD NOT ALLOWED)i
64
return:
65
66.
final String uri request getUri()i
67
final String path sanitizeUri(uri)i
68
if (path = null) t
69
sendError(ctx, FORBIDDen);
·162·第10章HTTP协议开发应用
70
returni
71
72
File file= new File(path)i
73
if (file. isHidden()II file exists())f
74
senderror(ctx, NOT FOUND )i
75
return:
76
77
此处代码省略
85
if ( file isFile())
86
sendError(ctx, FORBIDDEN)
87
return
88.
89,
RandomAccessFile randomAccessFile= null;
90
try I
91,
randomaccessfile= new RandomAccessFile(file,"x");//以只读的
方式打开文件
92
I catch (FileNot FoundE xception fnfe) f
93,
senderror(ctx, NOT FOUND)
94
return
95
96
long filelength randomAccessFile length()
97
HttpresponseresponsesnewDefaulthttpresponse(http1
OK)
98.
setContentlength(response, filelength)i
99
setContent TypeHeader(response, file)i
100
if (isKeepAlive(request))[
101
response, headers(). set( CONNECTION,
Httpheaders. Values
KEEP ALIVE):
102
103.
ctx. write(response)i
104
ChannelFuture sendFileFuture:
105
sendFileFuture=ctx. write(new ChunkedFile(randomAccessFile, 0
106,
fileLength, 8192), ctx new Progressive Promise())i
107
sendFileFuture, addlistener(new
ChannelprogressiveFuture
Listener()
142
此处代码省略..
143
private string sanitizeUri(String uri) t
144
try t
145
uri= URLDecoder decode (uri, " UTF-8
146
s catch (UnsupportedEncodingException e)(
147
try t
148
uri= URLDecoder decode (uri "ISo-8859-1")i
163Net!y权威指南(第2版)
149,
s catch (UnsupportedEncodingException el)[
150
throw new Error()i
151
152
153
此处代码省略
159.
uri = uri. replace('/, File. separatorchar)i
160.
if (uri. contains (File separator +''
161,
I uri contains(''+File separator)Luri startsWith("."
162.
II uri endswith(", ")|I INSECURE URI, matcher(uri).matches())[
163
return null
164
165,
return System, getProperty(user, dir")+ File separator uri
166
167
168
private static final Pattern ALLOWED FILE NAME- Pattern
169
compi1e("[A-Za-20-9][-A-Za-20-9\.]+");
170
171
private static void sendlisting (ChannelHandlerContext ctx, File
dir) i
172
Fullhttpresponseresponse
newDefaultfullhttpresponse
(httP 1 1, Oki
173.
response headers () set(CONTENT TYPE,"text/html charset-UTE-8")i
174
StringBuilder buf new StringBuilder()i
此处代码省略
185
buf append ("<li>t: <a href=\"./\">.</a></li>\r\n"
186
for (File f dir.listFiles())i
此处代码省略
194
buf, append("<1i>链接:< a href=V"");
此处代码省略
199
200,
buf append ("</ul></body></html>\r\n")i
201
ByteBuf buffer Unpooled. copiedBuffer(buf, Charsetutil UTF 8):
202.
response content().writeBytes(buffer)
203.
buffer release(;
204
ctx. writeAndFlush(response). adaListener
ChannelFuturelistener CLOSE);
205
206.此处代码省略..
227
首先从消息接入方法看起,第58~61行首先对HTTP请求消息的解码结果进行判断,
如果解码失败,直接构造HTTP400错误返回。第62~65行对请求行中的方法进行判断,
·164·第10章HTTP协议开发应用
如果不是从浏览器或者表单设置为GET发起的请求(例如POST),则构造HTTP405错
误返回。
第67行对请求URL进行包装,然后对 sanitizer方法展开分析。跳到第145行,首
先使用JDK的 java. net. URLDecoder对URL进行解码,使用UTF-8字符集,解码成功之
后对URI进行合法性判断,如果URI与允许访问的URI一致或者是其子目录(文件),则
校验通过,否则返回空。第159行将硬编码的文件路径分隔符替换为本地操作系统的文件
路径分隔符。第16l~164行对新的URI做二次合法性校验,如果校验失败则直接返回空。
最后对文件进行拼接,使用当前运行程序所在的工程目录+URⅠ构造绝对路径返回。
第68~71行,如果构造的URⅠ不合法,则返回HTTP403错误。第72行使用新组装
的URI路径构造File对象。第73-76行,如果文件不存在或者是系统隐藏文件,则构造
HTTP404异常返回。如果文件是目录,则发送目录的链接给客户端浏览器。下面我们重
点分析返回文件链接响应给客户端的代码。
第172行首先创建成功的HTIP响应消息,随后设置消息头的类型为“text/html;
charset=UTF-8”。第174行用于构造响应消息体,由于需要将响应结果显示在浏览器上,
所以采用了HTML的格式。由于大家对HTML的语法已经非常熟悉,这里不再详细介绍。
我们挑重点的代码进行分析,第185行打印了一个“.”的链接。第186~199行用于展示
根目录下的所有文件和文件夹,同时使用超链接来标识。第201行分配对应消息的缓冲对
象,第202行将缓冲区中的响应消息存放到HTTP应答消息中,然后释放缓冲区,最后调
用 write AndFlush将响应消息发送到缓冲区并刷新到 Socketchannel中。
如果用户在浏览器上点击超链接直接打开或者下载文件,代码会执行第85行,对超
链接的文件进行合法性判断,如果不是合法文件,则返回HTTP403错误。校验通过后,
第85~95行使用随机文件读写类以只读的方式打开文件,如果文件打开失败,则返回
HTTP404错误。
第96行获取文件的长度,构造成功的HTTP应答消息,然后在消息头中设置content
length和 content type,判断是否是Keep- Alive,如果是,则在应答消息头中设置 Connection
为Keep- Alive。第103行发送响应消息。第105-106行通过 Netty的 Chunkedfile对象直
接将文件写入到发送缓冲区中。最后为 sendfile future增加 GenericFutureListener,如果发
送完成,打印“ Transfer complete."
如果使用chunked编码,最后需要发送一个编码结束的空消息体,将LasthttpconteNt
的 EMPTY LAST CONTENT发送到缓冲区中,标识所有的消息体已经发送完成,同时调
165·Ne权威指南(第2版)
用fush方法将之前在发送缓冲区的消息刷新到 Socketchanne中发送给对方
如果是非Keep- Alive的,最后一包消息发送完成之后,服务端要主动关闭连接。
服务端的代码己经介绍完毕,下面让我们看看运行结果。
1023Net! / Http文件服务器例程运行结果
启动HTTP文件服务器,通过浏览器进行访问,运行结果如下。
首先,启动文件服务器,运行结果如图10-1所示。
public static void main(string[] args throws Exception t
int port- 8080:
I Problems Javadoc Le Decl aration 3 Search D Console 8 Frogress
■X、|品
Httphileserver[ Java Application]E: Program Files\Java\jdk1.7,0_451 binjai,·2014年2月27日下午11:44:40)
HTTP文件目录服务器启动,网址是http://192.168.1.102:8080/sec/com/phei/netty/
图10-1HTTP文件服务器启动结果
我们首先进行异常场景的测试,输入错误的URL网址:
http://192.168.1.102:8080/abcde/get?123
运行结果如图10-2所示。
hp/192.168.11028 abide oet122
°糟糕!网页无法访问,说数,43
网质
中360断网急救褚
陪搜索站果
an92161102
搜索一下
图10-2输入错误的网址,返回403错误
·166·第10章HTTP协议开发应用
结果分析:由于输入的URL路径不是个合法的文件或者目录,所以程序会执行第69
行,返回HTTP403错误。
我们继续测试正常场景,在浏览器中输入正确的网址:
http://192.168.1.102:8080/src/com/phei/netty/
浏览器显示结果如图10-3所示。
台O★回m192.1681102/m钟mt
创是 softwareheclipse-SDK4x+
11: software'eclipse-SDK-422-win 32 eclipselworkspace book src com phei netty E:
链接
链接:a
链接: basic
链接
·链接:char
链接: codec
链接:fame
链接
链接:pio
链接: protocol
图↑0-3Net1y文件服务器目录展示
单击 codec文件链接,显示结果如图10-4所示。
分合★|;192.168.1.102/=rt
凸1 softrare\eclipse+4×‖
M:software'teclipse-SDK-422-win 32 eclipse workspace book sre\com phei netty \codec *
链接
链接: marshalling
链接
链按:prot
链接: serializable
图10-4单击目录链接,进入下一级目录
查看浏览器的网址,已经进入下一级目录,继续单击 protobuf目录,显示如图10-5
所
167·Net!y权威指南(第2版)
9★自地2812数e
□:sNw画 . eclips+-SDE-42X+
M: software'eclipse-SDK-422-win 32 eclipse workspace book sre'com' phef netty codec protobuf A=t
链接:
链接: Subregchent iava
链接: SubRegchient Handler java
链按; SubReqserver java
链按; Subreqserverhlander iava
链接, Subscrbereqproto. java
链接: SubscrbeRespProto. java
链接; Test SubscrbeReqProto java
图10-5进入 protobuf目录
随便打开一个文件,由于是文本文件,可以直接在浏览器中显示,如图10-6所示。
htp:/1a.6.1.102:600/;x
Copyright 2013-2018 Linfeng
工cen当 d under he Apache工1G世ne,Ve1m20(he"eme")
you may not use this file except in compliance with the License
Y=Hma? actar. a copy of the上c些:思eat
http://www.apacheorg/licenses/license-2.0
nless equ1 ced by app1⊥cab2e1盘W口 r agreed to1 T WRATHⅡgr部tw点e
distributed under the License ig distributed on a AS IS BA5I5,
工 THOUT WARRANIIES CR COND工 ONS CF ANY KIND,e1已 He- Ax21mP1e,
See the License foz the specific Ianguage governing pezmi981ong and
limmat:omg under the License
package com. phel netty, codec. protobuf
1rp=出t5ava,山t11, Acay-19t
Lmport ava. util. List:
import com. google. protobuf. InvalldPrctecoiButterException:
Author admin⊥stat。x
3dae201年2月23日
-es1。n1,0
public class TestsubscribeReqFroto t
private static byte [l encode(SubscribeReqProto SubscribeReq req)t
eq. toBy
y()
图10-6打开 TestSubscribeReq Proto java文件
如果内容显示有乱码,说明浏览器使用的编码方式和源代码中的不一致,直接在打开
的网页中单击右键,在弹出菜单中选择编码方式为UTF-8即可,如图10-7所示。
168·第10章HTTP协议开发应用
后退c
前进①)
青景另存
设置为需心
复制背量C
设为桌面
全选因)
粘贴①
色腱快捷方式①
在手机打开当前页面
(byte[l
添加到收藏夹①
bod)
查看源文件
编码
自动选择
Subscrip打印q
简体中文GR312
s:bs巴1
刷新〕
V Unicode QTE-8)
导出到 i erosof office exe1)
其他)
从左到右的文挡
图10-7设置浏览器的编码方式为UTF-8解决中文乱码问题
我们也可以通过右键【目标另存为】从文件服务器下载文件,如图10-8所示。
接, SubRegChen.ine
链接:SuR9Sea
链接: SubRegserve Handler ja
已完成安装 IE- SubacribekeaProtd,im,白x
链按; Subscnberegpnoo va
链按
enbeResp Poto in
·链接; TestSubscrbeReg preto java
bseribazeglraL数
目121B.1.1D
另存为
P
骤存在):日我文替
30j:F1
Dispar
tencent Piles
开交件夹
片收露
我的视感
面我的香乐
的文硝
文伴名Q
保存
存类型①D:j文档
图10-8从文件服务器下載源文件
下载完成后,打开下载的文件,看内容是否正确,如图10-9所示。
·169·Net权威指南(第2版)
写宇
文件)典辑①查看甄入①格式①)帮助
自G日国酗
LT
吗
// Generated by the prot ocol buffer compiler. DO HOT EDIT
1/ source: netty/subscribeReq. proto
package com. phei. hetty. eodee protobuf
public final class SubseribeReqProto i
private SubscribeRegProtoo
public static void registerAllExtens
com goog le protobuf. ExtensionRegistry registry) I
public interf ace SubscribeRegOrBuilder
extends come google protobuf. MessageOrBuilder I
// required int 32 subReqID =1:
w <code>required int 32 subReqID= 1: </code>
boolean has subReqID(:
t <cade>required int 32 subReqID= 1:</code>
nt get SubReqIDO
required string userName
图10-9查看从文件服务器下载的源文件
对比服务器上的源文件,内容完全一致,说明HTTP文件服务器文件下载功能正常。
至此,作为入门级的NettyHttp协议栈的应用—HTTP文件服务器已经开发完毕,
相信通过本节的例程学习,大家已经初步掌握了基于Netty的HTTP服务端应用开发。
下一节,我们将学习目前最流行的HTTP+XML开发。HTTP+XML应用非常广泛,
旦我们掌握了如何在Net!y中实现通用的HTTP+XML协议栈,后续相关的应用层开发和
维护将会变得非常简单。
103 Netty Http+XML协议栈开发
由于HTTP协议的通用性,很多异构系统间的通信交互采用HTTP协议,通过HTTP
协议承载业务数据进行消息交互,例如非常流行的HTTP+XML或者RESTfu+JSON。
在Java领域,最常用的HTTP协议栈就是基于Serylet规范的Tomcat等Web容器,
由于谷歌等业界大佬的强力推荐, Jetty等轻量级的Web容器也得到了广泛的应用。但是,
很多基于HTTP的应用都是后台应用,HTTP仅仅是承载数据交换的一个通道,是一个载
体而不是Web容器,在这种场景下,一般不需要类似 Tomcat这样的重量型Web容器。
170第10章HTTP协议开发应用
在网络安全日益严峻的今天,重量级的web容器由于功能繁杂,会存在很多安全漏
洞,典型的如 Tomcat。如果你的客户是安全敏感型的,这意味着你需要为web容器做很
多安全加固工作去修补这些漏洞,然而你并没有使用到这些功能,这会带来开发和维护成
本的增加。在这种场景下,一个更加轻量级的HTTP协议栈是个更好的选择。
本章节将介绍如何利用Nety提供的基础HTTP协议栈功能,扩展开发HTTP+XML
协议栈。
10.3.1开发场景介绍
作为一个示例程序,我们先模拟一个简单的用户订购系统。客户端填写订单,通过
HTTP客户端向服务端发送订购请求,请求消息放在HTTP消息体中,以XML承载,即
采用HTTP+XML的方式进行通信。HTTP服务端接收到订购请求后,对订单请求进行修
改,然后通过HTTP+XML的方式返回应答消息。双方采用HTTP1.1协议,连接类型为
CLOSE方式,即双方交互完成,由HITP服务端主动关闭链路,随后客户端也关闭链路
并退出。
订购请求消息定义如表10-3所示。
表10-3订购请求消息定义( Order)
字段名称
类型
备注
订购数量
Int64
订购的商品数量
客户信息
Customer
客户信息,负责POO对象
账单地址
Address
账单的地址
枚举类型如下:
普通邮递
宅急送
寄送方式
Shipping
国际邮递
国内快递
国际快递
送货地址
Address
送货地址
总价
float
商品总价
客户信息定义如表10-4所示。
171·Net!权威指南(第2版)
表10-4客户信息定义( Customer)
字段名称
类型
备注
客户ID
Int64
客户ID.长整型
姓
String
客户姓氏,字符串
名
String
客户名字,字符串
全名
List<String>
客户全称,字符列表
地址信息定义如表10-5所
月、。
表10-5地址信息定义( Address)
宇段名称
类型
备注
街道I
String
街道2
String
城市
Strin
省份
String
邮政编码
String
国家
String
邮递方式定义如表10-6所示。
表10-6邮递方式定义( Shipping)
字段名称
类
备注
普通邮递
枚举类型
宅急送
枚举类型
国际邮递
枚举类型
国内快递
枚举类型
国际快递
枚举类型
数据定义完成之后,接着看订购请求消息的ⅹ ML Schema定义。
<xs:schemaxmlns:xs="http://www.w3.org/2001/xmlschema"xmins:tns="http://
phei.com/netty/protocol/http:/xml/pojo
element FormDe fault=lqualified'
targetnamespace="http://phei.com/netty/protocol/http:/xml/pojo">
<xs: element type="tns: order" name="order"/>
<xs: complexType name="address">
<XS: sequence>
<xs:element type="xs: string" name="street1" minOccurs=0"/>
172·第10章HTTP协议开发应用
<xs: element type=s: string" name="street2 minoccurs=0/>
<xs:element type=xs: string" name="city minOccurs="0"/>
<xs:element types: string name=state" minoccurs-0"/>
<xs:element type="xs: string" name="postcode"minoccurs=0"/>
<xs: element type="xs: string" name="country minoccurs=0"/>
</xs: sequence>
</xs: complexType>
<xs: complexType name=order>
<xs: sequence>
<xs:element name="customer minOccurs="0">
<xs: complexType>
<xS: sequence>
<xs: element type=xs: string" name=firstName" minOccurs=0"/>
<xs: element type-"xs: string" name="lastName" minoccurs="0"/>
<xs:element type="xs:string" name="middleName" minoccurs="0
maxOccurs="unbounded"/>
</xs: sequence>
<xs: attribute type=xs: long"use="required"name="customerNumber"/>
</xs: complexType>
</xs:element>
<xs: element type="tns: address" name="billTo" minoccurs="0"/>
<xs:element name="shipping" minoccurs="0
<xs: simpleType>
<xs:restriction base=xs: string>
<xs: enumeration value="STANDARD MAIL#/>
<xs: enumeration value="PRIORITY MAIL"/>
<xs: enumeration value="INTERNATIONAL MAIL"/>
<xs: enumeration value="DOMESTIC EXPRESS"/>
<xs: enumeration value="INTERNATIONAL EXPRESS"/>
</xs: restriction>
</xs: simpleType>
</xs: element>
<xs: element type="tns: address" name=shipTo" minoccurs=0"/>
</xs: sequence>
<xs:attribute type="xs: long use="required"name=orderNumber"/>
<xs:attribute type="xs: float name="total"/>
</xs: complexType></xs: schema>
熟悉ⅩML和 Schema的读者理解上面的 Schema定义没有什么困难,如果你对XML
的相关知识还不太了解,建议先找一本ⅩML开发入门方面的书籍进行学习,或者登录
W3C的网站学习XML的相关知识。
173·Ney权威指南(第2版)
开发背景介绍完毕,下面我们进入设计环节,看看如何设计和开发HTTP+XML协议栈。
10.3.2HTTP+XML协议栈设计
通过商品订购的流程图看下订购的关键步骤和主要技术点,找出当前 Netty Http协
议栈的功能不足之后,通过扩展的方式完成HTTP+XML协议栈的开发。如图10-10所示。
构造订购请求消息,将请求
消息编码为HTTP+XML格式
2HTTP客户端发起连接,通过HTTP
协议栈发送HTTP请求消息
3HTTP服务端对HTTP+XML请求消
息进行解码,解码成请求POJO
4服务端构造应答消息并编码,逦过
HTTP+XML方式返回给客户端
5客户端对HTTP+XML响应消息进
行解码,解码成响应POJO
图10-10HTTP+XML订购流程图
首先对订购流程图进行分析,先看步骤1,构造订购请求消息并将其编码为
HTTP+XML形式。Ney的HTP协议栈提供了构造HTTP请求消息的相关接口,但是无
法将普通的POJO对象转换为HTTP+XML的HTTP请求消息,需要自定义HTTP+XML
格式的请求消息编码器。
再看步骤2,利用Net!y的HTTP协议栈,可以支持HTTP链路的建立和请求消息的
发送,所以不需要额外开发,直接重用Net!y的能力即可
步骤3,HTTP服务端需要将HTTP+XML格式的订购请求消息解码为订购请求POJO
对象,同时获取HTTP请求消息头信息。利用Nety的HTTP协议栈服务端,可以完成HTTP
174第10章HTTP协议开发应用
请求消息的解码,但是,如果消息体为ⅹML格式,Net!y无法支持将其解码为POJO对象,
需要在 Netty协议栈的基础上扩展实现。
步骤4,服务端对订购请求消息处理完成后,重新将其封装成ⅹML,通过HTTP应答
消息体携带给客户端,Nety的HTP协议栈不支持直接将POJO对象的应答消息以XML
方式发送,需要定制。
步骤5,HTTP客户端需要将HTTP+XML格式的应答消息解码为订购POJO对象,同
时能够获取应答消息的HTTP头信息,Netty的协议栈不支持自动的消息解码
通过分析,我们可以了解到哪些能力是Nety支持的,哪些需要扩展开发实现。下面
给出设计思路。
(1)需要一套通用、高性能的ⅹML序列化框架,它能够灵活地实现POJO-XML的互
相转换,最好能够通过工具自动生成绑定关系,或者通过XML的方式配置双方的映射关系;
(2)作为通用的HTTP+XML协议栈,XML-POJO对象的映射关系应该非常灵活,支
持命名空间和自定义标签;
(3)提供HTTP+XML请求消息编码器,供HITP客户端发送请求消息自动编码使用;
(4)提供HTTP+XML请求消息解码器,供HTTP服务端对请求消息自动解码使用;
(5)提供HTTP+XML响应消息编码器,供HTTP服务端发送响应消息自动编码使用;
(6)提供HTTP+XML响应消息解码器,供HTTP客户端对应答消息进行自动解码使用
(7)协议栈使用者不需要关心HTTP+XML的编解码,对上层业务零侵入,业务只需
要对上层的业务POJO对象进行编排。
下个小节我们将讲述XML框架的选型和开发,它是HTTP+XML协议栈的关键技术点
10.3.3高效的XML绑定框架JiBX
JiBX是一款非常优秀的XML〔 Extensible Markup Language)数据绑定框架。它提供
灵活的绑定映射文件,实现数据对象与ⅹML文件之间的转换,并不需要修改既有的Java
类。另外,它的转换效率是目前很多其他开源项目都无法比拟的。
1.JBX入门
XML已经成为目前程序开发配置的重要组成部分了,可以用来操作XML文件的开源
175Net权威指南(第2版)
项日也已经成熟,比如说流行的 Digester、 XStream、 Castor、JDOM、dom4j和 Xalan等,
当然也少不了专门为Java语言设计的XML数据绑定框架JiBX。它的主要优点包括:转换
效率高、配置绑定文件简单、不需要操作 xpath文件、不需要写属性的 get/set方法、对象
属性名与XML文件 element名可以不同,等等。
使用JiBX绑定ⅩML文档与Java对象需要分两步走:第一步是绑定XML文件,也就
是映射XML文件与Java对象之间的对应关系;第二步是在运行时,实现XML文件与Java
实例之间的互相转换。这时,它已经与绑定文件无关了,可以说是完全脱耦了
在运行程序之前,需要先配置绑定文件并进行绑定,在绑定过程中它将会动态地修改
程序中相应的 class文件,主要是生成对应对象实例的方法和添加被绑定标记的属性
JiBX bindinglist等。它使用的技术是BCEL( Byte Code Engineering Library),BCEL是
A pache Software Foundation的 Jakarta项目的一部分,也是目前 Java classworking最广泛使
用的一种框架,它可以让你深入JVM汇编语言进行类操作。在JiBX运行时,它使用了目
前比较流行的一个技术XPP( Xml Pull Parsing),这也正是JiBX如此高效的原因。
JiBⅹ有两个比较重要的概念: Unmarshal(数据分解)和 Marshal(数据编排)。从字
面意思也很容易理解, Unmarshal是将XML文件转换成Java对象,而 Marshal则是将Java
对象编排成规范的ⅹML文件。JBX在 Unmarshal/marshal上如此高效,这要归功于使用
了XPP技术,而不是使用基于树型(tre- based)方式,将整个文档写入内存,然后进行
操作的DOM( Document Object Model),也不是使用基于事件流( event stream)的SAX
( Simple aPI for Xml)。XPP使用的是不断增加的数据流处理方式,同时允许在解析ⅹML
文件时中断。
介绍完了JiBx的基础概念,下面我们就结合订购例程,来学习下如何使用JiBx进行
XML的开发。
2.POJO对象定义
通过JiBⅹ提供的工具jar包,可以根据 Schema自动生成POJO对象,也可以根据普
通的POJO对象生成JBx绑定文件和 Schema定义XSD
考虑到大多数人的编码习惯,我们采用先定义POJO对象,再生成ⅹML和对象的绑
定文件的方式。JiBx对POJO对象没有特殊要求,只要符合 Java bean的规则即可,下面
我们以订购例程为例,看下主要类的定义。
176第10章HTTP协议开发应用
代码清单10-3HTTP+XMLPOJO类定义Order
2. public class order i
3
private long orderNumber;
private Customer customer;
6
/* Billing address information. *
7
private Address billToi
8.
9
private Shipping shippingi
10
11
12
Shipping address information. If missing, the billing address is also
13
x used as the shipping address
14
15
private Address shipTo
16.
17
private Float totali
/定义set和get方法
53,
代码清单10-4HTTP+XMLPOJO类定义Customer
2. import java. util. Listi
3. public class Customer i
private long customer Numberi
456789
*木 Personal name,*/
private String firstName i
/* Family name, *
private string lastName;
10
* Middle name(s), if any. *
11,
private List<string> middleNamesi
…//定义set和get方法
35
代码清单10-5HTTP+XMLPOJC类定义Address
2. public class Address t
/* First line of street information (required).*
345678
private String streetli
/* Second line of street information (optional), */
private string street;
private String cityi
·177Net!y权威指南(第2版)
10
State abbreviation (required for the U.s. and Canada, optional
11
otherwise)
12
13.
private string statei
14
15,
/* Postal code (required for the U.s. and Canada, optional otherwise).*/
16.
private string postCode:
17
* Country name (optional, U.S. assumed if not supplied).*/
18
private String country
//定义se和get方法
54
代码清单10-6HTTP+XMLPOJO类定义Shipping
1.packagecompheinettyprotocol.http.xmlpojo
2
3. public enum Shipping
STANDARD MAIL, PRIORITY MAIL, INTERNATIONAL MAIL, DOME STIC EXPRE SS
INTERNATIONAL EXPRESS
5.
POJO对象定义完成之后,通过Ant脚本来生成XML和POJO对象的绑定关系文件,
同时也附加生成XML的 Schema定义文件。下个小节开始介绍Ant脚本的编写
3.通过Ant脚步生成ⅩML和对象的绑定关系
首先确认你使用的 Eclipse安装了Ant,通过【 Window】主菜单选择【 Preferences】,
在弹出的窗口中可以查看是否支持Ant。如图10-11所示。
Preference:
Ant
了D血1
Geaeral Ant Settings
出D
F1cm电如糖d池"fin"
As> Ant uild when
at galeana net s beil
Help
hui]danl,以Lam
H Intal/update
b14x1
丁E
Saperate JRE tisaant (as):20000
H JascrIpt
Dcwn幅如L
http://unt.spsche,srdeundDosses
□ ran aw Ant eNnui pirati通iBth他uth曾
t Mylyn
t Purin Drelepaent
Remote Srit压
Some tasks, ssch as javad require the tools. jwr lihrary te beonthe
Ran/Tebe
5r解
回 wa thn t1; jur is not如 datapath
击T插
In血
vshe error didst whem Ant build fails
Waltdatlan
冒ebSr改进生
feati proble markers ta"js智”山t
主M
固 ker creation Rewires that emote b1 cited and1ist业r
图10-11 Eclipse的Ant配置
178·第10章HTTP协议开发应用
目前主流的 Eclipse版本默认都支持Ant,如果你使用其他的开发工具,可以安装对应
的Ant插件。
由于本书的重点并非讲解Ant的使用,所以,如果你对Ant感兴趣或者作为初学者学
习Ant,可以选择相关的Ant教材或者直接通过Ant的官方文档进行学习。
JiBⅹ的绑定和编译,重点关注两个task。如图10-12所示。
<l- generate default binding and schema ->
<target name="bindgen">
<echo message="Running Bind Gen tool"/>
java classpathref="classpath"fork="true"failonerror="true
classname=org. jibx binding generator. BindGen">
≤ arg value="-s"/>
cargvalue="sbasedir//srC/com/phei/netty/protocol/http:/xmlpojo">
<argvalue="com.phel.nettyprotocolhttpxmlpojoOrder>
≤ target>
图10-12使用 Bingen命令生成绑定文件
通过JiBx的 org. jibx. binding generator. BindGen工具类可以将指定的POJO对象 Order
类生成绑定文件和 Schema定义文件,执行结果如图10-13所示。
置t山 Javadoc B Deelwatiwn seach日 Console米其巴回r
termini4>bokb=i14m1【 Ant Bui14 E: \Progra Files sraljdkl7045 bijan,②204年月2日下年12:11:13
Buildtile: N:\software ec l1pse-SDK-42.2-y1n32\ec lipse\ wor kspace\bookibuild xmI
[ delete] Deleting directory 4: sottwareecl1pse-SDK-4,2.2-v1n32vecl1pse, workspace\ book\ bin com\ ph
deee] Selecing::or西r些ec1Pe一DK-42,2一1321些c11 pse\workspace\ boak\r1md1ng,xn
chee k-runE lme
echos -
->N:\Java,n1o\ netty jibx 1 2 5 31bx
echo Comp1 ling dava source code
I Javac] :,o*t wnre\ac 11ps--SDR-42, 2-01n32)ec lipme\ workspace\book\ but ld, xtal: 72: warning: inclu
avg]c甲aa5 source files t昌;￡wglB5D累-4,2,2-im32e白1 pse, woekspacebook\b
b1
[echo Running Binden too
check-bindin?
bind:
echo Running uiBs binding comptEr
tullI
图10-13执行Ant脚本,生成XML绑定关系
执行成功后,在当前的工程日录下生成 binding. xml和 pojo. xsd文件,结果如图10-14
所示。
白k
Gi A JRE System Library Lj dkt T.451
tE Referenced Libraries
@1
bindinc ral
build.xml
p6黑s
图10-14生成的ⅹML绑定文件
179·Ney权威指南(第2版)
打开绑定文件,我们可以发现绑定文件实际就是XML的元素和POJO对象字段之间
的映射关系,生成之后的文件可以手工调整,例如修改XML中的元素名称、必选和可选
标识等。如果你熟悉绑定规则,绑定文件也可以自己手工配置开发。XML和 Order对象的
映射关系如图10-15所示。
<mapping abstract="true"type-name="ns1: order"
class=comphei.nettyprotocol.httpxmlpojoOrder>
<value style="attribute"name="orderNumber"field"orderNumber/>
<structure field="customer"usage="optional"name="customer">
<value style="attribute"name="customerNumber'"
field="customerNumber s
<value style="element"name="firstName"field="firstName
usage="optional/>
<value style="element name="lastName"field="lastName
usage=
optional"/>
<collection field="middleNames"usage"optional "create-
type=" java util Array List>
<value name="middleName"type="java. lang String>
</collection>
</structure>
此处省略
</mapping>
图10-15XML和 Order对象的映射关系
再看一下JiBx的编译命令,它的作用是根据绑定文件和POJO对象的映射关系和规则
动态修改POJO类,Ant脚本如图10-16所示。
<target name="bind"depends="check-binding">
echo message="Running JiBX binding compiler/>
<taskdef name="bind"classname="org. jibx binding. ant Compile Task">
≤ classpath>
<fileset dir="syibx-home)/lib"includes="jar/>
</classpath>
taskdef>
<bind binding="S(basedir /binding. xml">
<classpath refid="classpath"p>
binds
</target>
图10-16编译绑定脚本和动态修改 Class的Ant脚本
编译结果如图10-17所示。
]Customer, dlass
brSihdisgaetary elass
aJiBi-bindingthungeAdapter class
工 BI bi diaorDer,lass
Order elv
回 OrdarFaetery e1ss
品 PiNs e1
图10-17动态修改 Class文件
180·第10章HTTP协议开发应用
到此为止,JiBx相关的准备工作已经完成,下个小节通过一个简单的测试程序来学习
JiBx类库的使用。
4.JBx的类库使用
JiBx的类库使用非常简单,下面直接看代码。
代码清单10-7HTTP+XMLPOJO测试类定义TestOrder
18. public class Testorder i
19
private IBindingFactory factory null;
20
private StringWriter writer nulli
21
private stringReader reader null;
22. private final static string CHARSET NAME ="UTF-8";
23,
private String encode 2Xml(Orderorder) throws JiBXException
IOException t
24.
factory
BindingDirectory. getFactory (Order class)i
25
writer= new StringWriter()
26,
IMarshallingContext mctx= factory, createMarshallingContext()i
27,
mctx, set Indent(2);
28
mctx.marshalDocument(order, CHARSET NAME, null writer)i
29
String xmlStr= writer toString()i
30
writer. close()i
31
System, out. printIn(xmlStr tostring())i
32
return mistra
33
34
35,
private Order decode 2order(String xmlBody) throws JiBXException i
36.
reader new StringReader(xmlBody)
37
IUnmarshallingContext uct= factory. createUnmarshallingContext ()i
Orderorder (Order) uct unmarshal Document (reader)j
return order
40
41
42
public static void main(String[] args) throws JiBXException
IOException t
43
Testorder test new Testorder(;
44
Order order= OrderFactory create(123)i
45
string body= test, encode 2Xml(order)i
46
Order order2 test decode 2Order(body
47
System. out. println(order2)i
181Netty权威指南(第2版)
48
49
首先看第24行,根据 Order的 Class实例构造 I Binding Factory对象。第25行创建新的
String Writer对象,通过 I Binding Factory构造 Marshalling上下文,最后通过 marshal Document
将 Order序列化为 String Writer,通过 String Writer的 toString方法可以返回 String类型的
XML对象。
解码与编码类似,不同的是它使用 Stringreader来读取 String类型的XML对象,然
后通过 unmarshalDocument方法将其反序列化为 Order对象。
执行结果如下。
<?xml version="1. 0" encoding="UTE-8"?>
orderxmins="htTp://phei.com/netty/protocol/http:/xml/pojo"ordernumber=
123"tota1="9999.999">
<customer cus tomerNumber-l123">
<firstName>2</firstName>
<1 astname>林峰</1 astName>
</customer>
<billTo>
< street1>龙眠大道</ street1>
<city>南京市</city>
< state>江苏省</ state>
<postcode>123321</postcode>
< country>中国</ country>
</billTo>
<shipping>INTERNATIONAL MAIL</shipping>
<shipTo>
< street1>龙眠大道</ street1>
<city>南京市</city>
< state>江苏省</ state>
<postcode>123321</postcode>
< country>中国</ country>
</shipTo>
</order>
Order [orderNumber=123, customer=Customer [customerNumber=123, firstName=
李, lastName=林峰, middlenames=nu11],bi11To= Address[ street1=龙眠大道,
street2=nu11,city=南京市, state=江苏省, postcode=123321, country=中国],
shipping= INTERNATIONAL MAII, shipTo= Address[ street1-龙眠大道, street2=nu11,
city=南京市, state=江苏省, postCode=123321, country=中国],tota1=9999.999
182·第10章HTTP协议开发应用
通过上面的执行结果可以发现,XML序列化和反序列化后的结果与预期一致,我们
开发的JBx应用可以正常工作
ⅹML绑定框架选型和开发完成之后,下面继续 Netty Http+XM编解码框架的开发。
10.34HTTP+XML编解码框架开发
本节会有6个部分来讲解如何基于Nety开发HTTP+XML协议栈,在Nely提供的
HTTP基础协议栈上进行扩展和封装,以实现对上层业务的零侵入。下面我们一起学习如
何进行开发。
1.HTTP+XML请求消息编码类
对于上层业务侧,构造订购请求消息后,以HTTP+XML协议将消息发送给服务端,
如果要实现对业务零侵入或者尽可能少的侵入,协议层和应用层应该解耦。
考虑到HTTP+XML协议栈需要一定的定制扩展能力,例如通过HTTP消息头携带业
务自定义字段,所以,应该允许业务利用Netty的HTTP协议栈接口自行构造私有的HTTP
消息头。
HTTP+XML的协议编码仍然采用ChannelPipeline中增加对应的编码handler类实现。
下面我们来一起看下HTTP+XML请求消息编码类的源码实现。
代码清单10-8HTTP+XmlHttp请求消息编码类
11. public class HttpxmirequestencodEr extends
12,
Abstracthttpxmlencoder<httpxmlrequest>[
13,
14.
override
15
protected void encode(channelhandlercontext ctx Httpxmlrequest msg
16
List<object> out) throws Exception t
17
ByteBuf body encoded(ctx, msg. getBody())i
18,
Fullhttprequestrequestsmsggetrequest()i
19
if (request = null)(
20
requestnewDefaultfullhttprequest(httpversion.Http11
21
Httpmethod. gEt, "/do", body)i
22
Httpheaders headers  = request headers()i
23,
headersset(httpheaders.Names.Host,
InetAddress, getLocalHost()
183Nety权威指南(第2版)
24,
getHostAddress())i
25
headers. set(Ht tpHeaders Name s CONNECTION,
Httpheaders. values Close);
26
headersset(httpheaders.Names.AccePtEncoDing,
27
Httpheaders. Values Gzip. tostring()+
28
+ Httpheaders. Values DeflaTe. tostring())i
29
headersset(httpheaders.Names.AccepTCharsEt,
30
"Iso-8859-1,utf-8;q=0.7,*;q=0.7");
31
headersset(httpheaders.Names.AccePtLangUage,"zh")i
32,
headersset(httpheaders.Names.UserAgenT,
33
Netty xml Http Client side")i
34,
headersset(httpheaders.Names.AccepT,
text/html, application/xhtml+xml, application/xm1;g=0.9, */*:g=0.8");
35
36,
Httpheaders. setcontentleNgth(request, body readablebytes());
37
out. add(request)i
38.
39.}
第17行首先调用父类的 encode0,将业务需要发送的POJO对象 Order实例通过JBx
序列化为XML字符串,随后将它封装成Nety的 Byte Buf。第18行对消息头进行判断,
如果业务侧自定义和定制了消息头,则使用业务侧设置的HTTP消息头,如果业务侧没有
设置,则构造新的HTTP消息头。
第20~35行用来构造和设置默认的HTTP消息头,由于通常情况下HTTP通信双方
更关注消息体本身,所以这里采用了硬编码的方式,如果要产品化,可以做成XML配置
文件,允许业务自定义配置,以提升定制的灵活性
第36行很重要,由于请求消息消息体不为空,也没有使用Chunk方式,所以在HTTP
消息头中设置消息体的长度 Content- Length,完成消息体的ⅩML序列化后将重新构造的
HTTP请求消息加入到out中,由后续Netty的HTTP请求编码器继续对HTTP请求消息进
行编码。
下面我们来看父类Abstracthttpxmlencoder的实现。
代码清单10-9HTTP+XmlHttp请求消息编码基类AbstracthttpXmlencoder
14.publicabstractclassAbstracthttpxmlencoder<r>extends
15
MessageToMessageEncoder<r> f
16
IBindingFactory factory null;
17
StringWriter writer nulli
18
final static string CHARSET NAME UTF-8";
·184·第10章HTTP协议开发应用
19
final static Charset UTF 8= Charset forName(CHARSET NAME);
20
21.
protected ByteBuf encoded(ChannelHandlerContext ctx, Object body
22.
throws Exception i
23
factory- Binding Directory. getFactory(body, getclass())i
24,
writer= new StringWriter()i
25
IMarshallingContext mctx factory createMarshalling Context ()i
26
mctx. setIndent(2)i
27
mctx. marshal Document (body, CHARSET NAME, null, writer)i
22
8
String xmlstr= writer tostring()i
writer.close()i
30
writer nulli
31
ByteBuf encodeBuf= Unpooled. copiedBuffer(xmlstr, UTF 8)i
32
return encodeBuf
33
34
35
oVerride
36
public void exceptioncaught (ChannelHandler Context ctx, Throwable
cause)
37
throws Exception I
38,
//释放资源
39
if (writer null) I
40
writer. close()i
41
writer null
42
43.
44.}
首先看下第23~30行,代码很熟悉,在JiBx章节已经介绍了XⅩML序列化和反序列
化的相关类库使用,在此将业务的 Order实例序列化为XML字符串。第31行将ⅩML字
符串包装成Net的ByteBuf并返回,实现了HTTP请求消息的ⅹML编码。
下面继续看下 Httpxmirequest是如何实现的。
代码清单10-10HTTP+XML请求消息HttpxmirequeSt
9. public class Httpxmlrequest  i
10
privateFullhttprequestrequest
private Object body;
12
13
publicHttpxmlrequest(fulLhttprequestrequestobjectbody)(
14,
this request request
185Nety权威指南(第2版)
15
this body bodyi
16
17,
18
/★★
19
ereturn the request
20
21,
publicfinalFullhttprequestgetrequest()t
22,
return request
23
24
25,
26
k @param request
27
the request to set
28
29
publicfinalvoidsetrequest(fUllhttprequestrequest
3
this request = request
31
32,
33
34,
return the object
35
36. public final Object getBody()[
37,
return body;
38
39
40,
41
param object
42
the object to set
43
44
public final void setBody(Object body)
45
this body body;
46.}
47.}
它包含两个成员变量FullhttprequEst和编码对象Object,用于实现和协议栈之间的解耦。
2.HTTP+XML请求消息解码类
HTTP服务端接收到HTP+XML请求消息后,需要从HTTP消息体中获取请求码流,
通过JBx框架对它进行反序列化,得到请求POJO对象,然后对结果进行封装,回调到业
186●第10章HTTP协议开发应用
务handler对象,业务得到的就是解码后的POJO对象和HTTP消息头。
下面就看下具体实现。
代码清单10-l1HTTP+XmlHttp请求消息解码类HttpxmirequeStdecoder
20. public class HttpxmirequestdecodeR extends
21
Abstracthttpxmldecoder<fullhttprequesT>i
22
23
public Httpxmlrequest Decoder (class<?> clazz)[
24
this(clazz, false)i
26
27
public HttpxmlrequestdecoDer(class<?> clazz, boolean isprint) (
2
super(clazz, isPrint)i
29,
30
31
override
32
protectedvoiddecode(channelhandlercontextargoFullhttprequest
argl,
33,
List<object> arg2) throws Exception i
34
if (! argl. getDecoderResult(). isSuccess())[
35
sendError(argO, BAD REQUEST)i
36
returni
37
38
Httpxmlrequest request = new Httpxmlrequest(arGl, decodeo(argo,
39
argl, content()))i
40
arg2. add(request)i
41,
42
43
private static void sendError(ChannelHandlerContext ctx,
44
Httpresponsestatus status) f
45
FullhttpresponseresponsenewDefaultfullhttpresponse(http11,
46
status, Unpooled. copiedBuffer("Failure: status tostring()
47
+h\r\n", Charsetutil UTE 8)):
48.
response headers(). set(CONTENT TYPE,"text/plain; charset=UTF-8);
49
ctx. writeAndFlush(response). addListener (ChannelFuturelistener
ClOSE)i
50
51.}
Http xmirequest decoder有两个参数,分别为需要解码的对象的类型信息和是否打印
187Net!y权威指南(第2版)
HTP消息体码流的码流开关,码流开关默认关闭。第34~37行首先对HTTP请求消息本
身的解码结果进行判断,如果已经解码失败,再对消息体进行二次解码已经没有意义。
第43~50行,如果HTTP消息本身解码失败,则构造处理结果异常的HTTP应答消
息返回给客户端。作为演示程序,本例程没有考虑ⅹML消息解码失败后的异常封装和处
理,在商用项目中需要统一的异常处理机制,提升协议栈的健壮性和可靠性。
第38行通过 Http xmirequest和反序列化后的oder对象构造 Http xmirequest实例,
最后将它添加到解码结果List列表中
继续看下它的父类Abstracthttpxmldecoder的实现
代码清单10-12HTTP+XmlHttp请求消息解码类Abstracthttpxmldecoder
18.publicabstractclassAbstracthttpxmldecoder<r>extends
19
MessageToMessageDecoder<T> i
20
private IBindingFactory factory
21
private StringReader reader
22
private Class<?> clazzi
23.
private boolean isPrinti
24,
private final static string CHARSET NAME ="UTF-8"i
25.
private final static Charset UTF 8=Charset forName(CHARSET NAME
26,
protectedAbstracthttpxmlDecoder(class<?>clazz)f
28.
this(clazz, false)i
29
30
protectedAbstracthttpxmldecoder(class<?>clAzz,booleanisprint)F
this. clazz
C⊥azz;
33
this, isprint isPrint:
34
35
36. protected object decode( ChannelHandlerContext argo, ByteBuf body
37,
throws Exception i
38.
factory
BindingDirectory. getFactory(clazz)i
39
String content body tostring(UTF 8)i
40
if (isPrint
41
System. out. printin("The body is: content);
42.
reader new StringReader(content)i
43
IUnmarshallingContext uctx- factory. createUnmarshallingContext(
Object result uctx. unmarshalDocument(reader)i
45
reader. close()
188第10章HTTP协议开发应用
46
reader null
47
return result
48.
49
@override
50
public void exceptionCaught(ChannelHandlerContext ctx, Throwable
cause)
51
throws Exception i
52
/′释放资源
53
if (reader ! null) t
54
reader, close()i
55
reader
nu11;
56
57
58.}
第38~47行从HTTP的消息体中获取请求码流,然后通过JBx类库将XML转换成
PoJO对象。最后,根据码流开关决定是否打卬消息体码流。増加码流开关往往是为了方
便问题定位,在实际项目中,需要打印到日志中。
第53~55行,如果解码发生异常,要判断 String Reader是否已经关闭,如果没有关
闭,则关闭输入流并通知JVM对其进行垃圾回收
3.HTTP+XML响应消息编码类
对于响应消息,用户可能并不关心HTTP消息头之类的,它将业务处理后的POJO对
象丢给HTTP+XML协议栈,由基础协议栈进行后续的处理。为了降低业务的定制开发难
度,我们首先封装一个全新的 Http Xml应答对象,它的实现如下。
代码清单10-13HTTP+XmlHttpXml应答消息HttpXmiresponsE
9. public class Httpxmlresponse (
10
privateFullhttpresponsehttpresponse
11
private object result
12
13.publicHttpxmlresponse(fUllhttprespOnsehttpresponse,Objectresult)t
14.
thishttpresponse=httpresponse;
15,
this, result result:
16
17
18
19
*returnthehttpresponse
189·Net!y权威指南〔第2版)
20,
21
publicfinalFullhttpresponsegethttpresponSe()f
22
returnhttpresponsei
23
24
25
26,
*paramhttpresponse
27,
thehttpresponsetoset
28
29
publicfinalvoidsethttpresponSe(fullhttpresponsehttpresponse)t
30
thishttpresponse=httpresponsei
31
32,
33
34
ereturn the body
35
36. public final Object getResult()[
37
return result:
38
39
40
41,
param body
42,
the body to set
43,
44
public final void setResult(object result)
45
this, result resulti
46
47
它包含两个成员变量:FullhttprespOnse和Object,Object就是业务需要发送的应答
POO对象
下面继续看应答消息的XML编码类实现。
代码清单10-14HTTP+XML应答消息编码类HttpxmlrespoNseEncoder
17. public class HttpxmlresponseencOder extends
18
Abstracthttpxmlencoder<httpxmiresponsE>t
19
20.
21
* (non-Javadoc)
22
190第10章HTTP协议开发应用
23
dsee
24..* io netty handler, codec. MessageToMessageEncoder#encode(ionetty
channel
25
* ChannelHandlerContext, java. lang Object, java util. List)
26
27
protected void encode(channelhandlercontext ctx, Httpxml Response msg
28
List<object> out) throws Exception
29,
ByteBuf body encoded(ctx, msg getResult())i
30
Fullhttpresponseresponse=msg.gethttpresponsE()i
31
if (response = null) I
32
response=newdeFaulteullhttpresponse(http11,Ok,body)i
33,
F else I
34,
response=newdeFaultfullhttpresponse(msg.gethttpresponSe()
35,
getprotocolverSion(),msg.gethttpresponse(),getstAtus(),
36
body )i
37,
38.
response headers(). set(CONTENT TYPE, "text/xml")
39
setContentLength(response, body. readableBytes ())i
40
out. add(response)i
41,
42.}
它的实现非常简单,第30行对应答消息进行判断,如果业务侧己经构造了HTTP应
答消息,则利用业务已有应答消息重新复制一个新的HTTP应答消息。无法重用业务侧自
定义HTTP应答消息的主要原因,是Net!DefaultfullhttpresponsE没有提供动态设置
消息体 content的接口,只能在第一次构造的时候设置内容。由于这个局限,导致我们的
实现有点麻烦。
作为示例程序并没有提供更多的API供业务侧灵活设置HTTP应答消息头,在实际商
用时,可以基于本书提供的基础协议栈进行护展。
第38行设置消息体内容格式为“ text/xml”,然后在消息头中设置消息体的长度。第
40行把编码后的DefaultfullhttpresponSe对象添加到编码结果列表中,由后续Netty的
HTTP编码类进行二次编码。
4.HTTP+XML应答消息解码
客户端接收到HTTP+XML应答消息后,对消息进行解码,获取HttpxmlresponSe对
象,源码如下。
191Nety权威指南(第2版
代码清单10-15HTTP+XML应答消息解码类HttpxmirespoNsedecoder
11. public class Httpxmlresponse DEcoder extends
Abstracthttpxmldecoder<defaultfullhTtpresponse>f
13
public Httpxmlresponsedecoder(class<?> clazz)
15
this(clazzr false)i
16
17
18. public HttpxmlresponsedEcoder (clasS<?> clazz, boolean isprintlOg)(
19
super (clazz, isPrintlog)i
20
21
22
override
23,
protected void decode( Channe lHandlercontext ctx,
24,
DefaultfullhttpresponsemsgList<object>outthrowsException
25
HttpxmlresponsereshttpxmlreSponse=newHttpxmlresponse(mSg,decode0(
26
ctx, msg. content()))i
27
out.add(reshttpxmlresponse)i
28
29
第25行通过DefaultfullhttpResponse和HTTP应答消息反序列化后的POJO对象构造
HttpxmiresponsE,并将其添加到解码结果列表中。
5.HTTP+XML客户端开发
客户端的功能如下。
1)发起HTTP连接请求
(2)构造订购请求消息,将其编码成XML,通过HTTP协议发送给服务端
(3)接收HTTP服务端的应答消息,将XML应答消息反序列化为订购消息POO对象;
(4)关闭HTTP连接。
基于它的功能定位,我们首先开始主程序的开发
代码清单10-16HTTP+XML客户端启动类Httpxmlclient
23. public class Httpxmiclient  i
24.
25
public void connect (int port) throws Exception
192第10章HTTP协议开发应用
26
//配置客户端NIo线程组
27
EventLoopGroup group new NioEventLoopGroup()i
28
try 0
29,
Bootstrap b= new Bootstrap()i
30
b group(group). channel(NioSocketchannel. class)
31,
option(Channeloption TCP NODELAY, true)
32,
handler(new ChannelInitializer<socketChanne1>()I
33
override
34
public void initchannel(Socketchannel ch)
35
throws Exception i
36
ch.pipeline().addlast(http-decoder
37
new Httpresponse decodEr())i
38
ch.pipeline().addlast("http-aggregator
39
new HttpobjectaggregaTor(65536))i
40,
//XML解码器
41,
ch, pipeline(). addlast
42
xml-decoder
43
new Httpxmlresponse Decoder(order. class
44
true))i
45
ch.pipeline().addlast(http-encoder,
46,
new Httprequestencoder())i
47
ch pipeline(), addLast("xml-encoder
48
new HttpxmlrequestencodEr())i
49
ch pipeline(),addLast("xmlClientHandler
50
new HttpxmlclienthandlE())i
51
52
53
54
//发起异步连接操作
55
ChannelFuture f-b connect (new InetSocketAddress (port)).sync()i
56
57
//等待客户端链路关闭
58
f channel(). closeFuture().sync(i
59,
I finally
60
//优雅退出,释放NIo线程组
61
group. shutdownGracefully()i
62.
63
64,
65
66
Param args
·193Netty权威指南(第2版)
67
@throws Exception
68
69
public static void main(String [] args) throws Exception
70,
int port =8080;
71.
if (args ! null & args length > 0)(
72.
try i
73
port Integer valueof(args[o])i
74
catch (Number FormatException e) t
75,
//采用默认值
76,
77
78
new Httpxmlclient(). coNnect(port);
79
80.
在ChannelPipeline中新增了HttpResponseDecoder,它负责将二进制码流解码成为HTTP
的应答消息;随后第38行新增了HttpobjectagGregator,它负责将1个HTTP请求消息的多
个部分合并成一条完整的HTTP消息:第41~44行将前面开发的XML解码器
Httpxmiresponse decoder添加到 Channelpipeline中,它有两个参数,分别是解码对象的类
型信息和码流开关,这样就实现了HTTP+XML应答消息的自动解码。
第45~46行将 HttprequestenCoder编码器添加到 Channelpipeline中时,需要注意顺
序,编码的时候是按照从尾到头的顺序调度执行的,它后面放的是我们自定义开发的
HTTP+XML请求消息编码器HttpxmirequestEncoder
最后是业务的逻辑编排类 Http XmiclientHanDle,我们继续分析它的实现。
代码清单10-17 Http+xml客户端业务逻辑编排类 HttpxmlclientHandle
789
public class Httpxmlclienthandle extends
SimplechannelinboundhandlEr<httpxmlresponse>t
override
11
public void channelActive(ChannelHandlercontext ctx)
12
Httpxmlrequest request new Httpxmlrequest (nulL
3
OrderFactory. create(123))i
14,
ctx. writeAndFlush(request)i
15
16,
17
oVerride
18.
public void exceptionCaught( ChannelHandlerContext ctx, Throwable
194·第10章HTTP协议开发应用
cause) i
19
cause printstackTrace()i
20
ctx. close();
21
22
23,
oVerride
24
protected void messageReceived (ChannelHandlerContext ctx
25
Httpxmlresponse msg throws Exception i
26
Systemoutprintin("theclientreceiveresponseofhttpheaderis:"
27
+msggethttpresponse().headers().names())i
28
System.out.printin("theclientreceiveresponseofhttpbodyis
29
msg getResult());
30.
31.}
客户端的实现非常简单,第12行构造 HttpxmirequesT对象,调用 ChannelhandlerContext
的 write Andflush发送 Http xmirequesT。
第24~30行用于接收服务端的应答消息,从接口看,它接收到的已经是自动解码后
的 Http xmiresponsE对象了;第28~29行将应答POJO消息打印出来,可以与服务端发送
的原始对象进行比对,两者的内容将完全一致。
最后,看下订购对象工厂类的实现。
代码清单10-18HTIP+ⅩML订购对象工厂类 Order Factory
2. public class orderFactory i
3
public static Order create(long orderID)(
4
Order order new Order ()i
order. setorderNumber (orderID)i
order. setTotal(9999.999f)i
7
Address address new Address();
8
ddress. setcity("南京市");
address, setCountry("中国")
10
address. setPost Code( 123321)i
11
address. setstate("江苏省");
12
address. setstreet1("龙眠大道");
13
order. setBillTo(address)
14,
Customer customer= new Customer();
15
customer. setCustomer Number(orderID)i
16
customer. setFirstName("p:")i
17
customer, set lastName("林峰")
195·Net!y权威指南(第2版)
18.
order. setcustomer(customer)i
order. setShipping (Shipping INTERNATIONAL MAIL);
20,
order. setshipTo(address)
21,
return orderi
22
23,
6.HTTP+XML服务端开发
HTTP服务端的功能如下。
(1)接收HTTP客户端的连接;
2)接收HTTP客户端的ⅹML请求消息,并将其解码为POJO对象;
(3)对POJO对象进行业务处理,构造应答消息返回;
(4)通过HTTP+XML的格式返回应答消息;
(5)主动关闭HTTP连接。
下面我们首先看下服务端监听主程序的实现。
代码清单10-19HTTP+XML服务端主程序Httpxmiserver
22. public class Httpxmiserver i
23
public void run(final int port) throws Exception i
24
EventLoopGroup boss Group= new NioEventLoopGroup()
25
EventLoopGroup workerGroup =new NioEventLoopGroup()i
26
try i
27
ServerBootstrap b= new ServerBootstrap ()i
28.
b group(bossGroup, workerGroup)
29
channel(NioServer Socket Channel, class)
30
childHandler(new ChannelInitializer<socketChannel>()t
31
override
32
protected void initchannel(Socket channel ch)
33
throws Exception t
34
ch.pipeline().addlast(http-decoder
35,
new Httprequest decodeR ())i
36
ch.pipeline().addlast(http-aggregator,
new Httpobjectaggregator(65536))i
38.
ch pipeline()
39
addLast
·196·第10章HTTP协议开发应用
40
nxmI-decoder
41
new HttpxmlrequestdecoDer(
42
Order class, true))i
43
ch.pipeline().addlast("http-encoder
44
new Httpresponseencoder())i
45
ch pipeline().addLast("xml -encoder
46
new HttpxmlresponseencOder())i
47
ch pipeline().addLast("xmlServerHandler",
48,
new Httpxmlserverhandler())i
49
50
51
Channelfuture future
b. bind (new Inet SocketAddress(port))
sync()i
52
System.out.println("HTTP订购服务器启动,网址是:”+
"http://localhost:
53
ort);
54
future, channel(), closeFuture(). sync()i
55
finally I
56
bossGroup. shutdownGracefully()i
57,
workerGroup. shutdownGracefully(i
58
59
60
61
public static void main(string [] args) throws Exception t
62
int port = 8080;
63
if (args. length 0)
64
try
65,
port= Integer parseInt(args[o])i
66
1 catch (NumberFormatException e)
67
e printstackTrace()i
68
69
70
new Httpxmlserver().ruN(port)i
71
72
HTTP服务端的启动与之前一样,在此不再详述,我们具体看下编解码Handler是如
何设置的
第34~37行用于绑定HTTP请求消息解码器;第38~42行将我们自定义的Httpxml
RequestDecoder添加到HTTP解码器之后;第45~47行添加自定义的HttpxmlrespoNseencoder
·197Nety权威指南(第2版)
编码器用于响应消息的编码
下面我们继续看 Http xmlserverHandler的实现。
代码清单10-20 Httpixml服务端处理类 Http xmiserverHandler
30. public class HttpxmlserverhandlEr extends
31,
SimplechannelinboundhandlersHttpxmirequest> t
32
33
@Override
34.
public void messageReceived(final ChannelHandlerContext ctx
35,
Httpxmlrequest xmlrequest) throws Exception  i
36
Httprequest request = xmlrequest. getrequest()i
37,
Orderorder-(Order) xmlRequest, getBody()i
38,
Systemoutprintin("httpserverreceiverequest:+order)i
39,
dobusiness(order)
40
Channelfuture future=ctx. writeandflush(new Httpxmlresponse(nuLl
41
order)):
42
if (! isKeepAlive(request))t
43
future addListener(new GenericFuturelistener<Future<? super
Void>>(
44
public void operationComplete(Future future) throws Exception t
45
ctx. close()i
46
47
48
49
50
51
private void dobusiness(Order order)
52
order. getCustomer().setFirstName("2");
53.
order, getcustomer(). setlastname("仁杰”);
54
List<string> miaNames new Arraylist<string>()i
madAmes.ad("李元芳");
order. get Customer().setMiddleNames(midNames)i
57
Address address order. getBillTo()i
58
address. setcity("洛阳");
59
address, setcountry("大唐")
60
address, setstate("河南道");
61
address. set Postcode(123456")
62.
order. setBillTo(address)i
63
order. setShipTo (address)i
64
198·第10章HTTP协议开发应用
65
66,
oVerride
67,
public void exceptioncaught(ChannelHandlerContext ctx, Throwable
cause)
58.
throws Exception i
69
causeprintstackTrace ()i
70
if (ctx channel(.isActive()
sendError(ctx, INTERNAL SERVER ERROR);
72
73
74
75
private static void sendError(ChannelHandlercontext ctx,
76,
Httpresponsestatus status) i
77
FullhttpresponseresponsesnewDefaultfullhttpresponse(http11
78.
status, Unpooled. copiedBuffer("W: " status toString()
79
+"r\n", CharsetUtil UTF 8))i
80.
response headers (). set(CONTENT TYPE,"text/plain; charset=UTF-8")
81
ctx. writeAndFlush(response). addListener (Channel Futurelistener
CLOSE)i
82,
83,}
通过 messageReceived的方法入参 Http Xmirequest,可以看出服务端业务处理类接收
到的已经是解码后的业务消息了。第37行用于获取请求消息对象;随后将它打印出来,
可以与客户端发送的原始消息进行对比;第39行对订购请求消息进行业务逻辑编排;第
40~47行用于发送应答消息,并且在发送成功之后主动关闭HTTP连接。
第70~71行,在发生异常并且链路没有关闭的情况下,构造内部异常消息发送给客
户端,发送完成之后关闭HTTP链路。
到此,HTTP+XML的协议栈开发工作全部完成,下个小节我们看下运行结果。
1035HTTP+XML协议栈测试
本小节对前面几节开发的HTTP+XML协议栈进行测试。
首先对工程进行编译,然后执行JjBx的Ant脚本,对涉及的POJO对象进行二次编译,
执行完成之后,首先运行HTTP服务端,然后再运行客户端,执行结果如下。
199·Nety权威指南(第2版)
1.服务端
服务端接收到的请求消息码流打印如下
The body is <? xml version="1.0 encoding="UTF-8"2>
Korderxmlns="http://phei.com/netty/protocol/http:/xml/pojo"ordernumber=
123" total="9999.9g9">
<customer customerNumber=#123">
<firstName></firstName>
<1 astName>林峰</ LastName>
</customer>
<billTo>
< street1>龙眠大道</ street1>
<city>南京市</city>
< state>江苏省</ state>
<post Code>123321</postcode>
< country>中国</ country
/billTo>
<shipping>INTERNATIONAL MAIL</shipping>
<shipTo>
< street1>龙眠大道</ street1>
<city>南京市</city>
< state>江苏省</ state>
<postCode>123321</post Code>
< country>中国</ country>
</shipTo>
</order>
服务端解码后的业务对象如下。
Http server receive request : Order [ordernumber=123, customer=customer
[customerNumber=123, firstName=f, lastName=Mr, middleNames-nulll, billTo-
Address[ street1=龙眠大道, street2=nu1,city=南京市, state=江苏省, postCode=
123321, country=f], shipping=INTERNATIONAL MAIL, shipTo=Address [street1
龙眠大道, street2=nu11,city=南京市, state=江苏省, postcode=123321, country=中国],
tota1=9999.999]
2.客户端
客户端接收到的响应消息体码流如下
·200·第10章HTTP协议开发应用
The body is <?xml version="1. 0" encoding=UTF-8"?>
Corderxmlns="http://phei.com/netty/protocol/http:/xml/pojoordernumber=
123" total="9999.999">
<customer customerNumber=123">
<firstName>X</firstName>
<1 astName>仁杰</1 lasTname>
< middleName>李元芳</ middlename>
</customer>
<billTo>
< street1>龙眠大道</ street1>
<city>洛阳</city>
< state>河南道</ state>
<postCode>123456</postcode>
< country>大唐</ country>
</billTo>
<shipping>INTERNAT IONAL MAIL</shipping>
<shipto>
< street1>龙眠大道</ street1>
<city>洛阳</city>
< state>河南道</ state>
<postcode>123456</postCode>
<countr
ry>大唐</ country>
</shipTo>
</order>
解码后的响应消息如下。
Theclientreceiveresponseofhttpbodyis:orDer[ordernumber=123,
customer=Customer [customerNumber=123, firstName= y, lastName=2 x
middleNames=[李元芳]],bi11To= Address[ street1=龙眠大道, street2=nu1,city=洛
阳, state=河南道, post Code-123456, country-大唐], shipping= INTERNATIONAL MAIL,
shipto= Address[ street1=龙眠大道, street2=nu11,city=洛阳, state=河南道,
postCode=123456, country=XFl, total=9999.9991
测试结果表明,HTTP+XML协议栈功能正常,达到了设计预期。
103.6小结
需要指出的是,尽管本章节开发的HTTP+XML协议栈是个高性能、通用的协议栈,
但是,作为例程我们忽略了一些异常场景的处理、可扩展性的API和一些配置能力。所以,
·201·Net!y权威指南(第2版)
如果你打算在商用项目中使用本章节开发的HTTP+XML协议栈,仍需要做一些产品化的
完善工作。
104总结
本章节重点介绍了HTTP协议以及如何使用Net!y的HTTP协议栈开发基于HTTP的
应用程序,最后通过HTTP+XML协议栈的开发向读者展示了如何基于Nety提供的HTTP
协议栈做二次定制开发。
本章节的HTTP+XML协议栈在实际项目中非常有用,如果读者打算以它为基础进行
商业应用,需要补齐一些产品化的能力,例如配置能力、容错能力、更丰富的API。
·202·第11章
Web Socket协议开发
直以来,网络在很大程度上都是围绕着HTTP的请求/响应模式而构建的。客户端加
载一个网页,然后直到用户单击下一页之前,什么都不会发生。在2005年左右,AJAX
开始让网络变得更加动态了。但所有的HTTP通信仍然是由客户端控制的,这就需要用户
进行互动或定期轮询,以便从服务器加载新数据。
长期以来存在着各种技术让服务器得知有新数据可用时,立即将数据发送到客户端。
这些技术种类繁多,例如“推送”或 Comet。最常用的一种黑客手段是对服务器发起连接
创建假象,被称为长轮询。利用长轮询,客户端可以打开指向服务器的HTTP连接,而服
务器会一直保持连接打开,直到发送响应。服务器只要实际拥有新数据,就会发送响应(其
他技术包括 Flash、 XHR multipart请求和所谓的 HTML Files)。长轮询和其他技术都非常
好用,在Gmai聊天等应用中会经常使用它们。
但是,这些解决方案都存在一个共同的问题:由于HTTP协议的开销,导致它们不适
用于低延迟应用
为了解决这些问题, Web Socket将网络套接字引入到了客户端和服务端,浏览器和服
务器之间可以通过套接字建立持久的连接,双方随时都可以互发数据给对方,而不是之前
由客户端控制的一请求一应答模式。Net!y权威指南(第2版)
本章主要内容包括:
◎HTTP协议的弊端
Web Socket入门
◎ Netty Web Socket协议开发
111HTTP协议的弊端
将HTTP协议的主要弊端总结如下。
(1)HTTP协议为半双工协议。半双工协议指数据可以在客户端和服务端两个方向上
传输,但是不能同时传输。它意味着在同一时刻,只有一个方向上的数据传送;
(2)HTTP消息冗长而繁琐。HTTP消息包含消息头、消息体、换行符等,通常情况
下采用文本方式传输,相比于其他的二进制通信协议,冗长而繁琐;
(3)针对服务器推送的黑客攻击。例如长时间轮询
现在,很多网站为了实现消息推送,所用的技术都是轮询。轮询是在特定的的时间间
隔(如每1秒),由浏览器对服务器发出 Http request,然后由服务器返回最新的数据给
客户端浏览器。这种传统的模式具有很明显的缺点,即浏览器需要不断地向服务器发出请
求,然而 Http request的 Header是非常冗长的,里面包含的可用数据比例可能非常低,
这会占用很多的带宽和服务器资源。
比较新的一种轮询技术是 Comet,使用了AJAX。这种技术虽然可达到双向通信,但
依然需要发出请求,而且在 Comet中,普遍采用了长连接,这也会大量消耗服务器带宽
和资源。
为了解决HTTP协议效率低下的问题,HTML5定义了WebSocket协议,能更好地节
省服务器资源和带宽并达到实时通信,下个小节让我们一起来学习 Websocket的入门知识。
11.2 Web Socket入门
WebSocket是HTML5开始提供的一种浏览器与服务器间进行全双工通信的网络技
·204·第11章 WebSocket协议开发
术, Web Socket通信协议于20l1年被IETF定为标准RFC645, Web socket APi被W3C
定为标准
在 Web Socket API中,浏览器和服务器只需要做一个握手的动作,然后,浏览器和服
务器之间就形成了一条快速通道,两者就可以直接互相传送数据了。 WebSocket基于TCP
双向全双工进行消息传递,在同一时刻,既可以发送消息,也可以接收消息,相比HTTP
的半双工协议,性能得到很大提升。
下面总结一下 WebSocket的特点。
◎单一的TCP连接,采用全双工模式通信;
⑧对代理、防火墙和路由器透明;
◎无头部信息、 Cookie和身份验证;
◎无安全开销;
◎通过“ping/pong”帧保持链路激活
◎服务器可以主动传递消息给客户端,不再需要客户端轮询
11.2.1 Web Socket背景
Web Socket设计出来的目的就是要取代轮询和 Comet技术,使客户端浏览器具备像
C/S架构下稟面系统一样的实时通信能力。浏览器通过 Javascript向服务器发出建立
WebSocket连接的请求,连接建立以后,客户端和服务器端可以通过TCP连接直接交换数
据。因为 WebSocket连接本质上就是一个TCP连接,所以在数据传输的稳定性和数据传
输量的大小方面,和轮询以及 Comet技术相比,具有很大的性能优势。 Websocket.org网
站对传统的轮询方式和 WebSocket调用方式作了一个详细的测试和比较,将一个简单的
Web应用分别通过轮询方式和 Websocket方式来实现,在这里引用一下测试结果,如图
11-1所示。
通过对比图可以清楚地看出,在流量和负载增大的情况下, Web Socket方案相比传统
的AJAX轮询方案有极大的性能优势。这也是我们认为 Web socket是未来实时Web应用
的首选方案的原因
205·Net!y权威指南(第2版)
Web Socket
4000000o
100000090
UmCA
UcweB
UecG
8968000
600.0000
69.50000
16000
图11-1轮询和 WebSocket网络负载对比图
11.2.2 Websocket连接建立
客户端和服务端连接建立的示意图如图11-2所示。
客户端
服务端
握手请求
握手响应
图11-2客户端和服务端握手连接
建立 WebSocket连接时,需要通过客户端或者浏览器发出握手请求,请求消息示例如
图11-3所示
●206·第11章 WebSocket协议开发
Get chat Http/1.1
Host:serverexample.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXB3ZSBub25129==
Originhttp://example.com
Sec-WebSocket-Protocol: chat, superchat
L Sec-WebSocket-Version: 13
图11-3 WebSocket客户端握手请求消息
为了建立一个Websocket连接,客户端浏览器首先要向服务器发起一个HTTP请求,
这个请求和通常的HTTP请求不同,包含了一些附加头信息,其中附加头信息“Upgrade:
Websocket”表明这是一个申请协议升级的HTTP请求。服务器端解析这些附加的头信息,
然后生成应答信息返回给客户端,客户端和服务器端的 Web Socket连接就建立起来了,双
方可以通过这个连接通道自由地传递信息,并且这个连接会持续存在直到客户端或者服务
器端的某一方主动关闭连接
服务端返回给客户端的应答消息如图11-4所示。
Http/1.1 101 Switching Protocols
Upgrade: web socket
Connection: Upgrade
Sec-Websocket- Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo
Sec-WebSocket-protocol: chat
图11-4 WebSocket服务端返回的握手应答消息
请求消息中的“Sec- Web Socket-Key”是随机的,服务器端会用这些数据来构造出
个SHA-1的信息摘要,把“Sec- Web Socket-Key”加上一个魔幻字符串“258EAFA5-E914
4⑦DA-95CA-C5 ABODC85B1l”。使用SHA-1加密,然后进行BASE-64编码,将结果做为
“Sec- WebSocket- Accept”头的值,返回给客户端。
11.2.3 Websocket生命周期
握手成功之后,服务端和客户端就可以通过“ messages”的方式进行通信了,一个消
息由一个或者多个帧组成, Web Socket的消息并不一定对应一个特定网络层的帧,它可以
被分割成多个帧或者被合并。
帧都有自己对应的类型,属于同一个消息的多个帧具有相同类型的数据。从广义上讲,
数据类型可以是文本数据(UTF-8[RFC3629]文字)、二进制数据和控制帧(协议级信令,
207Netty权威指南(第2版)
如信号)。
WebSocket连接生命周期示意图如图11-5所示。
对等端点
已逹
对等端点
(客户端)打开
(服务器)
打开
消息
消息
消息
暗误
消意
消息
美闭
已断开
图11-5 WebSocket生命周期示意图
11.2.4 Web Socket连接关闭
为关闭 WebSocket连接,客户端和服务端需要通过一个安全的方法关闭底层TCP连
接以及TLS会话。如果合适,丢弃任何可能已经接收的字节,必要时(比如受到攻击)可
以通过任何可用的手段关闭连接。
底层的TCP连接,在正常情况下,应该首先由服务器关闭。在异常情况下(例如在
一个合理的时间周期后没有接收到服务器的 TCP Close),客户端可以发起 TCP Close。因
此,当服务器被指示关闭 WebSocket连接时,它应该立即发起一个 TCP Close操作;客户
端应该等待服务器的 TCP Close。
Web Socket的握手关闭消息带有一个状态码和一个可选的关闭原因,它必须按照协议
要求发送一个 Close控制帧,当对端接收到关闭控制帧指令时,需要主动关闭 WebSocket
连接。
通过本节的描述,相信读者对 Web Socket的基础知识有了一定的了解,大家如果对
Web socket规范感兴趣,可以访问 WebSocket的官网去了解更多的相关知识。
下个小节我们将一起学习如何使用 Netty开发 WebSocket服务端。
·208·第11章 Web Socket协议开发
113 Netty WebSocket协议开发
Ne!基于HTTP协议栈开发了WebSocket协议栈,利用Nety的WebSocket协议栈可
以非常方便地开发出 Websocket客户端和服务端。本节通过一个Nety服务端实例的开发,
向读者讲解如何使用Nety进行 WebSocket开发。
11.3.1 Websocket服务端功能介绍
WebSocket服务端的功能如下:支持 WebSocket的浏览器通过 WebSocket协议发送请
求消息给服务端,服务端对请求消息进行判断,如果是合法的 WebSocket请求,则获取请
求消息体(文本),并在后面追加字符串“欢迎使用 Netty WebSocket服务,现在时刻:系统
时间”。
客户端 HTMI通过内嵌的JS脚本创建 Web Socket连接,如果握手成功,在文本框中
打印“打开 Web Socket服务正常,浏览器支持 Web Socket!”。客户端界面如图11-6所示。
Netty WebSocket时间服务器
Net佳实匙
发送 WebSocket请求息
服务端返回的应答消息
图11-6 WebSocket客户端HTML
209·Net!y权威指南(第2版)
当前支持 WebSocket的浏览器如图11-7所示。从图中可以看出,目前主流的浏览器
都已经支持 WebSocket,但是在运行本例程之前你仍然需要确认自已使用的浏览器版本是
否已经支持 Websocket,否则会提示“抱歉,您的浏览器不支持 Websocket协议!”。
Web Sockets-working Dran
Globel uir fate+
571
Aidrectianf commun caren rennweg for wnb apgs
44
64
Resources: wio
r0 we
4:0
50
18 vernon back
2.06.0
1? se oe bad
3.0
70
s haar
3.5
80
3,6
14 venons b
4.D
13r
5.D
11
卫2e
012.0
70
3,0
10
m bice
80140
9.0
Gunns had
90
150
959.6
avenues bas
10.0160
10.0-10,1
11D
17.
10.5
rs表adk
120
18自
106
aversions tacks
13。190
3.1
110
2,2
100数
4veriloni 6.0
14,
20.0
2
11,1
32
2-3
110
wsn20150210
4自
5
4.041
3.0
2versonshack 8.0
160
220
5.011.6
424.3
4.0
115
10
18.0
240
60121
605070427012418010
图11-7支持 Web Socket的浏览器及其版本
11.3.2 Websocket服务端开发
首先对 WebSocket服务端的功能进行简单地讲解。 WebSocket服务端接收到请求消息
之后,先对消息的类型进行判断,如果不是 Web Socket握手请求消息,则返回HTP400
BAD REQUEST响应给客户端。客户端的握手请求消息如图11-8所示。
Defaultfullhttprequestrdecoderesult:success
Get/wEbsoCket Http/1.1
Upgrade:wehs。cket
Connection: Upgrad
Host: localhost: 8080
Originhttp://localhost:8080
Sec-Websocket-Rey: qWor7m5Rhsgz a8UTBbC5A=-
Sec-tebsocket-version: 13
Scc-Ucbsocket-Extensiona: x-webkit-deflate-frarme
Content-Length: 0
图11-8客户端发送的 WebSocket握手请求消息
服务端对握手请求消息进行处理,构造握手响应返回,双方的 Socket连接正式建立
服务端返回的握手应答消息如图11-9所示
210·第11章 Websocket协议开发
Defaultfullhttpresponse(decodeResult:success
Http/1.1 101 Switching Protocols
Upgrade: websocket
I Connection: Upgrade
sec一ebs。cket- Accept: XPORwTKeQBrU8v+ CTLFE口+AI1Y=
图11-9 WebSocket握手应答消息
连接建立成功后,到被关闭之前,双方都可以主动向对方发送消息,这点跟HTTP的
请求一应答模式存在很大的差别。相比于HTP,它的网络利用率更高,可以通过全双
工的方式进行消息发送和接收。
下面一起来看下服务端代码的具体实现,首先看服务启动类
代码清单11-1 Web socket服务端启动类 Web Socketserver
public class WebSocketserver t
public void run(int port) throws Exception
23456
EventLoopGroup boss Group new NioEventLoopGroup ()i
EventLoopGroup workerGroup= new NioEventLoopGroup()i
try i
ServerBootstrap b= new ServerBootstrap():
789
b group (hossGroup, workerGroup)
channel (NioServerSocketChannel. class)
childHandler(new ChannelInitializer<socketchanne1>()[
10
11
@override
12.
protected void initchannel( SocketChannel ch)
13
throws Exception
14.
Channelpipeline pipeline- ch pipeline()i
15
pipelineaddlast("http-Codec
16,
new Httpservercodec())i
17
pipe line. addLast("aggregator
18
new HttpobjectaggregaTor(65536))i
19,
ch.pipeline(),addlast(http-chuNked
20
new Chunkedwri tehandler())
21,
pipeline, addLast(handler",
22,
new WebsocketserverHandler()i
23
24
25
26,
Channel ch = b. bind (port). sync(). channel(
211Ne权威指南(第2版)
27
System, out. printin(Web socket server started at port " port
28
十
29,
System. out
30
println("Open
your
browser
and
navigate
t
http://localhost:
31
+port+"/");
32
33
ch. closeFuture(), sync()i
34
s finally f
35,
bossGroup, shutdownGracefully()i
36
workerGroup. shutdownGracefully()i
37
38
39
40
public static void main(String [ args) throws Exception t
41,
int port =8080i
42,
if (args, length >0)i
try i
44,
port Integer parseInt (args[0])i
45,
I catch (NumberFormatException e) I
46
e printstackTrace();
47
48
49
new WebSocketserver () run (port)i
50
51.}
第15~16行首先添加HttpServercodec,将请求和应答消息编码或者解码为HTTP消
息:第17~18行增加HttpobjectaggRegator,它的目的是将HTTP消息的多个部分组合成
条完整的HTTP消息;第19~20行添加Chunkedwritehandler,来向客户端发送HIML5
文件,它主要用于支持浏览器和服务端进行 Websocket通信;最后21~22行增加 Web Socket
服务端 Handler
看了 WebSocket的服务启动类,很多读者会心存疑惑:怎么 WebSocket服务端的代码
跟HTTP协议的非常类似呢?没有看到在ChannelPipeline中增加WebSocket的Handler,
那如何处理 WebSocket消息?这个疑问很好,下面就一起来从 WebSocketserverhandler的
实现中寻找答案。
·212第11章 Websocket协议开发
代码清单11-2 WebSocket服务端处理类 Web SocketServerHandler
1. public
class
Websocket serverhandler
extends
SimpleChannel
InboundHandler<object>
private static final Logger logger= Logger
getLogger (WebSocketserverHandler class getName())i
456789
private WebSocketserverHandshaker handshakeri
override
public void messageReceived(ChannelHandler Context ctx, Object msg)
throws Exception i
10
//传统的HTTP接入
11
ifmsginstanceofFullhttprequest)
12,
handlehttprequest(ctx,(fuLlhttprequest)msg)i
13.
// WebSocket接入
15
else if (msg instanceof WebSocketFrame ) t
16,
handleweb SocketFrame(ctx, (Web SocketFrame) msg)i
17
18
20
override
21,
public void channelReadcomplete(ChannelHandlercontext ctx) throws
Exception i
22
ctx. flush()i
23
24
25,
privatevoidhandlehttprequest(channelHandlercontextctx
26
EullhttprequestreqthrowsException[
27
28,
/如果HTTP解码失败,返回HTTP异常
29
if ( reg. getDecoderResult().isSuccess(
30
II(!"websocket"equals(reg. headers(). get ("Upgrade"))))1
31
sendhttpresponse(Ctx,reg,newDefaultfullhttpresponse(http11
32
BAD REQUEST))I
33
returni
34
36
/构造握手响应返回,本机测试
37
Web SocketserverHandshakerFactory wsFactory new WebSocketserver
HandshakerFactory
213Nety权威指南(第2版
38
It ws://localhost: 8080/websocket", null, false)i
39.
handshake wsFactory. newHandshaker(req)i
40,
if (handshake = null)[
41,
WebSocketServerHandshaker Factory
42
sendUnsupportedwebSocketversionResponse(ctx channel())i
y else
44
handshake. handshake(ctx. channel(), reg)i
45,
46,
47.
48.
private void handleWeb SocketFrame(ChannelHandlerContext ctx
49
WebSocketFrame frame) i
50,
51
//判断是否是关闭链路的指令
52
if (frame instanceof CloseWebSocketFrame)
53,
handshake, close(ctx channel()r
54.
( CloseWebSocketFrame) frame. retain())i
55
return:
56
57,
/判断是否是Ping消息
58.
if ( frame instanceof PingWebSocketFrame) t
59
ctx channel(.write(
60
new PongWebsocketFrame (frame content(. retain()))i
61
returni
62
63
//本例程仅支持文本消息,不支持二进制消息
64
f(!(frame instanceof TextWebSocketFrame))
65
throw new Unsuppor tedoperationException (string. format
66
9s frame types not supported", frame getClass(). getName()))
67
68
69
/返回应答消息
70,
String request = ((TextWebSocketFrame) frame), text()i
if (logger. isLoggable(Level. FINE))t
72,
logger. fine(String. format("s received is", ctx. channel(),
request))i
73,
74.
ctx channel().write(
75
new TextWebSocketFrame(request
76
+”,欢迎使用 Netty WebSocket脹务,现在时刻:
77
new java util. Date(). tostring()))i
214·第11章 WebSocket协议开发
78
79
80
privatestaticvoidsendhttpresponse(ChannelhandlerconTextctx
81
FullhttprequestredFullhttpresponseres)i
82
/返回应答给客户端
83
if (res getstatus().code()=200)t
84
ByteBuf buf Unpooled copiedBuffer(res getstatus(). tostring(),
85
Charsetutil UTE 8)i
86
rescontent().writeBytes (buf)i
87,
buf. released
88.
setContentLength(res, res, content (). readableBytes())i
89
90
91
//如果是非Keep-41ive,关闭连接
92
Channelfuture f= ctx channel(), writeAndFlush(res)i
93
if (!isKeepAlive(reg)I res getstatus(). code()I= 200)(
94,
f addListener(ChannelFuturelistener. ClOSE)
95
6
97
98
@override
99
public void exceptionCaught(ChannelHandlerContext ctx, Throwable
cause)
100
throws Exception t
101
cause printstackTrace()i
102.
ctx. close()i
103
104
首先从第1行看起,第一次握手请求消息由HTTP协议承载,所以它是一个HTTP
消息,执行handlehttprequest方法来处理WebSocket握手请求。第29~34行首先对握手
请求消息进行判断,如果消息头中没有包含 Upgrade字段或者它的值不是 websocket,则
返回HTTP400响应。
握手请求简单校验通过之后,开始构造握手工厂,创建握手处理类 Web Socket Server
Handshake,通过它构造握手响应消息返回给客户端,同时将 Web Socket相关的编码和解
码类动态添加到 Channelpipeline中,用于 Websocket消息的编解码,代码如图11-10所示。
添加 WebSocket encoder和 WebSocket decoder之后,服务端就可以自动对 WebSocket
消息进行编解码了,后面的业务 handler可以直接对 WebSocket对象进行操作。下面继续
215Nety权威指南(第2版)
分析链路建立成功之后的操作:客户端通过文本框提交请求消息给服务端, Web Socket
Serverhandler接收到的是已经解码后的 Web socketframe消息。第48~96行对 WebSocket
请求消息进行处理,首先需要对控制帧进行判断,如果是关闭链路的控制消息,就调用
WebSocketServerhandshaker的 close方法关闭 Web Socket连接;如果是维持链路的ping消
息,则构造Pong消息返回。由于本例程的 Web socket通信双方使用的都是文本消息,所
以对请求消息的类型进行判断,不是文本的抛出异常。
if (ctx ==null](
W this means the user use a Http Servercodec
ctx=p.context(httpservercodec.class
if (ctx ==null)(
mise. setFailured
new llegalstateexceptiOn( no Httpdecoder and no
+"httpsErvercodecinthepipeline")):
return promise
paddBefore(ctx name(), wsdecoder", newwebsocketDecoder())
p addBefore(ctx name("",newWebSocketEncoder());
encoderName ctx name(
F else(
p replace(ctx name(), "wsdecoder, newWebsocketDecoder()
encodername=p.context(httpresponseencoder.class).name0
p add Before(encoderName, "wsencoder'" newWebSocketEncodero)
图11-10 Web Socket握手应答时动态增加编解码 handler
最后,从 Text Websocketframe中获取请求消息字符串,对它处理后通过构造新的
Text Web Socketframe消息返回给客户端,由于握手应答时动态增加了 TextWeb Socket frame
的编码类,所以,可以直接发送 Text Web socketframe对象
客户端浏览器接收到服务端的应答消息后,将其内容取出展示到浏览器页面中。我们
简单分析客户端 WebSocketServer htm的源码。
chtml>
shead>
<meta charset= uTF-8>
Netty Websocket时间服务器
</head>
br>
<body>
<br>
<script type="text/javascript">
var socket
if window WebSocket)
window. WebSocket window. MozWeb Socket
216第11章 Web socket协议开发
if (window. WebSocket) t
socket new WebSocket("ws: //localhost: 8080/websocket")i
socket, onmessage function(event)(
var ta document getElementById('responsefext')i
ta value="";
ta value event dat
socket. onopen = function (event) I
var ta document getElementById('responseText')i
ta.va1ue="打开 Websocket服务正常,浏览器支持 WebSocket!";
};
socket onclose function(event)(
var ta document getElementById('responserext)i
ta. value
ta.va1ue=" Web Socket关闭!"
else
aert("抱歉,您的浏览器不支持 Websocket协议!");
function send(message) I
if (window. WebSocket)[ return; F
if (socket readystate = WebSocket OPEN) I
socket send (message)i
else
a1ert(" Websocket连接没有建立成功!");
</script>
<form onsubmit="return false:>
< input type="text"name=" message"va1e=" Netty最实践"/>
<br><br>
< input type=" button” value=”发送 Web Socket请求消息"onc1ick="send
(this form. message value)/>
<hr color= blue /
<h3>服务端返回的应答消息</h3
217·Netty权威指南(第2版
<textarea id=responseText h style="width: 500px; height: 300px: " ></textarea>
</form>
</body>
</htm1>
由于通过JS开发 WebSocket的接口比较简单,所以此处不再赘述,对此感兴趣的同
学可以通过JSR356、相关的技术书籍或者网站进行学习。
好,基于Nety的 WebSocket服务端已经开发完毕,下个小节我们一起来测试下本节
开发的程序,看它的各项功能是否能够达到设计预期。
11.3.3运行 Web Socke服务端
启动 Web Socket服务,采用支持 WebSocket的浏览器访问 WebSocket Server.htm,显
示结果如图11-11所示。
如凸1H// seftruraladlipss x
Netty WebSocket时间服务器
NetY最佳实跳
发选WebS0ck时请消思
@:服务端返回的应答消息
打开 csocket服务正常,浏览器支持 ebsocket!
图11-11通过浏览器访问 Websocket服务端
文本框中显示“打开 Web Socket服务正常,浏览器支持 Web Socket!”",说明 Web Socket
链路建立成功,然后单击【发送 Web Socket请求消息】按钮,显示结果如图11-12所示,
当使用不支持 WebSocket的老版本IE浏览器打开 WebSocketServer.htm时,运行结果
如图11-13所示。
218·第11章 Web Socket协议开发
制图i1l:H/m/ oftware/eclipse x+
固回回
Net ty卿 csOcket时间服务器
Nett佳卖
发送 WebSocke请求肖恩
@:服务端返回的应答消息
Nett最佳实跳,欢迎使用 Netty HebSocketl服务,现在时劃: Thu lar06
22:51:05csT014
图11-12打印 WebSocket服务端返回的结果
D ieMsoeketse, febsocketSer.0 telseekets,·ist.t圆
Netty Websocket时间服务器
网页的清息
A
抱歉,您的询器不支持Sach电炒识!
图11-13不支持 WebSocket的浏览器运行效果图
114总结
本章首先介绍了HTTP协议的弊端和产生WebSocket的一些技术背景,随后对
WebSocket的优势和基础入门知识进行了介绍,包括 WebSocket的握手请求和响应、连接
的建立和关闭、 WebSocket的生命周期等。
219Net!y权威指南(第2版)
学习了 WebSocket的基础知识之后,通过 Netty WebSocket时间服务器的开发,读者
朋友可以更好地掌握如何利用Nety提供的 Web Socket协议栈进行 WebSocket应用程序的
开发。
由于 WebSocket本身的复杂性,以及可以通过多种形式(例如文本方式、二进制方式)
承载消息,所以,它的API和用法也非常多,限于篇幅,本书无法对这些场景一一枚举。
希望本章的例程能够起到抛砖引玉的作用,想要掌握更多的用法,需要读者结合Net!y的
测试用例和示例,以及 Web Socke相关类库的 Java Doc进行深入学习和实践,相信通过不
断地实践很快就能掌握更多的功能和用法。
下一章,我们将继续学习如何利用 Netty进行UDP协议的开发。
220·第12章
私有协议栈开发
广义上区分,通信协议可以分为公有协议和私有协议。由于私有协议的灵活性,它往
往会在某个公司或者组织内部使用,按需定制,也因为如此,升级起来会非常方便,灵活
性好
绝大多数的私有协议传输层都基于TCPP,所以利用 Netty的 NIO TCP协议栈可以
非常方便地进行私有协议的定制和开发。本章节通过一个私有协议的设计和开发,让读者
能够熟悉和掌握这方面的知识
本章主要内容包括:
私有协议介绍
◎基于Nety的私有协议栈设计
◎私有协议栈开发
121私有协议介绍
私有协议本质上是厂商内部发展和采用的标准,除非授权,其他厂商一般无权使用该
协议。私有协议也称非标准协议,就是未经国际或国家标准化组织采纳或批准,由某个企Nety权威指南(第2版)
业自己制订,协议实现细节不愿公开,只在企业自己生产的设备之间使用的协议。私有协
议具有封闭性、垄断性、排他性等特点。如果网上大量存在私有(非标准)协议,现行网
络或用户一旦使用了它,后进入的厂家设备就必须跟着使用这种非标准协议,才能够互连
互通,否则根本不可能进入现行网络。这样,使用非标准协议的厂家就实现了垄断市场的
愿望。
尽管私有协议具有垄断性的特征,但并非所有的私有协议设计者的初衷就是为了垄
断。由于现代软件系统的复杂性,一个大型软件系统往往会被人为地拆分成多个模块,另
外随着移动互联网的兴起,网站的规模也越来越大,业务的功能越来越多,为了能够支撑
业务的发展,往往需要集群和分布式部署,这样,各个模块之间就要进行跨节点通信。
在传统的Java应用中,通常使用以下4种方式进行跨节点通信
(1)通过RMI进行远程服务调用;
2)通过Java的 Socket+JaⅦa序列化的方式进行跨节点调用
3)利用一些开源的RPC框架进行远程服务调用,例如 Facebook的 Thrift、 Apache
的Avro等;
(4)利用标准的公有协议进行跨节点服务调用,例如HTP+XML、 RESTful+JSON或
者 WebService。
跨节点的远程服务调用,除了链路层的物理连接外,还需要对请求和响应消息进行编
解码。在请求和应答消息本身以外,也需要携带一些其他控制和管理类指令,例如链路建
立的握手请求和响应消息、链路检测的心跳消息等。当这些功能组合到一起之后,就会形
成私有协议。
事实上,私有协议并没有标准的定义,只要是能够用于跨进程、跨主机数据交换的非
标准协议,都可以称为私有协议。通常情况下,正规的私有协议都有具体的协议规范文档,
类似于《XXXX协议ⅴXX规范》,但是在实际的项目中,内部使用的私有协议往往是口头
约定的规范,由于并不需要对外呈现或者被外部调用,所以一般不会单独写相关的内部私
有协议规范文档
本章使用 Netty提供的异步TCP协议栈开发一个私有协议栈,该协议栈被命名为Net
协议栈。从下个小节开始,我们将详细介绍 Netty t协议的设计和开发
·222·第12章私有协议栈开发
12.2 Netty协议栈功能设计
Nety协议栈用于内部各模块之间的通信,它基于TcPP协议栈,是一个类HTTP协
议的应用层协议栈,相比于传统的标准协议栈,它更加轻巧、灵活和实用
122.1网络拓扑图
如图12-1所示,在分布式组网环境下,每个Nety节点( Netty进程)之间建立长连
接,使用Net!y协议进行通信。Nety节点并没有服务端和客户端的区分,谁首先发起连接,
谁就作为客户端,另一方自然就成为服务端。一个Net!y节点既可以作为客户端连接另外
的Net!节点,也可以作为Nety服务端被其他Ney节点连接,这完全取决于使用者的业
务场景和具体的业务组网
Netty节点1
Net!y协议
Netty
协议
光纤交换机
Netty节点3
Netty协议
Nety节点2
图12-1Nety协议网络拓扑示意图
223·Netty权威指南(第2版)
12.2.2协议栈功能描述
Nety协议栈承载了业务内部各模块之间的消息交互和服务调用,它的主要功能如下。
(1)基于 Netty的NO通信框架,提供高性能的异步通信能力;
2)提供消息的编解码框架,可以实现POJO的序列化和反序列化;
(3)提供基于IP地址的白名单接入认证机制;
(4)链路的有效性校验机制;
(5)链路的断连重连机制。
122.3通信模型
Nety协议栈通信模型如图12-2所示。
1握手请求
2握手应答
Netty
3发送业务消息
Netty
客户端
4发送心跳消息服务端
5发送心跳消息
6发送业务消息
关闭连接><关闭连楼
图12-2 Netty协议栈通信交互图
具体步骤如下
(1)Nety协议栈客户端发送握手请求消息,携带节点ID等有效身份认证信息;
(2)Net!y协议栈服务端对握手请求消息进行合法性校验,包括节点ID有效性校验
节点重复登录校验和PP地址合法性校验,校验通过后,返回登录成功的握手应答消息:
(3)链路建立成功之后,客户端发送业务消息;
(4)链路成功之后,服务端发送心跳消息;
(5)链路建立成功之后,客户端发送心跳消息;
·224·第12章私有协议栈开发
(6)链路建立成功之后,服务端发送业务消息;
7)服务端退出时,服务端关闭连接,客户端感知对方关闭连接后,被动关闭客户端
连接。
备注:需要指出的是,Net!协议通信双方链路建立成功之后,双方可以进行全双工
通信,无论客户端还是服务端,都可以主动发送请求消息给对方,通信方式可以是TWO
WAY或者 ONE WAY。双方之间的心跳采用Ping-Po晤g机制,当链路处于空闲状态时,客
户端主动发送Ping消息给服务端,服务端接收到ping消息后发送应答消息Pong给客户端
如果客户端连续发送N条Ping消息都没有接收到服务端返回的Pong消息,说明链路已经
挂死或者对方处于异常状态,客户端主动关闭连接,间隔周期T后发起重连搡作,直到重
连成功。
12.2.4消息定义
Netty协议栈消息定义包含两部分:
消息头
消息体
其具体定义分别如表12-1和表122所示。
表12-1Net!消息定义表( NettyMessage)
名称
类型
长度
描述
header
Header
变长
消息头定义
对于请求消息,它是方法的参数(作为示例,只支持携带一个参数)
Object
变长
对于响应消息,它是返回值
表12-2Nety协议消息头定义( Header)
名称
类
刑
长度
描述
Net!y消息的校验码,它由三部分组成
1)0 KABE:固定值,表明该消息是Net!y协议消息,2个字节
crotone
整型int
2)主版本号:1~255,1个字节:
3)次版本号:1~255,1个字节。
recOde=0 XABEF+主版本号+次版本号
225Netty权威指南(第2版)
续表
名称
类型
长度
描述
整型int
消息长度,整个消息,包括消息头和消息体
sessionID长整型long
集群节点内全局唯一,由会话ID生成器生成
0:业务请求消息
1:业务响应消息
2:业务 ONE WAY消息(既是请求又是响应消息)
type
BY
3:握手请求消息
4:握手应答消息
5:心跳请求消息
6:心跳应答消息
priority
Byte
消息优先级:0~255
attachment Map< String, Object>变长
可选字段,用于扩展消息头
122.5Nety协议支持的字段类型
Netty协议支持的数据类型如表12-3所示。
表12-3Nety协议支持的数据类型
宇段类型
备注说明
boolean
包括它的包装类型 Integer
bvte
包括它的包装类型Byte
Int
对应于CC++的int32
char
包括它的包装类型 Character
short
对应CC++的intl6
lc
对应CC++的int64
float
包括它的包装类型 Float
double
包括它的包装类型 Double
string
对应CC++的 String
list
支持各种List的实现
array
支持各种数组的实现
map
支持Map的嵌套和泛型
set
支持Set的嵌套和泛型
226·第12章私有协议栈开发
12.2.6Nett协议的编解码规范
1.Net!y协议的编码
Net!y协议 Netty Message的编码规范如下。
(1) crc code: Java nlo. ByteBuffer. putIn( Gint value),如果采用其他缓冲区实现,必须与
其等价;
(2) length: Java nIo. ByteBuffer. putIn( int value),如果采用其他缓冲区实现,必须与
其等价;
(3) sessionid: Java nIo, Byte Buffer pulOng( long value),如果釆用其他缓冲区实现,
必须与其等价;
(4)type: Java nIo, Byte Buffer. put( byte b),如果采用其他缓冲区实现,必须与其等价;
5) priority: Java. nIc. Byte.put( byte b),如果采用其他缓冲区实现,必须与其等价;
(6) attachment:它的编码规则为——如果 attachment长度为0,表示没有可选附件,
则将长度编码设为0, JavanIo. Byte Buffer; putIn(0);如果大于0,说明有附件需要编码,
具体的编码规则如下。
◎首先对附件的个数进行编码,java.nio. Byte Buffer. putInt(attachment,size)
◎然后对Key进行编码,先编码长度,再将它转換成byte数组之后编码内容,具
体代码如下。
string key- null
byte[] value null;
for(Map Entry<String, Object> param attachment entrySet())(
key param getKey()i
buffer writestring(key);
value = marshaller writeObject(param getvalue());
buffer. writeBinary(value)i
key
u11
value null:
227Nety权威指南(第2版)
需要说明的是,将 String字符串写入 Byte Buffer和通过 Jboss marshalling将 Object序
列化为byte数组,此处没有详细展开介绍,后续代码开发章节会给出具体实现。
(7)body的编码:通过 JBoss Marshalling将其序列化为bye数组,然后调用
java nio Byte Buffer put(byte[]sre)将其写入 ByteBuffer缓冲区中。
由于整个消息的长度必须等全部字段都编码完成之后才能确认,所以最后需要更新消
息头中的 length字段,将其重新写入 Byte Buffer中。
2. Netty协议的解码
相对于 Netty Message的編码,仍旧以 Java nio. ByteBuffer为例,给出Nety协议的解
码规范。
1) recOde:通过 Java. nlo. Byte Buffer getIntO)获取校验码字段,其他缓冲区需要与其
等价;
(2) length;通过 JavanIo. Byte Buffer· getInto获取Net!y消息的长度,其他缓冲区需要
与其等价;
(3) sessionid:通过 Java. n1o. Byte Buffer. getLongo获取会话ID,其他缓冲区需要与其
等价;
(4)type:通过 JavanIo. Byte Buffer:getO获取消息类型,其他缓冲区需要与其等价;
(5) priority:通过 Java, nIc. Byte Buffer, geto获取消息优先级,其他缓冲区需要与其等价
6) attachment:它的解码规则为——首先创建一个新的 attachment对象,调用
javanio Byte Buffer.. getInto获取附件的长度,如果为0,说明附件为空,解码结束,继续解
消息体;如果非空,则根据长度通过for循环进行解码。
String key null
Object value= null
for (int i 0; i size; i++)i
key= buffer readstring ()i
value- unmarshaller readobject(buffer. readBinary())i
thisattachment. put (key, value);
ey
u11;
value= null
·228·第12章私有协议栈开发
后续的代码开发章节会给出附件解码的具体实现,此处不再详细展开,仅仅給出解码
的规则。
7)body:通过 J Boss的 marshaller对其进行解码
122.7链路的建立
Nety协议栈支持服务端和客户端,对于使用Nety协议栈的应用程序而言,不需要刻
意区分到底是客户端还是服务端,在分布式组网环境中,一个节点可能既是服务端也是客
户端,这个依据具体的用户场景而定
Netty协议栈对客户端的说明如下:如果A节点需要调用B节点的服务,但是A和B
之间还没有建立物理链路,则由调用方主动发起连接,此时,调用方为客户端,被调用方
为服务端。
考虑到安全,链路建立需要通过基于IP地址或者号段的黑白名单安全认证机制,作
为样例,本协议使用基于IP地址的安全认证,如果有多个IP,通过逗号进行分割。在实
际商用项目中,安全认证机制会更加严格,例如通过密钥对用户名和密码进行安全认证。
客户端与服务端链路建立成功之后,由客户端发送握手请求消息,握手请求消息的定
义如下。
(1)消息头的type字段值为3
(2)可选附件为个数为0
(3)消息体为空
(4)握手消息的长度为22个字节
服务端接收到客户端的握手请求消息之后,如果IP校验通过,返回握手成功应答消
息给客户端,应用层链路建立成功。握手应答消息定义如下
(1)消息头的type字段值为4;
(2)可选附件个数为0;
(3)消息体为byte类型的结果,“0”表示认证成功;“-1”表示认证失败
链路建立成功之后,客户端和服务端就可以互相发送业务消息了
·229·Netty权威指南(第2版)
122.8链路的关闭
由于采用长连接通信,在正常的业务运行期间,双方通过心跳和业务消息维持链路,
任何一方都不需要主动关闭连接。
但是,在以下情况下,客户端和服务端需要关闭连接。
(1)当对方宕机或者重启时,会主动关闭链路,另一方读取到操作系统的通知信号,
得知对方REST链路,需要关闭连接,释放自身的句柄等资源。由于采用TCP全双工通信,
通信双方都需要关闭连接,释放资源;
(2)消息读写过程中,发生了IO异常,需要主动关闭连接;
(3)心跳消息读写过程中发生了LO异常,需要主动关闭连接;
(4)心跳超时,需要主动关闭连接
5)发生编码异常等不可恢复错误时,需要主动关闭连接。
1229可靠性设计
Netty协议栈可能会运行在非常恶劣的网络环境中,网络超时、闪断、对方进程僵死
或者处理缓慢等情况都有可能发生。为了保证在这些极端异常场景下Nety协议栈仍能够
正常工作或者自动恢复,需要对它的可靠性进行统一规划和设计。
心跳机制
在凌晨等业务低谷期时段,如果发生网络闪断、连接被Hang住等网络问题时,由于
没有业务消息,应用进程很难发现。到了白天业务高峰期时,会发生大量的网络通信失败,
严重的会导致一段时间进程内无法处理业务消息。为了解决这个问题,在网络空闲时采用
心跳机制来检测链路的互通性,一旦发现网络故障,立即关闭链路,主动重连。
具体的设计思路如下。
(1)当网络处于空闲状态持续时间达到T(连续周期T没有读写消息)时,客户端主
动发送Ping心跳消息给服务端
(2)如果在下一个周期T到来时客户端没有收到对方发送的Pong心跳应答消息或者
230第12章私有协议栈开发
读取到服务端发送的其他业务消息,则心跳失败计数器加1
(3)每当客户端接收到服务的业务消息或者Pong应答消息时,将心跳失败计数器清
零:连续N次没有接收到服务端的Pong消息或者业务消息,则关闭链路,间隔 INTERVAL
时间后发起重连操作。
(4)服务端网络空闲状态持续时间达到T后,服务端将心跳失败计数器加1;只要接
收到客户端发送的Ping消息或者其他业务消息,计数器清零。
5)服务端连续N次没有接收到客户端的Ping消息或者其他业务消息,则关闭链路,
释放资源,等待客户端重连。
通过Ping-Pong双向心跳机制,可以保证无论通信哪一方出现网络故障,都能被及时
地检测出来。为了防止由于对方短时间内繁忙没有及时返回应答造成的误判,只有连续N
次心跳检测都失败才认定链路已经损害,需要关闭链路并重建链路。
当读或者写心跳消息发生IO异常的时候,说明链路已经中断,此时需要立即关闭链
路,如果是客户端,需要重新发起连接。如果是服务端,需要淸空缓存的半包信息,等待
客户端重连
2.重连机制
如果链路中断,等待 INTERVAL时间后,由客户端发起重连操作,如果重连失败,间
隔周期 INTERⅤAL后再次发起重连,直到重连成功。
为了保证服务端能够有充足的时间释放句柄资源,在首次断连时客户端需要等待
INTERVAL时间之后再发起重连,而不是失败后就立即重连
为了保证句柄资源能够及时释放,无论什么场景下的重连失败,客户端都必须保证自
身的资源被及时释放,包括但不限于 Socketchannel、 Socket等。
重连失败后,需要打印异常堆栈信息,方便后续的问题定位。
3.重复登录保护
当客户端握手成功之后,在链路处于正常状态下,不允许客户端重复登录,以防止客
户端在异常状态下反复重连导致句柄资源被耗尽。
服务端接收到客户端的握手请求消息之后,首先对IP地址进行合法性检验,如果校
·231·Nety权威指南(第2版
验成功,在缓存的地址表中査看客户端是否已经登录,如果已经登录,则拒绝重复登录,
返回错误码-1,同时关闭TCP链路,并在服务端的日志中打印握手失败的原因。
客户端接收到握手失败的应答消息之后,关闭客户端的TCP连接,等待 INTERVAL
时间之后,再次发起TCP连接,直到认证成功。
为了防止由服务端和客户端对链路状态理解不一致导致的客户端无法握于成功的问
题,当服务端连续N次心跳超时之后需要主动关闭链路,清空该客户端的地址缓存信息,
以保证后续该客户端可以重连成功,防止被重复登录保护机制拒绝掉。
4.消息缓存重发
无论客户端还是服务端,当发生链路中断之后,在链路恢复之前,缓存在消息队列中
待发送的消息不能丢失,等链路恢复之后,重新发送这些消息,保证链路中断期间消息不
丢失。
考虑到内存溢出的风险,建议消息缓存队列设置上限,当达到上限之后,应该拒绝继
续向该队列添加新的消息。
12.2.10安全性设计
为了保证整个集群环境的安全,内部长连接采用基于IP地址的安全认证机制,服务
端对握手请求消息的IP地址进行合法性校验:如果在白名单之内,则校验通过;否则,
拒绝对方连接。
如果将Net!y协议栈放到公网中使用,需要采用更加严格的安全认证机制,例如基于
密钥和AES加密的用户名+密码认证机制,也可以采用 SSL/TSL安全传输。
作为示例程序, Netty协议栈采用最简单的基于IP地址的白名单安全认证机制。
12.2.11可扩展性设计
Nety协议需要具备一定的扩展能力,业务可以在消息头中自定义业务域字段,例如
消息流水号、业务自定义消息头等。通过Nety消息头中的可选附件 attachment字段,业
务可以方便地进行自定义扩展。
232·第12章私有协议栈开发
Net!y协议栈架构需要具备一定的扩展能力,例如统一的消息拦截、接口日志、安全、
加解密等可以被方便地添加和删除,不需要修改之前的逻辑代码,类似 Servlet的 Filter
Chain和AOP,但考虑到性能因素,不推荐通过AOP来实现功能的扩展。
123 Netty协议栈开发
12.3.1数据结构定义
首先,对Nety协议栈使用到的数据结构进行定义,Nety消息定义如下。
代码清单12-1 NettyMessage类定义
1. public final class NettyMessage
private Header header;//消息头
23456789
private Object body;//消息体
areturn the header
public final Header getHeader()i
eturn header
10.
11
12
13.
Param header
14
the header to set
15
16.
public final void setHeader(Header header) i
17. this header header:
18.
12
90
21
h回 return the boc
22.
23
public final Object getBody()t
24. return bodyi
22
6
233Netty权威指南(第2版)
27,
28
param body
29
the body to set
30
31
public final void setBody (object body) I
32. this body bodyi
33.
34
35
36
* (non-Javadoc)
37,
38
asee java. lang Object#tostring ()
39.
40
OVerride
41
public string toString()
42, return "NettyMessage [header"+ header "]"i
43.
44.
代码清单12-2消息头 Header类定义
1. public final class Header
2
private int crcCode= 0xabef0101
3
private int length;//消息长度
4。
private1 ong sessionID;//会话ID
5,
private byte type;//消息类型
6
private byte priority;//消息优先级
7
private Map<string, Object>attachment= new HashMap<String, Object>()i
//附件
8
10.
★ areturn the crccode
12
public final int getCrcCode()t
13. return crccode
14
15
16
17
param crccode
18
the crccode to set
19,
20
public final void setCrcCode(int crccode) i
·234·第12章私有协议栈开发
21. this. crccode crcCode:
22,
23
24
25
areturn the length
26
27. public final int getLength() t
28. return length
29
30.
31
32
param length
33
the length to set
34
35
public final void setLength (int length)t
36. this length length;
37
38
39
40.
* return the sessi。nD
41
42
public final long getsessionID(
43. return sessionIdi
44
45
46
47
param sessionID
48
the sessionid to set
49
50
public final void setsessionID(long sessionID) f
51, this, sessionID= sessionIDi
52
53
54.
55.
Return the type
56
57,
public final byte getType()
58. return type;
59
60
61
235Nety权威指南(第2版)
62
大 param type
63
the type to set
64
65
public final void setType(byte type) t
66. this, type type
67
68
69
70.
k Return the priority
71
72
public final byte getPriority(
73. return priority
74
75
76
77
Param priority
the priority to set
79
80.
public final void setPriority(byte priority)
81. this, priority priority
82
83
84
85
return the attachment
86,
87.
public final Map<string, Object> getAttachment()i
88, return attachment
89.
90
91
92.
★ param attachment
93
the attachment to set
94
95
public final void setAttachment (Map<string, Object> attachment) i
96. this attachment attachment
97
98
100
k(non-Javadoc)
101
102
asee java. lang Object#tostring()
·236·第12章私有协议栈开发
104.
@override
105
lic String tostring()t
106
return "Header [crcCode="+ crccode +" length="+ length
107,
+ sessionID=+ sessionID+ type="+ type + priority=
108
forit
attachment- attachment
]";
109.
110
由于心跳消息、握手请求和握手应答消息都可以统一由 Netty Message承载,所以不需
要为这几类控制消息做单独的数据结构定义。
12.3.2消息编解码
分別定义 Netty Message Decoder和 Netty Message Encoder用于 Netty Message消息的编
解码,它们的具体实现如下。
代码清单12-3Net!y消息编码类: Netty MessageEncoder
1, public final class NettyMessageEncoder extends
2. MessageToMessageEncoder<NettyMessage> t
3
MarshallingEncoder marshallingencoder;
5
6
public NettyMessageEncoder( throws IOException
7. this. marshallingEncoder= new MarshallingEncoder()
9,
10
@Override
11
protected void encode(ChannelHandlerContext ctx, NettyMessage msg,
12
List<object> out) throws Exception f
13
14. if (msg = null I msg. getHeader()
nu11)
15
throw new Exception("The encode message is null )i
16. ByteBuf sendBuf Unpooled buffer ()i
17. sendBuf. writeInt((msg. getHeader(). getcrccode ()))i
18. sendBuf. writeInt ((msg. getHeader () getlength())i
19. sendBuf writelong ((msg. getHeader(), getsessionID()))i
20. sendBuf writeByte((msg get Header(). getType()))i
21. sendBuf writeByte ((msg. getHeader(). getPriority()))i
22. sendBuf. writeInt((msg. getHeader(). getAttachment().size()))i
237Netty权威指南(第2版)
23. String key
null
24. byte[] keyArray= null;
25. Object value nulli
26. for (Map Entry<string, object> param msg getHeader(). getAttachment()
27
entryset())i
28
key= param getkey()i
29
keyArray key getBytes("UTF-8")i
30
sendBuf. writeInt (keyArray. length)i
31
sendBuf writeBytes(keyArray)i
32
value param, getvalue()i
33
marshallingEncoder. encode (value, sendBuf)i
34.}
35. key nulli
36. keyArray = nulli
37. value nulli
38. if (msg. getBody ()!= null)i
39.
marshallingEncoder. encode(msg. getBody (), sendBuf);
40.else
41
sendBuf. writeInt(0)i
42
sendBuf setInt(4, sendBuf. readableBytes())i
43
44.}
代码清单12-4 Netty消息编码工具类: Marshallingencoder
1. public class MarshallingEncoder
2
private static final byte[] LENGTH PLACE HOLDER new byte[4]i
3
Marshaller marshaller
456789
public MarshallingEncoder() throws IOException i
marshaller = Marshalling CodecFactory buildMarshalling(
protected void encode(Object msg, ByteBuf out) throws Exception t
10. try
11
int lengthPos out, writerIndex()
12
out writeBytes(LENGTH PLACEHOLdeR)i
13
ChannelBuf ferByteoutput output new ChannelBufferByteOutput (out)i
14
marshaller start(output)i
15,
marshaller writeobject(msg)i
16.
marshaller finish();
17
out setInt(engthPos, out. writerIndex()- lengthPos -4
238·第12章私有协议栈开发
18. finally t
19
marshaller close()
20.}
21
22.}
代码清单12-5Nety消息解码类: Netty MessageDecoder
1. public class NettyMessage Decoder extends LengthEieldBasedFrame Decoder I
MarshallingDecoder marshallingDecoderi
4
public NettyMessageDecoder(int maxFrameLength, int lengthFieldoffset
6
int lengthFieldLength) throws IOException t
7. super(maxFrameLength, lengthFieldoffset, lengthFieldLength)
8. marshalling Decoder- new Marshalling Decoder ()i
9,
10
11
oVerride
12
protected Object decode(ChannelHandlerContext ctx, ByteBuf in)
13
throws Exception
14. ByteBuf frame=(ByteBuf) super, decode(ctx, in)i
15. if (frame = null)i
16
return null
17.
18
19. NettyMessage message new NettyMessage()i
20. Headerheader new Header ()i
21. header. setcrcCode(in readInt())i
22. header setLength(in readInt())i
23, header. setSessionID(in. readLong())i
24. header setType(in. readByte())i
25. header setpriority (in. readByte())i
26
27. int size in readInt();
28. if (size > 0)[
29
Map<string, object> attch new HashMap<string, object>(size)i
30
int keysize=0;
31
byte[] keyArray null
32,
String key nulli
33.
for (int i=0: i size: i++)I
34.
keysize in readInt()i
·239·Nety权威指南(第2版)
35
keyArray new byte [keysizeli
36
in readBytes(keyArray)i
37.
key new String(keyArray, TUTE-8")i
38
attch, put(key, marshalling Decoder, decode(in))i
39
40
keyArray null
41
key null;
42. header. setAttachment(attch);
43,}
44. if (in. readableBytes ()> 4)
45
message. setBody (marshallingDecoder decode(in))i
46.
47. message setHeader (header)i
48. return messagei
49
50.}
在这里我们用到了 Netty A LengthFieldBasedFrame Decoder解码器,它支持自动的TCP
粘包和半包处理,只需要给出标识消息长度的字段偏移量和消息长度自身所占的字节数,
Netty就能自动实现对半包的处理。对于业务解码器来说,调用父类 Length FieldBased
Frame Decoder的解码方法后,返回的就是整包消息或者为空。如果为空则说明是个半包消
息,直接返回继续由IO线程读取后续的码流,代码如图12-3所示。
@override
protected Object decode( channelHandler Context ctx, Byte Buf in)
throws Exception
Byte Buf frame =(ByteBuf) superdecode(ctx, in)
if (frame =s null)(
turn null
图12-3半包解码代码
代码清单12-6Nery消息解码工具类: MarshallingDecoder
1. public class MarshallingDecoder t
private final Unmarshaller unmarshalleri
2345
Creates a new decoder whose maximum object size is i@code 1048576j
bytes
If the size of the received object is greater than i@code 1048576)
bytes,
7
a ilink StreamCorruptedException) will be raised
8
240·第12章私有协议栈开发
@throws IOException
10.
11
public MarshallingDecoder() throws IOException t
13. unmarshaller MarshallingCodecFactory buildunMarshalling()i
14.
15
16,
protected object decode(ByteBuf in) throws Exception i
17. int objectsize in readInt()i
18. ByteBuf buf in slice(in readerIndex(), objectsize)i
19. ByteInput input new Channel BufferByteInput(buf)i
20. try i
21.
unmarshaller start(input)
22
Object obj-unmarshaller readobject()
23
unmarshaller finish(i
24
in, readerIndex (in. readerIndex()+ objectsizeli
25,
return obj
26.) finally
27
unmarshaller, close()i
28.}
29
30.
消息的编解码类按照12.2.6章节的消息编解码模块设计实现即可,如果读者对二进制
编解码比较熟悉,结合第9章对 JBoss Marshall序列化框架的介绍,相信可以比较轻松地
读懂本章节的代码。如果对本章节的代码阅读起来比较吃力,建议补充下JDK的 Byte Buffer
和 Jboss marshall框架的相关知识,然后再学习本章。
12.3.3握手和安全认证
握手的发起是在客户端和服务端TCP链路建立成功通道激活时,握手消息的接入和
安仝认证在服务端处理。下面看下具体实现。
首先开发一个握手认证的客户端 Channelhandler,用于在通道激活时发起握手请求,
具体代码实现如下。
代码清单12-7 LoginAuthReq Handler
1. public class LoginAuthReqHandler extends ChannelHandlerAdapter i
2
·241·Net!y权威指南(第2版)
Calls @link ChannelHandlerContexttfirechannelActive()) to forward
to the
next (@link ChannelHandler in the (alink ChannelPipeline h
56789
Sub-classes may override this method to change behavior
@Override
10,
public void channelActive(ChannelHandlerContext ctx) throws
Exception
11. ctx. writeAndFlush(buildLoginReg())i
12
13
14
15,
calls [alink ChannelHandlercontexttfireChannelRead (Object))
f。 rward to
the next i@link Channelhandler in the telink Channelpipeline h
17
18
Sub-classes may override this me thod to change behavior
19
20.
@override
21.
public void channelRead( ChannelHandlerContext ctx, Object msg)
22
throws Exception t
23. NettyMessage message-(NettyMessage)msgi
24
25.//如果是握手应答消息,需要判断是否认证成功
26. if (message. getHeader ()!= null
27
& message getHeader(). getType()== MessageType LOGIN RESP
28
value()) i
29.
byte loginResult -(byte) message. getBody ()i
30
if (loginResul
(byte)0) f
31
//握手失败,关闭连接
32
ctx. close():
33.
e⊥se
34
System. out. println("Login is ok : message)i
35
ctx. fireChannelRead(msg)i
36
37. else
38.
ctx. fire ChannelRead(msg)i
39
40
41
private NettyMessage buildLoginReq() i
242·第12章私有协议栈开发
42. NettyMessage message new NettyMessage();
43. Headerheader new Header()i
44. header setType(MessageType LOGIN REQ. value())i
45. message. setHeader (header)i
46. return messagei
47.
48
49
public void exceptionCaught(ChannelHandlercontext ctx, Throwable
cause)
50
throws Exception t
51. ctx. fireExceptioncaught(cause)i
52
53.}
第10~12行,当客户端跟服务端TCP三次握手成玏之后,由客户端构造握手请求消
息发送给服务端,由于采用P白名单认证机制,因此,不需要携带消息体,消息体为空,
消息类型为“3:握手请求消息”。握手请求发送之后,按照协议规范,服务端需要返回握
手应答消息。
第21~39行对握手应答消息进行处理,首先判断消息是否是握手应答消息,如果不
是,直接透传给后面的 Channelhandler进行处理;如果是握手应答消息,则对应答结果进
行判断,如果非0,说明认证失败,关闭链路,重新发起连接。
接着看服务端的握手接入和安全认证代码。
代码清单12-8 Login AuthRespHandler
1. public class LoginAuthRespHandler extends ChannelHandlerAdapter i
2,
private Map<string, Boolean> nodeCheck= new ConcurrentHashMap<string,
Boolean>()i
3
private String[] whitelIst =[" 127.0.0.1",192.168.1.104"1i
5
5
Calls f@link ChannelHandlerContext#fireChannelRead(Object)] to
forward to
the next ialink ChannelHandler) in the [alink ChannelPipeline k
8
Sub-classes may override this method to change behavior
10
oVerride
public void channelRead( ChannelHandler Context ctx, Object msg)
243Netty权威指南(第2版
13
throws Exception i
14. NettyMessage message =(NettyMessage) msg:
16./′如果是握手请求消息,处理,其他消息透传
17. if (message. getHeader(!= null
18
& message. getHeader(). getType()== MessageType LOGIN REQ
19
value()
20
String nodeIndex ctx channel(), remoteAddress().tostring()i
21.
NettyMessage loginResp null
22.
/重复登录,拒绝
23.
if (nodeCheck. containsKey(node Index))t
24.
loginResp buildResponse((byte)-1)
25
e⊥se
26.
InetsocketAddress address =(InetsocketAddress) ctx channel(
7
remoteAddress()i
28.
string ip address getAddress().getHostAddress()i
29
boolean isok false
30
for (String WIP whitelIst) t
31
if (WIP equals(ip))
32.
isOK truei
33
break
34
35
36
loginResp- isoK buildResponse((byte)0)
37
buildRe sponse((byte)-1)i
38
if (1sOK)
39.
nodeCheck. put(nodeIndex, true)i
40
41
System. out. println("The login response is : loginResp
42.
+ body [" loginResp. getBody()+ "]")i
43.
ctx. writeAndFlush (loginResp)i
44,else i
45
ctx. fireChanne lRead (msg)i
47
48
49
private NettyMessage buildResponse (byte result) i
50, NettyMessage message= new NettyMessage ()i
51. Headerheader new Header ()i
52. header setType(Mes sageType. LOGIN RESP. value())i
53. message. setHeader (header)i
244第12章私有协议栈开发
54. message. setBody(result)i
55. return message
56,
58,
public void exception Caught(ChannelHandlerContext ctx, Throwable cause)
59
throws Exception
60, namecheck. remove(etx, channe1(). remoteAddress(). tostring()://删除缓存
61. ctx. close(i
62. ctx. fireExceptionCaught(cause);
63
64
第2、3行分别定义了重复登录保护和IP认证白名单列表,主要用于提升握手的可靠
性。第17~47行用于接入认证,首先根据客户端的源地址(27.0.0.1:12088)进行重复
登录判断,如果客户端已经登录成功,拒绝重复登录,以防止由于客户端重复登录导致的句
柄泄漏。随后通过 Channelhandlercontext的 Channel接口获取客户端的 Inetsocketaddress
地址,从中取得发送方的源地址信息,通过源地址进行白名单校验,校验通过握手成功,
否则握手失败。最后通过 buildResponse构造握手应答消息返回给客户端。
当发生异常关闭链路的时候,需要将客户端的信息从登录注册表中去注册,以保证后
续客户端可以重连成功
12.3.4心跳检测机制
握手成功之后,由客户端主动发送心跳消息,服务端接收到心跳消息之后,返回心跳
应答消息。由于心跳消息的目的是为了检测链路的可用性,因此不需要携带消息体。
客户端发送心跳请求消息的代码如下
代码清单12-9 HeartBeatReq Handler
1. public class HeartBeatReqHandler extends ChannelHandlerAdapter
private volatile ScheduledFuture<?> heartBeat
3
4
oVerride
5
public void channelRead (ChannelHandlerContext ctx, object msg)
6
throws Exception I
7. NettyMessage message =(NettyMessage)msg:
8.//握手成功,主动发送心跳消息
9, if (message. getHeader ()!= null
·245Nety权威指南(第2版)
10
& message, getHeader(). getType()== MessageType LOGIN RESP
11
value()(
12
heartBeat ctx executor(. scheduleatFixedRate(
13
new HeartBeatReqHandler HeartBeatTask(ctx),0, 5000
14
TimeUnit MILLISECONDS)i
15. else if (message. getHeader()!- null
16
& message. getHeader(). getType()== MessageType HEARTBEAT RESP
17
value())I
18.
System. out
19
printin(Client receive server heart beat message --->
20.
message)i
21.}e1se
22
ctx. firechannelRead(msg)i
23.
24
25
private class HeartBeatrask implements Runnable i
26, private final ChannelHandlerContext cti
27
28. public HeartBeatrask(final ChannelHandlercontext ctx)t
29
this ctx= ctx
30.}
31
32. Override
33. public void run() I
34
NettyMessage heatBeat bui ldHeatBeat (
35
System.out
36
println("Client send heart beat messsage to server
t heatBeat)i
ctx. writeAndFlush(heatBeat)i
39.}
40,
41. private NettyMessage buildHeat Beat() i
42. NettyMessage message new NettyMessage()i
43
Headerheader new Header oi
44,
header setType(Message Type. HEARTBEAT REQ, value())i
45.
message. setHeader(header)i
46.
return message i
47,
48
49
50.
override
·246·第12章私有协议栈开发
51. public void exceptioncaught (ChannelHandler Context ctx, Throwable cause)
52.
throws Exception i
53. if (heartBeat ! null)I
54
heartBeat. cancel(true);
55
heartBeat null;
56,}
57. ctx. fireExceptionCaught (cause)i
58
59.}
首先看第9行,当握手成功之后,握手请求 Handler会继续将握手成功消息冋下透传,
HeartBeatReqHandler接收到之后对消息进行判断,如果是握手成功消息,则启动无限循环
定时器用于定期发送心跳消息。由于 NioEventLoop是一个 Schedule,因此它支持定时器
的执行。心跳定时器的单位是毫秒,默认为5000,即每5秒发送一条心跳消息。
为了统一在一个 Handler中处理所有的心跳消息,因此第15~20行用于接收服务端发
送的心跳应答消息,并打印客户端接收和发送的心跳消息。
心跳定时器 HeartBeat Task的实现很简单,通过构造函数获取 ChannelHandler Context,
构造心跳消息并发送。
服务端的心跳应答 Handler代码如下
代码清单12-10 HeartBeatResp Handler
1. public class HeartBeatRespHandler extends ChannelHandlerAdapter i
234
oVerride
public void channeIRead(ChannelHandlerContext ctx, Object msg)
throws Exception t
5. NettyMessage message =(NettyMessage)msg;
6.∥/返回心跳应答消息
7. if (message. getHeader()!= null
& message getHeader(). getType()-- MessageType HEARTBEAT REQ
value()) i
10
System. out. println("Receive client heart beat message
11
message);
12.
NettyMessage heartBeat buildHeatBeat()i
System. out
14
println("Send heart beat response message to client:
15
t heartBeat)
16
ctx. writeAndFlush(heartBeat);
17.}e1se
247·Nety权威指南(第2版)
18.
ctx. fireChanne lRead(msg)i
19
20
21.
private NettyMessage buildHeatBeat ()(
22. NettyMessage message- new NettyMessage()i
23. Header header- new Header (i
24. header setType(MessageType HEARTBEAT RESP. value())i
25. message. setHeader (header)i
26. return message;
27.
28.
服务端的心跳 Handler非常简单,接收到心跳请求消息之后,枃造心跳应答消息返回,
并打印接收和发送的心跳消息。
心跳超时的实现非常简单,直接利用Nety的 ReadTimeouthandler机制,当一定周期
内(默认值50s)没有读取到对方任何消息时,需要主动关闭链路。如果是客户端,重新
发起连接;如果是服务端,释放资源,清除客户端登录缓存信息,等待服务端重连,
具体代码实现在下面的小节中会进行说明。
12.3.5断连重连
当客户端感知断连事件之后,释放资源,重新发起连接,具体代码实现如图12-4所
∥发起异步连接操作
Channe fUture future=b connect(
new InetsocketAddress(host, port).
new InetSocketAddress( Netty Constant. LOCALIP
Netty Constant LOCAL PORT)). sync(
uture channel(). closeFuture(). sync(;
) finally I
∥所有资源释放完成之后,清空资源,再次发起重连操作
executor. execute(new Runnable)(
@override
lic void run(t
try t
TimeUnit SECONDS sleep(1)
try I
connect(Netty Constant PORT.
Netty Constant, REMOTE|P)H发起重连操作
3 catch(EXception e)i
e printStackTrace(:
图12-4客户端重连代码
·248·第12章私有协议栈开发
首先监听网络断连事件,如果 Channel关闭,则执行后续的重连任务,通过 Bootstrap
重新发起连接,客户端挂在 close future上监听链路关闭信号,一旦关闭,则创建重连定时
器,5s之后重新发起连接,直到重连成功。
服务端感知到断连事件之后,需要清空缓存的登录认证注册信息,以保证后续客户端
能够正常重连。
12.36客户端代码
客户端主要用于初始化系统资源,根据配置信息发起连接,代码如下。
代码清单12-11 NettyClient
1. public class Nettyclient
234
private ScheduledExecutorservice executor Executors
newScheduledThreadPool(1)i
EventLoopGroup group
new NioEventLoopGroup ()
public void connect(int port, string host) throws Exception
6.//配置客户端NI线程组
7. try t
Bootstrap b= new Bootstrap()i
9
b group (group). channel(NioSocketChannel class
10,
option (Channeloption, TCP NODELAY, true)
11
handler(new ChannelInitializer<socketChannel>()i
override
13
public void initchannel(Socket Channel ch)
14.
throws Exception i
15,
ch pipeline(). addLast
16
new NettyMessageDecoder(1024* 1024, 4,4))i
17,
ch pipeline().addLast("MessageEncoder
18
new NettyMessageEncoder())i
19. ch pipeline(). addLast("readTimeoutHandler"
20
new ReadTimeoutHandler(50));
21
ch pipeline().addLast("LoginAuthHandler'
22
new LoginAuthRegHandler ())
23
ch pipeline(), addLast("HeartBeatHandler"r
24
new HeartBeatReqHandler())i
25
26
);
27
/发起异步连接操作
249Netty权威指南(第2版)
28
Channelfuture future b. connect
29
new Inet SocketAddress(host port)r
30.
new Inet SocketAddress(NettyConstant. LOCALIP,
31
NettyConstant, LOCAL PORT)). sync ()i
32,
future channel(). closeFuture (). sync ()i
33.1 finally i
34
/所有资源释放完成之后,清空资源,再次发起重连操作
35
executor, execute(new Runnable()
36
oVerride
37
public void run() i
38
try i
39,
TimeUnit SECONDS sleep(5)i
40.
try t
41
connect(Nettyconstant. PORT, NettyConstant REMOTEIP)i/2
起重连操作
42
I catch (Exception e) i
43
e printStackTrace();
44
45
1 catch (InterruptedException e)
46.
e printstackTrace()i
47
48
49
});
50.}
51
52.
54
@param args
55,
throws Excepti。n
57,
public static void main(String[] args) throws Exception
58. new
Nettyclient(). connect(NettyConstant. PORT,
NettyConstant. REMOTEIP);
59
60.}
第15和16行增加了Net! mEssage Decoder用于Nety消息解码,为了防止由于单条
消息过大导致的内存溢出或者畸形码流导致解码错位引起内存分配失败,我们对单条消息
最大长度进行了上限限制。第17和18行新增了Net!y消息编码器,用于协议消息的自动
编码。随后依次增加了读超时 Handler、握手请求 Handler和心跳消息 Handler。
250·第12章私有协议栈开发
第28行发起TCP连接的代码与之前的不同,这次我们绑定了本地端口,主要用于服
务端重复登录保护,另外,从产品管理角度看,一般情况下不允许系统随便使用随机端口。
利用Net!y的 ChannelPipeline和 Channelhandler机制,可以非常方便地实现功能解耦
和业务产品的定制。例如本例程中的心跳定时器、握手请求和后端的业务处理可以通过不
同的 Handler来实现,类似于AOP。通过 Handler chain的机制可以方便地实现切面拦截
和定制,相比于AOP它的性能更高。
12.3.7服务端代码
相对于客户端,服务端的代码更简单一些,主要的工作就是握手的接入认证等,不用
关心断连重连等事件。
服务端的代码如下。
代码清单12-12 Netty Server
1. public class Nettyserver i
r Dublic void bind() throws Exception I
3
/配置服务端的NIO线程组
4. EventLoopGroup bossGroup new NioEventLoopGroup()i
5. EventLoopGroup workerGroup- new NioEventLoopGroup()
6. ServerBootstrap b= new ServerBootstrap()i
7. b group(bossGroup,
workerGroup), channel(NioserverSocketChannel, class)
option(ChannelOption SO BACKLOG, 100)
9,
handler(new LoggingHandler(LogLevel. INFO))
10.
childHandler(new ChannelInitializer<socketChannel>()
11.
oVerride
12
public void init Channel(SocketChannel ch)
13,
throws IOException
14
ch pipeline(). addLast
15
new NettyMessageDecoder(1024*1024, 4, 4))
16
ch pipeline(). addLast(new NettyMessageEncoder())i
17. ch pipeline(). addLast("readTimeoutHandler "
18.
new ReadTimeout Handler(50));
19
ch pipeline().addLast(new LoginAuthRespHandler());
20
ch pipeline().addLast(" HeartBeatHandler
21,
new HeartBeatRespHandler())i
22.
·251Ne!权威指南(第2版)
23
24
25.//绑定端口,同步等待成功
26. b. bind (NettyConstant REMOTEIP, NettyConstant PORT). sync()i
27. System. out. println(Netty server start ok h
28
+(NettyConstant REMOTEIP +: NettyConstant PORT))
29
30.
31
public static void main(String[] args) throws Exception
32. new NettyServer().bind()i
33.
34.}
握手和接入认证的 Login AuthRespHandler和心跳应答 Heart BeatRespHandler, Y
与客户端不同的是,服务端 ChannelPipeline中除了Nety编码器和解码器以外,还有
124运行协议栈
124.1正常场景
启动服务端,待服务端启动成功之后启动客户端,检査链路是否建立成功,是否每隔
5s互发一次心跳请求和应答,运行结果如图12-5所示。
rmx@Jm1 claration 4 Search日Cal吗r■解回图亡回
attyserver[ Java Application]: rogan Files \avs\jdk1,7,0451bine(2014年3月15日下午11:02:3)
Netty server start ok 127.0.0.1 8080
The login response is NettyHessage [header-Header (crccode--1410399999, length=O, sessionID
Receive client heart beat message --- NectyMessage [header=Header [crccode--1410399999, le
Send heart beat reaponse mmessage to client :---> NettyMessage [header-Header [crccode--14103
Receive client heart beat message
>NettyMessage [header=Header [crccode=-1410399999, le
Send heart beat response message to client : --- NettyMessage [header -Header fcrecode--14103
Receive client heart beat message :--- NettyHeasage [header=Header [crcCode--1410399999, le
Send heart beat response message to client --- NettyMessage [header -Header [recode=-14103
图12-5服务端运行结果
客户端运行结果如图12-6所示
从上面的运行结果可以看出,客户端和服务端握手成功,双方可以互发心跳,链路正
常,如图12-7所示。
·252·第12章私有协议栈开发
Probles e Jwrndoe [2 Deelwratien .Search园Cmal,阅h画日图日··
yCLt口v命 pplicatianl E1Peg睡F出kl1704 banja2014年3月15日下年1103:m)
CL⊥ ent gend heart beat mesgg80吧 to enver日---> NeTty界e[ header Header [recode-1410399999,L
Client receive se工verh费 ct best message:-> Netty些想ae【 hesder -leader tcrccode-1410399999,1
cLient send heart beat meassage to Ber
rek :--- NettyHeasage [header-Header [crccode--1410399999,1
c11 nc and bt盘工tbet加想想想思 e to BereT:--> Nectyhessage【 header= Hender【 recode-1410399999,1
client acnd heatt beat message to server : --- NectyHeasage theader-Header [ crccode--1110399999, L
Client send heart beat messsage to server ---)Neetyhessage header=Header [erecode-1410399999, L
Client receive server heart beat message --- NettyMessage [=Header Icrccodem-1410399999, le
C⊥1西 nt send he& rt hent想想 age to server:--- Netty图凯想g[h老 dermHeader[ coccodes-1410399999,1
CLient send heart beat meassage to server : --- NettyHessage [header hEader [erccode--1410399999,1
c1⊥en画 end heatt beat me源 re to server:--> Nee eyleasage[ bescar= Hesder【 cOcCodes-1410399999;1
client send heart beat meassage to seRVeR : --- NetcyHessage [header"HendeE [eEcCode--1410399999,1
C11en已 receive server heart beat message:--> Netty图e围e[ headar=edeE[ Er cCode=-14103999991些
图12-6客户端运行结果
DOcuments and Settings \Administrator>netstat -ano ifindstr "8080
TGP
127.g..⊥:8B8
日...:g
LISTENING
IGP12.日.B.1:8B8B
127.B.8.1:12888
ESTABLISHED
1148
TCP
12日.9.1:12988
127.B,日.1:8的8日
ESTABLISHED
3692
图12-7TCP链接正常
12.4.2异常场景:服务端宕机重启
假设服务端宕机一段时间重启,检验如下功能是否正常。
(1)客户端是否能够正常发起重连;
(2)重连成功之后,不再重连;
(3)断连期间,心跳定时器停止工作,不再发送心跳请求消息;
(4)服务端重启成功之后,允许客户端重新登录;
(5)服务端重启成功之后,客户端能
够重连和握手成功;
(6)重连成功之后,双方的心跳能够大本:11个节
已使用:6,768,984个字节
最大:286.338.304个宇节
正常互发。
(7)性能指标:重连期间,客户端资m
源得到了正常回收,不会导致句柄等资源
泄漏。
a1520
2:15:5
15
服务端重启之前的客户端资源占用如
口堆大小
图128所示。
图12-8客户端堆内存占用
·253·Nety权威指南(第2版
线程资源占用如图12-9所示。
程:14
明网[病|洋信值
a显示:所育程
3知0
:唱
1:![";]
口 Mr Schaulen①
日PFc自)-12
日 I TCr Adept
国nuw24
口 runtleopur gup23
口ALhL电r
aS:cil Dispatcher
FIste
O ENT TCP Connetion 2)-192
运行■口等视
图12-9客户端线程资源信息列表
服务端宕机之后,重启之前,客户端周期性重连失败。如图12-10所示。
当S,⊥ ength工,≡e;
c⊥些 nt gend h些当上 beaE e思 ge ta server:---》 Newtyle思ge[上eder= Meader【cccd兽m-1410399999,1 enth=0,e
Java.net. ConnectException: Connection refused: no further intormation: /127.0.0.1:80001410399999, length-18, se
Client tece ive server heart beat message --- NeEEyHessage (header -Header fcrccode--
at sun n1o ch. SoeketChannelImp I chee kConheet (Native Metbod)
at sun n10. ch. Socketchanne ImpI. finishconnect (socket channe 11mp1, lava:735)
at 10,nettY channel, socket. nio, N1oSocket channel, doF iniahConnect (Niosocketchannel lave: 191)
10t?Chn,n1, taceNiochanne⊥5EN1Un,里1n1 connect《 caceNsoChanne1-1241
at 10.net ty channel n1D. NioEventLoop proces8selectedkey (NioEventLoop-gava: 502)
at a0netty channeL nio, NaoEventLoap procesaSelectedkeyaopt imizedINioEvent LooP- java: 4521
at 30, nety, channe L Bi9, NioEventLoPp,EunINL9EveDELD9P-Jave:316)
at 10, netty util. concurrent. s1ngleThreadEventExecucor 35 run (singleThEeadEventEKecutoE. ava: 794I
at Java. lang Threadrun(Thread. ava: 7441
Java. net. ConnectException: Connection refused: no further information: /127.0.0.118080
at sun, nio, ch Soe ketchanne1imp l checkconneet (Nat ive Het had
at sun nio ch Socket ChannelImpl finiahconnect (socketchannel Imploi8va:7351
t1。,ney, chAnne L,界口kt,n1a,N1 oso channe1,doFn1想 cOnnect IN1 Socke tHann1,2:191)
盘E1,e,GB确ne1,B10,ABE心 ENTOChaer县工N1心胜工,1 a1hconnac( AbtrctNtochanne1,1y侧:24)
at 10. netty channe 1. n10. NioEvent Loop proce3B5electedkey (NiOEventLoDp. eva:502l
at 10, netty, channe 1. ni0, N1DEvent Loop, proces3selectedkeysopt imized (NioEvent LOoP lava: 4521
at 10. netty, channe l n1D,NioEventLoop, run (N1oEventL00p,va:3461
at io.hetTY, uEll.concurrent. singleThreadEventExecutor 55, run(singleThreadEventExecutor Java: 794)
at Java. lang. Thread run (Thread. Java: 749)
nava.net.ConnectException: Connection refused: no turther intormation: /127.0.0.1: 8080
at sun nio. ch Socke cHanne l Impl. checkconnect Native Method)
图12-10客户端重连失败
重连期间线程资源占用正常,如图12-11所示
重连期间内存占用正常,如图12-12所示
·254·第12章私有协议栈开发
病时截程:15
守护費星。
时闻表洋信息
a鸟
所有
垦示!所有螻程
0:1n
口M面eL曲U画.
口 FII TLF Comities)-1≌2
UafaEwantLieparoup2-4
口 ALaLeahtLiap
日Dtr的J魂Ⅷ
国p=al-1·tha1
B moEventlonplr aup2-l
口器 mad lassiter
lOFisditet
ReE扑砸 Handler
目T己 unmeet②)一便
□行口口等箱■视
图12-11重连期间线程資源占用正常
堆Fer
大小:16日46144个宇节
已使用:8,03024个字节
最大:28.39304个字节
2s:22:50
国堆大小■使用的堆
图12-12重连期间内存占用正常
服务端重启成功,握手成功,链路重新恢复,如图12-13所示。
y口:B题H,Y
Jave.net. connectExseption: Connection refused: no further information: /127.0.0.1:8000
at sun.010.ch. 5ocketchanne I Impl checkconnect (native Method)
at sun, nio,h. Socketchanne i Impl-tinishGonnect (Socketchanne L Tpl. java: 735)
at 10, netty, channel.socket, n10.N1osocket Channe l. doFiniahconnect (1osocketchannel.Java: 191)
at to. hetty, channeI ni6. AbstraetNsoChanhels AbstraetNioUnsafe-IinishCenheet (AbstracENioChannel. java:241)
at 10. netty chnnnel nio. Ni0EventLoop. processe lectedKey (ioEventloop Java: 502)
at 10, netty, channel n1o, N1DEventLoop. pEoceaaselectedKeyaopt imized(NioEventLoop Java: 452)
at 10, netty, channe I nio. NsoEvencLoop run(NiOEvencLoop lava: 346]
at 10. netty, utll concurrent Sinale TheeadEventExecutor s5run(single ThreadEventExecutor-java:794)
盘tva.LAnq, ThRead.cun( Thread.a:?唾4
L。a⊥m1ak: ettyHessage[ header“显 eader【 casCode=-1410399999,1 ength=93,es当inID=D,type=4, priority=0。att
CIlent send heart beat messsage to server I ---2 NettyHessage [headermHeader (crcCodem-1410399999, length, ac
⊥ ent receive= ever heart beat message;--> NeEE?带日e[ header-Headen【 GEe Code=-1110399999,⊥ ength=1,ae
ciient send heart beat messsage ta server 4---2 NeEtyHeeange Cheader-Header [ereCode--1410399999, length-0, se
Client receive server heart beat Message :--=2 NettyHesaage [header-Header [erecodei-1410399999, length18, se
cilent send heart beat messsage to server ---p NettyHeasage [header=Header [creCode-1410399999, length-o, se:
cIient receive server heart beat message --=) Nett yHessage [header=Header [erecode--1410399999, lengt h-18, se
图12-13服务端重启成功后链路恢复
·255·Netty权威指南(第2版)
通过 netstat命令查看TCP连接状态,如图12-14所示。
\Documents and Settings Administrator)
\Documents and Settings \Administrator>netstat -ano ifindstr 8080
IGP12?.8.1:8888
区..8.B:8
LISTENING
212
TGP127..B.1=88
127.B..1:12g88
ESTABLISHED
2g12
TCP
127,因.1:1288
12..的.1:88
ESTABLISHED
3948
图12-14TCP连接正常
124.3异常场景:客户端宕机重启
客户端宕机重启之后,服务端需要能够清除缓存信息,允许客户端重新登录。下面看
测试结果。
客户端停机,然后重启,结果如图12-15所示。
Problems@ Javadoc De, Deelaration search consol图野aw
NetiyClient口4 Applicstion] E: \ Prop晒Fi1 sUwa\jd7045bin鲈Q螺6②014年3月15日下午11:33:06)
Login is ok NeteyMessage [header=Header [crccode--1410399999, length-93, sessionID-O, type-4, priority=0, attachm
client send heart beat messsage to serwer --- NettyHessage [header=Header [crccode=-1410399999, length=0, sessio
client receive server heart beat message : --- NettyMessage [header-Header [crccode--1410399999 length-18, se9s10
Client send heart beat messsage to server :--- NeteyHessage [header-Header [erecadem-1410399999,length-0, sesgio
Client teceive gerver heart beat message --- NettyMessage [header= Header crccode=-1410399999, length=18, se9910
Client send heart beat message to server --- NettyMessage [header"Header [crccade--1410399999, length 0,33310
client receive server heart beat message --- NettyHessage [header=Header [crcCode-1410399999, length=18, se3s10
Client send heart beat messsage ta server --- NettyMessage [header -Header [crecode--1410399999, length, se3s10
Client receive server heart be4tme吕age:---> Netty且e吕盘ge[he器dr= Header[ recOde=-1410399999,1 ength=18,ess1
图12-15客户端宕机重启重新登录
运行结果表明客户端重启之后可以重新登录成功,说明服务端功能正常
125总结
本章首先介绍了私有协议栈的相关概念,然后通过一个模拟私有协议栈—Nety协
议栈的设计和开发,让读者掌握私有协议栈的功能和开发要点,为后续在实际工作中进行
私有协议栈的设计和开发提供帮助。
尽管本章节在设计 Netty协议栈的时候,已经考虑了很多可靠性方面的功能,但是对
于实际商用协议栈而言,仍然是不足的。例如当链路断连的时候,已经放入发送队列中的
消息不能丢失,更加通用的做法是提供通知机制,将发送失败的消息通知给业务侧,由业
务做决定:是丢弃还是缓存重发。
256第12章私有协议栈开发
本章综合了之前所学的Nety知识,还涉及到了通用半包解码器、读超时、自定义定
时任务、安全认证等方面的知识,当读者能够综合运用所学知识进行灵活设计和开发时,
说明对Nety的掌握程度更上了一层楼。
需要指岀的是,本例程仅仅是个简单Demo,限于篇幅,一些实现未必是最优的,读
者在学习过程中也可以思考下哪些地方还可以进一步优化。
257·第13章
服务端创建
对于想要深入学习Nety原理的人而言,通过阅读源码是最有效的学习方式之一。尽
管Nety使用起来并不复杂,但是通过对源码的分析和学习,掌握一些必备的基础知识还
是很有必要的。
Netty服务端创建需要的必备知识如下
(1)熟悉 JDK NIO主要类库的使用,例如 Byte Buffer、 Selector、 Server Socket channel
等
(2)熟悉JDK的多线程编程;
(3)了解 Reactor模式
本文首先对 Java NIo服务端的创建进行简单介绍,然后对 Netty服务端的创建进行原
理讲解和源码分析,以期让更多希望了解 Netty底层原理的读者可以快速入门
本章主要内容包括:
◎原生NO类库的复杂性
◎Net!y服务端创建源码分析
◎客户端接入源码分析第13章服务端创建
13.1原生NIO类库的复杂性
在开始本文之前,我先讲一件自己亲身经历的事。大约在2011年的时候,身边有两
个业务团队同时进行新版本开发,他们都需要基于NIO非阻塞特性构建高性能、异步和高
可靠性的底层通信框架。
当时两个项目组的设计师都咨询了我的意见,在了解了两个项目团队的NIO编程经验
和现状之后,我建议他们都使用Nety构建业务通信框架。令人遗憾的是其中1个项目组
并没有按照我的建议做,而是选择直接基于JDK的NIO类库构建自己的通信框架。在他
们看来,构建业务层的NIO通信框架并不是件难事,即便当前他们还缺乏相关经验。
两个多月过去之后,自研NIO框架团队的通信框架始终无法稳定地工作,他们频繁遭
遇客户端断连、句柄泄露和消息丢失等问题,项目的进度出现了严重的延迟。形成鲜明对
比的是,另一个团队由于基于 Netty研发,在通信框架上节省了大量的人力和时间,加之
Nety自身的可靠性和稳定性非常好,他们的项目进展非常顺利。
这两个项目组的不同遭遇告诉我们:开发高质量的NIO程序并不是一件简单的事情
除去NO类库的固有复杂性和Bug,作为NIO服务端,需要能够处理网络的闪断、客户
端的重连、安全认证和消息的编解码、半包处理等。如果没有足够的NO编程经验积累,
自研NIO框架往往需要半年甚至数年的时间才能最终稳定下来,这种成本即便对一个大公
司而言也是个严重的挑战
132Nety服务端创建源码分析
当我们直接使用 JDK NIO的类库开发基于NIO的异步服务端时,需要使用到多路复
用器 Selector、 Server SocketChannel、 Socketchannel、 Byte Buffer、 SelectionKey等,相比
于传统的BO开发,NO的开发要复杂很多,开发出稳定、高性能的异步通信框架,一直
是个难题。
Netty为了向使用者屏蔽NO通信的底层细节,在和用户交互的边界做了封装,目的
就是为了减少用户开发工作量,降低开发难度。 Server Bootstrap是 Socket服务端的启动辅
助类,用户通过 Server Bootstrap可以方便地创建Net的服务端。时序图如图13-1所示
259Ne!权威指南(第2版)
13.2.1Net!t服务端创建时序图
erver Bootstrap
EventLoopGroup NioServerSacketChannelChannelPipelineChannelHlandler
用户
1、创建 ServerBootstrap实例O
2、设置并绑定
Reactor线程池)3、设置并绑定服务端
Channel(
4、TCP链路建立时创建 Channelpipeline(
5、添加并设置 Channelhandlen0
6、绑定监听端口并启动服务端
,7、 Selector轮询
8、网络事件通知0
9执行Nety系统和
业务 HandlerChannek)
图13-1 Netty服务端创建时序图
下面我们对Nety服务端创建的关键步骤和原理进行讲解
步骤1:创建 Server Bootstrap实例。 ServerBootstrap是Nety服务端的启动辅助类,
它提供了一系列的方法用于设置服务端启动相关的参数。底层通过门面模式对各种能力进
行抽象和封装,尽量不需要用户跟过多的底层API打交道,以降低用户的开发难度
我们在创建 Server Bootstrap实例时,会惊讶地发现 ServerBootstrap只有一个无参的构
造函数,作为启动辅助类这让人不可思议,因为它需要与多个其他组件或者类交互。
Server Bootstrap构造函数没有参数的根本原因是因为它的参数太多了,而且未来也可能会
发生变化,为了解决这个问题,就需要引入 Builder模式。《 Effective Java》第二版第2条
建议遇到多个构造器参数时要考虑用构建器,关于多个参数枸造函数的缺点和使用构建器
的优点大家可以查阅《 Effective java》,在此不再详述。
步骤2:设置并绑定 Reactor线程池。 Netty的 Reactor线程池是 EventLoop Group,它
实际就是 EventLoop的数组。 EventLoop的职责是处理所有注册到本线程多路复用器
Selector上的 Channel, Selector的轮询操作由绑定的 EventLoop线程run方法驱动,在
个循环体内循环执行。值得说明的是, EventLoop的职责不仅仅是处理网络IO事件,用
●260·第13章服务端创建
户自定义的Task和定时任务Task也统一由 EventLoφp负责处理,这样线程模型就实现了
统一。从调度层面看,也不存在从 EventLoop线程中再启动其他类型的线程用于异步执行
另外的任务,这样就避免了多线程并发操作和锁竞争,提升了O线程的处理和调度性能。
步骤3:设置并绑定服务端 Channel作为NO服务端,需要创建 Server Socketchannel,
Netty对原生的NO类库进行了封装,对应实现是 NioServer channel对于用户而言,
不需要关心服务端 Channel的底层实现细节和工作原理,只需要指定具体使用哪种服务端
Channel即可。因此, Netty的 Server Bootstrap方法提供了 channel方法用于指定服务端
Channel的类型。Nety通过工厂类,利用反射创建 NioServer Socketchannel对象。由于服
务端监听端口往往只需要在系统启动时才会调用,因此反射对性能的影响并不大。相关代
码如下。
public ServerBootstrap channel(Class<? extends Serverchannel> channelclass
if (channelclass = null)(
throw new NullPointerException("channelclass")i
return
channel Factory(new
ServerBootstrapchannelFactory<serverchannel>(channelclass))i
步骤4:链路建立的时候创建并初始化 ChannelPipeline。 ChannelPipeline并不是NlO
服务端必需的,它本质就是一个负责处理网络事件的职责链,负责管理和执行
Channelhandler。网络事件以事件流的形式在 ChannelPipeline中流转,由 ChannelPipeline
根据 Channelhandler的执行策略调度 ChannelHandler的执行。典型的网络事件如下。
(1)链路注册;
(2)链路激活
(3)链路断开;
(4)接收到请求消息;
(5)请求消息接收并处理完毕
(6)发送应答消息;
(7)链路发生异常;
(8)发生用户自定义事件。
·261Ney权威指南(第2版)
步骤5:初始化 ChannelPipeline完成之后,添加并设置 Channelhandler. Channelhandler
是Nety提供给用户定制和扩展的关键接口。利用 Channelhandler用户可以完成大多数的
功能定制,例如消息编解码、心跳、安全认证、TSL/SSL认证、流量控制和流量整形等。
Nety同时也提供了大量的系统 Channelhandler供用户使用,比较实用的系统
Channelhandler总结如下。
(1)系统编解码框架— Byte ToMε ssageCodec;
(2)通用基于长度的半包解码器— LengthFieldBasedFrame Decoder
(3)码流日志打印 Handler-Logging Handler;
(4)SSL安全认证 Handler-SsIHandler
(5)链路空闲检测 Handler—- Idle State Handler;
(6)流量整形 Handler-Channel Traffic Shaping Handler;
7)Base64编解码—Base64 Decoder和Base64 Encoder。
创建和添加 Channelhandler的代码示例如下。
childhandler (new ChannelInitializer<socketchannel>() i
override
public void initchannel(SocketChannel ch)
throws Exception t
ch pipeline().addLast(
new Echo serverHandlero))i
})
步骤6:绑定并启动监听端口。在绑定监听端口之前系统会做一系列的初始化和检测
工作,完成之后,会启动监听端口,并将 Server Socketchannel注册到 Selector上监听客户
端连接,相关代码如下。
protected void doBind(SocketAddress localAddress) throws Exception I
javachannel(). socket(). bind (localAddress, config. getBacklog())i
步骤7: Selector轮询。由 Reactor线程 Nio EventLoop负责调度和执行 Selector轮询操
作,选择准备就绪的 Channel集合,相关代码如下。
262·第13章服务端创建
private void select() throws IOException i
Selector selector this,, selector
try I
//此处代码省略.
int selectedKeys selector select(timeoutMillis)i
selectOn ++i
//此处代码省略.
步骤8:当轮询到准备就绪的 Channel之后,就由 Reactor线程 NioEventLoop执行
ChannelPipeline的相应方法,最终调度并执行 Channelhandler,接口如图13-2所示
D ChannelPipeline
o fire ChannelRegisteredo: ChannelPipeline
.A fire ChannelActive0: Channelpipeline
.A fire ChannelInactive0: ChannelPipeline
e fire Exception Caught(Throwable): ChannelPipeline
.A fireUserEvent Triggered(Object): ChannelPipeline
O fire ChannelRead(Object): ChannelPipeline
A fireChannelRead Complete: ChannelPipeline
A fire ChannelWritability Changed: ChannelPipeline
图13-2调度相关方法
步骤9:执行Nety系统 Channelhandler和用户添加定制的 Channelhandler o
Channelpipeline根据网络事件的类型,调度并执行 Channelhandler,相关代码如下。
public ChannelHandlerContext fireChannelRead(Object msg) t
DefaultchannelHandLerContext next=
findContextInbound (MASK CHANNEL READ);
next invoker invoke Channe IRead(next, msg)i
return this:
132.2Net!y服务端创建源码分析
首先通过构造函数创建 Server Bootstrap实例,随后,通常会创建两个 EventLoop Group
·263·Ne!y权威指南(第2版
(并不是必须要创建两个不同的 EventLoop Group,也可以只创建一个并共享),代码如下。
EventLoopGroup acceptorGroup new NiOEventloopGroup ()i
EventLoopGroup IoGroup new NioEventLoopGroup()i
NioEventLoop Group实际就是 Reactor线程池,负责调度和执行客户端的接入、网络
读写事件的处理、用户自定义任务和定时任务的执行。通过 Server Bootstrap的 group方法
将两个 EventLoop Group实例传入,代码如下。
public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup
childGroup)
supergroup (parentGroup)i
if (childGroup = null)1
throw new NullPointerException("childGroup)
if (this. childGroup ! null)i
throw new IllegalStateException("childGroup set already")i
ths. chilaGr。四= chilaGroup
return this
其中父 NioEventLoop Group被传入了父类构造函数中,代码如下。
public B group(EventLoopGroup group) i
if (group = null)
throw new NullPointerException ("group")i
if (this group null) I
throw new IllegalStateException("group set already )i
this group group
return (B)thisi
该方法会被客户端和服务端重用,用于设置工作IO线程,执行和调度网络事件的读
线程组和线程类型设置完成后,需要设置服务端 Channel用于端口监听和客户端链路
接入。Net!y通过 Channel工厂类来创建不同类型的 Channel,对于服务端,需要创建
NioServerSocketChannel。所以,通过指定 Channel类型的方式创建 Channel工厂
·264·第13章服务端创建
Server Bootstrap ChannelFactory是 ServerBootstrap的内部静态类,职责是根据 Channel的类
型通过反射创建 Channel的实例,服务端需要创建的是 Nio Server Socketchannel实例,代
码如下。
public T newChannel(EventLoop eventLoop, EventLoopGroup childGroup)
try t
Constructor<?
extends
constructor
clazz. getcons tructor(EventLoop. class, EventLoopGroup class)i
return constructor newInstance(eventLoop, childGroup)i
1 catch (Throwable t)
throw new Channe eXception (Unable to create channel from
class " clazz, t);
指定 Nio Server Socketchannel后,需要设置TCP的一些参数,作为服务端,主要是要
设置TCP的 backlog参数,底层C的对应接口定义如下。
int listen(int fd, int backlog)
backlog指定了内核为此套接口排队的最大连接个数,对于给定的监听套接口,内核
要维护两个队列:未链接队列和己连接队列,根据TCP三路握手过程中三个分节来分隔
这两个队列。服务器处于 listen状态时,收到客户端syn分节( connect)时在未完成队列
中创建一个新的条目,然后用三路握手的第二个分节即服务器的syn响应客户端,此条目
在第三个分节到达前(客户端对服务器syn的ack)一直保留在未完成连接队列中,如果
三路握手完成,该条目将从未完成连接队列搬到已完成连接队列尾部。当进程调用 accept
时,从已完成队列中的头部取出一个条目给进程,当已完成队列为空时进程将睡眠,直到
有条目在已完成连接队列中才唤醒。 backlog被规定为两个队列总和的最大值,大多数实
现默认值为5,但在高并发web服务器中此值显然不够,Lighttpd中此值达到128×8。需
要设置此值更大一些的原因是未完成连接队列的长度可能因为客户端syn的到达及等待三
路握手第三个分节的到达延时而增大。 Netty默认的 backlog为100,当然,用户可以修改
默认值,这需要根据实际场景和网络状况进行灵活设置。
TCP参数设置完成后,用户可以为启动辅助类和其父类分别指定 Handler两类 Handler
的用途不同:子类中的 Handler是 NioServerSocketchannel对应的 ChannelPipeline的
Handler;父类中的 Handler是客户端新接入的连接 Socket channel对应的 ChannelPipeline
的 Handler。两者的区别可以通过图13-3来展示。
265·Net!y权威指南(第2版)
Client l
Client 2
Client 3
New connec
T ColH
ew Con
NioServerS ocketChannel
Read e
R
ead
Write.
Head Handler
write■
Sub handler
Tail Hander
ew Sosketchannel l
New Socketchannel 2
ew sacketchanne 3
PipeLine l
PipeLine 2
PipeLine 3
head
head
head
Su
理p
Sup
Sup
tail
tail
图13-3 Server Bootstrap的 Hanlder模型
本质区别就是: Server Bootstrap中的 Handler是 Nio ServerSocketchannel使用的,
所有连接该监听端口的客户端都会执行它;父类 AbstractBootstrap中的 Handler是个
工厂类,它为每个新接入的客户端都创建一个新的 Handler。
服务端启动的最后一步,就是绑定本地端口,启动服务,下面我们来分析下这部
分代码。
private Channel Future doBind(final SocketAddress localAddress) i
final ChanneIFuture regeuture ini tAndRegister(,No. 1
final Channel channel- regFuture channel()i
if (reg Future cause()!= null)[
return regfuture
266·第13章服务端创建
final ChannelPromise promise
if (regFuture, isDone ())t NO. 2
promise channel. newpromise()i
doBindo (regFuture, channel, IocalAddress, promise)i
else t
promise
new
De faultchannelPromise(channel
GlobalEventExecutor INSTANCE)i
regfuture. addListener(new Channelfuturelistener() i
override No. 3
public void operationComplete( ChannelFuture future) throws
Exception
doBindo (regFuture, channel, localLAddress, promise)i
return promise
先看下NO.1。首先创建 Channel, create Channel由子类 ServerBootstrap实现,创建新
的 NioServer SocketChannel。它有两个参数:参数1是从父类的NIO线程池中顺序获取一
个 Nio EventLoop,它就是服务端用于监听和接收客户端连接的 Reactor线程;参数2是所
谓的 worker Group线程池,它就是处理IO读写的 Reactor线程组,相关代码如下。
final ChannelFuture initAndRegister(
Channel channeli
tr
channel createChanne1();
I catch (Throwable t)f
return Voidchannel. INSTANCE. newFailedFuture(t
try i
init(channel);
catch (Throwable t) i
channel. unsafe(), closeForcibly()i
return channel. newFailedFuture(t)i
//后续代码省略
NioServerSocketchannel创建成功后,对它进行初始化,初始化工作主要有以下三点。
267Ne!y权威指南(第2版
(1)设置 Socket参数和 NioServer SocketChannel的附加属性,代码如下。
void init (Channel channel) throws Exception
final Map<channeloption<?>, Object> options= options()i
synchronized (options) t
channel. config(). setoptions (options)i
final Map<Attributekey<?>, Object> attrs attrs():
synchronized (attrs)[
for (Entry<AttributeKey<?>, Object> e: attrs. entryset())t
AttributeKey <object> key=(Attributekey object>)e getKey ()
channel attr(key). set(e getvalue())i
(2)将 Abstract Bootstrap的 Handler添加到 NioServer Socketchannel的 Channelpipeline
中,代码如下。
Channelpipeline p= channel pipeline()i
if (handler()!- null)[
p addLast(handler())i
(3)将用于服务端注册的 Handler Server BootstrapAcceptor添加到 ChannelPipeline中,
代码如下。
p, addLast(new ChannelInitializer<channe1>()i
OVerride
public void init Channel( Channel ch) throws Exception i
ch pipeline().addLast (new
ServerBootstrapAcceptor(currentchildHandler, currentchildoptions
currentchildAttrs))i
);
到此, Netty服务端监听的相关资源已经初始化完毕,就剩下最后一步一一注册
NioServer Socket Channel到 Reactor线程的多路复用器上,然后轮询客户端连接事件。在分
析注册代码之前,我们先通过图13-4看看目前 NioServer Socketchannel的 ChannelPipeline
的组成。
268·第13章服务端创建
INN SIIRE
Header Handler[ ServerBootstrapAccept
OUTSIREAM
A 13-4 NioServer SocketChannel ty ChannelPipeline
最后,我们看下 NioServer Socketchannel的注册。当 NioServer Socketchannel初始化
完成之后,需要将它注册到 Reactor线程的多路复用器上监听新客户端的接入,代码如下。
public final void register(final ChannelPromise promise) t
if (eventLoop. inEventLoop())i
register(promise)i
k else
try i
eventLoop. execute(new Runnable]) I
public void run) f
register(promise)i
});
y catch (Throwable t) I
//此处代码省略
首先判断是否是 Nio EventLoop自身发起的操作。如果是,则不存在并发操作,直接
执行 Channel注册;如果由其他线程发起,则封装成一个Task放入消息队列中异步执行。
此处,由于是由 Server Bootstrap所在线程执行的注册操作,所以会将其封装成Task投递
到 NioEventLoop中执行,代码如下。
private void register( ChannelPromise promise) I
try i
if (!ensureOpen(promise))i
returni
deRegister ()i
registered= truei
promise. setsuccess()i
pipeline. fireChannelRegistered()i
if (inActive())[
pipeline. fireChannelActive()i
catch (Throwable t) i
269·Nety权威指南(第2版)
//此处代码省略..
将 NioServerSocketchanne注册到 NioEventLoop的 Selector上,代码如下:
protected void deRegister() throws Exception i
boolean selected false:
for (i
try i
selectionkey javachannel().register(eventLoop(). selector,
0,th王s);
//此处代码省略
大家可能会很诧异,应该注册 OP ACCEPT(16)到多路复用器上,怎么注册0呢?
0表示只注册,不监听任何网络操作。这样做的原因如下
(1)注册方法是多态的,它既可以被 NioServer Socketchannel用来监听客户端的连接
接入,也可以注册 Socketchannel用来监听网络读或者写操作;
(2)通过 SelectionKey的 interestOrs( Int ops)方法可以方便地修改监听操作位。所以,
此处注册需要获取 SelectionKey并给 AbstractNioChannel的成员变量 selectionκey赋值。
注册成功之后,触发 Channelregistered事件,方法如下。
promise. setSuccess()i
pipeline. fireChannelRegistered()i
当 Channelregistered事件传递到 Tailhandler后结束, TailHandler也不关心
ChannelRegistered事件,因此是空实现,代码如下。
@override
public void channelRegistered(ChannelHandlerContext ctx) throws
Exception【
Channelregistered事件传递完成后,判断 ServerSocketchannel监听是否成功,如果成
功,需要出发 Nio Server Socketchannel的 Channelactive事件,代码如下
if (inActive())
pipeline. fireChannelActive(
is Active也是个多态方法。如果是服务端,判断监听是否启动;如果是客户端,判断
270·第13章服务端创建
TCP连接是否完成。 Channelactive事件在 Channelpipeline中传递,完成之后根据配置决
定是否自动触发 Channel的读操作,代码如下。
public ChannelPipeline fireChannelActive() t
head. firechannelActive()i
if (channel. config().isAutoRead()t
channel. read()i
return this
Abstract channel的读操作触发 ChannelPipeline的读操作,最终调用到 Headhandler的
读方法,代码如下。
public void read( ChannelHandlerContext ctx) f
unsafe. beginRead()i
继续看 Abstract Unsafe的 begin Read方法,代码如下。
public void beginRead() t
if (inActive()) I
returni
try
doBeginRead();
//后续代码省略
由于不同类型的 Channel对读操作的准备工作不同,因此, beginRead也是个多态方
法,对于NIO通信,无论是客户端还是服务端,都是要修改网络监听操作位为自身感兴趣
的,对于 Nio ServerSocketchannel感兴趣的操作是 OP ACCEPT(16),于是重新修改注册
的操作位为 OP ACCEPT,代码如下。
protected void doBeginRead() throws Exception t
//以上代码省略.
final int interestops selectionkey interestors()i
if ((interestors readInteres top)
0)
selectionKey interes tops(interes tops I readInterestop)i
271Net!y权威指南(第2版)
在某些场景下,当前监听的操作类型和 Chanel关心的网络事件是一致的,不需要重
复注册,所以增加了&操作的判断,只有两者不一致,才需要重新注册操作位。
JDK SelectionKey有4种操作类型,分别为:
(I OP READ=1<<0:
(2) OP WRITE =1<<2:
(3)OP CONNECT=1<<3:
(4) OP ACCEPT=1<<4。
由于只有4种网络操作类型,所以用4bit就可以表示所有的网络操作位,由于Java
语言没有bit类型,所以使用了整型来表示,每个操作位代表一种网络操作类型,分别为:
0001、0010、0100、1000,这样做的好处是可以非常方便地通过位操作来进行网络操作位
的状态判断和状态修改,从而提升操作性能。
由于创建 NioServer SocketChannel将 readInterestOp设置成了 OP ACCEPT,所以,在
服务端链路注册成功之后重新将操作位设置为监听客户端的网络连接操作,初始化
NioServer Socketchannel的代码如下。
public NioserverSocketchannel(EventLoop eventLoop, EventLoopGroup
childgroup) I
super(null, eventLooP, childGroup, newSocket()
SelectionRey OP ACCEPT)i
config new DefaultServerSocketChannelConfig(this
javachannel(). socket())i
到此,服务端监听启动部分源码已经分析完成,下一章节,让我们继续分析一个新的
客户端是如何接入的。
13.3客户端接入源码分析
负责处理网络读写、连接和客户端请求接入的 Reactor线程就是 NioEventLoop,下面
我们分析下 NioEvent Loop是如何处理新的客户端连接接入的。当多路复用器检测到新的
准备就绪的 Channel时,默认执行 processSelectedKeysOptimized方法,代码如下。
·272·第13章服务端创建
if selectedReys ! null)[
ProcessselectedKeysoptimized(selectedKeys flip())/
else
processselectedKeysPlain(selector. selectedKeys())i
由于 Channe的 Attachment是 Nio Server Socketchannel,所以执行 process SelectedKey
方法,根据就绪的操作位,执行不同的操作。此处,由于监听的是连接操作,所以执彳
unsafe. reado方法。由于不同的 Channel执行不同的操作,所以 NioUnsafe被设计成接口,
由不同的 Channel内部的 NioUnsafe实现类负责具体实现。我们发现 reado方法的实现有
两个,分别是 Nio Byte Unsafe和 NioMessageUnsafe。对于 NioServer socketchannel,它使
用的是 NioMessageUnsafe,它的read方法代码如下。
public void read()(
//代码省略..
final ChannelConfig config=config()i
final int maxMessagesPerRead= config. getMaxMessagesPerRead()i
final boolean autoRead config. isAutoRead();
final Channe pIpeline pipeline pipeline()i
boolean closed false:
Throwable exception = null
tr
y
for (ii)
int localRead doReadMessages(readBuf)i
i(1。 calread==0)
break;
if (localRead 0)
closed= true;
break:
if (readBuf size()>= maxMessages PerRead! autoRead) i
break;
/此处代码省略
对 doreadMessages方法进行分析,发现它实际就是接收新的客户端连接并创建
NioSocketChannel,代码如下
●273·Net!y权威指南(第2版)
protected int doReadMessages(List<object> buf) throws Exception I
Socketchannel ch javaChannel(). accept(i
try t
if(ch ! null) i
buf. add(new
NioSocket Channel (this
childEventLoopGroup(). next(), ch))i
return l;
i catch (Throwable t) t
//后续代码省略
接收到新的客户端连接后,触发 Channelpipeline的 Channelread方法,代码如下。
int size readBuf size(),
for (int i =0:i< size: i++)t
pipeline.fireChannelRead (readBuf get (i))i
执行 head ChannelHandlerContext的 fire Channelread方法,事件在 ChannelPipeline中
传递,执行 ServerBootstrap Acceptor的 channeled方法,代码如下。
public void channelRead (ChannelHandlerContext ctx, Object msg) i
Channel child= (Channel)msg:
child pipeline().addLast(childHandler)/
//代码省略
child. unsafe(). register(child. newPromise())i
该方法主要分为如下三个步骤。
第一步:将启动时传入的 childHandler加入到客户端 SocketChannel的 ChannelPipeline
第二步:设置客户端 Socketchannel的TCP参数;
第三步:注册 Socketchannel到多路复用器。
以上三个步骤执行完成之后,下面我们展开看下 NioSocketchannel的 register方法,
代码如图13-5所示。
274·第13章服务端创建
Types implementing or defining Unsafe register(channel Promise)"
d I Unsafe-io. netty, channel. Channel
CA AbstractUnsafe-io nettychannel.AbstractChannel
Fress'CtrlaT' to see the supertype hierarch
child. unsafe(), egister(child. newPromise())
图13-5 NioSocketchannel的 register方法实现
Nio SocketChannel的注册方法与 Server Socketchannel的一致,也是将 Channel注册到
Reactor线程的多路复用器上。由于注册的操作位是0,所以,此时 NioSocketchannel还不
能读取客户端发送的消息,那什么时候修改监听操作位为 OP READ呢,别着急,继续看
代码。
执行完注册操作之后,紧接着会触发 ChannelReadComplete事件。我们继续分析
ChannelreadComplete在 ChannelPipeline中的处理流程:Nety的 Header和Tai本身不关
注 ChannelreadComplete事件就直接透传,执行完 Channelreadcomplete后,接着执行
Pipeline的 reado方法,最终执行 Headhandler的 reado方法。
HeadHandler reado方法的代码已经在之前的小节介绍过,用来将网络操作位修改为读
操作。创建 NioSocketchannel的时候已经将 AbstractNioChannel的 readInterestOp设置为
OP READ,这样,执行 selectionKey interestOrs( interestOrs| readInterestOp)操作时就会把
操作位设置为 OP READ。代码如下
protected AbstractNioBytechannel(Channel parent, EventLoop eventloop
Selectablechannel ch) I
super(parent, eventLoop, ch, SelectionKey OP READ);
到此,新接入的客户端连接处理完成,可以进行网络读写等IO操作。
134总结
本章首先对原生NO类库的使用复杂性进行了讲解,然后对Net!y服务端创建的时序
图和步骤进行了详细地说明,随后结合Net!的源码对服务端创建进行剖析,最后对新的
客户端的接入进行了源码层面的分析和讲解
通过本章的学习,希望广大读者能够掌握Nety服务端创建的要点,并能够在实际的
工作中正确的使用服务端相关的类库,编写出高效的业务代码。
·275·第14章
客户端创建
相对于服务端, Netty客户端的创建更加复杂,除了要考虑线程模型、异步连接、客
户端连接超时等因素外,还需要对连接过程中的各种异常进行考虑。木章将对 Netty客户
端创建的关键流程和源码进行分析,以期读者能够了解客户端创建的细节。
本章主要内容包括:
◎客户端创建流程分析
客户端创建源码分析
14.1 Netty客户端创建流程分析
Nety为了向使用者屏蔽NIO通信的底层细节,在和用户交互的边界做了封装,目的
就是为了减少用户开发工作量,降低开发难度。 Bootstrap是 Socket客户端创建工具类,
用户通过 Bootstrap可以方便地创建 Netty的客户端并发起异步TCP连接操作
1421Net客户端创建时序图
Netty客户端创建时序图如图14-1所示。第14章客户端创建
创显冬尸
2构山线Q
3创建 NioSodetchanne
创建v的 efault PiDe
5异发起TcP连0
e注是蛋作位到多路复用器0
7是理造果事件0
进换成动事件0
调用用中 ChannalHend
图14-1 Netty客户端创建时序图
1422Net!v客户端刨建流程分析
步骤1:用户线程创建 Bootstrap实例,通过AP设置创建客户端相关的参数,异步发
起客户端连接
步骤2:创建处理客户端连接、IO读写的 Reactor线程组 NioEvent Loop Group。可以
通过构造函数指定IO线程的个数,默认为CPU内核数的2倍;
步骤3:通过 Bootstrap的 ChannelFactory和用户指定的 Channel类型创建用于客户端
连接的 NioSocketChannel,它的功能类似于 JDK NIO类厍提供的 Socket channel;
步骤4:创建默认的 Channel Handler Pipeline,用于调度和执行网络事件;
步骤5:异步发起TCP连接,判断连接是否成功。如果成功,则直接将 NioSocketchannel
注册到多路复用器上,监听读操作位,用于数据报读取和消息发送:如果没有立即连接成
功,则注册连接监听位到多路复用器,等待连接结果;
277Ne!权威指南(第2版)
步骤6:注册对应的网络监听状态位到多路复用器
步骤7:由多路复用器在LO现场中轮询各 Channel,处理连接结果;
步骤8:如果连接成功,设置 Future结果,发送连接成功事件,触发 ChannelPipeline
执行;
步骤9:由 Channelpipeline调度执行系统和用户的 Channelhandler,执行业务逻辑
14.2 Netty客户端创建源码分析
Net!y客户端的创建流程比较繁琐,本章节我们针对关键步骤和代码进行分析,通过
梳理关键流程来掌握客户端创建的原理。
142.1客户端连接辅助类 Bootstrap
Bootstrap是Nety提供的客户端连接工具类,主要用于简化客户端的创建,下面我们
对它的主要API进行讲解
设置IO线程组:在前面的章节我们介绍过,非阻塞IO的特点就是一个多路复用器
可以同时处理成百上干条链路,这就意味着使用NIO模式一个线程可以处理多个TCP连
接。考虑到1O线程的处理性能,大多数NO框架都采用线程池的方式处理I/O读写,Ney
也不例外。客户端相对于服务端,只需要一个处理IO读写的线程组即可,因为 Bootstrap
提供了设置IO线程组的接口,代码如下。
public B group(EventLoopGroup group)
if (group == null)i
throw new NullPointerException("group " )i
if (this group != null)i
throw new IllegalStateException("group set already")i
this group groupi
return (B) thisi
由子Nety的NlO线程组默认采用 EventLoop Group接口,因此线程组参数使用
278第14章客户端创建
EventLoopGroup
TCP参数设置接口:无论是异步NIO,还是同步BIO,创建客户端套接字的时候通常
都会设置连接参数,例如接收和发送缓冲区大小、连接超时时间等。 Bootstrap也提供了客
户端TCP参数设置接口,代码如下。
public <T> B option(ChannelOption<r> option, T value) t
f (option = null)[
throw new NullPointerException("option")i
if (value = null)i
synchroni zed (options) t
options. remove(option)i
1 else i
synchronized (options)i
options, put(option, value)i
return (B) this;
Netty提供的主要TCP参数如下。
(1) SO TIMEOUT:控制读取操作将阻塞多少毫秒。如果返回值为0,计时器就被禁
止了,该线程将无限期阻塞
2) SO SNDBUF:套接字使用的发送缓冲区大小;
3) SO RCVBUF:套接字使用的接收缓冲区大小
4) SO REUSEADDR:用于决定如果网络上仍然有数据向旧的 ServerSocket传输数
据,是否允许新的 Server Socket绑定到与旧的 ServerSocket同样的端口上。
SO REUSEADDR选项的默认值与操作系统有关,在某些操作系统中,允许重用端口,而
在某些操作系统中不允许重用端口;
(5) CONNECT TIMEOUT MILLIS:客户端连接超时时间,由于NIO原生的客户端
并不提供设置连接超时的接口,因此, Netty采用的是自定义连接超时定时器负责检测和
超时控制;
(6) TCP NODELAY:激活或禁止 TCP NODELAY套接字选项,它决定是否使用 Nagle
279·Nety权威指南(第2版)
算法。如果是时延敏感型的应用,建议关闭 Nagle算法。
channel接口:用于指定客户端使用的 channel接口,对于TCP客户端连接,默认使
用 NioSocketChannel,代码如下。
public Bootstrap channel (Class<? extends Channel> channelClass) I
if(channelClass = null)
throw new NullPointerException ("channeiClass")i
return
channelFactory (new
BootstrapChannelFactory<channel>(channelclass)):
Bootstrap ChannelFactory利用 channelclass类型信息,通过反射机制创建
NioSocketchanne对象。
设置 Handler接口: Bootstrap为了简化 Handler的编排,提供了 ChannelInitializer,它
继承了 ChannelHandler Adapter,当TCP链路注册成功之后,调用 unicHannel接口,用于
设置用户 Channelhandler。它的代码如下。
Excep_ublic final void channelRegistered ( ChannelHandlerContext ctx) throws
LIon
Channelpipeline pipeline= ctx pipeline(
boolean success false
try i
initchannel((c)ctx. channel()i
pipeline. remove(this),
ctx. firechanne oi
success= true;
//后续代码省略
其中 unicHannel为抽象接口,用户可以在此方法中设置 Channelhandler,代码如下。
handler(new ChannelInitializer<socketchannel>() I
OVerride
public void initchannel(Socketchannel ch)
thr。w8 Exception
ch pipeline(),addlast(
new EchoclientHandler(firstMessage Size));
});
280·第14章客户端创建
最后一个比较重要的接口就是发起客户端连接,代码如下。
Channelfuture f= b connect(host, port). sync()i
由于客户端连接方法比较复杂,下个小节对此进行详细讲解。
14.2.2客户端连接操作
首先要创建和初始化 NioSocketchannel,代码如下
private ChannelFuture doConnect(final SocketAddress remoteAddress, final
SocketAddress localAddress) f
final ChannelFuture regFuture ini tAndRegister();
final Channelchannel regFuture channel()
if (regFuture cause() != null) I
turn regFuturei
//代码省略
从 NioEventLoop Group中获取 Nio EventLoop,然后使用其作为参数创建
Nio Socketchannel,代码如下。
Channel createchannel([
EventLoop eventLoop= group(). next(i
return channelFactory () newchannel (eventLoop);
初始化 Channel之后,将其注册到 Selector上,代码如下。
ChannelPromise regFuture channel, newPromise()i
channel. unsafe().register(regEuture)i
链路创建成功之后,发起异步的TCP连接,代码如下。
private static void doConnecto(
final ChannelEuture regFuture, final Channel channel,
final SocketAddress remoteAddress, final SocketAddress
localAddress, final ChannelPromise promise) I
channe】. event。。p(). execute( new Runnab1e()f
cover⊥de
pub工 c void run()【
281Net!权威指南(第2版
if (regFuture insuccess ())
工￡( oca aDdress=mu11)f
channel, connect (remo teAddress, promise)i
else
channel connect(remoteAddress,
localAddress,
promise);
//后续代码省略
由上述代码可以看出,从 doconnecto操作开始,连接操作切换到了 Netty的NIO线
程 NioEventLoop中进行,此时客户端返回,连接操作异步执行。
do Connecto最终调用 Headhandler的 connect方法,代码如下。
public void connect
Channe lhandlerContext ctx
SocketAddress remoteAddress, SocketAddress localAddress,
ChannelPromise promise) throws Exception I
unsafe. connect(remoteAddress, locaLAddress, promise)i
AbstractNio Unsafe的 connect操作如下。
if (doConnect(remoteAddress, localAddress))t
fulfillConnect Promise(promise, wasActive)i
I else i
//后续代码省略.,
需要注意的是, Socketchannel执行 connect()操作后有以下三种结果。
(1)连接成功,返回True;
2)暂时没有连接上,服务端没有返回ACK应答,连接结果不确定,返回 False
3)连接失败,直接抛出IO异常。
如果是第二种结果,需要将 NioSocketchannel中的 selectionKey设置为
OP CONNECT,监听连接结果。
异步连接返回之后,需要判断连接结果,如果连接成功,则触发 Channelactive事件,
代码如下。
282·第14章客户端创建
if ( wasActive & isActive())i
pipeline(). firechanne LActive();
Channelactive事件处理在前面章节已经详细说明,最终会将 NioSocketchannel中的
selection Key设置为 SelectionKey. OP READ,用于监听网络读操作。
如果没有立即连接上服务端,则注册 SelectionKey. OP CONNECT到多路复用器,代
码如下。
boolean success false
try t
boolean connected s javaChannel().connect(remoteAddress)i
i(!c。 nnected)
selectionKey().interestors(SelectionKey. OP CONNECT);
success
truei
return connected
如果连接过程发生异常,则关闭链路,进入连接失败处理流程,代码如下。
finally i
if success) f
doclose(i
142.3异步连接结果通知
NioEventLoop的 Selector轮询客户端连接 Channel,当服务端返回握手应答之后,对
连接结果进行判断,代码如下
if ((readyOps Selectionkey OP CONNECT)!=0)I
int ops =k interestors ()
ops &=-Selectionkey, OP CONNECT
k, interestors (ops)i
unsafe. finishConnect()i
下面对 finish Connect方法进行分析,代码如下
·283·Net!权威指南(第2版)
try t
boolean wasActive isActive()i
doFinishconnect(i
fulfillConnectPromise(connect Promise, wasActive)i
dofinishconnect用于判断JDK的 Socketchannel的连接结果,如果返回true表示连接
成功,其他值或者发生异常表示连接失败。
protected void doEinishConnect ( throws Exception I
工(! avachanne1(). finishe。 nnect())f
throw new Error(i
连接成功之后,调用 fulfillConnectPromise方法,触发链路激活事件,该事件由 Channel
Pipeline进行传播,代码如下。
private void fulfillConnectPromise(ChannelPromise promise, boolean
wasActive) i
boolean promiseset promise. trySuccess()
if (I wasActive & isActive())(
pipeline(). firechannelActive()i
⊥f(! promisee)
close(voidPromise());
前面章节已经对 fireChannelActive方法进行过讲解,主要用于修改网络监听位为读操
作
142.4客户端连接超时机制
对于 Socketchannel接口,JDK并没有提供连接超时机制,需要NIO框架或者用户自
己扩展实现。 Netty利用定时器提供了客户端连接超时控制功能,下面我们对该功能进行
详细讲解。
·284·第14章客户端创建
首先,用户在创建Nety客户端的时候,可以通过 Channeloption. CONNECT TIMEOUT
MILLIS配置项设置连接超时时间,代码如下。
b group(group). channel(NioSocket Channel class)
option( Channeloption. TCP NODELAY, true)
option(ChannelOption. CONNECT TIMEOUT MILLIS, 3000)
//后续代码省略..
发起连接的同时,启动连接超时检测定时器,代码如下。
/ Schedule connect timeout
工 nt connective。utMi11is
config(). getconnectTimeoutMillis()i
if (connectTimeoutMillis >0)
connectrimeoutruture eventLoop(). schedule(new
Runnable( t
Override
public void run( i
Channel promise connectpromise
AbstractNiochannel, this connect promise
ConnectTimeoutException cause
new ConnectTimeoutException(connection
timed out: remoteAddress)i
if (connectPromise ! null &
connectPromise. tryFailure(cause)) i
close(voidPromise())i
Ir connectrimeoutMillis, TimeUnit MILLISECONDS)i
旦超时定时器执行,说明客户端连接超时,构造连接超时异常,将异常结果设置到
connect promise中,同时关闭客户端连接,释放句柄。
如果在连接超时之前获取到连接结果,则删除连接超时定时器,防止其被触发,代码
如下。
public void finishConnect()(
I finally i
if (connectTimeoutFuture !- null)
connectfimeoutFuture. cancel(false)i
connectPromise= nulli
285Net权威指南(第2版)
//后续代码省略,.
无论连接是否成功,只要获取到连接结果,之后就删除连接超时定时器
143总结
本章首先对Net客户端创建的主要流程进行说明,然后对客户端创建的关键步骤进
行详细分析和讲解。希望通过本章的学习,广大读者能够掌握Nety客户端创建的原理,
熟悉相关流程,编写出更加高效和可靠的业务代码。
286·源码分析篇
Net’y功能介绍和源码分析
第15章 ByteBuf和相关辅助类
第16章 Channel和 Unsafe
第17章 ChannelPipeline和 Channelhandler
第18章 EventLoop和 EventLoop Group
第19章 Future和 Promise第15章
Byte Buf和相关辅助类
从本章开始,我们将学习 Netty NIC相关的主要接口和模块的API功能,并对其源码
实现进行分析。希望读者通过对功能和API的学习,能够更加熟练地掌握和应用这些类库。
对源码的学习不仅能够帮助读者从源码的层面掌握Net!y框架,方便日后的维护、扩展和
定制,更能够起到触类旁通的作用,拓展读者的知识面,提升编程技能
本章主要内容包括:
◎ Byte Buf功能说明
◎ Byte Buf源码分析
◎ ByteBuf相关辅助类功能说明
151 Byte Buf功能说明
我们进行数据传输的时候,往往需要使用到缓冲区,常用的缓冲区就是 JDK NIO
类库提供的 java nio Buffer,它的实现类如图15-1所示。
实际上,7种基础类型( Boolean除外)都有自己的缓冲区实现。对于NIO编程而言,
我们主要使用的是 Byte Buffer从功能角度而言, ByteBuffer完全可以满足NIO编程的需
要,但是由于NIO编程的复杂性, Byte Buffer也有其局限性,它的主要缺点如下第15章 Byte Buf和相关辅助类
E E: \Progam Files\Javaij dk 1. 6.0-45jrellibrt jar b h java nio C Buffer
Type hierarchy of jawa. nio. Iutfer
C Objeet
ang
日 A Buffer
了.n1心
日G4 byteBuffer- java nio
a Heap ByteBufferR-javanio
S-GkMappediyteBuffer
Java.1
C DirectByteBuffer- java. hit
g DirectByteBufferR-jsvani
CherBuffer-jave nl o
a ByteBuffer AsChar BufferB-java nio
c Byte Buffer AsCher BufferRB-javanio
e
Byt eBufferAsChar BufferL-jaYs ni o
G ByteBufferAsCharBufferEL-javsnlo
B C DirectChar Buffers-java nig
a DirectCharFufferBS-J3va nio
e 9 DirectChar BufferUf-jsva nio
.G Direc tCharBufferEU-j9v4nio
cHe
1
G HeapCharBufferR-java,nio
Strin:CharBuffer-ava no
C-C Doubl eBuffer-java nio
t@ FloatBuffer-Jata nio
t-C IntBuffer-jav4nic
t-C LoncBuffer-javanio
tC4ShortBuffer-javanio
图15-1 java nio Buffer继承关系图
1) Byte Buffer长度固定,一旦分配完成,它的容量不能动态扩展和收缩,当需要编
码的POJO对象大于 ByteBuffer的容量时,会发生索引越界异常
(2) Byte Buffer只有一个标识位置的指针 position,读写的时候需要手工调用fip(和
rewind等,使用者必须小心谨慎地处理这些AP,否则很容易导致程序处理失败;
(3) Byte Buffer的APl功能有限,一些高级和实用的特性它不支持,需要使用者自己
编程实现。
为了弥补这些不足, Netty提供了自己的 ByteBuffer实现— Byte Buf,下面我们一起
学习 ByteBuf的原理和主要功能
15.1.1 Byte Buf的工作原理
不同 Byte Buf实现类的工作原理不尽相同,本小节我们从 ByteBuf的设计原理出发,
起探寻 Netty ByteBuf的设计理念。
首先, ByteBuf依然是个Byte数组的缓冲区,它的基本功能应该与JDK的 Byte Buffer
289Nety权威指南(第2版)
一致,提供以下几类基本功能。
◎7种Java基础类型、byte数组、 Byte Buffer( Byte Buf)等的读写
o缓冲区自身的copy和 slice等;
◎设置网络字节序;
构造缓冲区实例
操作位置指针等方法
由于JDK的 ByteBuffer已经提供了这些基础能力的实现,因此, Netty Byte Buf的实
现可以有两种策略。
◎参考 JDK Byte Buffer的实现,增加额外的功能,解决原 Byte Buffer的缺点;
③聚合 JDK Byte Buffer,通过 Facade模式对其进行包装,可以减少自身的代码量,
降低实现成木。
JDK Byte Buffer于只有一个位置指针用于处理读写操作,因此每次读写的时候都需
要额外调用nipO和 clear等方法,否则功能将出错,它的典型用法如下。
ByteBuffer buffer ByteBuffer allocate(88)i
String value=" Netty权威指南";
buffer put(value. getBytes())i
buffer, flip()i
byte[] vArray- new byte [buffer. remaining()]i
buffer. get(vArray)i
String decodeValue= new String(vArray)i
我们看下调用fip(操作前后的对比。
Netty权威指南
positI
图15-2 Byte Buffer flip(操作之前
如图152所示,如果不做fip操作,读取到的将是 position到 capacity之间的错误内容
290·第15章 Byte Buf和相关辅助类
当执行fipO操作之后,它的 limit被设置为 position, position设置为0, capacity不变。
由于读取的内容是从 position到 limit之间,因此,它能够正确地读取到之前写入缓冲区的
内容。如图15-3所示。
Nety权威指南
position
capacity
图15-3 Byte Buffer flipO操作之后
Byte Buf通过两个位置指针来协助缓冲区的读写操作,读操作使用 readerIndex,写操
作使用 writerlndex。
readerIndex和 writerIndex的取值一开始都是0,随着数据的写入 writerIndex会增加,
读取数据会使 readerIndex增加,但是它不会超过 writerlndex。在读取之后,0~ readerlndex
就被视为 discard的,调用 discardRead Bytes方法,可以释放这部分空间,它的作用类似
Byte Buffer的 compact方法。 ReaderIndex和 writerIndex之间的数据是可读取的,等价于
Byte Buffer position和 limit之间的数据。 Writerlndex和 capacity之间的空间是可写的,等
价于 ByteBuffer limit和 capacity之间的可用空间。
由于写操作不修改 readerIndex指针,读操作不修改 writerIndex指针,因此读写之间
不再需要调整位置指针,这极大地简化了缓冲区的读写操作,避免了由于遗漏或者不熟悉
fip(操作导致的功能异常。
初始分配的 Byte Buf如图15-4所示。
writable bytes
0=readerIndexwriterIndex
capacity
图15-4初始分配的 Byte Buf
写入N个字节之后的 Byte Buf如图15-5所示。
291Nety权威指南(第2版
readable bytes
writable bytes
O=readerlndex
N=writerIndex
capacit
图15-5写入N个字节后的 ByteBuf
读取M(<N)个字节之后的 Byte Buf如图15-6所示
discardable bytes: readable bytes
writable bytes
0
v-readerIndex
N=writerIndex
capacity
图15-6读取M个字节后的 Byte Buf
调用 discardread Bytes操作之后的 Byte Buf如图15-7所示。
readable bytes
writable bytes
o=readerIndex
N-M=writerIndex
capacity
图15-7 discardReadBytes操作之后的 Byte Buf
调用 clear操作之后的 Byte Buf如图15-8所示。
writable bytes( more space
0=readerlndex=writerlndex
capacity
图15-8 clear操作之后的 Byte Buf
下面我们继续分析 Byte Buf是如何实现动态扩展的。通常情况下,当我们对 ByteBuffer
进行put操作的时候,如果缓冲区剩余可写空间不够,就会发生 BufferOverflow Exception
292·第15章 Byte Buf和相关辅助类
异常。为了避免发生这个问题,通常在进行put操作的时候会对剩余可用空间进行校验。
如果剩余空间不足,需要重新创建一个新的 Byte Buffer,并将之前的 Byte Buffer复制到新
创建的 Byte Buffer中,最后释放老的 Byte Buffer,代码示例如下。
if (this buffer. remaining()< needsize)
int toBeExtsize needsize 128? needsize 128
ByteBuffer tmpBuffer- ByteBuffer allocate(this, buffer capacity()+
toBeExtsize)
this buffer. flip()i
tmpBuffer put( this buffer)i
this buffer tmpBufferi
从示例代码可以看出,为了防止 Byte Buffer溢出,每进行一次put操作,都需要对可
用空间进行校验,这导致了代码冗余,稍有不慎,就可能引入其他问题。为了解决这个问
题, ByteBuf对 write操作进行了封装,由 ByteBuf的 write操作负责进行剩余可用空间的
校验。如果可用缓冲区不足, Byte Buf会自动进行动态扩展。对于使用者而言,不需要关
心底层的校验和扩展细节,只要不超过设置的最大缓冲区容量即可。当可用空间不足时,
Byte Buf会帮助我们实现自动扩展,这极大地降低了 ByteBuf的学习和使用成本,提升了
开发效率。校验和扩展的相关代码如图15-9、15-10所示。
OVerride
public Byte Buf write Byte(int value
ensureWritable(
setByte(writerIndex++, value)
return this
图15-9 ByteBuf写入字节
通过源码分析,我们发现当进行 wrIte操作时,会对需要 write的字节进行校验。如果
可写的字节数小于需要写入的字节数,并且需要写入的字节数小于可写的最大字节数,就
对缓冲区进行动态扩展。无论缓冲区是否进行了动态扩展,从功能角度看使用者并不感知,
这样就简化了上层的应用。
由于NO的 Channel读写的参数都是 Byte Buffer,因此, Netty的 Byte Buf接口必须提
供AP,以方便地将 Byte Buf转换成 Byte Buffer,或者将 Byte Buffer包装成 Byte Buf.。考虑
到性能,应该尽量避兔缓冲区的复制,内部实现的时候可以考虑聚合一个 Byte Buffer的私
有指针用来代表 ByteBuffer。在后面的源码分析章节我们将详细介绍它的实现原理
293Netty权威指南(第2版)
@override
public ByteBuf ensureWritable(int minWritableBytes)(
if (min Writable Bytes <O)t
throw new IllegalArgumentException(String. format(
minWritableBytes: %d(expected: >=0), min WritableBytes))
if(min Writable Bytes < writable Bytes)i
return this
if (minWritable Bytes max Capacity-writerIndex)(
throw new IndexoutofBounds Exception(String. format(
writerIndex(%d)+minWritableBytes(% d)exceeds
max Capacity(%od): %S
writerIndex, minWritable Bytes, max Capacity, this)
I/ Normalize the current capacity to the power of 2.
int new Capacity s calculate NewCapacity writerIndex
minWritable Bytes);
l Adjust to the new capacity.
capacity(new Capacity)
return this
图15-10 Byte Buf写入宇节
学习完 Byte Buf的原理之后,下面我们继续学习它的主要API功能。
1512 Byte Buf的功能介绍
本小节我们将对 Byte Buf的常用API进行分类说明,讲解它的主要功能,后面的章节
将给出重要API的一些典型用法。
1.顺序读操作(read)
Byte Buf的read操作类似于 Byte Buffer的get操作,主要的API功能说明如表15-1所
表15-1 Byte Buf的读操作API列表
方法名称
返回值
功能说明
read Boolean
olean
从 readerlndex开始获取 boolean值, readerIndex增加1
readByte
yte
从 readerlndex开始获取字节值, readerIndex增加1
readUnsigned Byte
byte
从 readerIndex开始获取无符号字节值, readerIndex增加l
read Short
short
从 readerIndeκ开始获取短整型值, readerIndex增加2
readUnsignedShort
short
从 readerIndex开始获取无符号短整型值, readerlndex增加2
294·第15章 Byte Buf和相关辅助类
续表
方法名称
返回值
功能说明
从 readerIndex开始获取24位整型值, readerIndex增加3(注
readMediurm
意:该类型并非Java的基本类型,大多数场景使用不到
从 readerIndex开始获取24位无符号整型值, readerlndex增加
readUnsignedMedium
3(注意:该类型并非Java的基本类型,大多数场景使用不到)
readInt
int
从 reader Index开始获取整型值, readerIndex增加4
readUnsignedInt
Int
从 rcaderIndex开始获取无符号整型值, readerlndex增加4
read Long
long
从 readerIndex开始获取长整型值, readerIndex增加8
read Char
chat
从 readerIndex开始获取字符值, readerlndex增加2
readFloat
float
从 readerIndex开始获取浮点值, readerlndex增加4
redoUble
double
从 readerIndex开始获取双精度浮点值, readerIndex增加8
将当前 Byte But中的数据读取到新创建的 Byte Buf中,读取的
长度为 length操作成功完成之后,返回的 ByteBuf的 readerIndex
readBytes(int length)
cebU
f
为0, writerIndex为 length
如果读取的长度 length大于当前操作的 Byte Buf的可写字节
数,将抛出 IndexOutOfBounds Exception,操作失败
返回当前 Byte Buf衙创建的子区域,子区域与原 Bvte Buf共享
缓冲区,但是独立维护自己的 readerIndex和 writerlndex
readslice(int length)
Byte Buf
新创建的子区域 readerlndex为0, writerIndex为 length
如果读取的长度 length大于当前操作的 Byte Buf的可写字节
数,将抛出 Index OutOfBounds Exception,操作失败
将当前 Byte Buf的数据读取到目标 Byte Buf中,直到目标
ByteBuf没有剩余的空间可写
操作完成之后,当前 ByteBuf的 readerIndex+=读取的字节数
read Bytes( ByteBuf dst
ByteBuf
如果目标 Byte Buf可写的字节数大于当前 Byte Buf可读取的字
节数,则抛出
Index OutOf Bounds Exception,操作失败
将当前 ByteBuf的数据读取到目标 Byte Buf中,读取的字节数
长度为 length
操作完成之后,当前 Byte Buf的 readerlndex+= length
read Bytes( Byte Buf dst, int lengt
vte
如果需要读取的字节数长度 length大于当前 Byte Buf可读的字
节数或者目标 Byte Buf可写的字节数,则抛出
ndexOutOfBounds Exception,操作失败
295Nety权威指南(第2版)
续表
方法名称
返回值
功能说明
将当前 Byte Buf的数据读取到目标 Byte Buf中,读取的字节数
长度为 length
目标 Byte Buf的起始索引为 dstIndex,非 writerIndex
read Bytes( Byte Buf dst, int
操作完成之后,当前 ByteBuf的 readerIndex+= length
ByteBuf
dstIndex, int length
如果需要读取的字节数长度 length大于当前 ByteBuf可读的字
节数,或者 dstlndex小于0,或者 dstlndex+ length大于目标 ByteBuf
的 capacity,则抛出
ndex OutofBounds Exception,操作失败
将当前 ByteBuf的数据读取到目标byte数组中,读取的字节数
长度为 dst. length
操作完成之后,当前 Byte Buf的 readerlndex+= dst. lengt
readBytes(byte[ dst)
ByteBuf
如果目标字节数维的长度大于当前 ByteBuf可读的字节数,则
抛出
IndexOutOfBounds Exception,操作失败
将当前 Byte Buf的数据读取到目标byte数组中,读取的字节数
长度为 length,目标字节数组的起始索引为 dstIndex
read Bytes(byte[ dst, int dstIndex,
ByteBut'
如果 dstlndex小于0,或者 length大于当前 Byte But的可读字
int length)
节数,或者 dstlndex+ - length大于 dst length,则抛出
IndexOutOfBoundsException,操作失败
将当前 Byte Buf的数据读取到目标 ByteBuffer中,直到位置指
针到达 ByteBuffer的 limit
操作成功完成之后,当前 Byte Buf的 teaderlndex+
read Bytes( Byte Buffer dst)
ByteBuf
dest. remaining()
如果目标 Byte BufTer的可写字节数大于当前 Byte Buf可读字节
数,则抛出 Index OutOfBounds Exception,操作失败
将当前 ByteBuf的数据读取到目标输出流中,读取的字节数长
度为 length
如果操作成功,当前 ByteBuf的 readerlndex+= length
readBytes( OutputStream out, int
Byte Buf
如果 length大于当前 Byte Buf可读取的字节数,则抛出
length
Index OutOfBounds Exception,操作失败
如果读取过程中 OutputStream自身发生了MO异常,则抛出
IOException
296·第15章 Byte Buf和相关辅助类
续表
方法名称
返回值
功能说明
将当前 Byte Buf的数据写入到目标 Gathering Byte Channel中,
写入的最大字节数长度为 length
注意:由于 Gathering Byte Channel是非阻塞 Channel,调用它
的 write操作井不能保证一次能够将所有需要写入的字节数都
写入成功,即存在“写半包”问题。因此,它写入的字节数范
围为[0 ength
如果操作成功,当前 Byte Buf l的 readerIndex+=实际写入的字
read Bytes( Gathering Byte Channel
节数
out, int length
如果需要写入的 length大于当前 ByteBuf的可读字节数,则
抛出
Index OutOfBounds Exception异常;如果操作过程中
Gathering Byte Channel发生了IO异常,则抛出 IOException
无论抛出何种异常,操作都将失败
与其他read方法不同的是,本方法的返回值不是当前的
Byte But,而是写入 Gathering Byte Channel的实际字节数
2.顺序写操作(wite)
Byte Buf的 write操作类似于 Byte Buffer的put操作,主要的API功能说明如表15-2
所示
表15-2 ByteBuf的写操作API列表
方法名称
返回值
功能说明
将参数 value写入到当前的 ByteBut中
操作成功之后 writerIndex+=1
write Boolean(boolean value)
Byte But
如果当前 Byte Buf可写的字节数小于1,则抛出
ndexOutOfBoundsException,操作失败
将参数 value写入到当前的 Byte Buf中
操作成功之后 writerIndex+=1
writeByte(int value
BVteBut
如果当前 ByteBuf可写的字节数小于1,则抛出
ndexOutOfBounds Exception,操作失败
·297·Nety权威指南(第2版
续表
方法名称
返回值
功能说明
将参数 value写入到当前的 Byte Buf中
操作成功之后 writerIndex+=2
writeshort( int value)
Byte Buf
如果当前 ByteBuf'可写的字节数小于2,则抛出
Index OutOfBoundsException,操作失败
将参数 value写入到当前的 ByteBuf中
操作成功之后 writer Index+=3
write Medium( int value)
Byte Bul
如果当前 ByteBuf可写的字节数小于3,则抛出
Index OutOfBoundsException,操作失败
将参数 value写入到当前的 ByteBuf中
操作成功之后 writerIndex+=4
writeln( int value)
Byte But
如果当前 Byte Buf可写的字节数小于4,则抛出
Index OutOfBounds Exception,操作失败
将参数 value写入到当前的 ByteBuf中
操作成功之后 writerIndex+=8
writeLong(long value
Bvte Buf
如果当前 Byte Buf可写的字节数小于8,则抛出
Index OutboUnds Exception,操作失败
将参数 value写入到当前的 ByteBuf中
操作成功之后 writerlndex+=2
write Char( int value)
ByteBuf
如果当前 ByteBuf可写的字节数小于2,则抛出
Index OutOt Bounds Exception,操作失败
将源 BvteBuf src中的所有可读字节写入到当前 ByteBuf中
操作成功之后当前 BvteBuf的 writerIndex+=
write Bytes(Byte Buf src)
ByteBuf
src. readableBytes
如果源 ByteBuf src可读的字节数大于当前 Byte Buf的可写字
节数,则抛出 Index OutofBounds Exception,操作失败
将源 Byte Buf src中的可读字节写入到当前 Byte But中,写入
的字节数长度为 length
write Bytes(ByteBuf src, int length) ByteBuf
操作成功之后当前 Bvte but的 writerIndex+= length
如果 length大于源 Byte Buf的可读字节数或者当前 Byte Buf
的可写字节数,则抛出 Index OutOfBounds Exception,操作失败
·298第15章 Byte Buf和相关辅助类
续表
方法名称
返回值
功能说明
将源 ByteBuf sre中的可读字节写入到当前 Byte Buf中,写入
的字节数长度为 length,起始索引为 reiNdex
write Bytes( Byte Buf src, int srclndex
操作成功之后当前 ByteBuf的 writerIndex+= length
Byte Buf
Int length)
如果 reindex小于0,或者 reiNdex+ length大于源src的容
量:或者写入长度 length大于当前 BytcBuf的可写字节数,则
抛出 Index OutofBounds Exception,操作失败
将源字节数组sre中的所有字节写入到当前 ByteBuf中
操作成功之后当前 Byte Buf的 writerIndex+= src length
write Bytes(byte[ src)
BYteBut
如果源字节数组src的长度大于当前 ByteBuf的可写字节数,
则抛出 Index OutOfBounds Exception,操作失败
将源字节数组src中的字节写入到当前 ByteBuf中,写入的
字节数长度为 length,起始索引为 reiNdex
writeBytes(bywell sre, int reiNdex. ByteBuf
操作成功之后当前 ByteBuf的 writerIndex+= length
Int length)
如果 reiNdex小于0,或者 reiNdex+ length大于源src的容
量:或者写入长度 length大于当前 ByteBuf的可写字节数,则
抛出 Index OutofBounds Exception,操作失败
将源 Byte ButTer src中所有可读字节写入到当前 Byte Buf中
写入的长度为 sIc.remaining(
writeBytes( ByteBuffer src)
Byte Buf
操作成功之后当前 ByteBuf的 writerIndex+= stc.remaining0
如果源 Byte Buffer sre的可读字节数大于当前 ByteBuf的可
写字节数,则抛出 Index OutOfBounds Exception,操作失败
将源 Inputstream src中的内容写入到当前 BYte But中,写入
的最大字节数长度为 length
实际写入的字节数可能小于 length
操作成功之后当前 Byte Buf的 writerIndex+=实际写入的字
writeBytes(InputStream in, int length)
节数
如果 length大于源 ByteBuf的可读字节数或者当前 ByteBuf
的可写字节数,则抛出 Index OutofBounds Exception,操作失败
如果从 InputStream读取的时候发生了1o异常,则抛出
IOException
·299·Nety权威指南(第2版)
续表
方法名称
返回值
功能说明
将源 Scattering B
lsre中的内容写入到当前 ByteBuf
中,写入的最大字节数长度为 length
实际写入的字节数可能小于 length
writeBytes( Scattering Bytechannel
操作成功之后当前 Byte Buf的 writerIndex+=实际写入的字节数
int
length)
如果 ength大于源sre的可读字节数或者当前 ByteBuf的可
写字节数,则抛出 Index OutOfBounds Exception,操作失败
如果从 Scattering Byte Channel读取的时候发生了IO异常,
则抛出 IOException
将当前的缓冲区内容填充为NUL(0x00),起始位置为
writerIndex,填充的长度为 length
writeZero(int length)
ByteBut
填充成功之后 writerIndex+= length
如果 length大于当前 ByteBuf的可写字节数则抛出
Index OutotBounds Exception操作失败
3. readerlndex fl writerIndex
Net!y提供了两个指针变量用于支持顺序读取和写入操作: readerlndex用于标识读取
索引, writerlndex用于标识写入索引。两个位置指针将 Byte Buf缓冲区分割成三个区域,
如图15-11所示
discardable bytes
readable bytes
writable bytes
【 ONTENT
reader index t
writerindex
capacit
图15-1 Byte Buf的 readerlndex和 writerIndex
调用 Byte Buf的read操作时,从
readerindex
处开始读取
readerindex
到
writerIndex
之间的空间为可读的字节缓冲区;从 writerIndex到 capacity之间为可写的字节缓冲区;0
到 readerIndex之间是已经读取过的缓冲区,可以调用 discardRead Bytes操作来重用这部分
空间,以节约内存,防止 Byte Buf的动态扩张。这在私有协议栈消息解码的时候非常有用,
因为TCP底层可能粘包,几百个整包消息被TCP粘包后作为一个整包发送。这样,通过
discardRead Bytes操作可以重用之前已经解码过的缓冲区,从而防止接收缓冲区因为容量
300第15章 Byte Buf和相关辅助类
不足导致的扩张。但是, discardEd Bytes操作是把双刃剑,不能滥用,关于这一点在后
续章节会进行详细说明。
4. Discardable bytes
相比于其他的Java对象,缓冲区的分配和释放是个耗时的操作,因此,我们需要尽
量重用它们。由于缓冲区的动态扩张需要进行字节数组的复制,它是个耗时的操作,因此,
为了最大程度地提升性能,往往需要尽最大努力提升缓冲区的重用率。
假如缓冲区包含了N个整包消息,每个消息的长度为L,消息的可写字节数为R。当
读取M个整包消息后,如果不对 ByteBuf做压缩或者 discardReadBytes操作,则可写的缓
冲区长度依然为R。如果调用 discardRead Bytes操作,则可写字节数会变为R=(R+Mx
L),之前已经读取的M个整包的空间会被重用。假如此时 Byte Buf需要写入R+1个字节,
则不需要动态扩张 Byte Buf
Byte Buf的 discardReadBytes操作效果图如下。
操作之前如图15-12所示。
I discardable bytes I readable bytes I writable bytes I
一+一一+一一+-一一一一一一一
一一-------+一一-
reader index < writer index
capacity
图15-12 discardRead Bytes操作之前的 Byte Buf
操作之后如图15-13所示。
readable butes
writable bytes (got more space)
readerIndex (0)<=writer Index (decreased)
capacity
图15-13 discardReadBytes操作之后的 ByteBuf
需要指出的是,调用 discardReadBytes会发生字节数组的内存复制,所以,频繁调用
将会导致性能下降,因此在调用它之前要确认你确实需要这样做,例如牺牲性能来换取更
多的可用内存。 discardReadBytes的相关源码如图15-14所示。
需要指出的是,调用 discardReadBytes操作之后的 writable bytes内容处理策略跟
Byte Buf接口的具体实现有关
·301·Net!权威指南(第2版)
@Override
public Byte Buf discard Read Bytes
ensureAccessible(:
if (readerIndex ==0)(
return this
if(readerIndex I= writerIndex)t
setBytes(0, this, readerIndex, writerIndex-readerIndex)
writerIndex-= readerIndex:
adjustMarkers(readerIndex
readerIndex= 0
else
djustMarkers(readerIndex)
writerIndex readerlndex =0
return this:
图15-14 discardRead Bytes操作会导致内存复制
5. Readable bytes Fl Writable bytes
可读空间段是数据实际存储的区域,以read或者skip开头的任何操作都将会从
readerIndex开始读取或者跣过指定的数据,操作完成之后 readerIndex增加了读取或者跳
过的字节数长度。如果读取的字节数长度大于实际可读的字节数,则抛出
IndexOutofBoundsException。当新分配、包装或者复制一个新的 Byte Buf对象时,它的
readerlndex为0。
可写空间段是尚未被使用可以填充的空闲空间,任何以 write开头的操作都会从
writerlndex开始向空闲空间写入字节,操作完成之后 writerIndex增加了写入的字节数长
度。如果写入的字节数大于可写的字节数,则会抛出 IndexOutOfBounds Exception异常。
新分配一个 Byte Buf对象时,它的 readerIndex为0。通过包装或者复制的方式创建一个新
的 Byte Buf对象时,它的 writerlndex是 Byte Buf的容量。
6. Clear操作
正如 JDK Byte Buffer的 clear操作,它并不会清空缓冲区内容本身,例如填充为NUL
(0x00)。它主要用来操作位置指针,例如 position、 limit和mark。对于 ByteBuf,它也是
用来操作 readerlndex和 writerIndex,将它们还原为初始分配值。具体的处理示例图如下
Clear(操作之前如图15-15所示。
Clear(操作之后如图15-16所示。
·302·第15章 Byte Buf和相关辅助类
十一一一一一一一一一一一一一一一一一一一一一一一一一m一===4
I discardable bytes readable bytes writable bytes
readerIndex < writerIndex < capacity
图15-15 clear操作之前的缓冲区
writable bytes (got more space)
reader index writerindex
capacity
图15-16 clear操作之后的缓冲区
7.Mak和Rest
当对缓冲区进行读操作时,由于某种原因,可能需要对之前的操作进行回滚。读操作
并不会改变缓冲区的内容,回滚操作主要就是重新设置索引信息。
对于JDK的 Byte Buffer,调用mark操作会将当前的位置指针备份到mak变量中,当调用
rest操作之后,重新将指针的当前位置恢复为备份在mark中的值,源码代码如图15-17所示。
public final Buffer marko
mark position;
return this
图15-17mark操作之后的缓冲区位置指针
调用 reset操作之后如图15-18所示。
Net!y的 Byte Buf也有类似的rest和mark接口,因为 ByteBuf有读索引和写索引,因
此,它总共有4个相关的方法,分别如下。
◎ mark ReaderIndex:将当前的 readerIndex备份到 markedReaderlndex中;
◎ reset ReaderIndex:将当前的 readerIndex设置为 marked ReaderIndex;
mark WriterIndex:将当前的 writerIndex备份到 markedwriterIndex;
reset writerIndex:将当前的 writerIndex设置为 marked WriterIndex。
303Net!权威指南(第2版)
public final Buffer reset)I
int m mark
f(m≤0)
throw new InvalidMark Exception(:
position m:
return this
图15-18rest操作之后的缓冲区位置指针
相关的代码实现如图15-19所示。
@override
public Byte Buf markReaderIndex((
markedReaderIndex readerIndex
turn this
OVerride
public Byte Buf resetReaderIndex(i
readerIndex(marked ReaderIndex)
return this
@override
public Byte Buf markWriterIndex(i
marked writerindex writerindex:
return this.
@override
public ByteBuf resetWriterIndex((
writerlndex= marked writerlndex
return thi
图15-19mark和rest操作前后的缓冲区位置指针
8.查找操作
很多时候,需要从 ByteBuf中查找某个字符,例如通过“rn”作为文本字符串的换
行符,利用“NUL(0x00)”作为分隔符
Byte Buf提供了多种查找方法用于满足不同的应用场景,详细分类如下。
(1) index of( int fromIndex, int toIndex, byte value):从当前 ByteBuf中定位出首次出现
value的位置。起始索引为 fromIndex,终点是 toIndex。如果没有查找到则返回-1,否则返
回第一条满足搜索条件的位置索引。
(2) bytes Before( byte value):从当前 Byte Buf中定位出首次出现 value的位置。起始
304第15章 ByteBuf和相关辅助类
索引为 readerIndex,终点是 writerIndex。如果没有查找到则返回-1,否则返回第一条满足
搜索条件的位置索引。该方法不会修改 readerIndex和 writerIndex。
(3) bytes Before( int length, byte value):从当前 ByteBuf中定位出首次出现vaue的位
置。起始索引为 readerlndex,终点是 readerindex+ length。如果没有查找到则返回-1,否则
返回第一条满足搜索条件的位置索引。如果 length大于当前字节缓冲区的可读字节数,则
抛出 IndexOutOfBoundsException异常。
(4) bytes Before(int index, int length, byte value);:从当前 Byte Buf中定位出首次出现
value的位置。起始索引为 index,终点是 index+ -length。如果没有查找到则返回-1,否则
返回第一条满足搜索条件的位置索引。如果 index+ -length大于当前字节缓冲区的容量,则
抛出 IndexOutOfBounds Exception异常。
(5) for Each Byte( ByteBufProcessor processor):遍历当前 ByteBuf的可读字节数组,与
Byte BufProcessor设置的查找条件进行对比。如果满足条件,则返回位置索引,否则返回-l。
(6) for Each Byte(int index, int length, Byte BufProcessor processor): DA
以 index为起始位
置, index+ length为终止位置进行遍历,与 Byte BufProcessor设置的查找条件进行对比。
如果满足条件,则返回位置索引,否则返回-1。
(7)for Each Byte Desc(Byte BufProcessor processor):
遍历当前 ByteBuf的可读字节数组,
与 Byte BufProcessor设置的査找条件进行对比。如果满足条件,则返回位置索引,否则返
回-1。注意对字节数组进行迭代的时候采用逆序的方式,也就是从 writerIndex-1开始迭代,
直到 readerlndex。
(8) for Each Byte Desc(int index, int length, Byte BufProcessor processor): DA index *tt
始位置, index+ - length为终止位置进行遍历,与 Byte ButProcessor设置的查找条件进行对
比。如果满足条件,则返回位置索引,否则返回-1。采用逆序查找的方式,从 index+ length
-1开始,直到 index。
对于查找的字节而言,存在一些常用值,例如回车换行符、常用的分隔符等,Net!y为了减
少业务的重复定义,在 Byte BufProcessor接口中对这些常用的查找字节进行了抽象,定义如下
(1) FIND NUL: NUL (0x00)
(2) FIND CR: CR('\r):
(3) FIND LF: LF (n,);
305Nett权威指南(第2版)
(4) FIND CRLF:CR("r)或者LF("mn):
(5) FIND LINEAR WHITESPACE:‘或者"t
使用者也可以自定义查找规则,实现如15-20所示接口即可。
@return I@code true) if the processor wants to continue the loop and
handle the next byte in the buffer
I@code false) if the processor wants to stop handling bytes and
abort the loop.
boolean process(byte value)throws Exception
图15-20字节查找接口
9. Derived buffers
类似于数据库的视图, ByteBuf提供了多个接口用于创建某个 Byte Buf的视图或者复
制 Byte Buf,具体方法如下
(1) duplicate:返回当前 Byte Buf的复制对象,复制后返回的 ByteBuf与操作的 ByteBut
共亨缓冲区内容,但是维护自己独立的读写索引。当修改复制后的 Byte Buf内容后,之前
原 ByteBuf的内容也随之改变,双方持有的是同一个内容指针引用。
(2)copy:复制一个新的 ByteBuf对象,它的内容和索引都是独立的,复制操作本身
并不修改原 Byte Buf的读写索引。
(3)copy( int index, int length):从指定的索引开始复制,复制的字节长度为 length,
复制后的 ByteBuf内容和读写索引都与之前的独立
(4) slice:返回当前 Byte I的可读子缓冲区,起始位置从 readerIndex到 writerIndex,
返回后的 Byte Buf与原 Byte Buf共亨内容,但是读写索引独立维护。该操作并不修改原
ByteBuf的 readerIndex和 writerIndex
(5) slice(int index, int length):返回当前 ByteBuf的可读子缓冲区,起始位置从 index
到 index+ length,返回后的 ByteBuf与原 Byte Buf共亨内容,但是读写索引独立维护。该
操作并不修改原 Byte Buf的 readerlndex和 writerIndex o
10.转换成标准的 Byte Buffer
我们知道,当通过NIO的 Socketchannel进行网络读写时,操作的对象是JDK标准的
306·第15章 Byte Buf和相关辅助类
JavanIo. Byte Buffer,由于 Netty统一使用 Byte Buf替代JDK原生的 Java.nlo. ByteBuffer,所
以必须从接口层面支持两者的相互转换,下面就一起看下如何将 Byte Buf转换成
java nio ByteBuffer.
将 Byte Buf转换成java.nio. Byte Buffer的方法有两个,详细说明如下
1) Byte Buffer nio Bufferd:将当前 ByteBuf可读的缓冲区转换成 Byte Buffer,两者共
享同一个缓冲区内容引用,对 Byte Buffer的读写操作并不会修改原 Byte Buf的读写索引
需要指出的是,返回后的 Byte Buffer无法感知原 Byte Buf的动态扩展操作。
(2) Byte Buffer nio Buffer(int index, int length):将当前 Byte Buf从 index开始长度为
length的缓冲区转换成 ByteBuffer,两者共享同一个缓冲区内容引用,对 ByteBuffer的读
写操作并不会修改原 Byte Buf的读写索引。需要指出的是,返回后的 Byte Buffer法感知
原 Byte Buf的动态扩展操作。
11.随机读写(set和get)
除了顺序读写之外, Byte Buf还支持随机读写,它与顺序读写的最大差别在于可以随
机指定读写的索引位置
读取操作的API列表如图15-21所示。
-9AByteBuf
e boOlean Gint):boolean
是e1
●" gatuni ma出Byt[it): thor t
e Eetshart (int) short
a getUnsigmedhort (int): int
o getediu (int) int
e getUnsignedMedium (int) int
catInt (int) int
gatUni meant (int) lung
o celLon (nt) Lenz
getChar (int) cha
refLoat lint):心t
getDouhle (int)-donal
getBytes tint. ByteBuf) Eyt bUf
tBytes (int, Byt
A getBytes (int, ByteBuf, int, int) Bytelaf
A getBytes tint, byte[l) ByteEuf
o cetBytes lint, byte[l. int, int) Byt eBuf
A ret Gint. BrteBuffer): lyteBuf
e cetBytes (int, OutputStream, int) EyteEuf
图15-21 Byte Buf随机读操作API列表
随机写操作的API列表如图15-22所示。
307Nety权威指南(第2版)
KA ByteBuf
setIndex (int, int): ByteBuf
setBoolean (int, boolean]: Byte Buf
A setByte (int, int): ByteBuf
e setShort(int, int): ByteBuf
●^ remEdium〔int,int): ByteBuf
O setInt (int, int): ByteBuf
●^ strOng〔int,1ong): yteBuf
o setChar (int, int): ByteBuf
● setrloat(int,且oat): ByteBuf
setDouble (int, double): ByteBuf
A setBytes Gint, ByteBuf):ByteBuf
etBytes int, Byt e Buf, int): ByteBuf
A setBytes (int, ByteBuf, int, int): ByteBuf
e setBytes (int, byte[]): ByteBuf
A
●" setByte雪
〔int,byte[].i
t): ByteBuf
A
setBytes (int, ByteBuffer): ByteBuf
setBytes(int, InputStream, int):int
A setBytes (int, ScatteringByteChannel, int):int
Zero (int, int): ByteBuf
图15-22 Byte Buf醢机写操作API列表
无论是get还是set操作, Byte Buf都会对其索引和长度等进行合法性校验,与顺序读
一致。但是,set操作与 write操作不同的是它不支持动态扩展缓冲区,所以使用者必须
保证当前的缓冲区可写的字节数大于需要写入的字节长度,否则会抛出数组或者缓冲区越
界异常。相关代码如图15-23所示。
@Override
public Byte Buf setByte(int index, int value)(
checkIndex(index):
setByte (index, value);
return this
图15-23 Byte Buf随机写操作不支持动态扩展缓冲区
152 Byte Buf源码分析
由于 ByteBuf的实现非常繁杂,因此本书不会对其所有子类都进行穷举分析,我们挑
选 Byte Buf的主要接口实现类和主要方法进行分析说明。相信理解了这些主要功能之后,
再去阅读和分析其他辅助类会更加简单。
·308·第15章 Byte Buf和相关辅助类
1521 Byte Buf的主要类继承关系
首先,我们通过主要功能类库的继承关系图(见图15-24),来看下 Byte Buf接口的不
同实现。
Byte Buf
Abstract Byte Buf
AbstractReference CountedByte Buf
c UnpooledHeapByteBuf
UnpooledDirectByteBuf
c UnpooledUnsafe DirectByteBuf
Pooled Byte Buf
Pooled Direct Byte Buf
S PooledHeapByteBuf
PooledHeap Byte Buf
图15-24 Byte Buf主要功能类继承关系图
从内存分配的角度看, Byte Buf可以分为两类
(1)堆内存( Heap ByteBuf)字节缓冲区:特点是内存的分配和回收速度快,可以被
JVM自动回收;缺点就是如果进行 Socket的IO读写,需要额外做一次内存复制,将堆
内存对应的缓冲区复制到内核 Channel中,性能会有一定程度的下降。
(2)直接内存( DirectByte Buf)字节缓冲区:非堆内存,它在堆外进行内存分配,相
比于堆内存,它的分配和回收速度会慢一些,但是将它写入或者从 Socket Channel中读取
时,由于少了一次内存复制,速度比堆内存快。
正是因为各有利弊,所以Nety提供了多种 Byte Buf供开发者使用,经验表明, Byte Buf
的最佳实践是在IO通信线程的读写缓冲区使用 Direct Byte Buf,后端业务消息的编解码模
块使用 HeapByteBuf,这样组合可以达到性能最优。
·309Net!y权威指南(第2版)
从内存回收角度看, Byte Buf也分为两类:基于对象池的 ByteBuf和普通 Byte Buf。两
者的主要区别就是基于对象池的 ByteBuf可以重用 ByteBuf对象,它自己维护了一个内存
池,可以循环利用创建的 Byte Buf,提升内存的使用效率,降低由于高负载导致的频繁GC。
测试表明使用内存池后的Nety在高负载、大并发的冲击下内存和GC更加平稳。
尽管推荐使用基于内存池的 ByteBuf,但是内存池的管理和维护更加复杂,使用起来
也需要更加谨慎,因此,Net提供了灵活的策略供使用者来做选择。
下面我们对主要的功能类和方法的源码进行分析和解读,以便能够更加深刻地理解
ByteBuf的实现,掌握其更加高级的功能。
1522 AbstractByte Buf源码分析
Abstract ByteBuf继承自 Byte Buf, Byte Buf的一些公共属性和功能会在 AbstractByte Buf
中实现,下面我们对其属性和重要代码进行分析解读。
1.主要成员变量
首先,像读索引、写索引、mark、最大容量等公共属性需要定义,具体定义如图15-25
所示。
我们重点关注下 leak Detector,它被定义为 static,意味着所有的 Byte Buf实例共享同
个 Resource leak detector对象。 Resource leakdetector用于检测对象是否泄漏,后面有专
门章节进行讲解
static final ResourceLeak Detector<Byte Buf> leak Detector =new
ResourceLeakDetector<Byte Buf>(ByteBuf. class);
Int readerIndex
private int writerIndex
private int markedReaderIndex
private int marked WriterIndex
private int max Capacity
private SwappedByte Buf swapped Buf;
图15-25 AbstractByte Buf成员变量定义
我们发现,在 Abstract ByteBuf中并没有定义 ByteBuf的缓冲区实现,例如byte数组
或者 DirectByte Buffer。原因显而易见,因为 AbstractByte Buf并不清楚子类到底是基于堆
310第15章 Byte Buf和相关辅助类
内存还是直接内存,因此无法提前定义
2.读操作簇
无论子类如何实现 Byte Buf,例如 UnpooledHeapByteBuf使用byte数组表示字节缓冲
区, Unpooled DirectByteBuf直接使用 Byte Buffer,它们的功能都是相同的,操作的结果是
等价的。
因此,读操作以及其他的一些公共功能都由父类实现,差异化功能由子类实现,这也
就是抽象和继承的价值所在。
read类操作的方法如图15-26所示。
●△ readByte0byte
●△ rendboolean0:boa1n
ea readUnsigmedByteO: shor+
●△ headshot0sh
@a readUnsignedshortO. int
●△了品 MedianO int
●ds4iw0;nt
0a regeNt O int
.e readchar@.char
●Fea1t0:aat
ea readDoubleo): doubl
eadBytes dint) ByteBuf
readSliee (int) EyteBuf
。rb+44D57
山aByt[byte
△Y命 adStar[ tabUn): Bvt eBnf
oa readBytes CytaBuf, int): BytaBuf
●。 readkytes0 teluk,int,int)Bye
●a￥Byt电s① reoffer)ytd
●△r4 adBytes GGatheringBytoChannal,int):int
re塞围yte0upu!S!,int): Bytes
图15-26读操作方法一览表
限于篇幅,我们不能一一枚举,挑选其中框线所示的 readBytes(byte[]dst, int dstIndex,
int length)方法进行分析,首先看源码实现,如图15-27所示。
@Override
public Byte Buf readBytes(bytel dst, int dstlndex, int length)(
checkReadable Bytes(length)
getBytes(readerIndex, dst, dstlndex, length);
readerlndex + length,
turn this
图15-27 readBytes(byte]dst, int dstIndex, int length)方法源码
在读之前,首先对缓冲区的可用空间进行校验,校验的代码如图15-28所示
311Net!y权威指南(第2版)
protected final void check Readable Bytes(int minimumReadable Bytes)[
ensureAccessible(
if (minimumReadable Bytes <0)
throw new IllegalArgumentException("minimumReadableByt
minimum Readable Bytes +"(expected: >=0)")
if (readerIndex writerIndex-minimumReadable Bytes)(
throw new IndexoutofBoundsEXception(String. format(
readerIndex(%d)+ length(%d)exceeds writerIndex( %d): %s
readerIndex, minimum Readable Bytes. writerIndex, this))
图15-28 read Bytes(byte]dst, int dstIndex, int length)方法源码
如果读取的长度小于0,则抛出Ⅲ legalArgument Exception异常提示参数非法;如果可
写的字节数小于需要读取的长度,则抛出 IndexOut OfBounds Exception异常。由于异常中
封装了详细的异常信息,所以使用者可以非常方便地进行问题定位。
校验通过之后,调用 getBytes方法,从当前的读索引开始,复制 length个字节到目标
byte数组中。由于不同的子类复制操作的技术实现细节不同,因此该方法由子类实现,如
图15-29所示
Transfers this buffers data to the specified destination starting at
the specified absolute @code index
This method does not modify (@code readerindex) or @code writerlndexl
of both the source(ie t@code this))and the destination
@param dstindex the first index of the destination
@param length the number of bytes to transfe
@throws IndexOutofBoundsExcept
if the specified l@code index is less than @code OF
if the specified(@code dstIndex) is less than i@code 01,
if [@code index length is greater than
@code this capacity, or
if [@code dstindex +lengthl is greater than
[@code dst capacityl
public abstract Byte Buf getBytes(int index, Byte Buf dst, int dstlndex, int
ngth)
图15-29宇节数组读取操作
如果读取成功,需要对读索引进行递增: readerlndex+= length。其他类型的读取操作
与之类似,不再展开介绍,感兴趣的读者可以自行阅读相关代码。
3.写操作簇
与读取操作类似,写操作的公共行为在 Abstract Byte Buf中实现,它的API列表如图
312第15章 Byte Buf和相关辅助类
30所示
我们选择与读取配套的 write Bytes( byte[ src, int srclndex, int length)进行分析,它的功
能是将源字节数组中从 reiNdex开始,到 reiNdex+ length截止的字节数组写入到当前的
ByteBuf中。下面具体看源码实现,如图15-31所示
曰 AbstractByte
iterant
int
●, i terIndex0:int
ea writerInder (int): Byt Buf
De writeBoolean (boolean) ByteBuf
OA writeByte (int): ByteBuf
da writeShert Gint): Byt Bf
Medium Gint): ByteBuf
Oa riteInt (int): ByteBuf
OA writeLong aomc): ByteBuf
△ writeChar(int),y
● wri tep1[t), YuebU
OA writeBytes Byte[l, int, int): ByteBuf
teBytes rteBuf) ByteBuf
Oa writeEytes (ByteBuf, int): ByteBuf
会 a wTi teEytes田 debUf,int,int): ByteBuf
ea writeBytes nptStream, int)- int
● writeBytes catterineByt
tzerolint)
图15-30写操作方法一览
@overhit
public Byte Buf write Bytes(ByteBuf src, int srclndex, int length)
ensureWritable(length);
setBytes(writerIndex, srG, srclndex, length:
writerIndex + length
return this
图15-31指定的宇节数组写入缓冲区源码
首先对写入字节数组的长度进行合法性校验,校验代码如图15-32所示。
如果写入的字节数组长度小于0,则抛出 IllegalArgumentException异常;如果写入的
字节数组长度小于当前 Byte Buf可写的字节数,说明可以写入成功,直接返回;如果写入
的字节数组长度大于可以动态扩展的最大可写字节数,说明缓冲区无法写入超过其最大容
量的字节数组,抛出 IndexOutofBounds Exception异常。
如果当前写入的字节数组长度虽然大于目前 ByteBuf的可写字节数,但是通过自身的
动态扩展可以满足新的写入请求,则进行动态扩展。可能有读者会产生疑问,既然需要写
入的字节数组长度大于当前缓冲区可写的空间,为什么不像JDK的 Byte Buffer那样抛出
缓冲区越界异常呢?
·313Netty权威指南(第2版)
@Override
public Byte Buf ensure Writable(int min Writable Bytes)f
if(minWritable Bytes < o)t
throw new IllegalArgumentException( String. format(
minWritable Bytes: %d (expected: >=0), minWritable Bytes)
if (minWritable Bytes < writable Bytes()(
return this:
if(minWritableBytes > max Capacity-writerIndex)t
hrow new Index OutOfBounds Exception(String. format(
writerIndex(d)+ minWritable Bytes(%od)exceeds
maxCapacity (%d): %s
writerIndex, minWritableBytes, max Capacity. this)):
// Normalize the current capacity to the power of 2
int new Capacity = calculateNew Capacity writerIndex minWritable Bytes)
N Adjust to the new capacity
capacity(new Capacity)
return this
图15-32对写入的宇节数组长度进行校验
在前面我们分析 JDK Byte Buffer缺点的时候已经有过介绍, Byte Buffer的一个最大的
缺点就是一旦完成分配之后不能动态调整其容量。由于很多场景下我们无法预先判断需要
编码和解码的PωJO对象长度,因此只能根据经验数据给个估计值。如果这个值偏大,就
会导致内存的浪费;如果这个值偏小,遇到大消息编码的时候就会发生缓冲区溢出异常。
使用者需要自己捕获这个异常,并重新计算缓冲区的大小,将原来的内容复制到新的缓冲区
中,然后重置指针。这种处理策略对用户非常不友好,而且稍有不慎,就会引入新的问题。
Net!y的 Byte Buffer可以动态扩展,为了保证安全性,允许使用者指定最大的容量,
在容量范围内,可以先分配个较小的初始容量,后面不够用再动态扩展,这样可以达到功
能和性能的最优组合。
我们继续看 calculate New Capacity方法的实现。首先需要重新计算下扩展后的容量,
它有一个参数,等于 writerlndex+ min Writable Bytes,也就是满足要求的最小容量。如图
15-33所示
首先设置门限阈值为4MB,当需要的新容量正好等于门限阈值时,使用阈值作为新的
缓冲区容量。如果新申请的内存空间大于阈值,不能采用倍增的方式(防止内存膨胀和浪
费)扩张内存,而采用每次步进4MB的方式进行内存扩张。扩张的时候需要对扩张后的
314·第15章 Byte Buf和相关辅助类
内存和最大内存( max Capacity)进行比较,如果大于缓冲区的最大长度,则使用 max Capacity
作为扩容后的缓冲区容量
private int calculate New Capacity(int min NewCapacity)t
final int maxCapacity= this maxCapacity
final int threshold 1048576*4: //4 MiB page
if(min New Capacity = threshold)(
return threshold
// If over threshold, do not double but just increase by threshold
if (min New Capacity >threshold)t
int new Capacity min New Capacity /threshold*threshold
if(new Capacity max Capacity-threshold)(
newcapacity max Capacity
S else I
new Capacity += threshold
return new Capacity:
I/ Not over threshold. Double up to 4 MiB, starting from 64
int new Capacity = 64:
while(new Capacity minNew Capacity)t
new Capacity <<=1
return Math. min(new Capacity, max Capacity)
图15-33重新计算缓冲区的容量
如果扩容后的新容量小于阈值,则以64为计数进行倍增,直到倍增后的结果大于或
等于需要的容量值
采用倍增或者步进算法的原因如下:如果以 minNew Capacity作为目标容量,则本次
扩容后的可写字节数刚好够本次写入使用。写入完成后,它的可写字节数会变为0,下次
做写入操作的时候,需要再次动态扩张。这样就会形成第一次动态扩张后,每次写入操作
都会进行动态扩张,由于动态扩张需要进行内存复制,频繁的内存复制会导致性能下降。
采用先倍增后步进的原因如下:当内存比较小的情况下,倍增操作并不会带来太多的
内存浪费,例如64字节->128字节-->256字节,这样的内存扩张方式对于大多数应用系
统是可以接受的。但是,当内存增长到一定阈值后,再进行倍增就可能会带来额外的内存
浪费,例如10MB,采用倍增后变为20MB。但很有可能系统只需要12MB,则扩张到20MB
后会带来8MB的内存浪费。由于每个客户端连接都可能维护自己独立的接收和发送缓冲
区,这样随着客户读的线性增长,内存浪费也会成比例地增加,因此,达到某个阈值后就
需要以步进的方式对内存进行平滑的扩张。
315·Net!y权威指南(第2版)
这个阈值是个经验值,不同的应用场景,这个值可能不同,此处, ByteBuf取值为4MB。
重新计算完动态扩张后的目标容量后,需要重新创建个新的缓冲区,将原缓冲区的内
容复制到新创建的 Byte Buf中,最后设置读写索引和mark标签等。由于不同的子类会对
应不同的复制操作,所以该方法依然是个抽象方法,由子类负责实现。如图15-34所示。
public void initChannel( Socketchannel ch)
throws Exception I
Byte Buf delimiter Unpooled copied Buffer("S
getBytes
f ch pipeline( . addLast
l new DelimiterBased FrameDecoder(1024
l delimit
ch pipeline(). addLast(new String Decoder)
).pipeline(). addLast(new Echo ServerHandler()):
图15-34重新分配缓冲区的容量
4.操作索引
与索引相关的操作主要涉及设置读写索引、mark和rest等。如图15-35所示。
●△r⊥t啦b⊥ bYtes o:int
●△ markReaderIndex0: ByteBuf
●△ resetReaderInder0: BrteBuf
Oa sarkiriterInde O. BvieBuf
Qa resetwriterIndex: Byt eBut
a writerIndexo. int
A writerIndex Gint) ByteBuf
命 reader index0:int
ee reader Index (int).ByteFuf
图15-35索引操作相关API列表
由于这部分代码非常简单,我们就以设置读索引为例进行分析,相关代码如图15-36
所示
OVerride
public Byte Buf readerindex(int readerindex)i
if(readerIndex <0 l readerIndex >writerindex)(
throw new IndexOutOfBoundsException( String format
readerIndex: %d(expected: 0 < readerlndex <
writerIndex(%d))". readerIndex, writerIndex)].
this readerIndex readerindex
return this
图15-36重设读索引
在重新设置读索引之前需要对索引进行合法性判断,如果它小于0或者大于写索引,
316·第15章 Byte Buf和相关辅助类
则抛出 Index OutOfBounds Exception异常,设置失败。校验通过之后,将索引设置为新的
值,然后返回当前的 ByteBuf对象。
5.重用缓冲区
前面介绍功能的时候已经简单讲解了如何通过 discardReadBytes和 discardSomeRead Bytes
方法重用已经读取过的缓冲区,下面结合 discardReadBytes方法的实现进行分析,源码如
图15-37所示。
首先对读索引进行判断,如果为0则说明没有可重用的缓冲区,直接返回。如果读索
引大于0且读索引不等于写索引,说明缓冲区中既有已经读取过的被丢弃的缓冲区,也有
尚未读取的可读缓冲区。调用 setBytes(0,this, readerIndex, writerIndex- readerIndex)方法进
行字节数组复制。将尚未读取的字节数组复制到缓冲区的起始位置,然后重新设置读写索
引,读索引设置为0,写索引设置为之前的写索引减去读索引(重用的缓冲区长度)
@override
public ByteBuf discard Read Bytes(I
ensureAccessible
if (readerIndex ==0)
return this
if (readerIndex I= writerIndex)(
setBytes(O, this, readerIndex, writer Index-readerIndex):
writerlndex-= readerlndex.
adjustMarkers(readerIndex):
derlndex=0:
y else i
adjustMarkers (readerIndex)
writerlndex readerIndex =0
return this:
图15-37重用读取过的缓冲区
在设置读写索引的冋时,需要同时调整 marked ReaderIndex和 marked writerIndex,调
整mark的代码如图15-38所示。
首先对备份的 marked ReaderIndex和需要减少的 decrement进行判断,如果小于需要
减少的值,则将 marked Readerlndex设置为0。注意,无论是 marked ReaderIndex还是
marked writerIndex,它的取值都不能小于0。如果 marked writerIndex也小于需要减少的值,
则 marked writerIndex置为o,否则, marked Writerlndex减去 decrement之后的值就是新的
marked WriterIndex。
317Netty权威指南(第2版)
protected final void adjustMarkers(int decrement)t
int marked ReaderIndex= this marked Readerlndex
if (markedReaderIndex < decrement)
this marked Readerlndex 0:
int markedwriterlndex= this. marked writerindex.
if(markedWriterindex < decrement)i
this markedWriterIndex 0
else t
this. markedwriterindex markedwriterIndex-decrement
y else
this marked ReaderIndex marked ReaderIndex - decrement
markedwriterindex-= decrement
图15-38调整mark
如果需要减小的值小于 markedReaderlndex,则它也一定也小于 marked Writerlndex,
markedReaderlndex和 marked writerIndex的新值就是减去 decrement之后的取值。
如果 readerIndex等于 writerIndex,则说明没有可读的字节数组,那就不需要进行内存
复制,直接调整mark,将读写索引设置为0即可完成缓冲区的重用,代码如图15-39所示。
else
adjustMarkers(readerIndex)
writerIndex readerindex =0
图15-39没有可读的字节数组,不需要内存复制
6. skipBytes
在解码的时候,有时候需要丟弃非法的数据报,或者跳跃过不需要读取的字节或字节
数组,此时,使用 skipBytes方法就非常方便。它可以忽略指定长度的字节数组,读操作
时直接跳过这些数据读取后面的可读缓冲区,详细的代码实现如图15-40所示。
Override
public Byte Buf skip Bytes(int length)(
checkReadableBytes(length)
int new Readerindex readerIndex length
if(newReaderIndex >writerindex)(
throw new Index OutofBoundsException( String. format(
length: %d(expected: readerlndex( %d)+length <=
writerIndex ( %d))
length, readerIndex. writerIndex )
readerlndex= newReaderindex
图15-40跳过指定长度的缓冲区
·318第15章 Byte Bu和相关辅助类
首先判断跳过的长度是否大于当前缓冲区可读的字节数组长度,如果大于可读字节数
组长度,则抛出 IndexOutOfBounds Exception;如果参数本身为负数,则抛出 legalArgument
Exception异常
如果校验通过,则设置新的读索引为旧的索引值与跳跃的长度之和,然后对新的读索引
进行判断。如果大于写索引,则抛出 IndexOutofBoundsException异常:如果合法,则将读索
引设置为新的读索引。这样后续读操作的时候就会从新的读索引开始,跳过 length个字节。
152.3 AbstractReference Counted Byte Buf源码分析
从类的名字就可以看出该类主要是对引用进行计数,类似于JVM内存回收的对象引
用计数器,用于跟踪对象的分配和销毁,做自动内存回收。
下面通过源码来看它的具体实现。
1.成员变量
AbstractReference Counted Byte Buf成员变量列表如图15-41所
private static final
AtomicIntegerField<Abstract Reference Counted Byte But>
refCntUpdater=
AtomiclntegerFieldUpdater. newupdater(AbstractReference Counted Byte Buf cl
ass, "refCnt)
private static final long REFCNT FIELD OFFSET
static i
long refCntFieldOffset =-1
try i
if( PlatformDependent. hasUnsafe()i
refCnt Fieldoffset= Platform Dependent. objectFieldOfiset(
AbstractReference CountedByteBuf class getDeclared FieldcrefCnt ))
1 catch(Throwable t)(
∥ Ignored
REFCNT FIELD OFFSET refCntField offset
@SuppressWarnings("Field MayBe Final)
private volatile int refCnt=1
图15-41 AbstractReference Counted ByteBuf成员变量列表
319Nety权威指南(第2版)
首先看第一个字段 refCntUpdater,它是 AtomiclntegerFieldUpdater类型变量,通过原
子的方式对成员变量进行更新等操作,以实现线程安全,消除锁。第二个字段是 REFCNT
FIELD OFFSET,它用于标识 refcnt字段在 AbstractReference Counted Byte Buf中的内存地
址。该内存地址的获取是JDK实现强相关的,如果使用SUN的JDK,它通过 sun. misc. Unsafe
的 objectFieldoffset接口来获得, ByteBuf的实现子类 UnpooledUnsafe DirectByte Buf和
PooledUnsafe Direct Buf会使用到这个偏移量。
最后定义了一个 volatile修饰的 refcnt字段用于跟踪对象的引用次数,使用 volatile
是为了解决多线程并发访问的可见性问题,此处不对 volatile的用法展开说明,后续多线
程章节会有详细介绍。
2.对象引用计数器
每调用一次 retain方法,引用计数器就会加一,由于可能存在多线程并发调用的场景,所
以它的累加操作必须是线程安全的,下面我们一起看下它的具体实现细节,如图15-42所示。
@Override
public Byte Buf retain((
for
int refCnt this refCnt.
if (refCnt ==0)
throw new Illegal Reference CountException(, 1)
if (refCnt = Integer MAX VALUE)
throw new IllegalReferenceCountException(Integer. MAX VALUE, 1):
if (refCntUpdater compareAndSet(this, refCnt, refCnt 1))i
break.
return this
图15-42调用 retain函数,引用计数器加
通过自旋对引用计数器进行加一操作,由于引用计数器的初始值为1,如果申请和释
放操作能够保证正确使用,则它的最小值为1。当被释放和被申请的次数相等时,就调用
回收方法回收当前的 ByteBuf对象。如果为0,说明对象被意外、错误地引用,抛出
IllegalReference CountException。如果引用计数器达到整型数的最大值,抛出引用越界的异
常Ⅲ legalReference Count Exception。最后通过 compare AndSet进行原子更新,它会使用自
已获取的值跟期望值进行对比。如果其间已经被其他线程修改了,则比对失败,进行自旋,
重新获取引用计数器的值再次比对;如果比对成功则对其加一。注意: compareAndSet是
320·第15章 Byte Buf和相关辅助类
由操作系统层面提供的原子操作,这类原子操作被称为CAS,感兴趣的读者可以看下Java
CAS的原理
下面看下释放引用计数器的代码,如图15-43所示。
与 retain方法类似,它也是在一个自旋循环里面进行判断和更新的。需要注意的是:
当 refCnt==1时意味着申请和释放相等,说明对象引用已经不可达,该对象需要被释放和
垃圾回收掉,则通过调用 deallocate方法来释放 Byte Buf对象。
@override
public final boolean release(t
for (;)I
int refCnt= this refCnt
if (refCnt ==0)0
throw new IllegalReference CountException(, -1)
if(o
Updater compareAndSet(this, refCnt, refCnt -1))[
if (refCnt ==1)[
deallocate(
return false
图15-43调用释放函数,引用计数器减
1524 Unpooled Heap Byte Buf源码分析
Unpooled Heap Byte Buf是基于堆内存进行内存分配的字节缓冲区,它没有基于对象池
技术实现,这就意味着每次MO的读写都会创建一个新的 UnpooledHeap Byte Buf,频繁进
行大块内存的分配和回收对性能会造成一定影响,但是相比于堆外内存的申请和释放,它
的成本还是会低一些
相比于 PooledHeap Byte Buf, UnpooledHeap Byte Buf的实现原理更加简单,也不容易出
现内存管理方面的问题,因此在满足性能的情况下,推荐使用 UnpooledHeap Byte Buf。
下面我们就一起来看下 Unpooled Heap Byte Buf的代码实现。
1.成员变量
首先看下 Unpooled Heap Byte Buf的成员变量定义,如图15-44所示。
321Nety权威指南(第2版)
public class UnpooledHeapByte Buf extend
AbstractReference Counted Byte Buf i
private final Byte BufAllocator alloc
private bytel array.
private ByteBuffer tmpNioBuf
图15-44 UnpooledHeap Buf成员变量定义
首先,它聚合了一个 Byte BufAllocator,用于 Unpooled Heap Byte Buf的内存分配,紧
接着定义了一个byte数组作为缓冲区,最后定义了一个 Byte Buffer类型的 tmpNio Buf变
量用于实现 Netty ByteBuf到 JDK NIO Byte Buffer的转换。
事实上,如果使用JDK的 Byte Buffer替换byte数组也是可行的,直接使用byte数组
的根本原因就是提升性能和更加便捷地进行位操作。JDK的 Byte Buffer底层实现也是byte
数组,代码如图15-45所示。
public abstract class Byte Buffer
extends Buffer
implements Comparable<ByteBuffer>
I/ These fields are declared here rather than in Heap-X-Buffer in order to
d reduce the number of virtual method invocations needed to access these
// values, which is especially costly when coding small buffers
final bytel hb
l Non-null only for heap buffers
final int offset
boolean isReadOnly
f valid only for heap butters
图15-45 JDK Byte Buffer内部实现源码
2.动态扩展缓冲区
在前一章介绍 Abstract Byte Buf的时候,我们讲到 ByteBuf在最大容量范围内能够实现
自动扩张,下面我们一起看下缓冲区的自动扩展在 Unpooled Heap Byte Buf中的实现,如图
15-46所示。
方法入口首先对新容量进行合法性校验,如果大于容量上限或者小于0,则抛出
IllegalArgumentException异常。
判断新的容量值是否大于当前的缓冲区容量,如果大于则需要进行动态扩展,通过
byte] newArray= new byte[ newCapacity]创建新的缓冲区字节数组,然后通过
System. arraycopy进行内存复制,将旧的字节数组复制到新创建的字节数组中,最后调用
setArray替换旧的字节数组。如图15-47所示。
322第15章 Byte Buf和相关辅助类
需要指出的是,当动态扩容完成后,需要将原来的视图 tmpNio Buf设置为空。
@Override
public Byte Buf capacity(int new Capacity)(
ensureAccessible(:
if (new Capacity s0 l newCapacity max o)[
throw new IllegalArgumentException("new Capacity: " new Capacity)
int old capacity =array length
f(new Capacity >oldCapacity )t
bytel newArray new byte new Capacityl
System. arraycopy(array, 0, newArray, 0, array length)
setArray(newArray)
J else if (new Capacity oldCapacity)i
bytel newArray new byte[newCapacityl:
int readerIndex= readerIndex0:
if (readerIndex new Capacity)
writerIndex =writerIndex(:
if ( writer Index >newCapacity)(
writerIndex( writerIndex new capacity)
System. arraycopy(array, readerIndex, newArray, readerIndex
writerIndex-readerIndex)
y else
setlndex(new Capacity, new Capacity)
setArray(newArray)
return this:
图15-46缓冲区的动态扩展
private void setArray(byte[l initialArray)i
array= initialArray
tmpNioBuf null
图15-47宇节数组替换
如果新的容量小于当前的缓冲区容量,不需要动态扩展,但是需要截取当前缓冲区创
建一个新的子缓冲区,具体的算法如下:首先判断下读索引是否小于新的容量值,如果小
于进一步判断写索引是否大于新的容量值,如果大于则将写索引设置为新的容量值(防止
越界)。更新完写索引之后通过内存复制 System. arraycopy将当前可读的字节数组复制到新
创建的子缓冲区中,代码如下。
system. arraycopy (array, readerIndex, newArray, readerIndex, writerIndex
readerindex)i
如果新的容量值小于读索引,说明没有可读的字节数组需要复制到新创建的缓冲区
323·Net!y杈威指南(第2版)
中,将读写索引设置为新的容量值即可。最后调用 setArray方法替换原来的字节数组。
3.字节数组复制
在前一章节里我们介绍 setBytes(int index, byte[] src, int reiNdex, int length)方法的时
候说它有子类实现,下面我们看看 UnpooledHeap Byte Buf如何进行字节数组的复制。如图
15-48所示。
@override
public Byte Buf setBytes(int index, bytel srC, int srcIndex, int length)(
check Srclndex(index, length, srclndex, src length)
System. arraycopy(srC, srclndex, array, index, length)
return this:
图15-48字节数组复制
首先仍然是合法性校验,我们看下校验代码。如图15-49所示。
protected final void check Srclndex(int index, int length, int srclndex, int
srcCapacity)
checkIndex(index, length )
if (srclndex <0 srclndex srcCapacity-length)t
throw new IndexOutOfBoundsException(String. format(
srclndex: %od, length: % od (expected: range(o, %od)", srclndex
length, srcCapacity)).
图15-49字节数组复制前的校验
校验 index和 length的值,如果它们小于0,则抛出 IllegalArgumentException,然后
对两者之和进行判断:如果大于缓冲区的容量,则抛出 IndexOutOfBounds Exception。
reiNdex和 srcCapacity的校验与 index类似,不再赘述。校验通过之后,调用
System. arraycopy (src, reiNdex,aray, index, length)方法进行字节数组的复制
需要指出的是, Byte Buf以set和get开头读写缓冲区的方法并不会修改读写索引。
4.转换成 JDK Byte Buffer
熟悉 JDK NIO Byte Buffer的读者可能会想到转换非常简单,因为 Byte Buf基于byte
数组实现,NO的 ByteBuffer提供了wrap方法,可以将byte数组转换成 ByteBuffer对象,
JDK的相关源码实现如图15-50所示。
大家的猜想是对的,下面我们一起看下 UnpooledHeap Byte Buf的实现,如图15-51所示。
324第15章 Byte Buf和相关辅助类
我们发现,唯一不同的是它还调用了 Byte Buffer的 slice方法, slice的功能前面已经
介绍过了,此处不再展开说明。由于每次调用 nio Buffer都会创建一个新的 ByteBuffer,因
此此处的 slice方法起不到重用缓冲区内容的效果,只能保证读写索引的独立性。
public static ByteBuffer wrap(bytel array.
int offset, int length)
return new HeapByte Buffer(array, offset, length)
catch(IllegalArgumentException x)(
throw new IndexOutofBoundsException (
图15-50 JDk Byte Buffer的warp方法源码
@
public Byte Buffer nio Bufter(int index, int length)t
ensureAccessible()
return ByteBuffer, wrap(array, index, length).slice
图15-51 UnpooledHeap ByteBuf的warp源码
5.子类实现相关的方法
Byte Buf中的一些接口是跟具体子类实现相关的,不同的子类功能是不同的,本小节
我们将列出这些不同点。
◎ is Direct方法:如果是基于堆内存实现的 ByteBuf,它返回 false,相关的代码实现
如图15-52所示。
◎ harRay方法:由于 UnpooledHeap ByteBuf基于字节数组实现,所以它的返回值
是
true。
o array方法:由于 Unpooled Heap ByteBuf基于字节数组实现,所以它的返回值是内
部的字节数组成员变量。如图15-53所示。
@Override
@
Override
public byte[ array I
public boolean is Directo)(
ensureAccessible ()
return false
return array
图15-52 Unpooled Heap Byte Buf的 isDirect方法图15-53 Unpooled Heap Byte Buf的aray方法
读者在调用 array方法之前,可以先通过 harRay进行判断。如果返回 false说明当前
325·Nety权威指南(第2版)
的 Byte Buf不支持aray方法。
◎其他本地相关的方法有: arrayOffset、 has Memory Address和 memory Address,这
些方法的实现如图15-54所示。
内存地址相关的接口主要由 Unsafe Byte Buf使用,它基于 SUN JDK的 sun, misc. Unsafe
方法实现,本书的重点并不是介绍 sun. misc. Unsafe的,如果读者对sun.misc. Unsafe的实
现感兴趣,可以阅读 OPEN JDK的相关源码实现,也可以通过其他的DOC文档进行深入
学习。
@override
public int array offset()(
return 0
OVerride
public boolean hasMemoryAddress()
return false
@override
public long memory Address(I
throw new UnsupportedOperation Exception:
图15-54 UnpooledHeap Byte Buf的 address相关方法
由于 Unpooled Direct Buf与 UnpooledHeapByteBuf的实现原理相同,不同之处就
是它内部缓冲区由 java nIo, DirectByte Buffer实现。当掌握了 UnpooledHeap Byte Buf之后,
阅读 Unpooled Direct Byte Buf I的代码会非常容易,所以本书不再对 Unpooled DirectByteBuf
进行源码解读。
152.5 Pooled Byte Buf内存池原理分析
由于 Byte Buf内存池的实现涉及到的类和数据结构非常多,限于篇幅,本章节不对其
源码进行展开说明,而是从设计原理角度来讲解内存池的实现
1. PoolArena
Arena本身是指一块区域,在内存管理中, Memory Arena是指内存中的一大块连续的
区域, Poolarena就是 Netty.内存池实现类。
326·第15章 Byte Buf和相关辅助类
为了集中管理内存的分配和释放,同时提高分配和释放内存时候的性能,很多框架和
应用都会通过预先申请一大块内存,然后通过提供相应的分配和释放接口来使用内存。这
样一来,对内存的管理就被集中到几个类或者函数中,由于不再频繁使用系统调用来申请
和释放内存,应用或者系统的性能也会大大提高。在这种设计思路下,预先申请的那一大
块内存就被称为 Memory Arena
不同的框架, Memory Arena的实现不同,Net的 Poolarena是由多个 Chunk组成的
大块内存区域,而每个 Chunk则由一个或者多个Page组成,因此,对内存的组织和管理
也就主要集中在如何管理和组织 Chunk和Page了。 PoolArena中的内存 Chunk定义如图
15-55所示。
abstract class PoolArena<T>(
final PooledByte BufAllocator parent
private final int page Size
private final int max Order
private final int page Shifts
private final int chunk:
private final int subpageOverflowMask
private final PoolSubpage<T>I tiny Subpage Pools
private final PoolSubpage<T>I smallSubpagePools
private final Poolchunklist<T> q050
private final PoolChunkList<T> 9025:
private final PoolChunkList<T> q000
private final Pool chunkList<T> qInit
private final PoolChunkList<T> q075
private final PoolChunkList<T>q100:
图15-55 Netty的 Memory Arena实现
2. PoolChunk
Chunk主要用来组织和管理多个Page的内存分配和释放,在 Netty中, Chunk中的
Page被构建成一棵二叉树。假设一个 Chunk由16个Page组成,那么这些Page将会被按
照图15-56所示的形式组织起来。
Page的大小是4个字节, Chunk的大小是64个字节(4x16)。整棵树有5层,第1层
(也就是叶子节点所在的层)用来分配所有Page的内存,第4层用来分配2个Page的内
存,依此类推。
每个节点都记录了自己在整个 Memory Arena中的偏移地址,当一个节点代表的内存区域
327Ney权威指南(第2版)
被分配出去之后,这个节点就会被标记为已分配,自这个节点以下的所有节点在后面的内存
分配请求中都会被忽略。举例来说,当我们请求一个16字节的存储区域时,上面这个树中的
第3层中的4个节点中的一个就会被标记为已分配,这就表示整个 Memroy Arena中有16个
字节被分配出去了,新的分配请求只能从剩下的3个节点及其子树中寻找合适的节点。
64
32
32
16
16
16
4444日4
444444
图15-56 Chunk的数据结构
对树的遍历采用深度优先的算法,但是在选择哪个子节点继续遍历时则是随机的,并
不像通常的深度优先算法中那样总是访问左边的子节点。
3. PoolSubpage
对于小于一个Page的内存,Nety在page中完成分配。每个Page会被切分成大小相
等的多个存储块,存储块的大小由第一次申请的内存块大小决定。假如一个Page是8个
字节,如果第一次申请的块大小是4个字节,那么这个Page就包含2个存储块:如果第
一次申请的是8个字节,那么这个Page就被分成1个存储块。
一个Page只能用于分配与第一次申请时大小相同的内存,比如,一个4字节的Page,
如果第一次分配了1字节的内存,那么后面这个Page只能继续分配1字节的内存,如果
有一个申请2字节内存的请求,就需要在一个新的Page中进行分配。
Page中存储区域的使用状态通过一个long数组来维护,数组中每个long的每一位表
b328·第15章 Byte Buf和相关辅助类
示一个块存储区域的占用情况:0表示未占用,1表示以占用。对于一个4字节的Page来
说,如果这个Page用来分配1个字节的存储区域,那么long数组中就只有一个long类型
的元素,这个数值的低4位用来指示各个存储区域的占用情况。对于一个128字节的Page
来说,如果这个Page也是用来分配l个字节的存储区域,那么long数组中就会包含2个
元素,总共128位,每一位代表一个区域的占用情况。
相关的代码实现如图15-57所示
final class PoolSubpage<T>4
final Poolchunk<T> chunk
final int memoryMapldx;
final int runoffset
final int page Size:
final longl bitmap
PoolSubpage<T> prev
PoolSubpage<T> next
boolean doNotDestroy
int elem Size.
nt maxNumEl
int nextAvail:
nt bitmapLength
nt unaVail:
图15-57 PoolSubpage的变量定义
4.内存回收策略
无论是 Chunk还是Page,都通过状态位来标识内存是否可用,不同之处是 Chunk通
过在二叉树上对节点进行标识实现,Page是通过维护块的使用状态标识来实现
对于使用者来说,不需要关心内存池的实现细节,也不需要与这些类库打交道,只需
要按照API说明正常使用即可。
152.6 PooledDirectByte Buf源码分析
PooledDirect Byte Buf基于内存池实现,与 UnPooled DirectByte Buf的唯一不同就是缓
冲区的分配是销毁策略不同,其他功能都是等同的,也就是说,两者唯一的不同就是内存
分配策略不同
329·Nety权威指南(第2版)
1.创建字节缓冲区实例
由于采用内存池实现,所以新创建 PooledDirect Buf对象时不能直接new一个实
例,而是从内存池中获取,然后设置引用计数器的值,代码如图15-58所示。
static Pooled DirectByte Buf newInstance(int max Capacity)(
PooledDirectByte Buf buf RECYCLER geto
buf. setRefCnt(1):
buf. max Capacity(max Capacity)
return buf,
图1558 Pooled DirectByteBuf的创建
直接从内存池 Recyclers< PooledDirectByte Buf>中获取 PooledDirect Byte Buf对象,然后
设置它的引用计数器为1,设置缓冲区最大容量后返回。
2.复制新的字节缓冲区实例
如果使用者确实需要复制一个新的实例,与原来的 Pooled Direct Byte Buf独立,则调用
它的copy( int index, int length)可以达到上述目标,代码如图15-59所示。
@override
public ByteBuf copy(int index, int length)(
checkIndex(index, length)
ByteBuf copy= alloc().directBuffer(length, maxcapacityo)
copy. write Bytes( this, index, length):
return copy,
图15-59 Pooled Direct Byte Buf的copy方法
首先对索引和长度进行合法性校验,通过之后调用 Pooled ByteBufAllocator分配一个
新的 Byte Buf,由于 Pooled Byte BufAllocator没有实现 direct Buffer方法,所以最终会调用
到 AbstractByte BufAllocator的 directBuffer方法,相关代码如图15-60所示。
@override
public ByteBuf directBufter(int initialcapacity, int max Capacity)t
if (initialCapacity ==0 & maxCapacity == 0)(
return empty Buf
validate(initialcapacity, max Capacity);
return newDirectBufter(initialCapacity, max capacity)
图15-60 Abstract ByteBufAllocator的缓冲区分配
new Direct Buffer方法对于不同的子类有不同的实现策略,如果是基于内存池的分配
330·第15章 Byte Buf和相关辅助类
器,它会从内存池中获取可用的 Byte Buf,如果是非池,则直接创建新的 Byte Buf,相关
代码实现如图15-61、15-62所示。
@
Override
protected ByteBuf new DirectBuffer(int initialCapacity, int maxCapacity)I
PoolThreadcache cache= thread cache. get(
PoolArena< Byte Buffer> directArena cache directArena
Byte Buf buf
if (directArena I= null)(
buf directArena allocate(cache, initialCapacity, max Capacity)
>else i
if(PlatformDependent. hasUnsafe O)(
buf new UnpooledUnsafe DirectByte Buf(this, initialCapacity
maxCapacity):
else
buf =new Unpooled Buf(this, initialCapacity, max Capacity);
return toLeak Buffer(buf)
图15-61基于内存池的缓冲区分配
@Override
protected Byte Buf new Direct Buffer( int initialCapacity int maxCapacity)I
ByteBuf buf;
if(PlatformDependent. hasUnsafe()I
buf new UnpooledUnsafeDirectByteBuf( this, initialCapacity
max Capacity)
) else
buf new UnpooledDirectByteBuf(this, initial Capacity, max Capacity)
return toLeakAware Buffer(buf)
图15-62非内存池实现直接创建新的缓冲区
通过上述代码对比我们可以看出,基于内存池的实现直接从缓存中获取 Byte Buf而不
是创建一个新的对象。
3.子类实现相关的方法
正如 UnpooledHeap Byte Buf,, PooledDirectByte Buf也有子类实现相关的功能,这些方
法如图15-63所示。
从上述代码可以看出,当我们操作子类实现相关的方法时,需要对是否支持这些操作
进行判断,否则会导致异常
·331·Netty权威指南(第2版)
@o
verlag
public boolean hasArrayo(
return talse
@overrid
public byte[ array((
throw new UnsupportedOperationException(direct buffer")
@override
public int array Offset()
throw new UnsupportedOperationException("direct buffer)
OVerride
public boolean hasMemoryAddressot
turn false
@override
public long memory Address(t
throw new UnsupportedOperationExceptiono
图15-63 Pooled Direct Byte Buf实现相关的方法
15.3 Byte Buf相关的辅助类功能介绍
学习完了核心的 Byte Buf之后,下面一起继续学习它的一些常用辅助功能类
15.3.1 Byte BufHolder
ByteBufHolder是ByteBuf的容器,在Nety中,它非常有用。例如HTTP协议的请求
消息和应答消息都可以携带消息体,这个消息体在 NIO ByteBuffer中就是个 Byte Buffer对
象,在Nety中就是 Byte Buf对象。由于不同的协议消息体可以包含不同的协议字段和功
能,因此,需要对 ByteBuf进行包装和抽象,不同的子类可以有不同的实现。
为了满足这些定制化的需求,Netl抽象出了 Byte BufHolder对象,它包含了一个
Byte Buf,另外还提供了一些其他实用的方法,使用者继承 Byte BufHolder接口后可以按需
封装自己的实现。相关类库的继承关系如图15-64所示。
332·第15章 Byte Buf和相关辅助类
Type hierarchy of io, netty buffer. ByteButHolder
a BytelutHol der- io netty buffer
G DatagramPacket-1o netty channel socket
a e Default ByteBufHolder-1o netty buffer
C Setpllessage-i, netty channel setp
FUa博eag
10.ne气ty, chann1.udt
日G^ebsocketFr幽+1取etty.handercodechttp2W+brocket
cbinaryfebsOcketframe-ionettyhandlercodechttpwebsocketx
oClosewebsocketpRame-ienettyhandlercodechttpvebsocketx
CContinmationwebsoeketirame-ionettyhandlercodehttpwabsoeket:
cPingfebsocketframe-iO,nettyhandlercodechttp.websocketx
CpoNgebsocketframe-ioneTtyhandlercodechttpwebsocketx
cTextwebsockEtframe-Ionettyhandlercodeshttpwabsockets
tUhtTpcontent-iO.nettyhandlercodechttp
-dHttpdata-ienettyhandlereedeehttpmultipart
eCabstracthttPdata-1o.nettyhandlercodeehttpmultipart
=aAbstractdiskhttpdata-ionettyhandlercodechttpmultipart
9DiskattribuTe-ionettyhandlercodechttpmultipart
CdiSkfileuploaD-ionettyhandlercodechttpmultipart
aCAbstractmemorylttpdata-Ionettyhandlercedechttpmultipart
CmeMoryattribute-ionettyhandlercodechttpmultipart
eM幽 h oryFilel19ad-1. etty. handl.ede.htp,a山 tapert
DAttribute-i9,nettyhandlercodehttpmultipart
oDiskkttribute-1onettyhandlercodechttpmultipart
CMemoryattribute-1o.Nettvhandlercodechttpmultipart
GMizedattribute-io.nettyhandlercodechttpmultipart
afiLeupload-1o,nettyhandercodechttpaultapart
cDiskfileuploAd-ionettyhandlercodechttpmultipart
目 morfi1 uPload
ttyhandlercodechttpmulapart
GmiZedfileupload-iOnettyhandlercodechttpmultipart
O Memcache -. netty hand er codec memcache
o SpdyDataFreme- io netty handler codec spdy
图15-64 Byte BufHolder继承关系图
15.3.2 Byte BufAllocator
ByteBufAllocator是字节缓冲区分配器,按照Nety的缓冲区实现不同,共有两种不同
的分配器:基于内存池的字节缓冲区分配器和普通的字节缓冲区分配器。接口的继承关系
如图15-65所示。
Type hierarchy of'io netty buffer. ByteBufAllocator'.
B RI ByteBufAllocator -ionetty buffer
CA AbstractByteBufAllocator-1o, netty buffer
C PooledByteBufAllocator-io netty buffer
CF UnpooledByteBufAllocator-io netty buffer
图15-65 Byte BufAllocator继承关系图
333·Nety权威指南(第2版
下面我们给出 ByteBufAllocator的主要AP功能列表(表15-3)。
表15-3 Byte BufAllocator主要AP功能列表
方法名称
返回值说明
功能说明
分配一个字节缓冲区,缓冲区的类型由 Byte BufAllocator
buffer
ByteBuf
的实现类决定
分配一个初始容量为 initialCapacity的字节缓冲区,缓冲
buffer(int initialCapacity
Byte Buf
区的类型由 Byte BufAllocator的实现类决定
分配一个初始容量为 initialCapacity,最大容量为
buffer(int initial Capacity, int
Byte
max Capacity的字节缓冲区,缓沖区的类型由
maxCapacity
ByteBufAllocator的实现类决定
分配一个初始容量为 initialCapacity,最大容量为
io Buffer int initialCapacity, int
ByteBuf
max Capacity的 direct buffer,因为 direct buffer的O操作性
max Capacity)
能更高
heap Buffer(int in\ city, Byte
分配一个初始容量为
initialCapacity
最大容量为
int max Capacity
max Capacity B] heap buffer
direct Bufterfint initia cApacity.
分配一个初始容量为 initialCapacity,最大容量为
ByteBuf
int max Capacity
max Capacity H direct buffer
composite Buffer(int
分配一个最大容量为 max Capacity的 Composite ByteBuf,
Composite ByteBuf
maxNumComponents
内存类型由 ByteBufAllocator的实现类决定
is Buffer Pooled
b
Olean
是否使用了直接内存内存池
15.3. 3 Composite Byte Buf
Composite Byte Buf允许将多个 ByteBuf的实例组装到一起,形成一个统一的视图,有
点类似于数据库将多个表的字段组装到一起统一用视图展示。
Composite Byte Buf在一些场景下非常有用,例如某个协议POJO对象包含两部分:消
息头和消息体,它们都是 Byte Buf对象。当需要对消息进行编码的时候需要进行整合,如
果使用JDK的默认能力,有以下两种方式。
(1)将某个 Byte Buffer复制到另一个 Byte Buffer中,或者创建一个新的 ByteBuffer
将两者复制到新建的 Byte Buffer中;
(2)通过List或数组等容器,将消息头和消息体放到容器中进行统一维护和处理。
·334·第15章 Byte But和相关辅助类
上面的做法非常别扭,实际上我们遇到的问题跟数据库中视图解决的问题一致——缓
冲区有多个,但是需要统一展示和处理,必须有存放它们的统一容器。为了解决这个问题,
Netty提供了 Composite Byte Buf
我们一起简单看下它的实现,如图15-66所示。
public class Composite Byte Buf extends
AbstractReference CountedByteBuf t
private final ResourceLeak leak:
private final Byte BufAllocator alloc
private final boolean direct
private final List< Component> components new Array List<Component>(;
private final int maxNumcomponents
private static final Byte Buffer FULL BYTEBUFFER=(Byte Buffer)
ByteBuffer allocate(1).position(1):
private boolean freed
图15-66 Composite Byte Buf源码
它定义了一个 Component类型的集合,实际上 Component就是 Byte Buf I的包装实现类,
它聚合了 Byte Buf对象,维护了在集合中的位置偏移量信息等,它的实现如图15-67所示
private final class Component I
final Byte Buf buf
final int length
int offset
int endorse
Component(ByteBuf buf)(
this buf buf.
length buf, readable Bytes(;
void freelfNecessaryot
Unwrap so that we can free slices, too
buf release (: / We should not get a NPE here. If so, it must be a bug
图15-67 Component源码
向 Composite Byte Buf中新增一个 ByteBuf的代码,如图15-68所示。
public Composite Byte Buf addcomponent(ByteBuf buffer)[
add Component(components. size(), buffer)
consolidatelfNeeded(
return this
图15-68 Composite Byte Buf中新增 ByteBuf源码
335Netty权威指南(第2版)
删除增加的 ByteBuf源码,如图15-69所示。
public Composite Byte Buf remove Component(int cIndex)[
checkcomponentIndex(cIndex )
components. remove(cIndex). freelfNecessary(
update Componentoffsets(cIndex
return this
图15-69 Composite Byte Buf中删除 ByteBuf源码
注意:删除 Byte Buf之后,需要更新各个 Component的索引偏移量。
15.3.4 Byte BufUtil
ByteBufUtil是一个非常有用的工具类,它提供了一系列静态方法用于操作 ByteBuf
对象。它的功能列表如图15-70所示。
一由o. natty. buffer
c'ByteBufUtil
tPF HEXDUMP_TABLE: char[
e hex lump (ByteBuf): String
hexDump ByteBuf, int, int): String
o hexDump (byte[]): String
s hex Dump (byte[l, int, int):String
● ashdod (ByteBuf):int
es equalsOyteBuf, Byt eBuf): boolean
e compare ( ByteBuf, ByteBuf). int
s indexOf (Byt eBuf, int, int, byte):int
swapShort(short). short
e swapMedium (int): int
swapInt (int)
●5 swapLongQ
e readBytes ( ByteBufAllocator, ByteBuf, int): ByteBuf
a' firstIndexOf ByteBuf, iat, int, byte):int
lastIndexOf Byt eBuf
e encodeString yteBufAllocator, CharBuffer, Charset]: ByteBuf
deesdastriag ByteBuffar, Charset): string
a ByteBufUtil O
图15-70 ByteBufUtil工具类
其中最有用的方法就是对宇符串的编码和解码,具体如下
(1) encode String( Byte BufAllocator alloc, Char Buffer src, Charset charset):对需要编码
的字符串src按照指定的字符集 charset进行编码,利用指定的 Byte BufAllocator生成一个
新的 ByteBuf
336·第15章 Byte Buf和相关辅助类
(2) decode string( Byte Buffer src, Charset charset):使用指定的 Byte Buffer和 charset
进行对 Byte Buffer进行解码,获取解码后的字符串
还有一个非常有用的方法就是 hex dump,它能够将参数 Byte Buf的内容以十六进制
宇符串的方式打印出来,用于输出日志或者打印码流,方便问题定位,提升系统的可维
护性
hex Dump包含了一系列的方法,参数不同,输出的结果也不同,如图15-71所示。
日 C'ByteBututi1
tPF HEXDUMP TABLE: char[]
s hex Dump ByteBuf): String
s hexDump OByteBuf, int, int). String
●5 hexDump Byte[]):s
e hexDump (byte[]. int, int): String
hashcode Byt bUf): int
图15-71 hex Dump方法
154总结
本章节重点介绍了 ByteBuf的API功能和其源码实现,同时介绍了与 Byte Buf密切相
关的工具类和辅助类。 ByteBuf是Nety架构中最重要、最基础的数据结构,熟练地掌握
和使用它是学好Nett的基本要求,也是成长为高级Nety开发人员的必经之路
由于 Byte Buf的功能复杂性,它的子类实现非常庞大,在本书中进行穷举是不现实的
读者学习完本章之后,对Net! Byte Buf的设计理念和重要类库的实现原理都有了比较深
入的了解。以此为基础,再去学习其他相关联的类库会容易很多。
下个章节,我们继续学习 Netty的另两个重要类库: Channel和 Unsafe
337·第16章
Channe和 Unsafe
提起 Channel,读者朋友们可能并不陌生—JDK的NIO类库的一个重要组成部分,
就是 JavanIo. Socketchannel和 java nio ServerSocket Channel,它们用于非阻塞的IO操作
类似于NO的 Channel,Ney提供了自己的 Channel和其子类实现,用于异步I/O操
作和其他相关的操作。
Unsafe是个内部接口,聚合在 Channe中协助进行网络读写相关的操作,因为它的设
计初衷就是 Channel的内部辅助类,不应该被 Netty框架的上层使用者调用,所以被命名
为 Unsafe。这里不能仅从字面理解认为它是不安全的操作,而要从整个架构的设计层面体
会它的设计初衷和职责。
本章主要内容包括:
◎ Channel功能说明
◎ Unsafe功能说明
Channel的主要实现子类源码分析
◎ Unsafe的主要实现子类源码分析
161 Channe功能说明
io netty channel. Channel是 Netty网络操作抽象类,它聚合了一组功能,包括但不限于第16章 Channe和 Unsafe
网路的读、写,客户端发起连接,主动关闭连接,链路关闭,获取通信双方的网络地址等
它也包含了Nety框架相关的一些功能,包括获取该 Chanel的 Event Loop,获取缓冲分配
器 Byte BufAllocator和 pipeline等。
下面我们先从 Channel的接口分析,讲解它的主要API和功能,然后再一起看下它的
子类的相关功能实现,最后再对重要子类和接口进行源码分析。
16.1.1 Channel的工作原理
Channel是Nety抽象出来的网络IO读写相关的接口,为什么不使用 JDK NIO原生
的 Channel而要另起炉灶呢,主要原因如下
(1)JDK的 Socketchanne和 ServerSocketchannel没有统一的 Channel接口供业务开
发者使用,对于用户而言,没有统一的操作视图,使用起来并不方便。
(2)JDK的 Socketchannel和 Server Socketchannel的主要职责就是网络IO操作,由
于它们是SPⅠ类接口,由具体的虚拟机厂家来提供,所以通过继承SPⅠ功能类来扩展其功
能的难度很大;直接实现 ServerSocketchannel和 Socketchannel抽象类,其工作量和重新
开发一个新的 Channe功能类是差不多的。
(3)Net'y的 Channel需要能够跟Nety的整体架构融合在一起,例如IO模型、基于
Channelpipeline的定制模型,以及基于元薮据描述配置化的TCP参数等,这些JDK的
Socketchannel和 Server Socketchanne都没有提供,需要重新封装
(4)自定义的 Channel,功能实现更加灵活
基于上述4个原因,Nety重新设计了 Channel接口,并且给予了很多不同的实现。
它的设计原理比较简单,但是功能却比较繁杂,主要的设计理念如下。
(1)在( hannel接口层,采用 Facade模式进行统一封装,将网络LO操作、网络IO
相关联的其他操作封装起来,统一对外提供。
(2) Channel接口的定义尽量大而全,为 SocketChannel和 ServerSocketchannel提供
统一的视图,由不同子类实现不同的功能,公共功能在抽象父类中实现,最大程度地实现
功能和接口的重用。
(3)具体实现采用聚合而非包含的方式,将相关的功能类聚合在 Channel中,由 Channel
统一负责分配和调度,功能实现更加灵活
339Net!权威指南(第2版)
16.1.2 Channel的功能介绍
Channel的功能比较繁杂,我们通过分类的方式对它的主要功能进行介绍。
1.网络MO操作
Channel网络IO相关的方法定义如图16-1所示。
曰电 Channel
e renotaAddress O! SocketAddress
e盘d0:a1
a contigo: ChanneL
isopen: boolean
Registered
da也0)Ch出ne]e气daa
localAddress0. SoeketAddress
renoteAddress0: Socketddrer
closeFuture O: ChannelFnture
eis置 ritable O:b1ean
● connect ISocketAddre玉s): Channe1图ute
e connact ( SocketAddrers, SocketAddrags) Channelfuture
a disconnect o: CharnelFuture
close: ChannelFuture
o bind(SocketAddress, ChannelPronise): CharnelPuture
●6hne!C小心k真r,Chnn也1Pxm温): Channe1Fe
e connect (ocketAddress, SocketAddress, ChannelPronise): ChamelFuture
o d i sconnect ChannelPromi se) ChannelPuturg
●c1as〔 Channeler雾e): Channe1Pute
g write object): ChaemelFature
e rite(Object, ChannelPronise).ChannelFuture
组urh0 ChaTTE1
●Hmu0bm1pmm
图16-1 Channel的IO操作API列表
下面我们对这些API的功能进行分类说明,读写相关的API列表。
(1) Channel reado:从当前的 Channel中读取数据到第一个 inbound缓冲区中,如果
数据被成功读取,触发 ChannelHandler. channelRead( ChannelHandler Context, Object)事件。
读取操作APⅠ调用完成之后,紧接着会触发 ChannelHandler. channelRead Complete( Channel
HandlerContext)事件,这样业务的 Channelhandler可以决定是否需要继续读取数据。如果
己经有读操作请求被挂起,则后续的读操作会被忽略。
(2) Channelfuture write( Object msg):请求将当前的msg通过 ChannelPipeline写入到
目标 Channel中。注意, write操作只是将消息存入到消息发送环形数组中,并没有真正被
发送,只有调用 flush操作才会被写入到 Channel中,发送给对方
(3)ChannelFuture write(Object msg, ChannelPromise promise): IhRE E write(Object msg)
340第16章 Channe和 Unsafe
相同,但是携带了 Channel Promise参数负责设置写入操作的结果。
(4)ChannelFuture write And Flush(Object msg, ChannelPromise promise): hi(3)
功能类似,不同之处在于它会将消息写入 Channel中发送,等价于单独调用 write和 flush
操作的组合
(5) Channel Future write Flush(Object msg):功能等同于方法(4),但是没有携带
write And Flush( Object msg)参数。
(6) Channel flush(:将之前写入到发送环形数组中的消息全部写入到目标 Chane中,
发送给通信对方。
(7) Channelfuture close( ChannelPromise promise):主动关闭当前连接,通过 Channel
Promise设置操作结果并进行结果通知,无论操作是否成功,都可以通过 Channelpromise
获取操作结果。该操作会级联触发 ChannelPipeline中所有 Channelhandler的
Channelhandler: close( ChannelHandlerContext, ChannelPromise)事件。
8) ChannelFuture disconnect( Channelpromise promise):请求断开与远程通信对端的
连接并使用 Channelpromise来获取操作结果的通知消息。该方法会级联触发 Channel
Handler. disconnect( ChannelhandlerContext, ChannelPromise)事件。
(9) Channel Future connect( SocketAddress remote Address):客户端使用指定的服务端地址
remoteAddress发起连接请求,如果连接因为应答超时而失败, Channelfuture中的操作结果就
是 ConnectTimeout Exception异常;如果连接被拒绝,操作结果为 ConnectException。该方法
会级联触发 Channelhandler connect( ChannelHandlerContext, SocketAddress, SocketAddress,
Channelpromise)事件。
(10)Channel Future connect(SocketAddress remoteAddress, SocketAddress localAddress)
与方法(9)功能类似,唯一不同的就是先绑定指定的本地地址 localaddress,然后再连接
服务端。
(11) ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise):
与方法(9)功能类似,唯一不同的是携带了 Channel Promise参数用于写入操作结果。
(12) connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise
promise):与方法(11)功能类似,唯一不同的就是绑定了本地地址。
(13) Channel Future bind( SocketAddress localAddress):绑定指定的本地 Socket地址
localAddress,该方法会级联触发 Channelhandler.bind( Channelhandlercontext, Socketaddress,
ChannelPromise)事件。
341·Ney权威指南(第2版
(14) ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise): h
法(13)功能类似,多携带了了一个 ChannelPromise用于写入操作结果
(15) Channel Config config(:获取当前 Channel的配置信息,例如 CONNECT
TIMEOUT MILLIS。
(16) boolean isOpen:判断当前 Channel是否已经打开。
(17) boolean isReg isteredo:判断当前 Channel是否已经注册到 EventLoop上。
(18) boolean is(;判断当前 Channel是否已经处于激活状态。
(19) Channelmetadata metadata(:获取当前( hannel的元数据描述信息,包括TCP
参数配置等。
(20) SocketAddress localAddresso:获取当前 Channel的本地绑定地址。
(21) SocketAddress remoteAddress(:获取当前 Channel通信的远程 Socket地址。
2.其他常用的API功能说明
第一个比较重要的方法是 eventLoop(。 Channel需要注册到 EventLoop的多路复用器
上,用于处理IO事件,通过 eventLoop(方法可以获取到 Channel注册的 EventLoop。
Eventloφp本质上就是处理网络读写事件的 Reactor线程。在Net!中,它不仅仅用来处理
网络事件,也可以用来执行定时任务和用户自定义 NioTask等任务。
第二个比较常用的方法是 metadata(方法。熟悉TCP协议的读者可能知道,当创建
Socket的时候需要指定TCP参数,例如接收和发送的TCP缓冲区大小、TCP的超时时间、
是否重用地址等。在Nely中,每个 Channel对应一个物理连接,每个连接都有自己的TCP
参数配置。所以, Channel会聚合一个 Channelmetadata用来对TCP参数提供元数据描述
信息,通过 metadata)方法就可以获取当前 Channel的TCP参数配置
第三个方法是 parento。对于服务端 Channel而言,它的父 Channel为空;对于客户端
Channel,它的父 Channel就是创建它的 Server Socketchannel
第四个方法是用户获取 Channel标识的id,它返回 Channell对象, Channell是
Channel的唯一标识,它的可能生成策略如下
(1)机器的MAC地址(EUI-48或者EUI-64)等可以代表全局唯一的信息;
(2)当前的进程ID;
·342·第16章 Channel和 Unsafe
(3)当前系统时间的毫秒— System currentTime Millis(
(4)当前系统时间纳秒数—— System nano Time(;
(5)32位的随机整型数;
(6)32位自增的序列数。
16.2 Channe源码分析
Channe的实现子类非常多,继承关系复杂,从学习的角度我们抽取最重要的两个
Channel-ionetty channel socket nio. NioServerSocketChannel H io netty channel socket nio
NioSocketchannel进行重点分析。如果读者对其他的 Channel实现细节感兴趣,可以按照
本书的指导自行阅读。
16.2.1 Channe的主要继承关系类图
为了便于学习和阅读源码,我们分别看下 NioSocketchannel和 NioServer socketchannel
的继承关系类图。
服务端 NioServer Socketchannel的继承关系类图如图16-2所示。
[
)Channel
CA AbstractChannel
江 ServerChaHnel
CA AbstractNioChannel
T ServerSockerChannel
gA AbstracrNioMessageChannel
A AbstractNioMessageServerChannel
NioServerSockerChannel
图16-2 NioServer SocketChannel继承关系类图
·343·Ney权威指南(第2版)
客户端 NioSocketChannel的继承关系类图如图16-3所示。
江
Channel
I Sockerchannel
CA AbstractChannel
CA AbstraciNioChannel
CA AbstractNio Byte channel
吧 NioSocketchannel
图16-3 NioSocketchannel继承关系类图
162.2 Abstractchannel源码分析
1.成员变量定义
在分析 Abstractchannel源码之前,我们先看下它的成员变量定义,如图16-4所示。
首先定义了两个静态全局异常,如下。
◎ CLOSED CHANNEL EXCEPTION:链路已经关闭已经异常;
◎ NOT YET CONNECTED EXCEPTION:物理链路尚未建立异常。
声明完上述两个异常之后,通过静态块将它们的堆栈设置为空的 Stack Trace Element。
estimatorhandle用于预测下一个报文的大小,它基于之前数据的采样进行分析预测。
根据之前的 Channel原理分析,我们知道 Abstractchannel采用聚合的方式封装各种功
能,从成员变量的定义可以看出,它聚合了以下内容。
◎ parent:代表父类 Channel
id:采用默认方式生成的全局唯一ID
344·第16章 Channe|和 Unsafe
◎ unsafe: Unsafe实例;
o pipeline:当前 Channel对应的 Default ChannelPipeline;
eventLoop:当前 Channel注册的 Eventloop;
private static final InternalLogger logger
InternalLoggerFactory getInstance(AbstractChanneL. class);
static final Closed ChannelException CLOSED CHANNEL EXCEPTION
new ClosedchannelException(
static final NotYetConnected Exception
NOT YET CONNECTED EXCEPTION =new Not Yet Connected Exception(
static
CLOSED CHANNEL EXCEPTION. setStackTrace(Empty Arrays. EMPTY STA
CK TRACE)
NOT_YET CONNECTED_ EXCEPTION. setstackTrace(EmptyArrays EMPTY
STACK TRACE)
private Message SizeEstimator Handle estimatorHandle
private final Channel parent
private final Channelld id- Defaultchannelld newInstanceo
private final Unsafe unsafe
rivate final Default ChannelPipeline pipeline
private final ChannelFuture succeeded Future= new
SucceededchannelFuture (this, null):
private final Void Channel Promise voidPromise= new
Void ChannelPromise(this, true);
private final Void ChannelPromise unsafe VoidPromise=new
Void ChannelPromise( this, false);
private final Close Future close Future=new Close Future(this):
private volatile socketAddress localAddress
private volatile SocketAddress remoteAddress:
private final EventLoop eventLoop
private volatile boolean registered
/ Cache for the string representation of this channel/
ivate boolean strValActive
private String strval
图16-4 AbstractChannel成员变量定义
在此不一一枚举。通过变量定义可以看出, Abstractchannel聚合了所有 Channel使用
到的能力对象,由 abstractchanne提供初始化和统一封装,如果功能和子类强相关,则定
义成抽象方法由子类具体实现,下面的小节就对它的主要API进行源码分析。
345Ne权威指南(第2版)
2.核心AP源码分析
首先看下网络读写操作,前面介绍网络O操作时讲到,它会触发 ChannelPipeline中
对应的事件方法。Nety基于事件驱动,我们也可以理解为当 Chnanel进行I/O操作时会产
生对应的IO事件,然后驱动事件在 ChannelPipeline中传播,由对应的 Channelhandler
对事件进行拦截和处理,不关心的事件可以直接忽略。采用事件驱动的方式可以非常轻松
地通过事件定义来划分事件拦截切面,方便业务的定制和功能扩展,相比AOP,其性能更
高,但是功能却基本等价。
网络IO操作直接调用 DefaultChannelPipeline的相关方法,由 Default ChannelPipeline
中对应的 ChannelHandler进行具体的逻辑处理,如图16-5所示。
@override
so. ublic Channel Future connect(SocketAddress remoteAddress,
cketAddress localAddress)(
return pipeline connect(remote Address, localAddress)
@Override
public ChannelFuture disconnect(
return pipeline. disconnect(:
@Override
public ChannelFuture close(t
return pipeline. close(;
@override
public Channel fushi
pipeline, fiush(
return this
图16-5 Abstractchannel网络Ⅰ/O操作源码实现
abstractchannel也提供了一些公共API的具体实现,例如 localAddressO和
remoteAddresso方法,它的源码实现如图16-6所示。
@overide
public SocketAddress remoteAddress()(
SocketAddress remote Address this remoteAddress
if (remote Address = nu)(
try i
this remoteAddress- remoteAddress= unsafe()- remoteAddresso
1 catch(Throwable t)t
J! Sometimes fails on a closed socket in windows
return nu‖l
return remoteAddress
图16-6 Abstract channel remote address方法实现
346·第16章 Channe和 Unsafe
首先从缓存的成员变量中获取,如果第一次调用为空,需要通过 unsafe的
remote Address获取,它是个抽象方法,具体由对应的 Channel子类实现。
16.2.3 AbstractNio Channe|源码分析
1.成员变量定义
首先,还是从成员变量定义入手,来了解下它的功能实现,成员变量定义如图16-7
所示
private static final InternalLogger logger s
InternalLoggerFactory. getInstance(AbstractNioChannel class)
private final
protected final int readInterestOp
private volatile SelectionKey selectionKey:
private volatile boolean input shutdown;
The future of the current connection attempt. If not null, subsequent
connection attempts will fail
private Channel Promise connectPromise:
private ScheduledFuture<?>connect TimeoutFuture
private SocketAddress requestedRemoteAddress
图16-7 Abstract NioChannel成员变量定义
由于 NiO Channel、 NioSocketchannel和 NioSeryer socketchannel需要共用,所以定义
了一个 Java. nto. SocketChannel和 Java. nIc. Server SocketChannel的公共父类 Selectable Channel,
用于设置 Selectablechannel参数和进行IO操作。
第二个参数是 readInterestOp,它代表了 JDK SelectionKey的 OP READ。
随后定义了一个 volatile修饰的 SelectionKey,该 SelectionKey是 Channel注册到
Eventlocφp后返回的选择键。由于 Channel会面临多个业务线程的并发写操作,当
SelectionKey由 SelectionKey修改之后,为了能让其他业务线程感知到变化,所以需要使
用 volatile保证修改的可见性,后面的多线程章节会专门对 volatile的使用进行说明。
最后定义了代表连接操作结果的 Channelpromise以及连接超时定时器
Scheduled Future和请求的通信地址信息。
·347Net!y权威指南(第2版)
2.核心AP|源码分析
我们一起看下在 AbstractNiochannel实现的主要API,首先是 Channel的注册,如图
16-8所示。
@Override
protected void doRegister() throws Exception I
boolean selected= false
for(:;){
try i
selectionKey javaChannel(), register(eventLoop( selector, 0, this);
return
y catch(CancelledKey Exception e)i
if (Selected)(
Force the Selector to select now as the canceled"SelectionKey
may still be
l cached and not removed because no select select( )operation
was called yet
eventLoop(. selectNow0:
selected true
/ We forced a select operation on the selector before but the
SelectionKey is still cached
// for whatever reason. JDK bug
throw e.
图16-8 Abstract NioChannel的注册方法实现
定义一个布尔类型的局部变量 selected来标识注册操作是否成功,调用 Selectable
Channel的 register方法,将当前的 Channel注册到 EventLoop多路复用器上, Selectable
Channel的注册方法定义如图16-9所示。
public abstract Selection Key register(Selector sel, int ops, Object att)
throws Closedchannel Exception
图16-9 JDK SelectableChannel的注册方法定义
注册 Channel的时候需要指定监听的网络操作位来表示 Channe对哪几类网络事件感
兴趣,具体的定义如下
◎ public static final int OP READ=1<<0:读操作位;
◎ public static final int OP WRITE=1<<2:写操作位;
◎ public static final int OP CONNECT=1<<3:客户端连接服务端操作位;
348·第16章 Channe和 Unsafe
◎ public static final int OP ACCEPT=1≤<4:服务端接收客户端连接操作位
AbstractNiochanne注册的是0,说明对任何事件都不感兴趣,仅仅完成注册操作。注
册的时候可以指定附件,后续 Channel接收到网络事件通知时可以从 SelectionKey中重新
获取之前的附件进行处理,此处将 AbstractNioChannel的实现子类自身当作附件注册。如
果注册 Channel成功,则返回 selectionKey,通过 selectionKey可以从多路复用器中获取
Channel对象。
如果当前注册返回的 selectionKey已经被取消,则抛出 CancelledKey Exception异常,
捕获该异常进行处理。如果是第一次处理该异常,调用多路复用器的 selectNow(方法将已
经取消的 selection Key从多路复用器中删除掉。操作成功之后,将 selected置为true,说
明之前失效的 selectionKey已经被删除掉。继续发起下一次注册操作,如果成功则退出,
如果仍然发生 CancelledKey Exception异常,说明我们无法删除已经被取消的 selectionκey,
按照JDK的API说明,这种意外不应该发生。如果发生这种问题,则说明可能NIO的相
关类库存在不可恢复的BUG,直接抛出 CancelledKeyException异常到上层进行统一处理。
下面继续看另一个比较重要的方法:准备处理读操作之前需要设置网路操作位为读
代码如图16-10所示。
@Override
protected void doBeginRead(throws Exception t
if (inputShutdown)t
return
final SelectionKey selectionkey=this selectionKey:
if (IselectionKey isValid()(
return
final int interestOrs= selectionKey interestOpso
if ((interestors readInterestop)==0)
selectionKey, interestOps(interestops readInterestOp);
图16-10修改网络操作位为读
先判断下 Channel是否关闭,如果处于关闭中,则直接返回。获取当前的 SelectionKey
进行判断,如果可用,说明 Channel当前状态正常,则可以进行正常的操作位修改。将
SelectionKey当前的操作位与读操作位进行按位与操作,如果等于0,说明目前并没有设
置读操作位,通过 interestOps readInterestOp设置读操作位,最后调用 selectionKey的
interestOrs方法重新设置通道的网络操作位,这样就可以监听网络的读事件了
349Netty权威指南(第2版
实际上,对于读操作位的判断和修改与 JDK NIO SelectionKey的相关方法实现是等价
的,如图16-11所示
public final boolean is Readable((
return(ready ops(& OP READ)I= 0;
图16-11判断当前 SelectionKey是否可读
1624 AbstractNio Byte Channel源码分析
由于成员变量只有一个 Runnable类型的 flushTask来负责继续写半包消息,所以对成
员变量不再单独进行介绍
最主要的方法就是 do write( Channeloutbound Buffer in),下面一起看看它的实现,由
于该方法过长,所以我们按照其逻辑进行拆分介绍。如图16-12所示。
@override
protected void doWrite(Channeloutbound Buffer in) throws Exception f
int write SpinCount =-1
Object msg= in current(true);
if (msg ==null)t
∥ Wrote all messages
clearopWriteo
break
图16-12 dowrite( Channeloutbound Buffer in)源码片段1
从发送消息环形数组 Channeloutbound Buffer弹出一条消息,判断该消息是否为空,
如果为空,说明消息发送数组中所有待发送的消息都已经发送完成,清除半包标识,然后
退出循环。清除半包标识的 clearOp Write方法实现如图l6-13所示。
protected final void clearOpWriteO[
final SelectionKey key= selectionKey(
final int interestors= key interestOrs()
if((interestops SelectionKey OP WRITE)I=0)
d ey. interestops(interestops &-Selectio n Key OP__ WRITE)
key
图16-13清除写半包标识
从当前 Selection Key中获取网络操作位,然后与 SelectionKey. OP WRITE做按位与,
如果不等于0,说明当前的 Selection Key是 is Writable的,需要清除写操作位。清除方法
很简单,就是 SelectionKey OP WRITE取非之后与原操作位做按位与操作,清除
·350·第16章 Channe|和 Unsafe
SelectionKey的写操作位
继续看源码,如果需要发送的消息不为空,则继续处理。如图16-14所示。
if(msg instanceof Byte Buf)I
Byte Bufbuf -(ByteBur)msg
int readableBytes buf readableBytes(
if(readable Bytes ==0)
in remove(:
continue:
OpWrite false
boolean done s false
long flushedAmount =0
if (write Spin Count ==-1)
write Spin Count config( getwrite Spin Count()
图16-14 do write( Channeloutbound Buffer in)源码片段2
首先判断需要发送的消息是否是 Byte Buf类型,如果是,则进行强制类型转换,将其
转换成 Byte Buf类型,判断当前消息的可读字节数是否为0,如果为0,说明该消息不可
读,需要丢弃。从环形发送数组中删除该消息,继续循环处理其他的消息。
声明消息发送相关的成员变量,包括:写半包标识、消息是否全部发送标识、发送的
总消息字节数。
这些局部变量创建完成之后,对循环发送次数进行判断,如果为-1,则从 Channel配
置对象中获取循环发送次数。循环发送次数是指当一次发送没有完成时(写半包),继续
循环发送的次数。设置写半包最大循环次数的原因是当循环发送的时候,IO线程会一直
尝试进行写操作,此时IO线程无法处理其他的IO操作,例如读新的消息或者执行定时
任务和 NioTask等,如果网络ⅠO阻塞或者对方接收消息太慢,可能会导致线程假死
继续看循环发送的代码如图16-15所示。
for (int i= write SpinCount-1; i>=0; i-)
int localFlushedAmount doWrite Bytes(buf)
if (localFlushedAmount ==0)(
OpWrite= true:
break.
flushedAmount + loca fLushed Amount
if(Buf is Readable)I
done true
break
图16-15 do write( Channeloutbound Buffer in)源码片段3
351·Netty权威指南(第2版)
调用 do write Bytes进行消息发送,不同的 Channel子类有不同的实现,因此它是抽
象方法。如果本次发送的字节数为0,说明发送TCP缓冲区已满,发生了
ZERO WINDOW。此时再次发送仍然可能出现写0字节,空循环会占用CPU的资源,
导致IO线程无法处理其他ⅣO操作,所以将写半包标识 setOp Write设置为true,退出
循环,释放IO线程。
如果发送的字节数大于0,则对发送总数进行计数。判断当前消息是否已经发送成功
缓冲区没有可读字节),如果发送成功则设置done为true,退出当前循环。
消息发送操作完成之后调用 Channeloutbound Buffer更新发送进度信息,然后对发送
结果进行判断。如果发送成功,则将已经发送的消息从发送数组中删除;否则调用
incomplete Write方法,设置写半包标识,启动刷新线程继续发送之前没有发送完全的半包
消息(写半包)。如图16-16所示
in progress(flushedAmount
if (done)I
in, remove (:
y else
incompleteWrite(setOpWrite)
break
图16-16 do write( ChannelOutbound Buffer in)源码片段4
处理半包发送任务的方法 incomplete Write的实现如图16-17所示。
protected final void incompleteWrite(boolean setOpWrite)(
∥ Did not write completel
if (setOpWrite)(
setOpWriteO
F else
l Schedule flush again later so other tasks can be picked up in the
meantime
Runnable flush Task this. flush Task:
if (flush Task = null)t
flush Task this flushTask new Runnable (f
@overrid
public void runo(
flush(;
eventLoopO) execute(flush Task
图16-17启动写半包任务线程用于后续继续发送半包消息
352·第16章 Channel和 Unsafe
首先判断是否需要设置写半包标识,如果需要则调用 setOp Write设置写半包标识,代
码如图16-18所示。
protected final void setOp Write((
final SelectionKey key selectionKeyO)
final int interestors key interestops(:
if ((interestOps SelectionKey OP WRITE)==0)4
key. interestOps(interestops SelectionKey OP WRITE);
图16-18设置写半包标识
设置写半包标识就是将 SelectionKey设置成可写的,通过原操作位与
SelectionKey OP WRITE做按位或操作即可实现
如果 SelectionKey的 OP WRITE被设置,多路复用器会不断轮询对应的 Channel,用
于处理没有发送完成的半包消息,直到清除 SelectionKey的 OP WRITE操作位。因此
设置了 OP WRITE操作位后,就不需要启动独立的 Runnable来负责发送半包消息了。
如果没有设置OP_ WRITE操作位,需要启动独立的 Runnable,将其加入到 EventLoop
中执行,由 Runnable负责半包消息的发送。它的实现很简单,就是调用fush(方法来发
送缓冲数组中的消息。
消息发送的另一个分支是文件传输,由于它的实现原理与 ByteBuf类似,限于篇幅,
在此不再详细说明,感兴趣的读者可以自己独立完成分析
16.25 AbstractNioMessage Channel源码分析
由于 AbstractNioMessage Channel没有自己的成员变量,所以我们直接对其方法进行
说明。
它的主要实现方法只有一个: do write( ChannelOutbound Buffer in),下面首先看下它的
源码,如图16-19所示
在循环体内对消息进行发送,从 Channeloutbound Buffer中弹出一条消息进行处理,
如果消息为空,说明发送缓冲区为空,所有消息都已经被发送完成。清除写半包标识,退
出循环。
与 AbstractNioByte Channel的循环发送类似,利用 write Spin Count对单条消息进行发
送,调用 do writeMessage(Object msg, Channeloutbound Buffer in)判断消息是否发送成功,
353·第16章 Channe和 Unsafe
型的 childgroup,用于给新接入的客户端 NioSocketChannel分配 EventLoop,它的源码实
现如图16-20所示。
public abstract class AbstractNioMessage Server channel extends
AbstractNioMessage Channel implements ServerChannel I
private final EventLoop Group child Group
protected AbstractNioMessage Serverchannel(
Channel parent, EventLoop eventLoop, EventLoop Group childGroup
Selectable Channel ch, int readInterestop)i
super(parent, eventLoop, ch, readInterestOp)
this child Group= child
@override
public EventLoop Group childEventLoop Group((
return child Group
图16-20 AbstractNioMessageServer Channel源码
每当服务端接入一个新的客户端连接 NioSocketchannel时,都会调用 childEventLoop group
方法获取 EventLoop Group线程组,用于给 NioSocketchannel分配 Reactor线程 EventLoop,
相关分配代码如图16-21所示。
@Override
protected int doReadMessages(List<object> buf) throws Exception I
SocketChannel ch java Channel().accept():
f(ch I= null)I
buf. add(new NioSocketchannel(this
child EventLoop Group(). nexto, ch));
return 1
图16-21通过 childEventLoop Group方法进行IO线程分配
16.2.7 NioServer Socketchanne源码分析
NioServerSocketchannel的实现比较简单,下面我们重点分析主要API的实现,首先
看它的成员变量定义和静态方法,如图16-22所示。
355Net!y权威指南(第2版
private static final ChannelMetadata METADATA= new
ChannelMetadata(false)
private static final Internallogger logger
InternalLoggerFactory. getinstance(Nio Server Socket Channel. class):
private static Server Socket Channel newSocketo)(
return Server Socket Channel open(:
y catch(IOException e)(
throw new ChannelException(
Failed to open a server socket. e)
private final ServerSocketchannel Config config
图16-22 NioServer SocketChannel成员变量定义
首先创建了静态的 Channel Metadata成员变量,然后定义了 Server Socket ChannelConfig
用于配置 ServerSocketchannel的TCP参数。静态的 new Socket方法用于通过
ServerSocketchannel的open打开新的 Server Socketchannel通道。
接着我们再看下 ServerSocketchannel相关的接口实现: inActive、 remote address、
javaChannel和 goBind,它们的源码如图16-23所示。
@override
public boolean isActiveO[
return javachannelo. socket). isBoundo
@override
public Inet SocketAddress remote Addressor
return null.
@override
protected Server SocketChannel java Channel()(
return( Server SocketChannel) super, java Channel(;
@override
protected SocketAddress localAddressoo(
return java channel(). socket). getLocalSocketAddresso:
override
protected void do Bind( SocketAddress localAddress) throws Exception
javaChannel(). socket). bind (localAddress, config. getBacklogo
图16-23 NioServer Socketchannel本地实现相关方法
·356·第16章 Channe和 Unsafe
通过 java. net Server Socket的 is Bound方法判断服务端监听端口是否处于绑定状态,它
的 remoteAddress为空。 java Channel的实现是 Java nIo. ServerSocketChannel,服务端在进
行端口绑定的时候,可以指定 backlog,也就是允许客户端排队的最大长度。相关API说
明如图16-24所示。
e waid java. net. ServerSeeket bind (seeketAddress endpoint, int backlog) throws IOlxeeptian
Binds the Server socket to a specifie address ar address and port number
IEth垂 ddress is nu1, then th野st魎 will Piekφ an ephemeral port and a valid 1。 cel address to bind the
The backlog argument is the requested maximum number of pending connections on the socket. Its exact
semantics are implementation specific. In particular, an implementati on may impose a maximum length or may
choose to ignore the paraneter altogther. The value provi ded should be greater than 0. If it is less than o
equl to 0, then an implenentati on speci fic default will be used
endpoint The IP address a port number to bind to
backlog requested maximum length of the queue of incoming connections.
Throws
IOException - if the bind operati on fails, or if the socket is aready bound
SecurityException- if a SecurityManager is present and its checkLiaten method doesn t allow the
operatlon
IllegalArgumentException -if endpoint is s SocketAddress subclass not supp orted by this socket
图16-24 Server Socket的绑定方法
下面继续看服务端 Channel的 doreadMessages(List< Object> buf,的实现,如图16-25
所
@override
protected int doReadMessages(List<object> buf)throws Exception I
SocketChannel ch=javaChannel(). accept(
tr
if (ch I=null)t
buf. add(new Nio SocketChannel(this, child EventLoop Group(). next(),
ch))
return 1
1 catch(Throwable t)
logger. warn("Failed to create a new channel from an accepted socket
ch closed
3 catch(Throwable t2)
logger.warn("Failed to close a socket. ",t2)
return o.
图16-25 NioServerSocketChannel doReadMessages方法
首先通过 ServerSocketchannel的 accept接收新的客户端连接,如果 Socketchannel不
为空,则利用当前的 NioServer Socketchannel、 EventLoop和 Socketchannel创建新的
357·Nety权威指南(第2版)
NioSocketchannel,并将其加入到 List<object>buf中,最后返回1,表示服务端消息读取成功。
对于 NioServer Socketchannel,它的读取操作就是接收客户端的连接,创建
NioSocketChannel对象。
最后看下与服务端 Channel无关的接口定义,由于这些方法是客户端 Channel相关的,
因此,对于服务端 Channel无须实现。如果这些方法被误调,则返回 UnsupportedOperation
Exception异常,这些方法的源码如图16-26所示。
@override
protected boolean doConnect(
SocketAddress remote Address, SocketAddress localAddress) throws
Exception
throw new UnsupportedOperationException(
@override
protected void doFinish Connect() throws Exception I
throw new Unsupportedoperation Exception(:
@Override
protected SocketAddress remote((
return null:
@override
protected void doDisconnecto throws Exception t
throw new UnsupportedOperation Exception
@override
protected boolean doWriteMessage(object msg, ChannelOutbound Buffer in
throws Exception i
throw new UnsupportedoperationException(:
图16-26 NioServer Socket channel不支持的方法列表
16.2.8 NioSocketChanne|源码分析
1.连接操作
我们重点分析与客户端连接相关的API实现,首先看连接方法的实现,如图16-27所示。
判断本地 Socket地址是否为空,如果不为空则调用 java nio channels. Socketchannel
socket(). bindo方法绑定本地地址。如果绑定成功,则继续调用java,nio. channels.
SocketChannel. connect(SocketAddress remote)发起TCP连接。对连接结果进行判断,连接
结果有以下三种可能。
358·第16章 Channe|和Unsa
(1)连接成功,返回true;
2)暂时没有连接上,服务端没有返回ACK应答,连接结果不确定,返回 false;
3)连接失败,直接抛出1O异常。
override
protected boolean do connect( SocketAddress remoteAddress
SocketAddress localAddress)throws Exception I
if (localAddress I= null)(
avaChannel().socket(). bind(localAddress)
boolean success false:
boolean connected java Channel(). connect(remoteAddress)
if(Connected)[
selectionKey ( interestOps(SelectionKey OP CONNECT)
success= true
return connected
3 finally t
if (success)i
doclose(
图16-27 NioSocketchannel的连接方法
如果是结果(2),需要将 NioSocketchannel中的 selectionKey设置为 OP CONNECT,
监听连接网络操作位。如果抛岀了ⅠO异常,说明客户端的TCP握手请求直接被REST或
者被拒绝,此时需要关闭客户端连接,代码如图16-28所示。
@override
protected void doClose() throws Exception
javaChannel(). close()
图16-28连接失败,关闭客户端
2.写半包
分析完连接操作之后,继续分析写操作,由于它的实现比较复杂,所以仍然需要将其
拆分后分段进行分析,代码如图16-29所示。
获取待发送的 ByteBuf个数,如果小于等于1,则调用父类 AbstractNio Byte Channel
的 do write方法,操作完成之后退出
·359Nety权威指南(第2版)
在批量发送缓冲区的消息之前,先对一系列的局部变量进行赋值,首先,获取需要发
送的 Byte Buffer数组个数 nio Bufferin,然后,从 Channeloutbound Buffer中获取需要发送
的总宇节数,从 NioSocketChannel中获取NO的 SocketChannel,将是否发送完成标识设
置为 false,将是否有写半包标识设置为 false.如图16-30所示。
@override
protected void doWrite(ChannelOutboundBuffer in)throws Exception t
l Do non - gathering write for a single buffer case.
final int msg Count= in sized
if (msg Count <=1)
super. doWrite(in)
return
/I Ensure the pending writes are made of Byte Bufs only
Byte Buffer nio Buffers = in. nioBuffers(:
if(nioBuffers
super. doWrite(in
return
图16-29 NioSocketchannel的写方法片段1
int nioBufferCnt= in nio Buffer Counto
long expectedWritten Bytes in nio Buffer Size;
final Socket channel ch= javachannel(:
long written Bytes =0:
boolean done false:
boolean setOp Write =false;
图16-30 NioSocketchannel的写方法片段2
继续分析循环发送的代码,代码如图16-31所示。
for(int i=config.getWriteSpinCounto-1: 1>=0: i-I
final long localWritten Bytes = ch write(nio Buffers, 0, nioBufferCnt;
图16-31 NioSocketchannel的写方法片段3
就像循环读一样,我们需要对一次 Selector轮询的写操作次数进行上限控制,因为如
果TCP的发送缓冲区满,TCP处于KEEP- ALIVE状态,消息会无法发送出去,如果不对
上限进行控制,就会长时间地处于发送状态, Reactor线程无法及时读取其他消息和执行
排队的Task。所以,我们必须对循环次数上限做控制
调用 NIO Socketchannel的 write方法,它有三个参数:第一个是需要发送的 Byte Buffer
360·第16章 Channe和 Unsafe
数组,第二个是数组的偏移量,第三个参数是发送的 Byte Buffer个数。返回值是写入
Socketchannel的字节个数。
下面对写入的字节进行判断,如果为0,说明TCP发送缓冲区已满,很有可能无法再
写进去,因此从循环中跳出,同时将写半包标识设置为true,用于向多路复用器注册写操
作位,告诉多路复用器有没发完的半包消息,需要轮询出就绪的 Socketchannel继续发送。
代码如图16-32所示。
if (localwritten Bytes==0)[
setOpWrite true
break:
图16-32 NioSocketChannel的写方法片段4
发送操作完成后进行两个计算:需要发送的字节数要减去已经发送的字节数;发送的
字节总数+已经发送的字节数。更新完这两个变量后,判断缓冲区中所有的消息是否已经
发送完成。如果是,则把发送完成标识设置为true同时退出循环;如果没有发送完成,则
继续循环。从循环发送中退出之后,首先对发送完成标识done进行判断,如果发送完成,
则循环释放己经发送的消息。环形数组的发送缓冲区释放完成后,取消半包标识,告诉多
路复用器消息已经全部发送完成。代码如图16-33所示。
if (done)I
d Release all buffers
for (int i
Count; i>0; i--)i
remov
e()
// Finish the write loop if no new messages were flushed by
in remove
if (in isEmpty o)t
clearOpWrite(
图16-33 NioSocketchannel的写方法片段5
当缓冲区中的消息没有发送完成,甚至某个 Byte Buffer只发送了几个字节,出现了所谓
的“写半包”时,该怎么办?下面我们继续看看 Netty是如何处理“写半包”的,如图16-34
所示。
361·Nety权威指南(第2版)
for(int i= msgCount: i>0; i-I
final Byte Buf buf =(Byte Buf) in current()
final int readerIndex =buf. readerIndex(:
final int readable Bytes =buf. writerIndex(-readerIndex
if (readable Bytes written Bytes)I
in progress(readable Bytes)
in remove
written Bytes -= readable Bytes
y else if (readable Bytes written Bytes)(
buf. readerIndexreaderIndex +(int)written Bytes);
in progress(written Bytes)
break.
else [l readable Bytes =s written Bytes
in progress(readable Bytes)
In rem。ve0)
break
图16-34 NioSocketchannel的写方法片段6
首先,循环遍历发送缓冲区,对消息的发送结果进行判断,下面具体展开进行说明。
(1)从 Channeloutbound Buffer弹出第一条发送的 Byte Buf,然后获取该 Byte Buf的读
索引和可读字节数
(2)对可读字节数和发送的总字节数进行比较,如果发送的字节数大于可读的字节数,
说明当前的 ByteBuf已经被完全发送出去,更新 Channeloutbound Buffer的发送进度信息,
将已经发送的 Byte Buf删除,释放相关资源。最后,发送的字节数要减去第一条发送的字
节数,得到后续消息发送的总字节数,然后继续循环判断第二条消息、第三条消息
(3)如果可读的消息大于已经发送的总字节数,说明这条消息没有被完整地发送出去,
仅仅发送了部分数据报,也就是出现了所谓的“写半包”问题。此时,需要更新可读的索
引为当前索引+已经发送的总字节数,然后更新 ChanneloutboundBuffer的发送进度信
息,退出循环。
(4)如果可读字节数等于已经发送的总字节数,则说明最后一次发送的消息是个整包
消息,没有剩余的半包消息待发送。更新发送进度信息,将最后一条已发送的消息从缓冲
区中删除,最后退出循环。
循环发送操作完成之后,更新 Socketchannel的操作位为 OP WRITE,由多路复用器
在下一次轮询中触发 Socket channel,继续处理没有发送完成的半包消息。
3.读写操作
NioSocketchannel的读写操作实际上是基于NlO的 Socketchannel和Net!y的 ByteBuf
362·第16章 Channe和 Unsafe
封装而成,下面我们首先分析从 Socketchannel中读取数据报,如图16-35所示
for(int i=msg Count; i>0: i-)[
final Byte Buf buf=(Byte Buf) in current()
final int readerIndex= buf. readerIndex()
final int readable Bytes= buf. writerIndexo-readerIndex
@override
protected int doReadBytes(ByteBufbyteBuf) throws Exception I
return byte Buf. write Bytes(ava channel(), byte Buf. writableBytes()
图16-35 NioSocketChannel读取数据报
它有两个参数,说明如下。
o java nio channels. SocketChannel: JDK NIO H SocketChannel;
◎ length: Byte Buf的可写最大字节数。
实际上就是从 Socketchannel中读取L个字节到 ByteBuf中,L为 Byte Buf可写的字节
数,下面我们看下 ByteBuf writeBytes方法的实现,如图16-36所示。
@override
public int write Bytes(Scattering Byte Channel in, int length) throws
IOException i
ensure Writable (length)
int written Bytes= set Bytes(writerIndex, in, length)
if (writtenBytes>0)(
writerIndex + written Bytes.
return writtenBytes:
图16-36从 Socketchannel读取数据报到 ByteBuf中
首先分析 setBytes( int index, Scattering Byte Channel in, int length)在 UnpooledHeapByte Buf
中的实现,如图16-37所示。
@override
public int setBytes(int index, Scattering Byte Channel in, int length)throws
lOE
ensureAccessibleO
try i
turn in. read((ByteBufter)
internalNio Buffer(). clear(). position(index). limit(index +length));
3 catch(Closed ChannelException e)i
return -1
图16-37 UnpooledHeap ByteBuf的set方法实现
363Netty权威指南(第2版)
从 Socketchannel中读取字节数组到缓冲区 Java nIo. Byte Buffer中,它的起始 position
为 writelndex, limit为 writelndex+ length, JDK Byte Buffer的相关DOC说明如图16-38
所示。
itj瓶,..hane1s. Reada⊥ eiyteChannel, read BrteBuffer dst) thres oLe吧P正
Reids a sequence of bytes from this channel into the given buffer
An attempt is made to read up to r bytes from the channel, where r is the number of bytes remaining in the
buffer, that is, ast. remaining(, at the moment this method is invoked.
Suppose that a byte sequence of length n is read, where o te n-r This byte sequence will be transferred
into the buffer so that the first byte in the sequence is at index F and the last byte is at index p+ n-1
where p is the buffers posi tion at the moment this method is invoked. Upon return the buffer s position will b
e1tp+且:its1 IRIL 9i11 aot have eh的ged
A read oparsti on might not fill the buffer, and in fact it miat not resd any bytes at all. Whether or not it
doas to depends upon the nature and state of the channel. A socket channel in nom-blocking sode, for exmple
cannot read any mora bytas than are immediately available from the socket' s input buffer: similarly, a file
channel cannot read any mor bytes than remain in the file. It is guarantee
d. however. that if a channel is in
blocking mode and there is at least one byte remaining in the buffer then this method will block until at least
one trte1s【e
This method may be invoked at any time. If another thread has alresdy initiated a read operation upon this
channel, however, then an invocation of this method will block until the first operation is complete
图16-38 Java.no. Byte Buffer的read方法
163 Unsafe功能说明
Unsafe接口实际上是 Channel接口的辅助接口,它不应该被用户代码直接调用。实际
的I/O读写操作都是由 Unsafe接口负责完成的。下面我们一起看下它的API定义。
表16-1 Unsafe API功能列表
方法名
返回值
功能说明
invoker
Channelhandlerln voker
返回默认使用的 Channelhandlerlnvoker
localAddresso
Socketaddress
返回本地绑定的 Socket地址
remoteAddresso
SocketAddress
返回通信对端的 Socket地址
注册 Channel到多路复用器上,一旦注册操作完成,
register( ChannelPromise promise)
void
通知 Channel future
bind( socketAddress localAddress
绑定指定的本地地址 localAddress到当前的 Channel
void
ChannelPromise promise)
上,一旦完成,通知 Channelfuture
connect(SocketAddress
绑定本地的 localaddress之后,连接服务端,一旦操
remote address. Socketaddre
作完成,通知 Channelfuture
localAddress, ChannelPromise promise
364第16章 Channe和 Unsafe
续表
方法名
返回值
功能说明
disconnect( Channel Promise promise)void
断开 Channel的连接,一旦完成,通知 Channelfuture
close(ChannelPromise promise)
void
关闭 Channel的连接,一旦完成,通知 Channelfuture
close forcibly
void
强制立即关闭连接
beginReado
void
设置网终操作位为读用于读取消息
write(Object msg, ChannelPromise
发送消息,一旦完成,通知 Channelfuture
promise)
flush
void
将发送缓冲数组中的消息写入到 Channel中
返回一个特殊的可重用和传递的 Channelpromise,它
void
ChannelPromise
不用于操作成功或者失败的通知器,仅仅作为一个容器
被使用
outbound Buffer
ChanneloutboundBuffer返回消息发送缓冲区
164 Unsafe源码分析
实际的网络IO操作基本都是由 Unsafe功能类负责实现的,下面我们一起看下它的主
要功能子类和重要的API实现。
164.1 Unsafe继承关系类图
首先看下如图16-39所示 Unsafe接口的类继承关系图。
I Unsafe
ONioUnsafe
CA AbstracrUnsafe
CA-AbstractNioUnsafe
CAbstractNioU'nsafe
s NioMessageU'nsafe
图16-39 Unsafe继承关系图
365Net!y权威指南(第2版)
1642 AbstractUnsafe源码分析
. register方法
register方法主要用于将当前 Unsafe对应的 Channel注册到 EventLoop的多路复用器
上,然后调用 Default ChannelPipeline的 fireChannelRegistered方法。如果 Channel被激活,
则调用 DefaultChannelPipeline的 fire Channelactive方法。源码如图16-40所示
首先判断当前所在的线程是否是 Channel对应的 NioEventLoop线程,如果是同一个
线程,则不存在多线程并发操作问题,直接调用 register0进行注册;如果是由用户线程或
者其他线程发起的注册操作,则将注册操作封装成 Runnable,放到 NioEventLoop任务队
列中执行。注意:如果直接执行 register0方法,会存在多线程并发操作 Channel的问题
@override
public final void register(final ChannelPromise promise)(
if (eventLoop. inEventLoopo)t
gisterO(promise):
tr
eventLoop. execute(new Runnable(I
@override
public void run(I
gistero(promise)
})
y catch(Throwable t)
agger,wam〔
Force-closing a channel whose registration task was not
accepted by an event loop: t
AbstractChannel. this, t);
closeForcibly(
closeFuture. setClosedo
promise. setFailure(t):
图16-40 AbstractUnsafe的 register方法
下面继续看 register方法的实现,代码如图16-41所示。
首先调用 ensureOpen方法判断当前 Channel是否打开,如果没有打开则无法注册,直
接返回。校验通过后调用 deRegister方法,它由 AbstractNioUnsafe对应的 AbstractNio Channel
实现,代码如图16-42所示。
366第16章 Channel和 Unsafe
private void register(ChannelPromise promise)(
n check if the channel is still open as it could be closed in the mean
time when the register
H/ call was outside of the eventLoop
if (ensureOpen(promise))(
return
rO
registered= true
promise. setSuccesso
pipeline. fire Channe REgistered(
if (inActive)t
pipeline. fire ChannelActive(
catch(Throwable t)[
d Close the channel directly to avoid FD leak
closeForcibly(.
closeFuture, setclosedo:
if(Ipromise. try Failure(O))t
logger. warn(
Tried to fail the registration promise, but it is complete
Swallowing the cause of the registration failure: O)
图16-41 AbstractUnsafe的 register(0方法
@override
protected void doRegister() throws Exception
boolean selected fals
for (:)f
selectionKey =java Channel(). register(eventLoop(). selector, 0, this)
returm
F catch(CancelledKeyException e)
if (Is
I Force the Selector to select now as the"canceled"SelectionKey
may still b
l cached and not removed because no Select select(.)operation
was called yet.
eventLoop(). selectNowo
selected tri
F else
We forced a select operation on the selector before but the
SelectionKey is still cached
/ for whatever reason, JDK bug
throw自
图16-42 Abstract niochannel的 deRegister方法
该方法在前面的 AbstractNiochannel源码分析中已经介绍过,此处不再赘述。如果
deregister方法没有抛出异常,则说明 Channe注册成功。将 Channelpromise的结果设置
为成功,调用 ChannelPipeline的 fire ChannelRegistered方法,判断当前的 Channel是否已
367Nety权威指南(第2版)
经被激活,如果己经被激活,则调用 ChannelPipeline的 fire ChannelActive方法。
如果注册过程中发生了异常,则强制关闭连接,将异常堆栈信息设置到 Channelpromise中。
2.bind方法
bind方法主要用于绑定指定的端口,对于服务端,用于绑定监听端口,可以设置 backlog
参数;对于客户端,主要用于指定客户端 Channel的本地绑定 Socket地址。代码实现如图
16-43所示。
boolean wasActive isActive0
oBindglocalAddress)
I catch(Throwable t
promise. setFailure(t
closelfclosed(:
return
if(Iwas Active & isActive()(
invokeLater(new Runnable(
@override
public void runt
pipeline, fire channelActive ()
promise. setsuccess (
图16-43 AbstractUnsafe的bind方法实现
调用 do bind方法,对于 Nio SocketChannel和 NioServerSocketChannel有不同的实现,
客户端的实现代码如图16-44所示
@Override
protected void doBind(SocketAddress localAddress) throws Exception f
javaChannel(). socket(). bind(localAddress)
图16-4 NioSocketchannel的 goBind方法实现
服务端的 goBind方法实现如图16-45所示
@override
protected void doBind( SocketAddress localAddress)throws Exception
javaChannel(). socket().bind (localAddress, config getBacklogo)
图16-45 NioServerSocketchannel的 goBind方法实现
如果绑定本地端口发生异常,则将异常设置到 Channelpromise中用于通知
Channelfuture,随后调用 closelfClosed方法来关闭 Channel。
368·第16章 Channe和 Unsafe
3. disconnect方法
disconnect用于客户端或者服务端主动关闭连接,它的代码如图16-46所示。
@Override
public final void disconnect(final ChannelPromise promise)i
boolean wasActive=isActive(:
diSconnect)
y catch(Throwable t)t
promise. setFailure(t):
closelfclosed(
return
if(wasActive & isActive()t
invoke Later(new Runnable[
@overrid
public void run((
pipeline. fire channellnactive )
);
promise. setSuccess(:
closelfClosed(); // doDisconnect( might have closed the channel
图16-46 AbstractUnsafe的 disconnect方法实现
4.cose方法
在链路关闭之前需要首先判断是否处于刷新状态,如果处于刷新状态说明还有消息尚
未发送出去,需要等到所有消息发送完成再关闭链路,因此,将关闭操作封装成 Runnable
稍后再执行。如图16-47所示。
@o
override
public final void close(final ChannelPromise promise)
if (in Flush)Y
invoke Later(new Runnable((
@override
public void runo(
close(promise)
)
if (closeFuture. isDoneo(
∥ Closed already
promise. setsuccesso
retur
图16-47 AbstractUnsafe的 close方法片段I
369Nety权威指南(第2版)
如果链路没有处于刷新状态,需要从 close future中判断关闭操作是否完成,如果已经
完成,不需要重复关闭链路,设置 ChannelPromise的操作结果为成功并返回。
执行关闭操作,将消息发送缓冲数组设置为空,通知JVM进行内存回收。调用抽象
方法 doClose关闭链路。源码如图16-48所示
boolean wasActive isActive(
Channeloutbound Buffer outbound Buffer s this outbound Buffer.
this outboundBuffer null; //Disallow adding any messages and
flushes to outbound Buffer
disclose
()
closeFuture. setclosedo)
promise. setsuccess()
y catch(Throwable t)
closeFuture. setclosedo
promise. setFailure(t)
图16-48 Abstract unsafe的 close方法片段2
如果关闭操作成功,设置 Channelpromise结果为成功。如果操作失败,则设置异常对
象到 Channelpromise中。
调用 Channeloutbound Buffer的 close方法释放缓冲区的消息,随后构造链路关闭通知
Runnable放到 NioEventLoop中执行。源码如图16-49所示。
l Fail all the queued messages
try
outbound Buffer. failFlushed(CLOSED_ CHANNEL_EXCEPTION)
outbound Buffer. close(CLOSED CHANNEL_ EXCEPTION)
}fnay【
if(was Active & lisActive O)
invokeLater(new Runnable((
public void runo(
pipeline. fire Channellnactive
deregister()
图16-49 Abstract Unsafe的 close方法片段3
最后,调用 deregister方法,将 Channel从多路复用器上取消注册,代码实现如图16-50
所示
@Override
protected void doDeregistero throws Exception t
eventLoop(). cancel(selectionKey()
图16-50 AbstractUnsafe的 close方法片段4
370·第16章 Channe和 Unsafe
NioEventLoop的 cancel方法实际将 selection Key对应的 Channel从多路复用器上去注
册, NioEventLoop的相关代码如图16-51所示。
void cancel(SelectionKey key)(
key cancel()
cancelledKeys ++
if(cancelledKeys >=CLEANUP INTERVAL)[
cancelledKeys=0
needs ToSelectAgain= true
图16-51取消 Channel的注册
5.Wrte方法
write方法实际上将消息添加到环形发送数组中,并不是真正的写 Channel,它的代码
如图16-52所示。
@override
public void write(Object msg, ChannelPromise promise)(
if(lisActiveO)(
l Mark the write request as failure if the channel is inactive.
if (isOpen)t
promise. try Failure( NOT YET CONNECTED EXCEPTION);
y else
promise. tryFailure(CLOSED_CHANNEL_ EXCEPTION)
l release message now to prevent resource-leak
Reference CountUtil release(msg):
else t
2 outbound Buffer. addMessage(msg, promise)
图16-52写操作
如果 Channel没有处于激活状态,说明TCP链路还没有真正建立成功,当前 Channel
存在以下两种状态。
(1) Channel打开,但是TCP链路尚未建立成功: NOT YET CONNECTED EXCEPTION;
(2) Channel已经关闭: CLOSED CHANNEL EXCEPTION。
对链路状态进行判断,给 Channelpromise设置对应的异常,然后调用 Reference Countutil
的 release方法释放发送的msg对象。
如果链路状态正常,则将需要发送的msg和 promise放入发送缓冲区中(环形数组)。
371·Netty权威指南(第2版)
6.fush方法
flush方法负责将发送缓冲区中待发送的消息全部写入到 Channe中,并发送给通信对
方。它的代码如图16-53所示。
@override
public void flush(
ChannelOutbound Buffer outbound Buffer this outbound Buffer.
if (outboundBuffer== null)i
outbound Buffer. addFlush(:
filusho0
图16-53刷新操作
首先将发送环形数组的 unflushed指针修改为tail标识本次要发送消息的缓冲区范围。
然后调用fush0进行发送,由于fush0代码非常简单,我们重点分析 do write方法,代码
如图16-54所示。
@override
protected void doWrite(ChannelOutbound Buffer in) throws Exception 1
for()
N Do non-gathering write for a single buffer case
final int msg Count =in size(),
if(msg Count <=1)
super.dowrite(in)
return
图16-54 do write方法代码片段1
首先计算需要发送的消息个数( unflushed-fush),如果只有1个消息需要发送,则调
用父类的写操作,我们分析 AbstractNioByte Channel的 do writeC方法,代码如图16-55所示。
@override
protected void dowrite(ChannelOutboundBuffer in) throws Exception I
int writeSpin Count =-1
Object msg in current( true);
if(msg =s null)(
H Wrote all messages
clearopWrite(:
图16-55 do write方法代码片段2
因为只有一条消息需要发送,所以直接从 Channeloutbound Buffer中获取当前需要发
送的消息,代码如图16-56所示。
372·第16章 Channe和 Unsafe
public Object current( boolean preferDirect)(
if (isEmptyo)(
return null
else
Object msg buffer(flushed]. msg
if (threadLocal Direct Buffer Size <=0 Iprefer Direct)(
eturn
if(msg instanceof Byte Buf)i
Byte Buf buf =(Byte Buf) msg
if(buf, isDirect()I
return bu,
s else
int readableBytes- buf readable Bytes(
if (readable Bytes ==0)1
return buf.
Non-direct buffers are copied into JDK,'s own internal direct
buffer on every IO
I We can do a better job by using our pooled allocator. If the
current allocator does not
l pool a direct buffer, we use a ThreadLocal based pool
Byte BufAllocator alloc channel allocO)
ByteBuf direct Buf
if (alloc. isDirectBufferPooled( )(
directBuf = alloc. directBuffer(readable Bytes)
directBuf ThreadLocalPooled Byte Buf. newInstanced
图16-56 do write方法代码片段3
首先,获取需要发送的消息,如果消息为 Byte Buf且它分配的是JDK的非堆内存,则
直接返回。对返回的消息进行判断,如果为空,说明该消息已经发送完成并被回收,然后
执行清空 OP WRITE操作位的 clearOp Write方法,代码如图16-57所示。
protected final void clearopWriteO(
final SelectionKey key= selectionKey(:
final int interestOrs key interestOrs(:
if ((interestops SelectionKey OP WRITE)=o)I
key interestOrs(interestOps &-SelectionKey, OP WRITE);
图16-57 do write方法代码片段4
继续向下分析,如果需要发送的 ByteBuf已经没有可写的字节了,则说明已经发送完
成,将该消息从环形队列中删除,然后继续循环,代码如图16-58所示。
if(msg instanceof ByteBuf)(
Byte Buf buf =(Byte Buf) msg
int readable Bytes buf readable Bytes(:
if (readableBytes ==0)
in remove(
continue
图16-58 do write方法代码片段5
·373·Netty权威指南(第2版)
下面我们分析下 Channeloutbound Buffer的 remove方法,如图16-59所示
public boolean remove o(
if(isEmptyO)I
eturn false
Entry e= buffer[flushed]
Object msg =emsg.
if (msg ==null)(
return false
ChannelPromise promise = e promise:
int size =e. pendingSize
e clear
flushed= flushed 1& buffer length-1
reRelease(msg):
promise. trysuccess(:
decrementPending Outbound Bytes(size);
return true
图16-59 dowrite方法代码片段6
首先判断环形队列中是否还有需要发送的消息,如果没有,则直接返回。如果非空,
则首先获取 Entry,然后对其进行资源释放,同时对需要发送的索引 flushed进行更新。所
有操作执行完之后,调用 decrementPending Outbound Bytes减去已经发送的字节数,该方法
跟 increment Pending Outbound Bytes类似,会进行发送低水位的判断和事件通知,此处不再
赘述
我们接着继续对消息的发送进行分析,代码如图16-60所示。
boolean setopWrite= false
boolean done E false:
long flushedAmount =0:
if (write S!
write Spin Count= config(). getwrite Spin Count()
for(int i= write Count-1; i>=0: i-)i
int local FlushedAmount doWrite Bytes(buf)
if (localFlushedAmount ==0)
setOpWrite =true;
第一步;对写入的字节个数进行判读,如果为看说明TCP的发送暖
break.
冲已满,需退出井监听写操作
flushedAmount + localFlushedAmount
if (buf. isReadableO)(
done tr
break.
图16-60 do write方法代码片段7
374第16章 Channe|和 Unsafe
首先将半包标识设置为 false,从 Defaultsocketchannelconfig中获取循环发送的次数,
进行循环发送,对发送方法 do write Bytes展开分析,如图16-61所示。
ao
protected int doWrite Bytes(ByteBuf but) throws Exception
final int expected Written Bytes buf readable Bytes()
final int written Bytes =buf readBytes(javaChannel)
expectedWritten Bytes );
return written Byte
图16-6 i do write方法代码片段8
ByteBuf的 readBytes(方法的功能是将当前 Byte Buf中的可写字节数组写入到指定的
Channel中。方法的第一个参数是 Channel,此处就是 Socketchannel,第二个参数是写入
的字节数组长度,它等于 ByteBuf的可读字节数,返回值是写入的字节个数。由于我们将
Socketchannel设置为异步非阻塞模式,所以写操作不会阻塞
从写操作中返回,需要对写入的字节数进行判断,如果为0,说明TCP发送缓冲区已
满,不能继续再向里面写入消息,因此,将写半包标识设置为true,然后退出循环,执行
后续排队的其他任务或者读操作,等待下一次 selector的轮询继续触发写操作。
对写入的字节数进行累加,判断当前的 Byte Buf中是否还有没有发送的字节,如果没
有可发送的字节,则将done设置为true,退出循环。
从循环发送状态退出后,首先根据实际发送的字节数更新发送进度,实际就是发送的
字节数和需要发送的字节数的一个比值。执行完进度更新后,判断本轮循环是否将需要发
送的消息全部发送完成,如果发送完成则将该消息从循环队列中删除:否则,设置多路复
用器的 OP WRITE操作位,用于通知 Reactor线程还有半包消息需要继续发送
164.3 Abstractnio unsafe源码分析
AbstractnioUnsafe是 AbstractUnsafe类的NIO实现,它主要实现了 connect
finishConnect等方法,下面我们对重点API实现进行源码分析
1. connect方法
首先获取当前的连接状态进行缓存,然后发起连接操作,代码如图16-62所示
需要指出的是, Socketchannel执行 connecto操作有三种可能的结果。
375·Ne!y权威指南(第2版)
1)连接成功,返回true;
(2)暂时没有连接上,服务端没有返回ACK应答,连接结果不确定,返回 false
protected boolean doconnect(SocketAddress remote Address
SocketAddress localAddress)throws Exception
if (localAddress [= null)(
javaChannel(). socket(). bind(localAddress):
boolean success false
try
boolean connected=javaChannel(). connect(remote Address):
if( Connected)t
selectionKeyo interestors(SelectionKey OP CONNECT)
success true
return connected
如果指定了本地绑定端口.执行绑定操
y finally
作发起异步TCP连接,可能连接成功,
if (Success)
也可能暂时没有连接成功。如果没有立
do close()
即连接成功,则监听连接操作
图16-62 AbstractNio Unsafe的 connect方法代码片段1
(3)连接失败,直接抛出LO异常。
如果是第(2)种结果,需要将 NioSocketchannel中的 selectionKey设置为 OP CONNECT,
监听连接应答消息。
异步连接返回之后,需要判断连接结果,如果连接成功,则触发 Channelactive事件,
代码如图16-63所示。
/u private void fulfilIConnectPromise( ChannelPromise promise, boolean
rasActive)t
l trySuccess( will return false if a user cancelled the connection attempt
boolean promise Set= promise. try)
N Regardless if the connection attempt was cancelled, channelActive(
event should be triggered
because what happened is what happened
if (lwasActive & isActive()(
pipeline(). fire ChannelActive(:
l If a user cancelled the connection attempt, close the channel, which is
followed by channellnactive (
if (promise Set)
close(voidPromise()
图16-63 AbstractNioUnsafe的 connect方法代码片段2
376·第16章 Channel和 Unsafe
这里对 ChannelActive事件处理不再进行详细说明,它最终会将 NioSocketchannel中
的 selectionKey设置为 SelectionKey. OP READ,用于监听网络读操作位
如果没有立即连接上服务端,则执行如图16-64所示分支。
l Schedule connect timeout
int connect imeoutMillis config(). getConnectT imeoutMillis()
(connectTimeoutMillis >0)
connectTimeoutFuture eventLoop(). schedule(new Runnable0t
@override
public void run(I
ChannelPromise connectPromise
AbstractNioChannel. this connectPromise:
ConnectTimeoutException cause
new ConnectTimeout Exception("connection timed out
remote Address )
if (connectPromise I= null &
connectPromise try Failure(cause))(
close(voidPromiseO)
A, connect T imeoutMillis, TimeUnit. MILLISECONDS)
promise, addListener(new ChannelFutureListeneroi
oVerride
public void operation Complete( ChannelFuture future)throws
Exception
if (futureis Cancelled())t
if (connectTimeoutFuture I=null)t
connectTimeoutFuture. cancel(false)
connectpromise null:
close(voidPromise())
图16-64 AbstractNioUnsafe的 connect方法代码片段3
上面的操作有两个目的。
(1)根据连接超时时间设置定时任务,超时时间到之后触发校验,如果发现连接并没
有完成,则关闭连接句柄,释放资源,设置异常堆栈并发起去注册。
(2)设置连接结果监听器,如果接收到连接完成通知则判断连接是否被取消,如果被
取消则关闭连接句柄,释放资源,发起取消注册操作。
2. finishConnec方法
客户端接收到服务端的TCP握手应答消息,通过 Socketchanne的 finishConnect方法
对连接结果进行判断,代码如图16-65所示
377Netty权威指南(第2版)
@override
public void finish Connect((
l Note this method is invoked by the event loop only if the connection
attempt was
l neither cancelled nor timed out
assert eventLoop(). inEventLoop(
assert connect Promise l= null
boolean wasActive isActive(
doFinish Connect(
图16-65 AbstractNioUnsafe的 finishConnect方法代码片段1
首先缓存连接状态,当前返回 false,然后执行 do FinishConnect方法判断连接结果,
代码如图16-66所示。
@override
protected void do FinishConnect()throws Exception
if (java Channel(). finish Connect()(
throw new Error
图16-66 Abstractniounsafe的 finishConnect方法代码片段2
通过 Socketchannel的 finish Connect方法判断连接结果,执行该方法返回三种可能
结果。
◎连接成功返回true
◎连接失败返回 false;
◎发生链路被关闭、链路中断等异常,连接失败。
只要连接失败,就抛岀Eror(,由调用方执行句柄关闭等资源释放操作,如果返回
成功,则执行 fulfillConnect Promise方法,它负责将 Socketchannel修改为监听读操作位,
用来监听网络的读事件,代码如图16-67所示。
4,Private void fulflIConnectPromise( ChannelPromise promise, boolean
yasActive)
l try Success() will return false if a user cancelled the connection attempt.
boolean promise Set= promise, try successo
M Regardless if the connection attempt was cancelled, channelActiveO)
event should be triggered
w because what happened is what happened
if (Iwas Active & isActive()(
pipeline (). fire ChannelActive()
图16-67 Abstract NioUnsafe的 fulfillConnectPromise方法
378·第16章 Channe|和 Unsafe
最后对连接超时进行判断:如果连接超时时仍然没有接收到服务端的ACK应答消
息,则由定时任务关闭客户端连接,将 Socketchannel从 Reactor线程的多路复用器上摘除,
释放资源,代码如图16-68所示。
y finally i
l Check for null as the connect TimeoutFuture is only created if a
connect timeoutmillis >o is used
l/Seehttps://github.com/netty/nettyissues/1770
if(connect Timeout Future I= null)i
connect T imeoutFuture cancel(false);
connectPromise null
图16-68 AbstractNioUnsafe的 finishConnect方法代码片段3
164.4 NioByteUnsafe源码分析
我们重点分析它的read方法,源码如图16-69所示
@override
public void reado t
final ChannelConfig config =config(:
final ChannelPipeline pipeline= pipeline(:
final ByteBufAllocator allocator config getAllocator(
final int maxMessages PerRead =config. getMaxMessagesPerRead(
RecvByteBufAllocator Handle allocHandle= this allocHandle:
if (allocHandle =s null)
this allocHandle allocHandle
config. getRecv ByteBufAllocator(). newHandle(:
图16-69 NioByteUnsafe的read方法代碼片段l
首先,获取 NioSocketchannel的 SocketChannelConfig,它主要用于设置客户端连接的
TCP参数,接口如图16-70所示。
继续看 alloc handle的初始化。如果是首次调用,从 SocketchannelConfig的
Recv Byte BufAllocator中创建 Handle。下面我们对 Recv Byte BufAllocator进行简单地代码
分析: Recv Byte BufAllocator默认有两种实现,分别是 AdaptiveRecv Byte BufAllocator和
FixedRecv Byte BufAllocator。由于 FixedRecv ByteBufAllocator的实现比较简单,我们重点
分析 AdaptiveRecv Byte BufAllocator的实现。如图16-71所示
顾名思义, AdaptiveRecv Byte BufAllocator指的是缓冲区大小可以动态调整的 Byte Buf
分配器。它的成员变量定义如图16-72所示。
379·Nety权威指南(第2版)
cB io, netty channel. socket
E II SocketChannelConfia
o isTcpHoDelayo: boolean
o setTcpNoDelay (boolean): SocketCharnelConfig
● getSinger(
e setsoLinger (int): SocketChannelConfig
o getSendBufferSize0: int
o setSendBufferSize (int): SocketCharnelConfig
e getReceiveBufferSize0: int
e setReceiveBufferSize (int): SocketChannelConfig
o isKeepAlive0: boolean
e setKeepAlive (boolean): SocketChannelconfi g
getTrafficClass0: int
e setIrafficClass(int): socketChannelconfig
● i sReugeAddres=0: boo1ean
e setReuseAddress (boolean): SocketChsrnelConfig
e setPer formancePreferences (int, int, int): SecketChannelConfig
o isAllowHalfClosure0. boolean
e setAllowHal EClosure (boolean): SocketChannelConEig
@e setConnectTimeoutlillis (int): SocketChannelConfig
.a setMarMessagesPerRead (int): Socke tChannelConfig
Oa setwri tespinCount (int): SocketCharnelconfig
命△雪etA11 orator (Byt aBunA11 orator) SocketChannelconfi e
ea setRecvByteBufAlloeator ( ReevByteBufAllocator ) SocketChannelconfig
Oa setAutoRead Boolean): SocketCharnelConfi g
GA setMessageSi reEstimator MessageSireEstimator ) SocketChannelConfig
图16-70 SocketChannelConfig的API列表
Ire hi新chf‘i.chme1 HecwHyteBufA1aEx":
perations and keens the internul information whir
eewBytaBufAlloeatar-I0 ketty chanel
c AdsptirReerByt,BuEAlleeater-io,nett.chanel
o FizsdReswByteBufAllosator-i. natty channel
Frotr'Cirltr' to sa the tupeitypa hiaraich-i
图16-71 Recv Byte BufAllocator接口的继承关系
public class Adaptive Recv Byte BufAllocator implements Recv Byte BufAllocator
static final int DEFAULT MINIMUM =64:
static final int DEFAULT INITIAL 1024
static final int DEFAULT MAXIMUM= 65536
private static final int INDEX INCREMENT 4
private static final int INDEX DECREMENT =1
图16-72 Recv Byte BufAllocator的成员变量定义
它分別定义了三个系统默认值:最小缓冲区长度64字节、初始容量1024字节、最大
容量65536字节。还定义了两个动态调整容量时的步进参数:扩张的步进索引为4、收缩
的步进索引为1。
380·第16章 Channe和 Unsafe
最后,定义了长度的向量表 SIZE TABLE并初始化它,初始值如图16-73所示
0-->161-->322-->483-->644-->805-->966-->1127-->1288-->144
10-->17611-->19212-->20813-->22414-->24015-->25616-->272
17-=>28818=->304
19-->32020->33621-->35222-->36823-->38424-->40025-->416
26-->43227-->448
28-->46429-->48030->49631-->51232-->102433-->204834-->4096
35-->819236-->16384
37-->3276838-->6553639-->13107240-->26214441-->524288
42-->104857643-->209715244-->419430445-->8388608
46-->16777216
47-->33554432
48-->67108864
49-->134217728
50==>26843545651==>53687091252-=>1073741824
图16-73 SIZE TABLE的扩张
向量数组的每个值都对应一个 Buffer容量,当容量小于512的时候,由于缓冲区已经
比较小,需要降低步进值,容量每次下调的嶇度要小些;当大于512时,说明需要解码的
消息码流比较大,这时采用调大步进幅度的方式减少动态扩张的频率,所以它采用512的
倍数进行扩张
接下来我们重点分析下 Adaptive Recv Byte BufAllocator的方法
方法1: getsize Tablelndex( final int size),代码如图16-74所示
rivate static int getsize T ablelndex(final int size
for(int low =0, high= SIZE TABLE length-1,
if (high low)
return low
if(high = low)i
eturn high
nt mid =low high >>>1:
int a= SIZE TABLE[mid]
int b= SIZE TABLE[mid + 1:
if(size >b)I
low= mid 1
} else if(size≤a)
high =mid-1;
helse if(size = a)(
return mid
)else t
return mid +1
图16-74获取向量表索引
381Nety权威指南(第2版)
根据容量Size查找容量向量表对应的索引一这是个典型的二分查找法,由于它的算
法非常经典,也比较简单,此处不再赘述。
下面我们分析下它的内部静态类 Handlelmpl,首先,还是看下它的成员变量,如图
16-75所示
private static final class Handlelmpl implements Handle i
private final int minIndex
private final int maxIndex
ate int ind
private int nextReceiveBuffersize
private boolean decreaseNow
图16-75 Handlelmpl的成员变量
它有5个成员变量,分别是:对应向量表的最小索引、最大索引、当前索引、下一次
预分配的 Buffer大小和是否立即执行容量收缩操作。
我们重点分析它的 record( int actualReadBytes)方法:当 NioSocket Channel执行完读操
作后,会计算获得本次轮询读取的总字节数,它就是参数 actualRead Bytes,执行 record方
法,根据实际读取的字节数对 ByteBuf进行动态伸缩和扩张,代码如图16-76所示。
@override
public void record(int actualReadBytes)
if (actualRead Bytes < SIZE_ TABLE[Math. max(o,
index
NDEX DECREMENT·1))
if(decrease Now)
index= Math. max(index
INDEX DECREMENT, minIndex)
nextReceive Buffer Size
SIZE TABLELndex:
decreaseNow fal
t else
decreaseNow= true
y else if(actualReadBytes >=nextReceive Buffer Size
index Math, min(index
INDEX INCREMENT, maxIndex)
nextReceive BufferSize
SIZE TABLE[index]:
decreaseNow false
图16-76 ByteBuf动态伸缩
首先,对当前索引做步进缩减,然后获取收缩后索引对应的容量,与实际读取的字节
数进行比对,如果发现小于收缩后的容量,则重新对当前索引进行赋值,取收缩后的索引
·382·第16章 Channe和 Unsafe
和最小索引中的较大者作为最新的索引。然后,为下一次缓冲区容量分配赋值—一新的索
引对应容量向量表中的容量。相反,如果当前实际读取的字节数大于之前预分配的初始容
量,则说明实际分配的容量不足,需要动态扩张。重新计算索引,选取当前索引+扩张步
进和最大索引中的较小作为当前索引值,然后对下次缓冲区的容量值进行重新分配,完成
缓冲区容量的动态扩张。
通过上述分析我们得知, Adaptive Recv Byte BufAllocator就是根据本次读取的实际字节
数对下次接收缓冲区的容量进行动态调整
使用动态缓冲区分配器的优点如下。
(1)Nety作为一个通用的NIO框架,并不对用户的应用场景进行假设,可以使用它
做流媒体传输,也可以用它做聊天工具。不同的应用场景,传输的码流大小千差万别,无
论初始化分配的是32KB还是1MB,都会随着应用场景的变化而变得不适应。因此, Netty
根据上次实际读取的码流大小对下次的接收 Buffer缓冲区进行预测和调整,能够最大限度
地满足不同行业的应用场景。
(2)性能更高,容量过大会导致内存占用开销增加,后续的 Buffer处理性能会下降
容量过小时需要频繁地内存扩张来接收大的请求消息,同样会导致性能下降。
(3)更节约内存。假如通常情况下请求消息平均值为1MB左右,接收缓冲区大小为1.2MB
突然某个客户发送了一个10MB的流媒体附件,接收缓冲区扩张为10MB以接纳该附件,
如果缓冲区不能收缩,每次缓冲区创建都会分配10MB的内存,但是后续所有的消息都是
IMB左右,这样会导致内存的浪费,如果并发客户端过多,可能会发生内存溢出,最终宕
机
看完了 Adaptive Recv Byte BufAllocator,我们继续分析读操作。
首先通过接收缓冲区分配器的 Handler计算获得下次预分配的缓沖区容量
byte BufCapacity,如图16-77所示。紧接着根据缓冲区容量进行缓冲区分配, Netty的缓冲
区种类很多,此处重点介绍的是消息的读取,因此对缓冲区不展开说明。
int byte BufCapacity allocHandle guess(
int totalReadAmount= 0
do
byteBuf allocator ioBuffer(byteBufcapacity)
图16-77 NioByteUnsafe的read方法代码片段2
接收缓冲区 ByteBuf分配完成后,进行消息的异步读取,代码如图16-78所示。
383·Netty权威指南(第2版)
int localReadAmount doReadBytes(byte Buf)
图16-78 NioByteUnsafe的read方法代码片段3
它是个抽象方法,具体实现在 NioSocketChannel中,代码如图16-79所示
@override
protected int doReadBytes(Byte Buf byteBuf) throws Exception
return byte Buf, write Bytes(javaChannel(), byte Buf, writable Bytes()
图16-79 NioByte Unsafe的read方法代码片段4
其中 javaChannel(返回的是 Socketchannel,代码如图16-80所示。
@Override
protected Socketchannel javaChanneo(
return(Socketchannel) super javachannel(:
图16-80 Nio ByteUnsafe的read方法代码片段5
byte Buf, writable Bytes(返回本次可读的最大长度,我们继续展开看最终是如何从
Channel中读取码流的,代码如图16-81所示。
@override
public int write Bytes(Scattering Byte Channel in, int length) throws IOException
ensurewritable(length)
int written Bytes = setBytes( writerIndex, in, length)
if (written Bytes >0)(
writerIndex + writtenBytes
return written Bytes
图16-81 NioByteUnsafe的read方法代码片段6
对 setBytes方法展开分析如图16-82所示。
@Overrid
public int setBytes(int index, ScatteringByte Channel in, int length)throws
eXCeption
ensureAccessible(:
tr
return in read((Byte Buffer
internalNioBuffer(). clear() position(index ). limit(index length));
) catch(ClosedchannelException e)(
return -1
图16-82 Nio ByteUnsafe的read方法代码片段7
·384·第16章 Channe|和 Unsafe
由于 Socketchannel的read方法参数是 Java nio的 Byte Buffer,所以,需要先将 Netty
的 Byte Buf转换成JDK的 Byte Buffer,随后调用 Byte Buffer的 clear方法对指针进行重置
用于新消息的读取,随后将 position指针指到初始读 index,读取的上限设置为 index+读
取的长度。最后调用read方法将 Socketchannel中就绪的码流读取到 Byte Buffer中,完成
消息的读取,返回读取的字节数。
完成消息的异步读取后,需要对本次读取的字节数进行判断,有以下三种可能
(1)返回0,表示没有就绪的消息可读;
(2)返回值大于0,读到了消息
(3)返回值-1,表示发生了IO异常,读取失败。
下面我们继续看Nety的后续处理,首先对读取的字节数进行判断,如果等于或者小
于0,表示没有就绪的消息可读或者发生了IO异常,此时需要释放接收缓冲区;如果读
取的字节薮小于0,则需要将 close状态位置位,用于关闭连接,释放句柄资源。置位完
成之后,退出循环。源码如图16-83所示。
if (localReadAmount s= 0)t
l not was read release the buffer
byteBuf released
close localReadAmount <0:
break
图16-83 Nio ByteUnsate的read方法代码片段8
完成一次异步读之后,就会触发一次 ChanneIRead事件,这里要特别提醒大家的是:
完成一次读操作,并不意味着读到了一条完整的消息,因为TCP底层存在组包和粘包,
所以,一次读操作可能包含多条消息,也可能是一条不完整的消息。因此不要把它跟读取
的消息个数等同起来。在没有做任何半包处理的情况下,以 Channelread的触发次数做计
数器来进行性能分析和统计,是完全错误的。当然,如果你使用了半包解码器或者处理了
半包,就能够实现一次 ChanneIRead对应一条完整的消息。
触发和完成 Channelread事件调用之后,将接收缓冲区释放,代码如图16-84所示。
pipeline. fire ChannelRead(byte Buf);
byte Buf null
图16-84 NioByte Unsafe的read方法代码片段9
因为一次读操作未必能够完成TCP缓冲区的全部读取工作,所以,读操作在循环体
385·Netty权威指南(第2版)
中进行,每次读取操作完成之后,会对读取的字节数进行累加,代码如图16-85所示
if(totalReadAmount > Integer MAX VALUE -localReadAmount)(
∥ Avoid overflow
otalReadAmount Integer MAX VALUE
break.
totalReadAmount + localReadAmount:
图16-85 NioByteUnsafe的read方法代码片段10
在累加之前,需要对长度上限做保护,如果累计读取的字节数已经发生溢出,则将读
取到的字节数设置为整型的最大值,然后退出循环。原因是本次循环已经读取过多的字节
需要退出,否则会影响后面排队的Task任务和写操作的执行。如果没有溢出,则执行累
加操作。代码如图16-86所示。
if (localReadAmount writable)f
l Read less than what the buffer can hold
N which might mean we drained the recv buffer completely.
break-
图16-86 Nio Byte Unsafe的read方法代码片段Il
最后,对本次读取的字节数进行判断,如果小于缓冲区可写的容量,说明TCP缓冲
区已经没有就绪的字节可读,读取操作已经完成,需要退出循环。如果仍然有未读的消息
则继续执行读操作。连续的读操作会阻塞排在后面的任务队列中待执行的Task,以及写操
作,所以,要对连续读操作做上限控制,默认值为16次,无论TCP缓冲区有多少码流需
要读取,只要连续16次没有读完,都需要强制退出,等待下次 selector轮询周期再执行。
如图16-87所示。
y while(++ messages maxMessagesPerRead)
图16-87 NioByteUnsafe的read方法代码片段12
完成多路复用器本轮读操作之后,触发 ChannelRead Complete事件,随后调用接收缓
冲区容量分配器的 Hanlder的记录方法,将本次读取的总字节数传入到 record方法中进行
缓冲区的动态分配,为下一次读取选取更加合适的缓冲区容量,代码如图16-88所示。
pipeline. fire ChannelRead Complete(
allocHandle. record(totalReadAmount);
图16-88 Nio Byte Unsafe的read方法代码片段l3
上面我们提到,如果读到的返回值为-1,表明发生了LO异常,需要关闭连接,释放
·386第16章 Channe和 Unsafe
资源,代码如图16-89所示。
if (close)
closeonRead(pipeline)
close false
图16-89 Nio ByteUnsafe的read方法代码片段14
至此,请求消息的异步读取源码我们已经分析完成。
165总结
本章介绍了Ney最重要的接口之 Channel的设计原理和功能列表,并对其主要
实现子类 NioSocket Channel和 NioServerSocketchannel的源码进行了分析,涉及到了“半
包读”和“半包写”的相关知识。
由于 Channel的很多IO操作都是通过其内部聚合的 Unsafe接口及其子类实现的,如
果不清楚 Unsafe相关子类的代码实现,也就无法真正了解清楚 Channel的实现。因此本章
节对 Unsafe的相关实现也进行了源码分析。
事实上, Channel的实现子类还有很多,包括用于处理UDP的 DatagramChannel、用
于本地测试的 Embeddedchannel等。限于篇幅,本书无法对这些子类的功能和源码进行一
一枚举。感兴趣的读者可以通过阅读API文档、学习Demo和源码分析相结合的方式掌握
这些类库的使用。
387第17章
ChannelPipeline和
Channelhandler
Netty的 ChannelPipeline和( hanne handler机制类似于 Servlet和 Filter过滤器,这类
拦截器实际上是职责链模式的一种变形,主要是为了方便事件的拦截和用户业务逻辑的定
制。
Servlet Filter是 JEE Web应用程序级的Java代码组件,它能够以声明的方式插入到
HTTP请求响应的处理过程中,用于拦截请求和响应,以便能够查看、提取或以某种方式
操作正在客户端和服务器之间交换的数据。拦截器封装了业务定制逻辑,能够实现对web
应用程序的预处理和事后处理。
过滤器提供了一种面向对象的模块化机制,用来将公共任务封装到可插入的组件中。
这些组件通过web部署配置文件(web.xm1)进行声明,可以方便地添加和删除过滤器,
无须改动任何应用程序代码或JSP页面,由 Servlet进行动态调用。通过在请求/响应链中
使用过滤器,可以对应用程序(而不是以任何方式替代)的 Servlet或JSP页面提供的核
心处理进行补充,而不破坏 Servlet或JSP页面的功能。由于是纯Java实现,所以 Servlet
过滤器具有跨平台的可重用性,使得它们很容易被部署到任何符合 Servlet规范的JEE环
境中。第17章 Channel Pipeline和 ChannelHandler
Netty的 Channel过滤器实现原理与 Servlet filter机制一致,它将 Channel的数据管道
抽象为 ChannelPipeline,消息在 ChannelPipeline中流动和传递。 ChannelPipeline持有IO
事件拦截器 ChannelHandler的链表,由 Channelhandler对IO事件进行拦截和处理,可以
方便地通过新增和删除 Channelhandler来实现不同的业务逻辑定制,不需要对已有的
Channelhandler进行修改,能够实现对修改封闭和对扩展的支持
下面我们对 ChannelPipeline和 Channelhandler,以及与之相关的 ChannelhandlerContext
进行详细介绍和源码分析
本章主要内容包括:
ChannelPipeline功能说明
ChannelPipeline源码分析
Channelhandler功能说明
◎ Channelhandler源码分析
17.1 ChannelPipeline功能说明
Channelpipeline是 Channelhandler的容器,它负责 Channelhandler的管理和事件拦截
与调度
17.1.1 ChannelPipeline的事件处理
图17-1展示了一个消息被 ChannelPipeline的 Channelhandler链拦截和处理的全过程,
消息的读取和发送处理全流程描述如下。
(1)底层的 Socket Channel reado方法读取 Byte Buf,触发 Channel read事件,由lO
线程 NioEventLoop调用 Channelpipeline的 fire Channelread( Object msg)方法,将消息
( Byte Buf)传输到 ChannelPipeline中。
(2)消息依次被 Headhandler、 Channelhandler l、 Channelhandler2…… Tailhandler拦
截和处理,在这个过程中,任何 Channelhandler都可以中断当前的流程,结束消息的传递。
(3)调用 Channelhandlercontext的 write方法发送消息,消息从 TailHandler开始,途
389Net!y权威指南(第2版)
经 Channelhandlern… Channelhandlerl、 Headhandler,最终被添加到消息发送缓冲区中
等待刷新和发送,在此过程中也可以中断消息的传递,例如当编码失败时,就需要中断流
程,构造异常的 Future返回。
I/0 Request
via alink Channel3 or
telink ChannelHandlerContexty
Channelpipeline
Channelhandler N
channe hAndler N-1
ChannelHandlerContext. fireIN EVT() ChannelHandlerContext OUT EUT(I
I me thod callI
Lne thod callI
Channe handler 2
一一一一一一普一一一一一一一一一一非
ChannelHandler1
Socketread()]
[ Socket. write〔)
I Netty Internal I/0 Threads (Transport Implenentation)
图17- 1 ChannelPipeline对事件流的拦截和处理流程
Nety中的事件分为 inbound事件和 outbound事件 inbound事件通常由IO线程触发,
例如TCP链路建立事件、链路关闭事件、读事件、异常通知事件等,它对应图17-1的左
半部分。
触发 inbound事件的方法如下。
(1) ChannelHandlerContext. fire ChannelRegisteredo: Channel注册事件;
(2) ChannelHandler Context fire ChannelActiveO:TCP链路建立成功, Channel激活事件;
(3) ChannelhandlerContext. fire channelread( Object):读事件:
390·第17章 ChannelPipeline和 Channelhandler
(4) ChannelHandler Context fire ChannelRead Complete():读操作完成通知事件;
(5) ChannelHandlerContext. fire Exception Caught( Throwable):异常通知事件;
(6) ChannelHandler Context fireUser Event Triggered( Object):用户自定义事件
(7) ChannelHandlerContext. fire Channel Writability Changed(: Channel的可写状态变化
通知事件
(8) ChannelHandler Context fire Channellnactive():TCP连接关闭,链路不可用通知事件。
Outbound事件通常是由用户主动发起的网终ⅣO操作,例如用户发起的连接操作、绑
定操作、消息发送等操作,它对应图17-1的右半部分。
触发 outbound事件的方法如下:
(1) Channelhandlercontex.bind( Socketaddress, Channelpromise):绑定本地地址事件:
(2) ChannelHandler Context connect(SocketAddress, SocketAddress, ChannelPromise)
连接服务端事件
(3) ChannelhandlerContext. write( Object, ChannelPromise)}:发送事件;
(4) ChannelHandler Context.fush(:刷新事件;
(5) ChannelhandlerContext. read():读事件;
(6) ChannelhandlerContext. disconnect( ChannelPromise):断开连接事件
(7) ChannelhandlerContext. close( Channelpromise):关闭当前 Channel事件
17.1.2自定义拦截器
ChannelPipeline通过 Channelhandler接口来实现事件的拦截和处理,由于
Channelhandler中的事件种类繁多,不同的 Channelhandler可能只需要关心其中的某一个
或者几个事件,所以,通常 Channelhandler只需要继承 ChannelHandlerAdapter类覆盖自
已关心的方法即可。
例如,下面的例子展示了拦截 Channel Active事件,打印TCP链路建立成功日志,代
码如下。
391Nety权威指南(第2版)
public class MyInboundHandler extends Channe lHandlerAdapter i
oVerride
public void channelActive(ChannelHandlerContext ctx)
System. out.println("TCP connected! )i
ctx. fireChanne lActive()i
下面的例子展示了如何在链路关闭的时候释放资源,示例代码如下。
public class MyOutboundHandler extends ChannelHandlerAdapter
OVerride
public void close( ChannelHandlercontext ctx, Channel Promise promise)[
System, out, println("TCp closing ..")i
Object. release()i
ctx. Close(promise)i
17.1.3构建 pipeline
事实上,用户不需要自己创建 pipeline,因为使用 ServerBootstrap或者 Bootstrap启动
服务端或者客户端时,Nety会为每个 Channel连接创建一个独立的 pipeline。对于使用者
而言,只需要将自定义的拦截器加入到 pipeline中即可。相关的代码如下。
pipeline ch pipeline ()i
pipeline addLast(decoder", new My Decoder())i
pipeline, addLast(encoder", new My ProtocolEncoder())i
对于类似编解码这样的 Channelhandler,它存在先后顺序,例如 MessageToMessage
Decoder,在它之前往往需要有 Byte ToMessage Decoder将 Byte Buf解码为对象,然后对对
象做二次解码得到最终的POJO对象。 Pipeline支持指定位置添加或者删除拦截器,相关
接口定义如图172所示。
addBefore(StringString CharnelHandler): Channel Pipeline
e addBefore (EventErecutorGroup, Strint String ChannelHandler): Channelfipeline
addBefore(ChannelHandarInvoker, String Strinz ChannelHandler ), ChannelPipeline
e addAfter (String Strint CharnelHandler) ChannelPipeline
addifter CventEx ector Group, String. String ChannelHandler): ChannelPipeline
e addAfter (ChannelHandlerInvoker, StringString ChannelHandler): ChannelPipeline
图17-2按顺序添加 Channelhandler
392第17章 ChannelPipeline和 ChannelHandler
17.14 ChannelPipeline的主要特性
ChannelPipeline支持运行态动态的添加或者删除 Channelhandler,在某些场景下这个特
性非常实用。例如当业务高峰期需要对系统做拥塞保护时,就可以根据当前的系统时间进行
判断,如果处于业务高峰期,则动态地将系统拥塞保护 Channelhandler添加到当前的
Channelpipeline中,当高峰期过去之后,就可以动态删除拥塞保护 Channelhandler了。
ChannelPipeline是线程安全的,这意味着N个业务线程可以并发地操作 ChannelPipeline
而不存在多线程并发问题。但是, Channelhandler却不是线程安全的,这意味着尽管
ChannelPipeline是线程安全的,但是用户仍然需要自己保证 Channelhandler的线程安全
172 ChannelPipeline源码分析
Channel Pipeline的代码相对比较简单,它实际上是一个 Channelhandler的容器,内部
维护了一个 Channelhandler的链表和迭代器,可以方便地实现 Channelhandler查找、添加、
替换和删除
17.2.1 ChannelPipeline的类继承关系图
Channelpipeline的类继承关系比较简单,如图17-3所示。
Iterable
I ChannelPipeline
C Default ChannelPipeline
图173 ChannelPipeline类继承关系图
1722 ChannelPipeline对 Channelhandler的管理
ChannelPipeline是 Channelhandler的管理容器,负责 Channelhandler的查询、添加
替换和删除。由于它与Map等容器的实现非常类似,所以我们只简单抽取新增接口进行
393·Netty权威指南(第2版)
源码分析,其他方法读者可以自行阅读和分析。在 Channelpipeline中添加 ChannelHandler
方法如图17-4所示
@override
public ChannelPipeline add Before(String baseName, String name
ChannelHandler handler)i
return add Before((ChannelHandlerInvoker)null, base Name, name, handler).
图174 ChannelPipeline添加 Channelhandler方法
直接调用 add Before( Channelhandlerlnvoker invoker, String basename, final String name,
Channelhandler handler)方法,代码如图17-5所示
override
public ChannelPipeline addBefore(
ChannelHandlerInvoker invoker, string base Name, final string name
ChannelHandler handler]t
synchronized (this)i
Default ChannelHandlercontext ctx get ContextorDie(base Name):
check DuplicateName(name):
DefaultChannelHandler Context new Ctx=
new Default ChannelHandler Context(this, invoker, name, handler);
add Before D(name. ctx, newctx)
return this
图17-5 Channelpipeline的 add Before方法
由于 ChannelPipeline支持运行期动态修改,因此存在两种潜在的多线程并发访问场景。
③I/O线程和用户业务线程的并发访问;
◎用户多个线程之间的并发访问。
为了保证 ChannelPipeline的线程安全性,需要通过线程安全容器或者锁来保证并发访
问的安全,此处 Netty直接使用了 synchronized关键字,保证同步块内的所有操作的原子
性。首先根据 baseN ame获取它对应的 Default channelHandler Context, Channelpipeline维
护了 Channelhandler名和 ChannelHandlerContext实例的映射关系,代码如图17-6所示。
@override
public ChannelHandlerContext context(String name)(
if(name = null)(
throw new NullPointerException name)
synchronized (this)f
return name2ctx get(name):
图17-6 ChannelPipeline的 context方法
·394·第17章 ChannelPipeline和 Channelhandler
对新增的 Channelhandler名进行重复性校验,如果已经有同名的 Channelhandler存在,
则不允许覆盖,抛出 IllegalArgumentException(" Duplicate handler name:"+name)异常。校
验通过之后,使用新增的 Channelhandler等参数构造一个新的 DefaultchannelhandlerContext
实例,代码如图17-7所示。
DefaultchannelHandlerContext
DefaultChannelPipeline pipeline, ChannelHandlerInvoker invoker, string
name, ChannelHandler handler)(
if(name = null)[
throw new NullPointerEXception("name")
if(handler == null)(
throw new Null Pointer Exception(handler")
channel= pipeline. channel
this pipeline pipeline
this name name:
this handler handler:
skipFlags= skipFlags(handler);
if (invoker = null)(
this, invoker channel unsafe().invoker(
s else
this invoker invoker.
图17-7构造新的 Default channelhandlerContext实例
将新创建的 Defaultchannelhandlercontext添加到当前的 pipeline中,代码如图17-8
所示
private void add Beforeo(final String name, DefaultchannelHandlerContext ctx
Defaultchanne Handler Context newCtx)i
checkMultiplicity(newCtx)
newCt prev ctxprev
newCtx next ctx
ctx prev next= newctx
ctx. prey new Ctx
name2ctx. put(name, newctx)
callHandler Added(newCtx)
图17-8添加 DefaultchannelhandlerContext到 pipeline
首先需要对添加的 ChannelhandlerContext做重复性校验,校验代码如图17-9所示。
395·Nety权威指南(第2版)
如果 ChannelHandlerContext不是可以在多个 ChannelPipeline中共享的,且已经被添
加到 ChannelPipeline中,则抛出 ChannelPipelineException异常。 Handler指针修改如图17-10
所
private static void checkMultiplicity( ChannelHandlerContext ctx)(
ChannelHandler handler= ctx. handler(
if(handler instanceof Channel HandlerAdapter)(
ChannelHandler Adapter h=( ChannelHandlerAdapter) handler;
if (h is Sharable()&&h added)
throw new ChannelPipeline Exception(
h, getclass(, getName(+
is not a @Sharable handler, so can 't be added or removed
multiple times. )
h, added true
图17-9 Channelhandlercontext重复性校验
新增之前
prev
next
prev
next
prev
next
新增之后:
rev
nex t
prev
next
司prev
next
pre
NEW
next
图17-10 ChannelHandlerContext位置指针迁移图
加入成功之后,缓存 Channelhandlercontext,发送新增 Channelhandlercontext通知
消息
17.23 ChannelPipeline的 inbound事件
当发生某个ⅠO事件的时候,例如链路建立、链路关闭、读取操作完成等,都会产生
个事件,事件在 pipeline中得到传播和处理,它是事件处理的总入口。由于网络1O相
关的事件有限,因此Nety对这些事件进行了统一抽象,Ney自身和用户的 Channelhandler
会对感兴趣的事件进行拦截和处理。
396·第17章 ChannelPipeline和 ChannelHandler
f、 ipeline中以 fireXXX命名的方法都是从IO线程流向用户业务 Handler的 I inbound事
它们的实现因功能而异,但是处理步骤类似,总结如下
(1)调用 Headhandler对应的 fireXXx方法;
(2)执行事件相关的逻辑操作。
以 fire Channelactive方法为例,调用head. fireChannelActive(之后,判断当前的 Channel
配置是否自动读取,如果为真则调用 Channel的read方法,代码如图17-11所示。
@override
public ChannelPipeline fire ChannelActive f
head. tirechannelActive(
if (channeL. config(). isAuto Reado)(
channel. read
return this
图17-1 fire Channelactive方法
1724 ChannelPipeline的 outbound事件
由用户线程或者代码发起的1/O操作被称为 outbound事件,事实上 inbound和 outbound
是Nety自身根据事件在 pipeline中的流向抽象出来的术语,在其他NIO框架中并没有这
个概念
inbound事件相关联的操作如图17-12所示。
● bind (socket点ddre53): Charnelfsture
9a connect (SocketAddress): ChannelFuture
Oa connect (SocketAddress. SocketAddress) ChannelFuture
ea di sconnecto: Channelfut1
Qo close. ChannelFyttr'e
●△ flush(: ChannelPipeline
Oa bind (SocketAddress, Channelfromise]: Channel Future
ea connect (SocketAddress, ChannelPromise), ChannelFuture
Oa connect (ocketAddress, SocketAddress. ChannelPromise): Channelfutare
●△ disconnect〔 hannalfrontee) Chanto1 Futur
●c1心[ hanne1 Pronise): Chanhe1Ftue
●△ read O: Channel1pe1ine
命△ write(Object): Channelfuttre
@a write(Object, ChanmelPronise) ChannelPuture
Oa writeAndFlush (Object, ChannelPromise): ChannelPuture
A wri teAndFlush (Object) Channel Future
图17-12 in bound事件相关方法
397Netty权威指南(第2版
Pipeline本身并不直接进行WO操作,在前面对 Channel和 Unsafe的介绍中我们知道
最终都是由 Unsafe和 Channel来实现真正的1/O操作的。 Pipeline负责将IO事件通过
TailHandler进行调度和传播,最终调用 Unsafe的I/O方法进行IO操作,相关代码实现如
图17-13所示
override
public ChannelFuture connect(socketAddress remoteAddress
SocketAddress localAddress)i
return tail. connect(remote Address, localAddress):
图17-13 pipeline的客户端连接操作
它直接调用 TailHandler的 connect方法,最终会调用到 Headhandler的 connect方法,
代码如图17-14所示。
override
public void connect(
ChannelhandlerContext ctx
Socketaddress remote Address. socketaddress localaddress
ChannelPromise promise)throws Exception t
unsafe. connect(remote Address, localAddress, promise)
图17-14 Head Handler的 connect方法
最终由 Headhandler调用 Unsafe的 connect方法发起真正的连接, pipeline仅仅负责
事件的调度。
17.3 ChannelHandler功能说明
ChannelHandler类似于 Servlet的 Filter过滤器,负责对I/O事件或者1O操作进行拦
截和处理,它可以选择性地拦截和处理自已感兴趣的事件,也可以透传和终止事件的传递。
基于 Channelhandler接口,用户可以方便地进行业务逻輯定制,例如打印日志、统
封装异常信息、性能统计和消息编解码等。
Channelhandler支持注解,目前支持的注解有两种。
◎ Sharable;多个 Channelpipeline共用同一个 Channelhandler;
◎Skip:被Skp注解的方法不会被调用,直接被忽略。
398·第17章 ChannelPipeline和 Channelhand|er
17.3.1 ChannelHandlerAdapter功能说明
对于大多数的 Channelhandler会选择性地拦截和处理某个或者某些事件,其他的事件
会忽略,由下一个 Channelhandler进行拦截和处理。这就会导致一个问题:用户
Channelhandler必须要实现 Channelhandler的所有接口,包括它不关心的那些事件处理接
口,这会导致用户代码的冗余和臃肿,代码的可维护性也会变差。
为了解决这个问题,Nety提供了 ChannelHandler Adapter基类,它的所有接口实现都
是事件透传,如果用户 Channelhandler关心某个事件,只需要覆盖 ChannelHandlerAdapter对
应的方法即可,对于不关心的,可以直接继承使用父类的方法,这样子类的代码就会非常简
洁和清晰。前面几章样例代码中,我们的 Channelhandler都是直接继承自 Channelhandler
Adapter,开发起来非常简单和高效。
ChannelHandler Adapter相关的代码实现如图17-15所示。
@skip
oVerride
public void read(ChannelHandlercontext ctx) throws Exception f
ctx reado
@skip
@override
public void write( ChannelHandler Context ctx, Object msg, ChannelPromise
promise)throws Exception
ctx. write( msg, promise:
图17-15 ChannelHandlerAdapter源码
从图17-15的源码中我们发现这些透传方法被@Skip注解了,这些方法在执行的过程
中会被忽略,直接跳到下一个 ChannelHandler中执行对应的方法。
17.32 Byte ToMessage Decoder功能说明
利用NIO进行网络编程时,往往需要将读取到的字节数组或者宇节缓冲区解码为业务
可以使用的POJO对象。为了方便业务将 Byte Buf解码成业务POJO对象, Netty提供了
Byte ToMessageDecoder抽象工具解码类。
用户的解码器继承 Byte ToMessageDecoder,只需要实现 void decode( Channelhandler
Context ctx, Byte Buf in,List< Object>out)抽象方法即可完成 ByteBuf到POJO对象的解码。
·399·Netty权威指南(第2版)
由于 Byte ToMessage Decoder并没有考虑TCP粘包和组包等场景,读半包需要用户解
码器自己负责处理。正因为如此,对于大多数场景不会直接继承 Byte ToMessageDecoder,
而是继承另外一些更高级的解码器来屏蔽半包的处理,下面的小节我们会对它们进行一
介绍。
17.33 Message ToMessageDecoder功能说明
Message ToMessageDecoder实际上是Nety的二次解码器,它的职责是将一个对象二
次解码为其他对象。
为什么称它为二次解码器呢?我们知道,从 SocketChannel读取到的TCP数据报是
Byte Buffer,实际就是字节数组,我们首先需要将 ByteBuffer缓冲区中的数据报读取出来,
并将其解码为Java对象:然后对Java对象根据某些规则做二次解码,将其解码为另一个
POJO对象。因为 Message ToMessage Decoder在 Byte ToMessage Decoder之后,所以称之为
二次解码器。
二次解码器在实际的商业项目中非常有用,以HTTP+XML协议栈为例,第一次解码
往往是将字节数组解码成 Http request对象,然后对 Httprequest消息中的消息体字符串进
行二次解码,将XML格式的字符串解码为POJO对象,这就用到了二次解码器。类似这
样的场景还有很多,不再一一枚举
事实上,做一个超级复杂的解码器将多个解码器组合成一个大而全的 Message To
8 Decoder解码器似乎也能解决多次解码的间题,但是采用这种方式的代码可维护性
会非常差。例如,如果我们打算在HTTP+XML协议栈中增加一个打印码流的功能,即首
次解码获取 Httprequest对象之后打印XML格式的码流。如果采用多个解码器组合,在中
间插入一个打印消息体的 Handler即可,不需要修改原有的代码;如果做一个大而全的解
码器,就需要在解码的方法中增加打印码流的代码,可扩展性和可维护性都会变差。
用户的解码器只需要实现 void decode( Channelhandler Context ctx,Imsg,List< Object>
out)抽象方法即可,由于它是将一个POJO解码为另一个POJO,所以一般不会涉及到半包
的处理,相对于 Byte Decoder更加简单些。
17.3.4 Length Field Based Frame Decoder功能说明
在编解码章节我们讲过TCP的粘包导致解码的时候需要考虑如何处理半包的问题,
400第17章 Channel Pipeline和 Channelhandler
前面介绍了Nety提供的半包解码器 LineBased frameDecoder和 Delimiter based frame Decoder,
现在我们继续学习第三种最通用的半包解码器— -Length FieldBased Frame Decoder。
如何区分一个整包消息,通常有如下4种做法。
◎固定长度,例如每120个字节代表一个整包消息,不足的前面补零。解码器在处
理这类定常消息的时候比较简单,每次读到指定长度的字节后再进行解码。
◎通过回车换行符区分消息,例如FTP协议。这类区分消息的方式多用于文本协议。
◎通过分隔符区分整包消息。
◎通过指定长度来标识整包消息。
如果消息是通过长度进行区分的, Length FieldBasedFrame Decoder都可以自动处理粘
包和半包问题,只需要传入正确的参数,即可轻松搞定“读半包”问题。
下面我们看看如何通过参数组合的不同来实现不同的“半包”读取策略。第一种常用
的方式是消息的第一个字段是长度字段,后面是消息体,消息头中只包含一个长度字段。
它的消息结构定义如图17-16所示。
Length I Actual Content
JX S90CHELLU, WORLD
图17-16解码前的字节缓冲区(14字节)
使用以下参数组合进行解码。
o length FieldOffset=0:
o length FieldLength =2
o lengthAdjustment=0;
o initialBytesToStrip=0
解码后的字节缓冲区内容如图17-17所示。
Le
ng
Actual content
HELLO WORLD
图17-17包含消息长度字段(14字节)
401·Net!y权威指南(第2版)
因为通过 ByteBuf. readableByteso方法我们可以获取当前消息的长度,所以解码后的
字节缓冲区可以不携带长度字段,由于长度字段在起始位置并且长度为2,所以将
initial Bytes To Strip设置为2,参数组合修改为
o length FieldOffset=0
o length FieldLength =2
O lengthAdjustment=0
o initial Bytes ToStrip= 2
解码后的字节缓冲区内容如图17-18所示。
Actual Content
HELLO. WORLD
图17-18仅包含消息体(12字节)
从图17-18的解码结果看,解码后的字节缓冲区丢弃了长度字段,仅仅包含消息体,
不过通过 Byte Buf readable Bytes(方法仍然能够获取到长度字段的值。
在大多数的应用场景中,长度仅用来标识消息体的长度,这类协议通常由消息长度字
段+消息体组成,如图17-18所示的例子。但是,对于一些协议,长度还包含了消息头的
长度。在这种应用场景中,往往需要使用 lengthAdjustment进行修正,修正后的参数组合方
式如下。由于整个消息的长度往往都大于消息体的长度,所以, length Adjustment为负数,
图17-19展示了通过指定 length Adjustment字段来包含消息头的长度。
o length Fieldoffset=0
O length Field Length=2;
o lengthAdjustment =-2
③ initial Bytes ToStrip=0。
解码前〔1tes)
解码后〔
14 bytes)
画==
Length
Actua content
Length Actual content
x目BEI"HELL0, WORLD
0x"HELLO. WORLD
图17-19包含消息头长度的解码
402第17章 ChannelPipeline和 ChannelHandler
由于协议种类繁多,并不是所有的协议都将长度字段放在消息头的首位,当标识消息
长度的字段位于消息头的中间或者尾部时,需要使用 length FieldOffset字段进行标识,下
面的参数组合给出了如何解决消息长度字段不在首位的问题
O length FieldOffset= 2
o length FieldLength =3:
o lengthAdjustment=0:
o initial Bytes To Strip=0
解码前(17 bytes)
解码后(17btes
I Header 1
Length
Actual Content ----- Header 1 Length Actual Content
I 5x CAFE I UX00000 I"HELLO, WORLD
SxCAFE 0x 65806C HELLO, WORLD
图17-20通过定义长度偏移量解决长度字段不在首位的问题
由于消息头1的长度为2,所以长度字段的偏移量为2;消息长度字段 Length为3,
所以 length FieldLength值为3。由于长度字段仅仅标识消息体的长度,所以 length Adjustment
和 initialBytes ToStrip都为0。
最后一种场景是长度字段夹在两个消息头之间或者长度字段位于消息头的中间,前后
都有其他消息头字段,在这种场景下如果想忽略长度字段以及其前面的其他消息头字段
则可以通过 initialBytesToStrip参数来跳过要忽略的字节长度,它的组合效果如下。
◎ length fieldoffset=l
o length FieldLength= 2:
o lengthAdjustment= I
initial Bytes To Strip=3o
解码前(16btes
解码后【13btes)
HDR1 I Length I HDR2 I Actual Content
)1 HDR2 I Actual Content
Ox CA 5x 086C OxFE I"HELLO, WORLD
KFE|“"HELL0, WORLD
图17-21 initial ytes ToStrip参数的使用
首先,由于HDR1的长度为1,所以长度字段的偏移量 lengthFieldOffset为1;长度字
403Net!权威指南(第2版)
段为2个字节,所以 length FieldLength为2。由于长度字段是消息体的长度,解码后如果
携带消息头中的字段,则需要使用 length Adjustment进行调整,此处它的值为1,表示的
是HDR2的长度,最后由于解码后的缓冲区要忽略长度字段和HDR1部分,所以
ength Adjustment为3。解码后的结果为13个字节,HDR1和 Length字段被忽略。
事实上,通过4个参数的不同组合,可以达到不同的解码效果,用户在使用过程中可
以根据业务的实际情况进行灵活调整。
由于TCP存在粘包和组包问题,所以通常情况下必须自己处理半包消息。利用
Length Field Based Frame Decoder解码器可以自动解决半包问题,它通常的用法如下。
pipeline addlast ("frame Decoder", new LineBasedFrame Decoder(80))i
pipeline addlast("stringDecoder", new string Decoder(Charsetutil UTF 8))i
在 pipeline中增加 Line Based Frame Decoder解码器,指定正确的参数组合,它可以将
Nety的 Byte Buf解码成单个的整包消息,后面的业务解码器拿到的就是个完整的数据报,
正常进行解码即可,不再需要额外考虑“读半包”问题,方便了业务消息的解码。
1735 Message ToByte Encoder功能说明
Message To ByteEncoder负责将POJO对象编码成 ByteBuf,用户的编码器继承 Message
ToByte Encoder,实现 void encode( ChannelhandlerContext ctx,Imsg, Byte Buf out)接口接口,
示例代码如下。
public class IntegerEncoder extends MessageToByteEncoder<Integer> I
@override
public void encode( ChannelHandlerContext ctx, Integer msg, ByteBuf out)
throws Exception
out writeln(msg);
17.3.6 Message ToMessage Encoder功能说明
将一个POJO对象编码成另一个对象,以HTTP+XML协议为例,它的一种实现方式
是:先将POJO对象编码成ⅹML字符串,再将字符串编码为HTTP请求或者应答消息。
对于复杂协议,往往需要经历多次编码,为了便于功能扩展,可以通过多个编码器组合来
404第17章 ChannelPipeline和 ChannelHandler
实现相关功能。
用户的解码器继承 Message ToMessage Encoder解码器,实现 void encode( Channel
Handler context ctx,Imsg,List< Object>out)方法即可。注意,它与 Message ToByteEncoder
的区别是输出是对象列表而不是 Byte Buf,示例代码如下。
public class IntegerTostringEncoder extends MessageToMessageEncoder <Integer>
override
public void encode(ChannelHandler Context ctx, Integer message,
List<object> out)
throws Exception
out. add (message toString())i
17.37 Length FieldPrepender功能说明
如果协议中的第一个字段为长度字段,Nety提供了 Length FieldPrepender编码器,它可以
计算当前待发送消息的二进制字节长度,将该长度添加到 Byte Buf的缓冲区头中,如图17-22
所示。
编码前(12btes)
编码后(14btes)
HELLO. WORLD'
〉+匪 *908C I“HELL0, WORLD
图17-22 Length Field Prepender编码器
通过 Length FieldPrepender可以将待发送消息的长度写入到 Byte Buf的前2个字节,
编码后的消息组成为长度字段+原消息的方式。
通过设置 LengthFieldPrepender为true,消息长度将包含长度本身占用的字节数,打
开 Length FieldPrepender后,图17-22示例中的编码结果如图17-23所示。
编码前(12 bytes)
编码后(14 bytes)
HELL0,wRLD|-----〉+Bκ8眺E|"HELL0, WORLD"I
一一一一一一一一一一善
图17-23打开 Length Field Prepender开关后的编码结果
·405·Net权威指南(第2版)
17.4 Channelhandler源码分析
174.1 Channelhand|er的类继承关系图
相对于 Byte Buf和 Channel, Channelhandler的类继承关系稍微简单些,但是它的子
类非常多。由于 Channelhandler是Nety框架和用户代码的主要扩展和定制点,所以它的
子类种类繁多、功能各异,系统 Channelhandler主要分类如下。
◎ Channelpipeline的系统 Channelhandler,用于ⅣO操作和对事件进行预处理,对
于用户不可见,这类 Channelhandler主要包括 HeadHandler和 TailHandler;
◎编解码 Channelhandler,包括 Byte ToMessage Codec、 Message Decoder
等,这些编解码类本身又包含多种子类,如图17-24所示。
EC MessageIoByt eNcoder<I>-io netty handler codec
⊙【ptMx]dth山,odes1
CompatibleObjectEncoder-io. netty handler codec serialization
Encoder -40netty. handler codec, Byter oessagecodec
C MarshallingEncoder-ionetty handler codec marshalling
C NettyMessageEncoder -com phei netty protocol netty, codec
C NumberEd
io, netty. example. ft
actorS
C ObjeetEneoder-io, netty handler. codee, serialization
c Protobufvarint32LengthPieldPrepender-io netty handler codec. protabuf
C SnappyFr amedEncoder-1o netty handler codec. compression
C SocksMessageEncoder-io netty handler codec. socks
C SpdyFram eEneader-io, netty handler. eodee spdy
E-C ZlibEncoder-io netty handler, codec compressi on
C JakzlibEncoder-io. netty. handler codee, compression
oJzLibencoder-io.netty.hander.cadec.compression
B-CA Messager oMessageCo INBOUND_IN, OUTBOUND IN>-io netty handler,codec
CA Htt
eNcoder"io netty handl
dee.http
CHttpcontentcoMpressor-io.nettyhandlercodechttp
GspDyhttpresponSestreamiahAndler-io.nettyhandlercodecspdy
4t-CMessageToessagelecoder <>-io netty handler codec
ToMessageEncoder<>-i0 netty. handler, codec
图17-24编解码 Channel handler
◎其他系统功能性( hannelhandler,包括流量整型 Handler、读写超时 Handler、日
志 Handler等
本章节仅给出讲解到的编解码类,其他不再一一枚举。
406·第17章 Channel Pipeline和 Channelhandler
a ChannelHandlerAdapter
CA Message ToByteEncoder
A ByteToMessage Decoder cA MessageToMessageDecod
Message ToMessage Encoder
Length FieldBased FrameDecoder
图17-24编解码 Channelhandler子类继承关系图
174.2 Byte ToMessage Decoder源码分析
顾名思义, Byte ToMessageDecoder解码器用于将 ByteBuf解码成POJO对象,下面
起看它的实现。
首先看 channelLed方法的源码,如图17-25所示。
@overrid
public void channelRead(ChannelHandler Context ctx, Object msg) throws
Exception i
if(msg instanceof Byte Buf)i
RecyclableArrayList out- RecyclableArrayList newInstance(
ByteBuf data =(ByteBuf) msg:
first cumulation == null:
if (first)I
cumulation data:
) else
if (cumulation. writerIndex()> cumulation. max Capacity(
data readable Bytes()i
expand Cumulation(ct, data readable Bytes()
cumulation writeBytes(data)
data release(
callDecode(ctx, cumulation, out)
图17-25 Byte ToMessage Decoder的 channelEd方法
首先判断需要解码的msg对象是否是 Byte Buf,如果是 Byte Buf才需要进行解码,否
则直接透传。
通过 cumulation是否为空判断解码器是否缓存了没有解码完成的半包消息,如果为
空,说明是首次解码或者最近一次已经处理完了半包消息,没有缓存的半包消息需要处
407Nety权威指南(第2版)
理,直接将需要解码的 Byte Buf赋值给 cumulation;如果 cumulation缓存有上次没有解
码完成的 Byte Buf,则进行复制操作,将需要解码的 Byte Buf复制到 cumulation中,它
的原理如下
半包解码前:(半包消息1= cumulation readable Bytes()
半包消息1可写的缓冲区
半包解码后:(半包消息2= msg.readableBytesO)
半包消息1
半包消息2
整包消息
在复制之前需要对 cumulation的可写缓冲区进行判断,如果不足则需要动态扩展,扩
展的代码如图17-26所示。
private void expandCumulation( ChannelHandlerContext ctx, int readable)(
Byte Buf oldcumulation cumulation
cumulation = ctx alloc(). buffer(old Cumulation readable Bytes(+ readable)
cumulation write Bytes(old Cumulation):
old Cumulation release(
图17-26 Byte ToMessageDecoder的 expandCumulation方法
扩展的代码很简单,利用字节缓冲区分配器重新分配一个新的 ByteBuf,将老的
cumulation复制到新的 ByteBuf中,释放 cumulation。需要注意的是,此处内存扩展没有
采用倍增或者步进的方式,分配的缓冲区恰恰够用,此处的算法可以优化下,以防止连续
半包导致的频繁缓冲区扩张和内存复制。
复制操作完成之后释放需要解码的 ByteBuf对象,调用 callDecode方法进行解码,代
码如图17-27所示
对 Byte Buf进行循环解码,循环的条件是解码缓冲区对象中有可读的字节,调用抽象
decode方法,由用户的子类解码器进行解码,方法定义如图17-28所示。
解码后需要对当前的 pipeline状态和解码结果进行判断,代码如图17-29所示。
408·第17章 Channel Pipeline和 Channelhandler
protected void callDecode(Channe Context ctx, Byte Buf in,
Listcobje
t)(
try I
while(in is Readable()(
int outSize out, size()
int oldInputLength =in readableBytes(
decode( ctx, in, out)
if(ctx is Removed()(
break.
图17-27 Byte ToMes sage Decoder的 callDecode方法
protected abstract void decode( Channe lHandlerContext ctx, Byte Buf in
List<object> out throws Exception
图17-28 Byte To MessageDecoder的 decode抽象方法
if (outSize = out size)I
if (oldInputLength = in readableByteso)
break:
else
if (oldInputLength ==in, readable Bytes))[
throw new Decoder Exception
StringUtil. simple className(getclass()+
decode()did not read anything but decoded a message.
if (isSingleDecode ())I
break.
图17-29 ByteToMessage Decoder的 callDecode方法
如果当前的 Channelhandlerconteκt已经被移除,则不能继续进行解码,直接退出循环
如果输出的out列表长度没变化,说明解码没有成功,需要针对以下不同场景进行判断
1)如果用户解码器没有消费 Byte Buf.,则说明是个半包消息,需要由ⅣO线程继续
读取后续的数据报,在这种场景下要退出循环。
2〕如果用户解码器消费了 Byte Buf,说明可以解码可以继续进行。
从图17-29所示代码可以看出,业务解码器需要遵守Nety的某些契约,解码器才能
正常工作,否则可能会导致功能错误,最重要的契约就是:如果业务解码器认为当前的字
节缓冲区无法完成业务层的解码,需要将 readIndex复位,告诉Net解码条件不满足应当
退出解码,继续读取数据报
(3)如果用户解码器没有消费 Byte Buf,但是却解码出了一个或者多个对象,这种行
为被认为是非法的,需要抛出 DecoderException异常。
(4)最后通过 isSingleDecode进行判断,如果是单条消息解码器,第一次解码完成之
409·Nety权威指南(第2版)
后就退出循环。
174.3 Message ToMessage Decoder源码分析
essageToMessageDecoder负责将一个POJO对象解码成另一个POJO对象,下面
起看下它的源码实现。
首先看 channelLed方法的源码,如图17-30所示
先通过 Recyclable Array List创建一个新的可循环利用的 Recyclable Array List,然后对
解码的消息类型进行判断,通过类型参数校验器看是否是可接收的类型,如果是则校验通
过,参数类型校验的代码如图17-31所示。
校验通过之后,直接调用 decode抽象方法,由具体实现子类进行消息解码,解码抽
象方法定义如图17-32所示。
解码完成之后,调用 Reference CountUtil的 release方法来释放被解码的msg对象。
如果需要解码的对象不是当前解码器可以接收和处理的类型,则将它加入到
Recyclable Array List中不进行解码。
oVerride
public void channel Read(ChannelHandlerContext ctx, Object msg )throws
Exception t
RecyclableArrayList out= RecyclableArrayList newInstance()
if(accept bound Message(msg))
@SuppressWarnings(unchecked)
cast=(m
try t
decode(ctx, cast, out
1 finally
Reference CountUtil release(cast)
out. add(msg):
)catch(DecoderException e)(
throw e
)catch(Exception e)I
throw new Decoder Exception(e):
y finally
int size out sized)
for(int i=0; i< size: i++)
ctx. fire Read(out.get(O)
out. recycled
图17-30 Message ToMessage Decoder的 channelread方法
410第17章 ChannelPipeline和 Channelhandler
public boolean acceptinboundMessage(Object msg) throws Exception
return matcher match(msg);
图17-3 Message Decoder的参数校验
protected abstract void decode( ChannelHandlerContext ct, I msg, List<object>
out) throws Exception:
图17-32 Message ToMessage Decoder的抽象 decode方法定义
最后,对 RecyclableArrayList进行遍历,循环调用 ChannelHandlerContext的
fire ChannelRead方法,通知后续的 Channelhandler继续进行处理。循环通知完成之后,通
过 recycle方法释放 Recyclable Array List对象。
174.4 LengthFieldBasedFrame Decoder源码分析
本节我们一起来学习最通用和重要的解码器——基于消息长度的半包解码器,首先看
它的入口方法,源码如图17-33所示。
@override
protected final void decode(ChannelHandler Context ctx, Byte Buf in
List<Object> out)throws Exception I
Object decoded =decode(ctx, in)
if (decoded I=null)
out. add (decoded)
图17-33 Length Field Based FrameDecoder的 decode方法
调用内部的 decode( ChannelHandler Context ctx, Byte Buf in)方法,如果解码成功,将其
加入到输出的 List<object>out列表中。
下面继续看 decode( ChannelHandlerContext ctx, ByteBuf in)的实现,如图17-34所示
protected Object decode( channelHandler Context ctx, Byte Buf in) throws
Exception
if(discarding TooLong Frame)(
long bytesToDiscard=this, bytes ToDiscard
int localBytes ToDiscard =(int)Math, min(bytes To Discard,
in. readableBytes()
in skip Bytes(local Bytes ToDiscard)
bytes ToDiscard-=localBytes ToDiscard
this bytes ToDiscard bytesToDiscard
faillfNecessary(false)
图17-34 LengthField Based Frame Decoder的 decode方法片段1
411·Nety权威指南(第2版)
真点断 discarding TooLong Frame标识,看是否需要丢弃当前可读的字节缓冲区,如果为
则执行丢弃操作,具体如下。
判断需要丢弃的字节长度,由于丢弃的字节数不能大于当前缓冲区可读的字节数,所
以需要通过 Math. min( bytes ToDiscard,in. readable Bytes(函数进行选择,取 bytes ToDiscard和
缓冲区可读字节数之中的最小值。计算获取需要丢弃的字节数之后,调用 Byte Buf的
skip Bytes方法跳过需要忽略的字节长度,然后 bytes ToDiscard减去已经忽略的字节长度。
最后判断是否已经达到需要忽略的字节数,达到的话对 discarding TooLong Frame等进行置
位,代码如图17-35所示。
private void faillfNecessary (boolean first DetectionOfTooLong Frame)(
if (bytes ToDiscard -=0)t
l Reset to the initial state and tell the handlers that
/ the frame was too large
long tooLongFrameLength=this tooLong FrameLength
this tooLong FrameLength =0
discarding Too longFrame false
if(fal|Fast‖l
failFast & firstDetectionofTooLongFrame)[
fail( tooLong FrameLength);
else
l Keep discarding and notify handlers if necessary.
if (failFast & firstDetectionOf TooLong Frame)
fail(tooLong FrameLength)
图17-35 LengthField Based frame Decoder的 faillfNecessary方法
对当前缓冲区的可读字节数和长度偏移量进行对比,如果小于长度偏移量,则说明当
前缓冲区的数据报不够,需要返回空,由IO线程继续读取后续的数据报。如图17-36所
if (in readableBytes(<lengthFieldEndoffset)(
return null
int actualLength Fieldoffset =in readerlndex(+ length FieldOffset
long frameLength getUnadjusted FrameLength(in
actualLengthFieldOffset, lengthFieldLength, byteorder):
图17-36 Length Field Based Frame Decoder的 decode方法片段2
通过读索引和 length Fieldoffset计算获取实际的长度字段索引,然后通过索引值获取
消息报文的长度字段,代码如图17-37所示。
·412·第17章 ChannelPipeline和 Channelhandler
根据长度字段自身的字节长度进行判断,共有以下6种可能的取值。
◎长度所占字节为1,通过 Byte Buf的 getUnsigned Byte方法获取长度值;
长度所占字节为2,通过 ByteBuf的 getUnsignedshort方法获取长度值;
protected long getUnadjustedFrameLength(ByteBuf buf, int offset, int length
Byte Order order)[
buf buf order(order)
long frame Length
switch(length)(
1:
frameLength buf getUnsignedByte offset)
break.
case
2
frameLength buf getUnsignedshort(offset):
break
case 3:
frameLength buf get UnsignedMedium(offset)
break
case 4
frameLength= buf. getUnsignedInt(offset):
break
ase
8
frameLength buf getLong(offset):
break.
default
throw new Decoder Exception(
unsupported lengthFieldLength: lengthFieldLength
(expected: 1, 2, 3, 4, or 8)")
return frameLength
图17-37 Length Field BasedFrame Decoder的 getUnadjusted FrameLength方法
◎长度所占字节为3,通过 Byte Buf的 get UnsignedMediun方法获取长度值;
◎长度所占字节为4,通过 Byte Buf的 get UnsignedInt方法获取长度值;
◎长度所占字节为8,通过 Byte Buf的 geeLong方法获取长度值
◎其他长度不支持,抛出 DecoderException异常。
获取长度之后,就需要对长度进行合法性判断,同时根据其他解码参数进行长度调整,
代码如图17-38所示
413Nety权威指南(第2版)
if (frameLength <0)[
in skip Bytes(lengthFieldEndoffset
throw new Corrupted Frame Exception(
negative pre-adjustment length field: " frameLength);
frameLength + lengthAdjustment length FieldEndOffset:
if (frameLength length FieldEndoffset)I
inskip Bytes(lengthFieldEndoffset)
throw new CorruptedFrameExceptiond
Adjusted frame length ( frame Length )is less"+
than length FieldEndOffset: " length FieldEndoffset
图17-38 Length FieldBasedFrameDecoder的 decode方法片段3
如果长度小于0,说明报文非法,跳过 length Field EndOffset个字节,抛出 Corrupted
FrameException异常。
根据 length FieldEndOffset和 length Adjustment字段进行长度修正,如果修正后的报文长
度小于 length FieldEndoffset,则说明是非法数据报,需要抛出 Corrupted Frame Exception异常。
如果修正后的报文长度大于 Byte Buf的最大容量,说明接收到的消息长度大于系统允
许的最大长度上限,需要设置 discarding Toolong Frame,计算需要丢弃的字节数,根据情
况选择是否需要抛出解码异常
丢弃的策略如下: frameLength减去 Byte Buf的可读字节数就是需要丢弃的字节长度,
如果需要丢弃的字节数 discard小于缓冲区可读的字节数,则直接丢弃整包消息。如果需
要丢弃的字节数大于当前的可读字节数,说明即便将当前所有可读的字节数全部丢弃,也
无法完成任务,则设置 discarding TooLong Frame标识为true,下次解码的时候继续丟弃
丢弃操作完成之后,调用 faillfNecessary方法根据实际情况抛出异常。如图17-39所示。
int frameLengthInt =(int) frameLength;
if (in readable Bytes (<frame Lengthlnt)t
return null
if(initialBytes ToStrip frameLengthInt)
in skip Bytes(frame LengthInt)
throw new Corrupted Frame Exceptiont
Adjusted frame length (+ frameLength +")is less
" than initialBytes ToStrip: initialBytes Tostrp)
in. skipBytes(initial BytesTostrip)
J extract frame
int readerlndex= in readerindex0)
int actualFrameLength frameLengthInt- initial Bytes ToStrip
Byte Buf frame extract rame(ctx, in, readerindex, actualFrame Length)
in readerindex(readerIndex actualFrameLength)
return frame
图17-39 Length Field Based FrameDecoder的 decode方法片段4
414·第17章 ChannelPipeline和 Channelhandler
如果当前的可读字节数小于 frameLength,说明是个半包消息,需要返回空,由IO
线程继续读取后续的数据报,等待下次解码。
对需要忽略的消息头字段进行判断,如果大于消息长度 frameLength,说明码流非法,
需要忽略当前的薮据报,抛出 Corrupted Frame Exception异常。通过 Byte Buf的 skip bytes
方法忽略消息头中不需要的字段,得到整包 Byte Buf。
通过 extractFrame方法获取解码后的整包消息缓冲区,代码如图17-40所示。
protected Byte Buf extractFrame(ChannelHandler Context ctx, ByteBuf buffer, int
index, int length)
ByteBuf frame ctx alloc().buffer(length)
frame, writeBytes(buffer, index, length)
return frame
图1740 Length FieldBased Frame Decoder的 extract Frame方法
根据消息的实际长度分配一个新的 ByteBuf.对象,将需要解码的 Byte Buf可写缓冲区
复制到新创建的 Byte Buf中并返回,返回之后更新原解码缓冲区 Byte Buf为原读索引+消
息报文的实际长度( actual FrameLength)
至此,基于长度的半包解码器介绍完毕,对于使用者而言,实际不需要对 LengthField
Based frame Decoder进行定制。只需要了解每个参数的用法,再结合用户的业务场景进行
参数设置,即可实现半包消息的自动解码,后面的业务解码器得到的是个完整的整包消息,
不用再额外考虑如何处理半包。这极大地降低了开发难度,提升了开发效率。
17.4.5 Message ToByte Encoder源码分析
Message To Byte Encoder负责将用户的POJO对象编码成 Byte Buf,以便通过网络进行
传输。下面一起看它的源码实现,如图17-41所示。
override
public void write( ChannelHand er Context ctx Object mag. ChanneiPre
romise) throws Exeeption
ByteBuf bu=nu量
try d
if (acceptOr boundMessagc(msg)(
@supprosEWarningsunchocked')
I cast=()meg
if (preter Direct)(
buf =ctx alloc) ioButfert
plse
m= cx alloco heap utero
encode ctx, cast, buf)
)finally I
ReferenceCoun!Ubl. release(cast)
图17-41 Message To Byte Encoder的 write方法片段1
415·Nety权威指南(第2版)
首先判断当前编码器是否支持需要发送的消息,如果不支持则直接透传;如果支持则
判断缓冲区的类型,对于直接内存分配 ioBuffer(堆外内存),对于堆内存通过 heap buffer
方法分配。
编码使用的缓冲区分配完成之后,调用 encode抽象方法进行编码,方法定义如图17-42
所
protected abstract void encode(channelHandlerContext ctx, I msg, Byte Buf out)
throws Exception
图1742 Message ToByteEncoder的抽象 encode方法
编码完成之后,调用 Referencecountutil的 release方法释放编码对象msg。对编码后
的 ByteBuf进行以下判断
如果缓冲区包含可发送的字节,则调用 Channelhandlercontext的 write方法发送
ByteBuf
如果缓冲区没有包含可写的字节,则需要释放编码后的 ByteBuf,写入一个空的
Byte Buf到 ChannelhandlerContext中
发送操作完成之后,在方法退出之前释放编码缓冲区 ByteBuf对象。
174.6 Message ToMessageEncoder源码分析
Message ToMessage Encoder负责将一个POJO对象编码成另一个POJO对象,例如将
XML Document对象编码成ⅩML格式的字符串。下面一起看它的源码实现,如图17-43所示。
public void write(Channel Handlercontext ctx Object msg. Channel Promise
promise)throws Exception
RecyclablleArayList out null.
if (acoe
lesage(msg))(
out RecyclableArray LisL newinstance(
Cpsuppresswarmings(unchecked")
cast =( )msg.
odeco, cast, out):
A finally
Reference CountUtil release(castl
d (out isEmpty()(
out= null
throw new EncoderExoeption
StringUtil. simple Class(this)+ "must produce at least one
ctx write(msg
图17-43 Message ToMessage encoder的抽象 write方法
416第17章 ChannelPipeline和 Channelhandler
与之前的编码器类似,创建 Recyclable ArrayList对象,判断当前需要编码的对象是否
是编码器可处理的类型,如果不是,则忽略,执行下一个 Channelhandler的 write方法。
具体的编码方法实现由用户子类编码器负责完成,如果编码后的 Recyclable Array List
为空,说明编码没有成功,释放 RecyclableArray List引用。
如果编码成功,则通过遍历 Recyclable Array List,循环发送编码后的POJO对象,代
码如图17-44所示。
finally I
if(out I= null)f
final int size MinusOne out size(-1
if (sizeMinusOne >=0)t
for(int i=0: i< sizeMinusOne: i++)
ctx. write(out get(O);
ctx. write(out get(sizeMinusOne), promise)
recycle
图17-44循环发送编码后的POJO对象
17.4.7 LengthFieldPrepender源码分析
Length FieldPrepender负责在待发送的 Byte Buf消息头中增加一个长度字段来标识消息
的长度,它简化了用户的编码器开发,使用户不需要额外去设置这个长度字段。下面我们
来看下它的实现,如图17-45所示。
首先对长度字段进行设置,如果需要包含消息长度自身,则在原来长度的基础之上再
加上 length Field Length的长度。
如果调整后的消息长度小于0,则抛出参数非法异常。对消息长度自身所占的字节数
进行判断,以便采用正确的方法将长度字段写入到 Byte Buf中,共有以下6种可能。
◎长度字段所占字节为1:如果使用1个Byte字节代表消息长度,则最大长度需要
小于256个字节。对长度进行校验,如果校验失败,则抛出参数非法异常;若校
验通过,则创建新的 ByteBuf并通过 writeByte将长度值写入到 ByteBuf中。
◎长度字段所占字节为2:如果使用2个Byte字节代表消息长度,则最大长度需要
小于65536个字节,对长度进行校验,如果校验失败,则抛出参数非法异常;若
417·Nety权威指南(第2版)
校验通过,则创建新的 Byte Buf并通过 write short将长度值写入到 Byte Buf中
protected void encode( ChannelHandler Context ctx, Byte Buf msg, List<Object>
out)throws Exception t
int length msg readable Bytes()+ lengthAdjustment
if(lengthIncludesLength FieldLength)i
length + length FieldLength
if (length <0)
throw new llegalArgumentExceptiont
Adjusted frame length (" length +")is less than zero")
switch(length FieldLength)(
case 1
if (length >=256)[
throw new IllegalArgumentException
length does not fit into a byte: " length)
out. add(ctx alloc(). buffer(1).write Byte((byte )length)):
break,
图17-45 Length FieldPrepender的 encode方法片段1
长度字段所占字节为3:如果使用3个Byte字节代表消息长度,则最大长度需要小
于16777216个字节,对长度进行校验,如果校验失败,则抛出参数非法异常;若校
验通过,则创建新的 ByteBuf并通过 write Medium将长度值写入到 Byte Buf中。
长度字段所占字节为4:创建新的 Byte Buf,并通过 writeln将长度值写入到
Byte Buf中。
◎长度字段所占字节为8:创建新的 Byte Buf,并通过 writeLong将长度值写入到 ByteBuf中。
◎其他长度值:直接抛出 Error o
最后将原需要发送的 ByteBuf复制到List< Object>out中,完成编码。
17.5总结
本章介绍了 ChannelPipeline和 Channelhandler的功能及原理,并给出了使用建议,指
出了需要注意的细节
最后,对 ChannelPipeline和 Channelhandler的主要功能子类进行了源码分析。通过学
习源码,相信读者不仅仅能学到Nety的一些高级用法,而且能够举一反三,通过按需扩
展和功能定制来更好的满足业务的差异化需求
·418·第18章
EventLoop和
EventLoop Group
从本章开始我们将学习Nety的线程模型。 Netty框架的主要线程就是lO线程,线程
模型设计的好坏,决定了系统的吞吐量、并发性和安全性等架构质量属性。
Nεt!y的线程模型被精心地设计,既提升了框架的并发性能,又能在很大程度避免锁,
局部实现了无锁化设计。从本章开始,我们将介绍 Netty的线程模型,同时对它的NIO线
程 NioEventLoop进行详尽地源码分析,让读者能够学习到更多IO相关的多线程设计原
理和实现。
本章主要内容包括:
◎ Netty的线程模型
IoEventloo
p源码分析
18.1Net!y的线程模型
当我们讨论Net’y线程模型的时候,一般首先会想到的是经典的 Reactor线程模型,Nety权威指南(第2版)
尽管不同的NIO框架对于 Reactor模式的实现存在差异,但本质上还是遵循了 Reactor的
基础线程模型。
下面让我们一起回顾经典的 Reactor线程模型。
18.1.1 Reactor单线程模型
Reactor单线程模型,是指所有的IO操作都在同一个NO线程上面完成。NIO线程
的职责如下
◎作为NIO服务端,接收客户端的TCP连接
◎作为NIO客户端,向服务端发起TCP连接:
◎读取通信对端的请求或者应答消息
◎向通信对端发送消息请求或者应答消息
Reactor单线程模型如图18-1所示。
client
Reactor Thread
client
Dispatch
client
read
write
encode
/decode
Handler 3
Acceptor
Handler
Handler西
Handler 2
图18-1 Reactor单线程模型
由于 Reactor模式使用的是异步非阻塞IO,所有的1/O操作都不会导致阻塞,理论上
个线程可以独立处理所有IO相关的操作。从架构层面看,一个NO线程确实可以完成
其承担的职责。例如,通过 Acceptor类接收客户端的TCP连接请求消息,当链路建立成
功之后,通过 Dispatch将对应的 Byte Buffer派发到指定的 Handler上,进行消息解码。用
户线程消息编码后通过NIO线程将消息发送给客户端。
在一些小容量应用场景下,可以使用单线程模型。但是这对于高负载、大并发的应用
场景却不合适,主要原因如下。
◎一个NIO线程同时处理成百上千的链路,性能上无法支撑,即便NIO线程的CPU
420·第18章 EventLoop和 EventLoopGroup
负荷达到100%,也无法满足海量消息的编码、解码、读取和发送
◎当NO线程负载过重之后,处理速度将变慢,这会导致大量客户端连接超时,超
时之后往往会进行重发,这更加重了NIO线程的负载,最终会导致大量消息积压
和处理超时,成为系统的性能瓶颈。
◎可靠性问题:一旦NIO线程意外跑飞,或者进入死循环,会导致整个系统通信模
块不可用,不能接收和处理外部消息,造成节点故障
为了解决这些问题,演进出了 Reactor多线程模型。下面我们一起学习下 Reactor多线
程模型。
18.1.2 Reactor多线程模型
Rector多线程模型与单线程模型最大的区别就是有一组NO线程来处理I/O操作,它
的原理如图18-2所示。
client
Reactor Thread Dispatcher
Reactor pool
client
Acceptor
write
client
read
/decode
encode
Handler 3
Handler
Handers
Handler
图18-2 Reactor多线程模型
Reactor多线程模型的特点如下。
◎有专门一个NIO线程— Acceptor线程用于监听服务端,接收客户端的TCP连
接请求
◎网络IO操作—一读、写等由一个NO线程池负责,线程池可以采用标准的JDK
线程池实现,它包含一个任务队列和N个可用的线程,由这些NO线程负责消
息的读取、解码、编码和发送
◎一个NO线程可以同时处理N条链路,但是一个链路只对应一个NIO线程,防
止发生并发操作问题。
421·Net!y权威指南(第2版)
在绝大多数场景下, Reactor多线程模型可以满足性能需求。但是,在个别特殊场景
中,一个NO线程负责监听和处理所有的客户端连接可能会存在性能问题。例如并发百万
客户端连接,或者服务端需要对客户端握手进行安全认证,但是认证本身非常损耗性能。
在这类场景下,单独一个 Acceptor线程可能会存在性能不足的问题,为了解决性能问题,
产生了第三种 Reactor线程模型——主从 Reactor多线程模型。
18.1.3主从 Reactor多线程模型
主从 Reactor线程模型的特点是:服务端用于接收客户端连接的不再是一个单独的NIO
线程,而是一个独立的NO线程池。 Acceptor接收到客户端TCP连接请求并处理完成后
可能包含接入认证等),将新创建的 Socketchannel注册到Io线程池( sub reactor线程池)
的某个LO线程上,由它负责 Socketchannel的读写和编解码工作。 Acceptor线程池仅仅
用于客户端的登录、握手和安全认证,一旦链路建立成功,就将链路注册到后端 subreactor
线程池的IO线程上,由IO线程负责后续的IO操作。
它的线程模型如图18-3所示。
client
Dispatcher
Acceptor
Acceptor Pool
client
client
/encode
encode
auth
Shale-hand
logIn
SLA
Reactor Thread Pool
Dispatcher
NlO-Thread1
Nto-Thread2service handler
anders
NIO-Thread3 write
ydecode
图18-3主从 Reactor多线程模型
利用主从NIo线程模型,可以解决一个服务端监听线程无法有效处理所有客户端连接
的性能不足问题。因此,在Nety的官方Demo中,推荐使用该线程模型。
422第18章 EventLoop和 EventLoop group
18.1.4Net!y的线程模型
Nety的线程模型并不是一成不变的,它实际取决于用户的启动参数配置。通过设置
不同的启动参数,Nety可以同时支持 Reactor单线程模型、多线程模型和主从 Reactor多
线层模型
下面让我们通过一张原理图(图18-4)来快速了解Nety的线程模型。
Client
Active hre
NioEventLoop. execute
(Runnable task)
Thread.ru
Client
a…
NioEventLoop
/Acceptor
NioEventLoop schedule
Runnable task
Pool
Client
ueU
ue
图18-4Nety的线程模型
可以通过如图18-5所示的Net!服务端启动代码来了解它的线程模型。
A Configure the server
EventLoop Group boss Group new NioEventLoop Group()
EventLoop Group worker Group new NioEventLoop Groupo:
Server Bootstrap b= new ServerBootstrap(:
b group(boss Group, worker Group
channel(NioServer Socketchannel class
option(ChannelOption, SO BACKLOG, 100
handler(new Logging Handler(LogLevel. INFO))
childHandler(new ChannelInitializer<SocketchannePO t
图18-5 Netty服务端启动
服务端启动的时候,创建了两个 NioEventLoop Group,它们实际是两个独立的 Reactor
线程池。一个用于接收客户端的TCP连接,另一个用于处理IO相关的读写操作,或者执
行系统Task、定时任务Task等。
Net!y用于接收客户端请求的线程池职责如下
(1)接收客户端TCP连接,初始化 Channe参数;
(2)将链路状态变更事件通知给 Channelpipeline
·423·Ney权威指南(第2版
Nety处理Io操作的 Reactor线程池职责如下。
(1)异步读取通信对端的数据报,发送读事件到 ChannelPipeline;
(2)异步发送消息到通信对端,调用 ChannelPipeline的消息发送接口;
(3)执行系统调用Task;
(4)执行定时任务Task,例如链路空闲状态监测定时任务。
通过调整线程池的线程个数、是否共享线程池等方式, Netty的 Reactor线程模型可以
在单线程、多线程和主从多线程间切换,这种灵活的配置方式可以最大程度地满足不同用
户的个性化定制。
为了尽可能地提升性能,Net!在很多地方进行了无锁化的设计,例如在IO线程内
部进行串行操作,避免多线程竞争导致的性能下降问题。表面上看,串行化设计似乎CPU
利用率不高,并发程度不够。但是,通过调整NO线程池的线程参数,可以同时启动多个
串行化的线程并行运行,这种局部无锁化的串行线程设计相比一个队列一多个工作线程的
模型性能更优。
它的设计原理如图18-6所示。
de
ecode
read
Han
encode
HE
a
N
dler
dler
IOEventLoop
write
图18-6Net! y Reactor线程模型
Net!y的 NioEvent Loop读取到消息之后,直接调用 ChannelPipeline的 fire channelread
( Object msg)。只要用户不主动切换线程,一直都是由 NioEventLoop调用用户的 Handler,
期间不进行线程切换。这种串行化处理方式避免了多线程操作导致的锁的竞争,从性能角
度看是最优的。
18.1.5最佳实践
Net!y的多线程编程最佳实践如下
(1)创建两个 NioEventLoop Group,用于逻辑隔离 NIO Acceptor和 NIO/O线程
·424第18章 Event Loop和 EventLoop Group
(2)尽量不要在 Channelhandler中启动用户线程(解码后用于将POJO消息派发到后
端业务线程的除外)。
3)解码要放在NIO线程调用的解码 Handler中进行,不要切换到用户线程中完成消
息的解码。
4)如果业务逻辑操作非常简单,没有复杂的业务逻辑计算,没有可能会导致线程被
阻塞的磁盘操作、数据库操作、网路操作等,可以直接在NIO线程上完成业务逻辑编排,
不需要切换到用户线程。
5)如果业务逻辑处理复杂,不要在NIO线程上完成,建议将解码后的POJO消息封
装成Task,派发到业务线程池中由业务线程执行,以保证No线程尽快被释放,处理其
他的IO操作。
推荐的线程数量计算公式有以下两种。
◎公式一:线程数量=(线程总时间/瓶颈资源时间)ⅹ瓶颈资源的线程并行数。
公式二:QPS=1000/线程总时间×线程数。
由于用户场景的不同,对于一些复杂的系统,实际上很难计算出最优线程配置,只能
是根据测试数据和用户场景,结合公式给出一个相对合理的范围,然后对范围内的数据进
行性能测试,选择相对最优值
182 NioEventLoop源码分析
182.1 NiOEventLoop设计原理
Net!y的 Nio EventLoop并不是一个纯粹的O线程,它除了负责O的读写之外,还
兼顾处理以下两类任务。
◎系统Task:通过调用 NioEventLoop的 execute( Runnable task)方法实现,Net!y有
很多系统Task,创建它们的主要原因是:当IO线程和用户线程同时操作网络资
源时,为了防止并发操作导致的锁竞争,将用户线程的操作封装成Task放入消
息队列中,由ⅠO线程负责执行,这样就实现了局部无锁化。
◎定时任务:通过调用 Nio EventLoop的 schedule( Runnable command, long delay,
·425·Netty权威指南(第2版)
TimeUnit unit)方法实现。
正是因为 NioEventLoop具备多种职责,所以它的实现比较特殊,它并不是个简单的
Runnable。我们来看下它的继承关系,如图18-7所示。
E T Schedule dExecutorService-java util concurrent
9 DelegatedScheduledExecutorService-java util concurrent Executors
C ScheduledThreadPoolExecutor- jawa. util. concurrent
I EventExeeutorGroup -io, netty util. concurrent
C AbstractEventExecutorGroup-io netty util.concurrent
D EventExeeutor- io, netty, util. concurrent
9. CA Abstr actEventExecutor-io netty util. concurrent
E-CA AbstractEventLoop-ionetty channel
- -GF EmbeddedEventLoop-io netty channelembedded
c new AbstractEventLoopo[.I- io netty channel Voi dChannel Voi dchannelO
GF GlobalEventExecutor-ionetty util.concurrent
--CF ImmediateEventExecutor-io, netty, util. concurrent
a A SingleThreadEventExecutor-io netty util. concurrent
BCA SingleThreadEventLoop-io netty channe,current
CF DefaultEventExecutor-io, netty util. co
C DefaultEventLoop-io netty channel
CNioErentLoop-io, netty, channelnio
C ThreadPerChannelEvenLLoop-io, netty, channel
3- D EventLoop-io nettychannel
C AbstractEventLoop-io netty charnel
C EnbeddedEventLoop-io.netty, charnelembedded
a new AbstractEventLoopO I...1-io.netty channel Voi dChannel Voi dchannel0
--C SingleThreadEventLoop-io, netty channel
C Defaul tEventLoop-10. netty, channel
CF NioEventLoop -io netty channel nio
C ThreadPerChannelEventLoop-ig netty charnel
图18-7 NioEventLoop继承关系
它实现了 EventLoop接口、 EventExecutor Group接口和 ScheduledexecutorService接口,
正是因为这种设计,导致 NioEventLoop和其父类功能实现非常复杂。下面我们就重点分
析它的源码实现,理解它的设计原理
1822 NioEventL!oop继承关系类图
从下个小节开始,我们将对 NioEventLoop的源码进行分析。通过源码分析,希望读
者能够理解Net!y的 Reactor线程设计原理,掌握其精髓。 NioEventLoop继承关系图如图
18-8所示。
426·第18章 EventLoop和 EventLoop Group
U SeheduledExecutorService
Event ExecutorGroup
Executorservice
I Eventexecutor
AbstractExecutorService
AbstractEventExecutor
Event Loop
S Single Thread EventExecutor
a single Thread EventLoop
NioEvent Loop
图18-8 NioEventLoop继承关系图
18.2.3 Nio EventLoop
作为NIO框架的 Reactor线程, NioEvent Loop需要处理网络O读写事件,因此它必
须聚合一个多路复用器对象。下面我们看它的 Selector定义,如图18-9所示。
The NIo (@link Selector
Selector selector
private Selected Selection KeySet selectedKeys
private final Selector Provider provider
图18-9 NioEvent Loop的 Selector定义
Selector的初始化非常简单,直接调用 Selector。open()方法就能创建并打开一个新的
Selector. Netty对 Selector的 selectedKeys进行了优化,用户可以通过io.net. noKeySet
Optimization开关决定是否启用该优化项。默认不打开 selectedKeys优化功能。
Selector的初始化代码如图18-10所示。
427·Netty权威指南(第2版
private Selector open Selector()i
final Selector selector:
selector provider, openselector(
catch(IOException e)i
throw new ChannelException(failed to open a new selector, e)
if (DISABLE KEYSET OPTIMIZATION)(
return selector
图18-10 Selector的初始化
如果没有开启 selectedKeys优化开关,通过 provider. open Selector(创建并打开多路复
用器之后就立即返回
如果开启了优化开关,需要通过反射的方式从 Selector实例中获取 selectedKeys和
publicSelectedKeys,将上述两个成员变量设置为可写,通过反射的方式使用Nety构造的
selectedKeys包装类 selectedKey Set将原JDK的 selectedKeys替换掉。
分析完 Selector的初始化,下面重点看下run方法的实现,如图18-1l所示。
所有的逻辑操作都在for循环体内进行,只有当 NioEventLoop接收到退出指令的时候,
才退出循环,否则一直执行下去,这也是通用的NIO线程实现方式。
首先需要将 wakeuP还原为 false,并将之前的 wake up状态保存到 old WakeuP变量
中。通过 hasTasks(方法判断当前的消息队列中是否有消息尚未处理,如果有则调用
selectNowO方法立即进行一次 select操作,看是否有准备就绪的 Channel需要处理。它的
代码实现如图18-12所示。
@override
protected void run(t
for (:)t
void selectNow() throws IOException
oldWakenUp= waken Up. getAnd Set(false)
tr
selector, selectNow(;
if(has Tasks()
3 finally
selectNow0
l restore waku state if need
y else I
if (wakeuP geto)(
select(
lector wakeup(;
if (wakeuP geto)i
elector, wakeup
图18-11 NioEventLoop的run方法
图18-12 Nio EventLoop的 selectNow(方法
Selector的 selectNowO方法会立即触发 Selector的选择操作,如果有准备就绪的
Channel,则返回就绪 Channel的集合,否则返回0。选择完成之后,再次判断用户是否调
用了 Selector的 wakeup方法,如果调用,则执行 selector. wakeup操作。
428第18章 EventLoop和 Event。 op Group
下面我们返回到run方法,继续分析代码。如果消息队列中没有消息需要处理,则执
行 selecto)方法,由 Selector多路复用器轮询,看是否有准备就绪的 Channel。它的实现如图
18-13所示。
取当前系统的纳秒时间,调用 delay Nanos方法计算获得 NioEventLoop中定时任务的
触发时间。
private void select() throws IOException
Selector selector= this selector
int selectCnt =0
long currentTime Nanos System nano Time(
long select Dead LineNanos = currentT imeNanos
delayNanos(currentTime Nanos);
for(,)I
long timeoutMillis=(selectDeadLineNanos-current T imeNanos
500000L)/1000000L
if( (timeoutMillis≤=0)
if (selectCnt ==0)(
selector. selectNow()
selecton =1
break
图18-13 NioEventLoop的 select(方法
计算下一个将要触发的定时任务的剩余超时时间,将它转换成毫秒,为超时时间增加
0.5毫秒的调整值。对剩余的超时时间进行判断,如果需要立即执行或者已经超时,则调
用 selector. selectnow(进行轮询操作,将 selectOn设置为1,并退出当前循环。
将定时任务剩余的超时时间作为参数进行 select操作,每完成一次 select操作,对 select
计数器 selecton加1
Select操作完成之后,需要对结果进行判断,如果存在下列任意一种情况,则退出当
前循环。
◎有 Channel处于就绪状态, selectedKeys不为0,说明有读写事件需要处理;
◎ oldWakenUp为true;
◎系统或者用户调用了 wakeup操作,唤醒当前的多路复用器;
◎消息队列中有新的任务需要处理。
如果本次 Selector的轮询结果为空,也没有 wakeup操作或是新的消息需要处理,则
说明是个空轮询,有可能触发了JDK的 epoll bug,它会导致 Selector的空轮询,使IO线
429Net!权威指南(第2版)
程一直处于100%状态。截止到当前最新的JDK7版本,该bug仍然没有被完全修复。所
以Net需要对该bug进行规避和修正。
Bug-id=6403933的 Selector堆栈如图18-14所示。
该Bug的修复策略如下。
(1)对 Selector的 select操作周期进行统计
(2)每完成一次空的 select操作进行一次计数
3)在某个周期(例如100ms)内如果连续发生N次空轮询,说明触发了 JDK NIC
的 pollo死循环bug。
java. lang Thread State: RUNNABLE
at sun nio ch. EPollArrayMrapper epollWait Native Method)
at sun nio ch. EPollArraytrapper poll (EPollArrayWrapper java: 210)
at sun nio ch. EPollSelectorImpl deSelect (EPollSelectorImpl java: 65)
at sun nio ch. SelectorImpl lockAndDoSelect(SelectorImpl, java: 69)
locked <0x0000000750928190>(a sun nio. ch. Utils2)
locked <0x00000007509281 aB> (a java util. CollectionsUnmodi fi ableSet)
locked <0x0000000750946098>(a sun nio. ch. EPollSelectorImpl)
at sun nio ch. SelectorImpl select (SelectorImpl java: 80
a 18-14 JDK Selector CPU 100% bug
监测到 Selector处于死循环后,需要通过重建 Selector的方式让系统恢复正常,代码
如图18-15所示。
public void rebuildselector((
if (inEventLoop()t
execute(new Runnable(i
@override
blic void runt
rebuildSelector(*
)
retur
final Selector oldselector selector:
final Selector new Selector:
if(old Selector = null)(
retun
tr
newSelector =open Selector(:
3 catch(Exception e)(
logger. warn("Failed to create a new Selector. e)
return
图18-15重建 Selector
430第18章 EventLoop和 EventLoopGroup
首先通过 in Loop(方法判断是否是其他线程发起的 rebuild Selector,如果由其他
线程发起,为了避免多线程并发操作 Selector和其他资源,需要将 rebuild Selector封装成
Task,放到 NioEventLoop的消息队列中,由 NioEventLoop线程负责调用,这样就避免了
多线程并发操作导致的线程安全问题。
调用 openSelector方法创建并打开新的 Selector,通过循环,将原 Selector上注册的
Socketchannel从旧的 Selector上去注册,重新注册到新的 Selector上,并将老的 Selector关闭。
相关代码如图18-16所示。
int cHannels =0
for (,)
for(SelectionKey key: oldselector, keys)t
bject a= key attachment(?
if(key channel(). keyFor(new Selector)!= null)i
continue
int interestors= key. interestopso
key cancel()
key channel(). register(new Selector, interestops, a)
channels +
y catch(E
logger warn("Failed to re-register a Channel to the new Selector
e):
if (a
of AbstractNio Channel)[
AbstractNio Channel ch =(AbstractNio Channel)a:
ch unsafe(). close(ch unsafe().voidPromise())
3 else i
@SuppressWarnings(unchecked
Nio Task<selectableChannel> task
(Nio Task <Selectable Channel>)a
invoke ChannelUnregistered(task, key, e)
I catch(ConcurrentModification Exception e)f
l Probably due to concurrent modification of the key set
continue
break
图18-16将 Socketchannel重新注册到新建的 Selector上
通过销毁旧的、有问题的多路复用器,使用新建的 Selector,就可以解决空轮询 Selector
导致的O线程CPU古用100%的问题
如果轮询到了处于就绪状态的 Socketchannel,则需要处理网络l/O事件,相关代码如
·431Ne!权威指南(第2版)
图18-17所示
final long io StartT ime System nano Time(
needs ToSelectAgain = false
if(selectedKeys I= null)(
process Optimized(selectedKeys flip()
else
process SelectedKeysPlain(selector, selectedKeys()
final long io Time= System. nano Time()-ioStartTime
图18-17进行1O操作
由于默认未开启 selectedKeys优化功能,所以会进入 processSelected KeysPlain分支执
行。下面继续分析 process SelectedKeysPlain的代码实现,如图18-18所示
rivate void processselectedKeysPlainset sselectionKey> selectedKeys)i
if(selectedKeys. isEmptyo))i
return
Iterator<SelectionKey i= selected Keys. iterator(:
for ()
final Selectionkey k= i next()
final Object a=k attachment():
i removed
图18-18遍历 SelectionKey进行网络读写
对 SelectionKey进行保护性判断,如果为空则返回。获取 SelectionKey的迭代器进行
循环操作,通过迭代器获取 Selectionεy和 Socketchannel的附件对象,将已选择的选择
键从迭代器中删除,防止下次被重复选择和处理,代码如图18-19所示。
if(a instanceof AbstractNioChannel)(
process SelectedKey(k, (AbstractNioChannel)a)
else
@SuppressWarnings( unchecked")
NioTask<Selectable Channel> task =(Nio Task<Selectable Channel>)a
process SelectedKey(k, task)
图18-19判断 Socketchannel的附件类型
对 Socketchannel的附件类型进行判读,如果是 Abstract nio channel类型,说明它是
io ServerSocket channel或者 NioSocketChannel,需要进行I/O读写相关的操作;如果它是
NioTask,则对其进行类型转换,调用 processSelectedKey进行处理。由于Nety自身没实
现 Nio Task接口,所以通常情况下系统不会执行该分支,除非用户自行注册该Task到多路
复用器。
下面我们继续分析IO事件的处理,代码如图18-20所示
432·第18章 EventLoop和 EventLoop Group
2 orivate static void process SelectedKey(Selectionkey k, AbstractNioChannel
final NioUnsafe unsafe= ch unsafe()
if(Ik. isvalido)
l close the channel if the key is not valid anymore
unsafe, close(unsafe. voidPromise()
return*
图18-20对选择键的状态进行判断
首先从 NioServerSocketchanne或者 Nio SocketChannel中获取其内部类 Unsafe,判断
当前选择键是否可用,如果不可用,则调用 Unsafe的 close方法,释放连接资源。
如果选择键可用,则继续对网络操作位进行判断,代码如图18-21所示,
int ready Ops =k. readyopso
// Also check for readOps of 0 to workaround possible JDK bug which
may otherwise lead
∥ to a spin loop
if((ready Ops &(SelectionKey OP READ I
SelectionKey OP ACCEPT))I=0 l readyOps ==0)(
unsafe. read()
if(Ich is Open)i
W Connection already closed-no need to handle write
return
图18-21处理读事件
如果是读或者连接操作,则调用 Unsafe的read方法。此处 Unsafe的实现是个多态,
对于 NioServer Socketchannel,它的读操作就是接收客户端的TCP连接,相关代码如图
18-22所示。
protected int doRead Messages(List<Object> buf) throws Exception
Socketchannel ch= javaChannel(). accepto);
if (ch I= null)(
buf. add(new NioSocketchannel(this, child EventLoop Group(). next().
ch)):
return 1
)catch(Throwable t)i
logger warn("Failed to create a new channel from an accepted socke
t):
) catch(Throwable t2)
logger, warn("Failed to close a socket. ".t2):
return
图18-22 NioServer Socketchannel的读操作
·433·Nety杈威指南(第2版)
对于 Nio Socketchannel,它的读操作就是从 Socket Channel中读取 Byte Buffer,相关代
码如图18-23所示。
@Override
protected int doRead Bytes(Byte Buf byte Buf) throws Exception i
return byte Buf, write Bytes(javaChannel(), byte Buf. writableBytes():
图18-23 NioSocketchannel的读操作
如果网络操作位为写,则说明有半包消息尚未发送完成,需要继续调用fush方法进
行发送,相关的代码如图18-24所示。
if((readyOps SelectionKey OP WRITE)I=o
M Call force Flush which will also take care of clear the OP WRItE
once there is nothing left to write
ch unsafe(). force Flush()
图18-24调用fush方法写半包
如果网络操作位为连接状态,则需要对连接结果进行判读,代码如图18-25所示。
if ((readyOps SelectionKey OP CONNECT)I=O)
f remove OP CONNECT as otherwise Selector. select( )will always
I return without blocking
int ops =k interestors(.
ops &=-SelectionKey OP CONNECT;
k interestors(ops)
unsafe. finishConnecto
图18-25处理连接事件
需要注意的是,在进行 finish Connect判断之前,需要将网络操作位进行修改,注销掉
SelectionKey. OP CONNECTo
处理完IO事件之后, Nio EventLoop需要执行非IO操作的系统Task和定时任务,代
码如图18-26所示。
final long io Time System nano Time(-ioStartTime
final int hoRatio this, io ratio
runAll asks(io T ime"(100-ioRatio)/ioRatio)
图18-26执行非IO任务
由于 NioEventLoop需要同时处理IO事件和非IO任务,为了保证两者都能得到足够
的CPU时间被执行, Netty提供了lO比例供用户定制。如果lO操作多于定时任务和Task
·434·第18章 EventLoop和 EventLoop Group
则可以将IO比例调大,反之则调小,默认值为50%。
Task的执行时间根据本次1O操作的执行时间计算得来。下面我们具体看 runAllTasks
方法的实现,如图18-27所示。
otected
n runAlIlTasks(long timeoutNanos)(
fetch FromDelayedQueue(
Runnable task= poll Task()
if (task
return false.
图18-27执行非IO任务
首先从定时任务消息队列中弹出消息进行处理,如果消息队列为空,则退出循环。根
据当前的时间戳进行判断,如果该定时任务已经或者正处于超时状态,则将其加入到执行
Task Queue中,同时从延时队列中删除。定时任务如果没有超时,说明本轮循环不需要处
理,直接退出即可,代码实现如图18-28所示
private void fetch FromDelayed Queue0i
long nanoTime = OL
or(){
ScheduledFuture T ask<?> delayed ask delayedTask Queue peek()
if ( delayed Task =s null)(
break.
if (nano Time = OL)
nanoTime= Scheduled Future Task. nano Time()
if (delayed Task. deadlineNanos()<= nano Time)I
delayed TaskQueue. remove()
taskQueue. add(delayedTask)
else I
break;
图18-28从延时队列中移除消息到 Task Queue
执行 Task Queue中原有的任务和从延时队列中复制的己经超时或者正处于超时状态
的定时任务,代码如图18-29所示
由于获取系统纳秒时间是个耗时的操作,每次循环都获取当前系统纳秒时间进行超时
判断会降低性能。为了提升性能,每执行60次循环判断一次,如果当前系统时间已经到
了分配给非IO操作的超时时间,则退出循环。这是为了防止由于非1O任务过多导致IO
操作被长时间阻塞。
·435·Ney权威指南(第2版)
for(:;)【
task run():
1 catch(Throwable t)t
logger. warn("A task raised an exception. ",):
run Tasks +
if((run Tasks &0x3F)==0)t
lastExecution T ime= ScheduledFuture T ask nanoT ime
if(lastExecution Time > deadline)(
break
图18-29执行普通Task和定时任务
最后,判断系统是否进入优雅停机状态,如果处于关闭状态,则需要调用 closeAll方
法,释放资源,并让 NioEventLoop线程退出循环,结束运行。资源关闭的代码实现如图
18-30所
private void closeAllot
selectAgain(
Set<selectionKey> keys selector keys(
Collection sAbstractNioChannel> channels new
ArrayList<AbstractNio Channel>(keys. size()
for(Selectionkey k: keys
Object a=k
if (a instanceof AbstractNio Channel)i
channels. add((AbstractNio Channel)a);
s else
k cance
Nio Task< Selectable Channel> task =(NioTask<Selectable Channel>)a
invoke Channe!Unregistered( task, k, null)
for(AbstractNio Channel ch: channels)(
ch unsafe(). close(ch unsafe(). void Promise())
图18-30 NioEventLoop线程退出,资源释放
遍历获取所有的 Channel,调用它的 Unsafe. close(方法关闭所有链路,释放线程池、
Channel Pipeline和 Channelhandler等资源。
183总结
本章详细介绍了Nety的线程模型以及 NioEventLoop的实现,通过最佳实践和源码分
436第18章 EventLoop和 EventLoop Group
析,让读者加深对Nety框架线程模型的理解,能够在未来的工作中可以恰到好处地使用
对于任何架构,线程模型设计的好坏都直接影响软件的性能和并发处理能力。幸运的
是,Net的线程模型被精心地设计和实现。相信通过对Nety线程模型的学习,广大读者
朋友可以举一反三,将 Reactor线程模型的精髓应用到日常的工作中。
437第19章
Future和 Promise
本章我们介绍Net!y的 Future和 Promise。从名字可以看出, Future用于获取异步操
作的结果,而 Promise则比较抽象,无法直接猜测出其功能。本章将介绍Net! Future和
Promise的功能,分析它们的源码,帮助读者掌握其实现原理。
本章主要内容包括:
Future功能
Future源码分析
◎ Promise功能
◎ Promise源码分析
191 Future功能
Future最早来源于JDK的java. util. concurrent. Future,它用于代表异步操作的结果。相
关API如图19-1所示。
可以通过get方法获取操作结果,如果操作尚未完成,则会同步阻塞当前调用的线程;
如果不允许阻塞太长时间或者无限期阻塞,可以通过带超时时间的get方法获取结果;如第19章 Future和 Promise
果到达超时时间操作仍然没有完成,则抛出 TimeoutException。
曰心 Future
cancel (boolean): boolean
sCancelledo. bool
i sDone0. boolean
●getO:
●get
TimeUnit): v
图191 IDK Future的API列表
通过 isDone(方法可以判断当前的异步操作是否完成,如果完成,无论成功与否,都
返回true,否则返回 false
通过 cancel可以尝试取消异步操作,它的结果是未知的,如果操作已经完成,或者发
生其他未知的原因拒绝取消,取消操作将会失败。
ChannelFuture功能介绍
由于 Netty的 Future都是与异步IoO操作相关的,因此,命名为 Channelfuture,代表
它与 Channel操作相关。
它的API接口列表如表19-1所示。
表19-1 Channelfuture接口列表
返回值
方法名称
addListener( Generic Listener<? extends Futurec? super java. lang Void>> listener)
Channelfuture
Adds the specified listener to this future
addListeners( Generic FutureListener<? extends Future s? super java. lang, Void>>. listeners)
Channelfuture
Adds the specified listeners to this future
await()
ChannelFuture
Waits for this future to be completed
awaitUninterruptiblyO
Channelfuture
Waits for this future to be completed without interruption
channelo
Channe
Returns a channel where the 1/O operation associated with this future takes place
removeListener( Generic FutureListener? extends Future<? super java. lang Void>> listener)
Channelfuture
Removes the specified listener from this future
·439·Net!权威指南(第2版)
续表
返回值
方法名称
remove Listeners( Generic Future Listener=? extends Future<? super java, lang Void>>.. listeners)
ChannelFuture
Removes the specified listeners from this future
sync(
Channelfuture
Waits for this future until it is done. and rethrows the cause of the failure if this future failed
syncUninterruptiblyo
Channelfuture
Waits for this future until it is done. and rethrows the cause of the failure if this future failed
在Ney中,所有的IO操作都是异步的,这意味着任何lO调用都会立即返回,而不
是像传统BO那样同步等待操作完成。异步操作会带来一个问题:调用者如何获取异步操作
的结果? Channelfuture就是为了解决这个问题而专门设计的。下面我们一起看它的原理。
Channelfuture有两种状态: uncompleted和 completed。当开始一个1O操作时,一个
新的 Channelfuture被创建,此时它处于 uncompleted状态——一非失败、非成功、非取消,
因为IO操作此时还没有完成。一旦IO操作完成, Channelfuture将会被设置成 completed
它的结果有如下三种可能。
◎操作成功;
◎操作失败;
◎操作被取消。
Channelfuture的状态迁移图如图192所示。
+一-------------
=------+
I Commpleted successfully
19Done0)=trne
画
13Success()"true
Uncompleted
I Completed with failure
isDone()= false
=-----------------------+
135uccess()= false
1sDoneo= true
1 cAnce21ed()=王age
cause()= non-null
I cause()=null
Completed by cancellation I
iaDone(=true
⊥ Cancel1ea()=true
图19-2 Channelfuture状态迁移图
440·第19章 Future和 Promise
Channelfuture提供了一系列新的API,用于获取操作结果、添加事件监听器、取消IO
操作、同步等待等。
我们重点介绍添加监听器的接口。管理监听器相关的接口定义如图19-3所示。
出
1o. nett
y channe
Channelfutur e
hmme
10: Channel
OA addListener (GenericFutureListener <? extends Future<? super Void>>):ChannelFuture
@A addListeners (GenericFutureListener < extends Future<? super Void>>.): ChannelFuture
ea rem oveListener (GenericFutureListener<? extends Future<? super Void>>): ChannelFuture
Oa removeLi steers(GenericFutureListener<? extends Future<? super Void>>.):ChannelFuture
图19-3 Channelfuture管理监听器
Net!y强烈建议直接通过添加监听器的方式获取IO操作结果,或者进行后续的相关
操作。
Channelfuture可以同时增加一个或者多个 Generic Futurelistener,也可以用 remove方
法删除 Generic futurelistener o
Generic Future Listener的接口定义如图19-4所示
void operation Complete(F future)throws Exception
图19-4 Generic Future Listener接口定义
当IO操作完成之后,IO线程会回调 ChannelFuture中 GenericFuture Listener的
operation Complete方法,并把 Channelfuture对象当作方法的入参。如果用户需要做上下
文相关的操作,需要将上下文信息保存到对应的 ChannelFuture中。
推荐通过 Generic Future Listener代替 Channelfuture的get等方法的原因是:当我们进
行异步IO操作时,完成的时间是无法预测的,如果不设置超时时间,它会导致调用线程
长时间被阻塞,甚至挂死。而设置超时时间,时间又无法精确预测。利用异步通知机制回
调 Generic FutureListener是最佳的解决方案,它的性能最优
需要注意的是:不要在 Channelhandler中调用 ChannelFuture的 await(方法,这会导
致死锁。原因是发起IO操作之后,由1/O线程负责异步通知发起IO操作的用户线程,
如果IO线程和用户线程是同一个线程,就会导致IO线程等待自己通知操作完成,这就
导致了死锁,这跟经典的两个线程互等待死锁不同,属于自己把自己挂死
相关代码示例如图195所示。
441Nett权威指南(第2版)
BAD- NEVER DO THIS
OVerride
public void channelRead ( ChannelHandler Context ctx, GoodByeMessage msg)(
Channelfuture future ctx channel(),close()i
future. awaitUninterruptibly()i
// Perform post-closure operation
1/ GOOD
OVerride
public void channelRead (ChannelHandlercontext ctx, GoodByeMessage sg) t
ChannelFuture future ctx channel(. close(:
t凵xe.addL⊥ TeNer( new CharnelEuture⊥ tenex()
public void operationcomplete(charnelFuture future)!
/ Perform post-closure operat:on
)
图19-5 ChannelFuture的正反用法示例
异步1/O操作有两类超时:一个是TCP层面的1O超时,另一个是业务逻辑层面的操
作超时。两者没有必然的联系,但是通常情况下业务逻辑超时时间应该大于IO超时时间,
它们两者是包含的关系。
相关代码举例如图19-6所示。
/ GOCD
Bootstrap b
/ Configure the connect timeout option
b option(ChannelOption. CONNECT TIMEOUT MILLIS,10000)i
ChannelFuture f b connect(,,)i
f.awaitUninterruptibly();
/ Now we are sure the future is completed
assert fisDone();
1(f.1 BRance1⊥ea())
/ Connection attempt cancelled by user
r else if (f. i35ucces3())i
f cause(). printstackTrace(i
}e13e
/ Connection established successfully
图19-6I/O超时时间配置
·442·第19章 Future和 Promise
Channelfuture超时时间配置如图19-7所示。
Bootstrap b
ChannelEuture f b, connect(,,,)i
王,aWa⊥tUn⊥ ate-2uetI2iy(1, TImeUnIt. SECONDS)
1王(王, ScArce11ed())t
/ Connection attempt cancelled by user
3 else if (! f. 135uccess())(
/ You might get a NullPointerException here because the future
/ might not be completed yet
f cause(. printstackTrace();
s else t
/ Cornection established successfully
图19-7 Channel future超时时间配置
需要指出的是: Channel future超时并不代表I/O超时,这意味着 Channelfuture超时
后,如果没有关闭连接资源,随后连接依旧可能会成功,这会导致严重的问题。所以通常
情况下,必须要考虑究竟是设置IO超时还是 ChannelFuture超时。
19.2 Channel Future源码分析
ChannelFuture的接口继承关系如图19-8所示
io nettv channel
接口 ChannelFuture
所有超级按口:
java util. concurrent Future<java. lang Void>
所有已知子接口
ChannelProgressive Future ChannelProgressive Promise Channelpromise
所有已知实现类:
DefaultChannelProgressive Promise Defaut ChannelPromise
图19-8 Channelfuture接口继承关系图
443·Nety权威指南(第2版)
AbstractFuture
Abstract future实现 Future接口,它不允许IO操作被取消。下面我们重点看它的代码
实现。
获取异步操作结果的代码如图19-9所示。
public V get() throws Interrupted Exception, ExecutionException t
await(?
Throwable cause= cause()
if (cause = null)(
return getNow()
throw new Execution Exception(cause)
图19-9同步获取1/O操作结果
首先,调用 await(方法进行无限期阻塞,当1o操作完成后会被 notify。程序继续
向下执行,检査IO操作是否发生了异常,如果没有异常,则通过 getNowO方法获取结果
并返回。否则,将异常堆栈进行包装,抛出 Execution Exception
接着我们看支持超时的获取操作结果方法,如图19-10所示。
override
public V get(long timeout, TimeUnit unit) throws InterruptedException
Execution Exception, TimeoutException i
if (await(timeout, unit))(
Throwable cause cause()j
if (cause == null)t
return getNow O);
throw new Execution Exception(cause);
throw new Timeout Exception ()i
图19-10支持获取超时的方法
支持超时很简单,调用awai( long timeout, TimeUnit uni)方法即可。如果超时,则抛
出 TimeoutException。如果没有超时,则依次判断是否发生了IO异常等情况,操作与无
参数的get方法相同
其他 Channelfuture的实现子类,由于功能比较简单,读者阅读起来也没太大难度,
所以这里不再花费时间进行详细解读,感兴趣的读者可以独立阅读和分析。 Abstract Future
的继承关系如图19-11所示。
·444·第19章 Future和 Promise
Ine hierarchy efienett. atil concurrent. AbstractFuture:
G Objeet
=c AbstraetFuturacn-ia matty util. eoneurrant
CA CompleteFuturt o)-io netty util concurrent
=- C CoepleteChashelF田14!出hBa
g TailedChannalluture-1dnettychannel
cl SucceededchannelFuture-i9,nety,channel
C ail.dFatur. cv).te natty util concurrent
C'succeededFuturesw>-ie netty util concurrent
9 Defaul urromis4(v>-ienetty util concurrent
G DefaultChumhelGraupPutwre-io netty hammel graup
--G Dafaul tchushelPrasisa-te Fatty chattel
a Closeluture- to Letty channl AbstraetChannal
C D.faultPregesiwPreisav).it Batty util esher
G DeEaultChanellrepressiweFronise-to. netty,chanel
c ImmediatePregressivePromise )-1o betty util concurent, Immed at aEveatleeuter
I Inaedi ateProm134>-1 natty ut1cnra1m3图vEe好
cF LarrChannelFresise-1e netty handler srl.EelManlex
s 9 Promisefskv)p natty wtil eearurrent
a SehedledFaturelask2-10 tatty atil cane
F Yal dChasmelPreaise. io fetty channel
图19-11 Abstract future的继承关系图
193 Promise功能介绍
Promise是可写的 Future, Future自身并没有写操作相关的接口, Netty通过 Promise
对 Future进行扩展,用于设置I/O操作的结果。 Future相关的接口定义如图19-12所示。
10. netty util. concurrent
曰但Putu
isSuccess0. boolean
isCancellableo: boolean
● cause0: Throws
addListener (Generi cFutureListener < extends Future <? super v>>): Future<>
addListener s(GenerieFutureListener <? extends Future<? super v>>.): Future<v>
removelistener(GenericFutureListener<? extends Future<? super v>>): Future<v>
e removeLi steers (GenericFutureListener<? extends Future<? super V>>.). Future<v>
●symc0: Future
nterruptiblyO: Future<>
● await(: Future s
awai tUninterruptiblyO: Future vv>
t Qong, TimeUnit): boole
t Qong): bool
awai tUninterruptibly aong TimeUnit): boolean
awai tUninterruptibly aong): boolean
0:V
cancel (bolean): boolean
图19-12Net!y的 Future接口定义
Promise相关的写操作接口定义如图19-13所示。
445Nety权威指南(第2版)
Froma<y setFailnre (java. lang Throwable cause)
Marks this future as a failure and notifies all listeners
Gzom1sesetsuecess(v sesult)
Marks this future as a success and notifies all listeners
boolean setUncancellable ()
Make this future impossible to cancel
Prema<v> sync()
Waits for this future untl it is done and rethrows the cause of the failure if this futre failec
P里吧仍
syncUninterruptibly()
Waits for this future until it is done. and rethrows the cause of the failure if this future failed
beslan tryFailore(java. lang Throwable cause
Marks this future as a failure and notifies all listeners
boolean trySuccess(v result)
Marks this future as a success and notifies all listeners
图19-13 Promise写操作相关的接口定义
Netty发起I/O操作的时候,会创建一个新的 Promise对象,例如调用 Channelhandler
Context的 write( Object object)方法时,会创建一个新的 Channelpromise,相关代码如图
19-14
所
public ChannelPromise new Promise()(
return new DefaultchannelPromise(channel(), executor()
图19-14I/O操作时创建一个新的 Promise
当LO操作发生异常或者完成时,设置 Promise的结果,代码如图19-15所示。
@Override
public void write(Object msg, ChannelPromise promise)
if (isActiveO)
l' Mark the write request as failure if the channel is inactive
if (isOpen)I
promise. try Failure(NOT YET CONNECTED EXCEPTION)
else
promise. try Failure(CLOSED CHANNEL EXCEPTION)
l/ release message now to prevent resource-leak
Reference CountUtil release(msg)
]else i
outbound Buffer. add Message(msg, promise
图19-151O操作异常时调用 try Failure方法设置结果
·446第19章 Future和 Promise
19.4 Promise源码分析
194.1 Promise继承关系图
由于I/O操作种类非常多,因此对应的 Promise子类也非常繁多,它的继承关系如图
19-16所示。
日① Promi se<y>-i, netty.util. concurrent
B Defaul( v)-ionetty, util.concurrent
F DetanltChannelGroupFuture-ie netty channel group
Defaul tChannelPromise-i9 netty chann
EO GSF CloseFuture-ionettychannel.AbstractChannel
G DefaultChannelProgressivePromise-1o. netty, channel
GS Immedi ateProgressivePr omise v>-io netty atil concurrent. ImmediateEventExecutor
c ImmediatePromise<v>-1o netty util. concurrent. ImmediateEventExecutor
GF LatythannelPromise- io netty handler. ssl. SslHandler
A PromiseTask<v>-ionetty, util. concurrent
a scheduledFutureTask(>-ionetty util.concurrent
E-O ChannelPromise -io netty channel
E-C DefaultChannelPromise-ionetty channel
a CloseFuture-io. netty. channel. AbstractChannel
9 VoidchannelPr omise -ionetty chanel
日0 Chann1 rogressivePromi·-i0. netty. channe1
C DefaultChannelProgressivePromise-1o,netty, channel
U ProgressivePromise<v>-io netty util. concurrent
3-C DefaultProgessivePromise (v)-io, netty util. concurrent
C Defaul tChennelProgressivePromise-1o netty channel
0 S TmmediatefrogressivePromise v)- io netty util. concurrent. InmediateEventExecutor
ChannelProgressivePromise -io netty channel
C DefaultChannelProgressivePromise-io, nettychannel
图19-16 Promise继承关系图
尽管 Promise的子类种类繁多,但是它的功能相对比较清晰,代码也较为简单,因此
我们只分析一个它的实现子类的源码,如果读者对其他子类感兴趣,可以自行学习。
19.4.2 Default Promise
下面看比较重要的 setSuccess方法的实现,如图19-17所示。
首先调用 setsuccess0方法并对其操作结果进行判断,如果操作成功,则调用
·447·Ne!y权威指南(第2版)
notify Listeners方法通知 listener
@override
public Promise<V> setSuccess(V result)t
if(set Successo(result))f
notifyListenerso
return this.
throw new Illegal State Exception("complete already. " this)
图19-17 Default Promise的 setsuccess方法
set succe方法的实现如图19-18所示
private boolean setsuccesso(V result)i
if (isDone()t
return fals
synchronized this)(
if(is Done ())t
return false
if (result ==null)(
this result= SUCCESS
3 else i
this, result result
if(has Waiters)i
notify(:
图19-18 DefaultPromise的 set success0私有方法
首先判断当前 Promise的操作结果是否已经被设置,如果已经被设置,则不允许重复
设置,返回设置失败
由于可能存在O线程和用户线程同时操作 Promise,所以设置操作结果的时候需要
加锁保护,防止并发操作。
对操作结果是否被设置进行二次判断(为了提升并发性能的二次判断),如果已经被
设置,则返回操作失败。
对操作结果 result进行判断,如果为空,说明仅仅需要 notify在等待的业务线程,不
包含具体的业务逻辑对象。因此,将 result设置为系统默认的 SUCCESS。如果操作结果
非空,将结果设置为 result
·448第19章 Future和 Promise
如果有正在等待异步O操作完成的用户线程或者其他系统线程,则调用 notifyAll
方法唤醒所有正在等待的线程。注意, notify和wait方法都必须在同步块内使用。
分析完 setSuccess0方法,我们继续看 await方法的实现,如图19-19所示。
public Promise <v> await( throws InterruptedException i
if (idOneo)t
return this
if (Thread interrupted()
throw new InterruptedException(to String()
synchronized(this)
while(lisD。ne0)
check DeadLock
);
incWaiterso
try
waitO;
) finally
dewAters o
return
图19-19 Default Promise的 await方法
如果当前的 Promise已经被设置,则直接返回。如果线程已经被中断,则抛岀中断异
常。通过同步关键字锁定当前 Promise对象,使用循环判断对 is Done结果进行判断,进
行循环判断的原因是防止线程被意外唤醒导致的功能异常。如果对循环判断的实现原理
感兴趣,读者可以查看《 Effective Java中文版第2版》第243页对wait和 notify用法的
讲解。
由于在IO线程中调用 Promise的 await或者sync方法会导致死锁,所以在循环体中
需要对死锁进行保护性校验,防止1O线程被挂死,最后调用 java.lang. Object. waito方法
进行无限期等待,直到IO线程调用 setsuccess方法、 trySuccess方法、 setfailure或者
try Failure方法。
195总结
本章重点介绍了 Future和 Promise,由于 Netty中的I/o操作种类繁多,所以 Future
和 Promise的子类也非常繁多。尽管这些子类的功能各异,但本质上都是异步I/O操作结
449·Nety权威指南(第2版)
果的通知回调类。 Future-Listener机制在JDK中的应用已经非常广泛,所以本章并没有对
这些子类的实现做过多的源码分析,希望读者在本章源码分析的基础上自行学习其他相关
子类的实现
无论 Future还是 Promise,都强烈建议读者通过增加监听器 Listener的方式接收异步
I/O操作结果的通知,而不是调用wait或者sync阻塞用户线程
450架构和行业应用篇
Nety高级特性
第20章 Netty架构剖析
第21章Java多线程编程在Nety中的应用
第22章高性能之道
第23章可靠性
第24章安全性
第25章Net未来展望第20章
Netty架构剖析
本章将重点分析Nety的逻辑架构,通过对其关键架构质量属性的分析,让读者朋友
能够更加深入地了解 Netty的设计精髓
希望读者在今后的架构设计中能够从 Netty架构中汲取营养,设计出高性能、高可靠
性和可扩展的产品。
本章主要内容包括:
◎Nety逻辑架构分析
关键架构质量属性
20.1 Netty逻辑架构
Netty采用了典型的三层网络架构进行设计和开发,逻辑架构如图20-1所示。第20章 Netty架构剖析
Service
Http Protocol
Thrift Protocl
Data service
C
ge sevice
CMPP Protocol
FTP Protocl
Mail service
Order service
Pi
beLine
Tail handler
Channel
Encode handler
Dcode handier
DUT IN
PipeLine
Header Handier
Reactor
NioSocket channel
NioTask
select
execute
Server Reactor pool
Client reactor pool
Fox Scheduler Pool
Channel
Task
图20-1Nety逻辑架构图
20.1.1 Reactor通信调度层
它由一系列辅助类完成,包括 Reactor线程 NioEventLoop及其父类, NioSocketchannel
Nio Server Socketchannel及其父类, Byte Buffer以及由其衍生出来的各种 Buffer, Unsafe
以及其衍生出的各种内部类等。该层的主要职责就是监听网络的读写和连接操作,负责将
网络层的数据读取到内存缓冲区中,然后触发各种网络事件,例如连接创建、连接激活、
读事件、写事件等,将这些事件触发到 Pipe line中,由 Pipeline管理的职责链来进行后续
的处理。
20.1.2职责链 ChannelPipeline
它负责事件在职责链中的有序传播,同时负责动态地编排职责链。职责链可以选择监
听和处理自己关心的事件,它可以拦截处理和向后/向前传播事件。不同应用的 Handler节
点的功能也不同,通常情况下,往往会开发编解码 Hanlder用于消息的编解码,它可以将
外部的协议消息转换成内部的POO对象,这样上层业务则只需要关心处理业务逻辑即可,
不需要感知底层的协议差异和线程模型差异,实现了架构层面的分层隔离。
●453Nety权威指南(第2版)
20.1.3业务逻辑编排层( Service ChannelHander)
业务逻辑编排层通常有两类:一类是纯粹的业务逻辑编排,还有一类是其他的应用层
协议插件,用于特定协议相关的会话和链路管理。例如CMPP协议,用于管理和中国移动
短信系统的对接。
架构的不同层面,需要关心和处理的对象都不同,通常情况下,对于业务开发者,只
需要关心职责链的拦截和业务 Handler的编排。因为应用层协议栈往往是开发一次,到处
运行,所以实际上对于业务开发者来说,只需要关心服务层的业务逻辑开发即可。各种应
用协议以插件的形式提供,只有协议开发人员需要关注协议插件,对于其他业务开发人员
来说,只需关心业务逻辑定制。这种分层的架构设计理念实现了NO框架各层之间的解耦,
便于上层业务协议栈的开发和业务逻辑的定制。
正是由于 Netty的分层架构设计非常合理,基于 Netty的各种应用服务器和协议栈开
发才能够如雨后春笋般得到快速发展。
20.2关键架构质量属性
20.2.1高性能
影响最终产品的性能因素非常多,其中软件因素如下。
◎架构不合理导致的性能问题。
编码实现不合理导致的性能问题,例如锁的不恰当使用导致性能瓶颈
硬件因素如下。
◎服务器硬件配置太低导致的性能问题。
⑧带宽、磁盘的IOPS等限制导致的LO操作性能差
◎测试环境被共用导致被测试的软件产品受到影响。
尽管影响产品性能的因素非常多,但是架构的性能模型合理与否对性能的影响非常
大。如果一个产品的架构设计得不好,无论开发如何努力,都很难开发出一个高性能、高
可用的软件产品。
454·第20章 Netty架构剖析
“性能是设计出来的,而不是测试出来的”。下面我们看 Netty的架构设计是如何实现
高性能的。
(1)采用异步非阻塞的1O类库,基于 Reactor模式实现,解决了传统同步阻塞IO
模式下一个服务端无法平滑地处理线性增长的客户端的问题。
(2)TCP接收和发送缓冲区使用直接内存代替堆内存,避免了内存复制,提升了IO
读取和写入的性能。
3〕支持通过内存池的方式循环利用 Byte Buf,避免了频繁创建和销毁 Byte Buf带来
的性能损耗。
(4)可配置的IO线程数、TCP参数等,为不同的用户场景提供定制化的调优参数,
满足不同的性能场景。
〔5)采用环形数组缓冲区实现无锁化并发编程,代替传统的线程安全容器或者锁。
(6)合理地使用线程安全容器、原子类等,提升系统的并发处理能力。
(7)关键资源的处理使用单线程串行化的方式,避免多线程并发访问带来的锁竞争和
额外的CPU资源消耗问题。
〔8)通过引用计数器及时地申请释放不再被引用的对象,细粒度的内存管理降低了
GC的频率,减少了频繁GC带来的时延增大和CPU损耗。
无论是Nety的官方性能测试数据,还是携带业务实际场景的性能测试,Nety在各个
NIO框架中综合性能是最高的。下面,我们来看 Netty官方的性能测试数据,如图20-2
20-3、20-4和20-5所示。
sre-b Loopback
my Frmn A Frmmhetk B Frmr C Frrmark D
afS
0779
076
3
251
189
121
4
2909
2027
1590
3735
6152
451
172
277
2633
1主
4452
3.910
354528
66s
396
4454
LaO
37
35T
45
4945
12B5
3.72
436g
2793
cormer connectens
1EIDD
38集
4211
Eope12RLoenbudk
S设128Laak
Net千m函 k A FIrmE B FimmwrkC Frmwetk D
14s0
1245
119g
L569
L054
3.717
3402
1B-e
102
72E
啁01
6936
2
573
息35
52a
SEa
1223
48
500132F4
5的7
19
8心
1000
11741
7
7223
选
7022
5.
0m0
9下06
6思4
397
759
510510000100050001DoD
96
726
618
图20-264和128字节测试消息(本机网卡回环)
·455·Ne权威指南(第2版)
Sratt4Loopback
se=254 Loopback
回"需"
Frmrtc Fimt B
1973
6279
959
22466
6206
177
110
7s2
15m2
1064
420
16邦4514351
500a9
E6 686
15465
171
145
195】6
17s7111090
501810a
LBB1461215B156714
renrureri cretins
PgsI
Fanoimance Companion bihar NU Frameworks
s10241ab
Size=1024 Loopback
Hetty Frow真Fmw吕 mwer C Frmwnk T
1拍c
1
如711001003
98581
返8355
10720
167
5451
52且1s57颐
457
;i1:
330
615785A433
0留97积662我0到25
000Q
443
78
Pdos
51-B4H
45.521
5程
fr007
42562
图20-3256和1K字节测试消息(本机网卡回环)
great IGb Chemet
Srremb 1b ethemet
Wenty Finer A Firmer E Frimwwrs< Fmri D
0320
031
0426
0418
032
131
L40
14U
3]9
上28
2238
3992
484
4467
4是0
4B45
5
533
17
13850100102
53
4324
1636
75
的·加A甲(即D
aurea 128 1Gb ethernet
引=22 a IGh Ethernet
隔伤 Fimwurk i snarl日 muTk[ Firework D
1
07
a74
0B37
260
2496
269
737
4474
4192
4
872
264
11
12882
La152
72
933
1012631043310214
119
9108410.785
9143
LooR
I. DEO
15
46
9M8
悉7
30
960
是
a
44
CEPe cmn-stamm
图20-464和128字节测试消息(跨主杌逼信)
Stws3561Gb Et
A Fomat E Frsh c即mD
se26 1Gb Thanet
1417
1596
122
139
4了
4已L3
4711
8173
8430
7577
2±12
氵:1!i
L6 NGSS
155815M02
画595
719
19F
8974
182
6423
70
18
2221
1846
丑03m1815卫817512
1
110g20191540
2000012518268
4B0
Peformance Comparison between NA Frameworks
Serm He24 .Gb Ethernet
sihe=104 1Gb Ethernet
etb rmwrk A merk B rmmwrkc Frnk D
1
4E5
5248
41
4710
51472
766194
L691
103112728612m0269计s
t:!1
857267207
65274
57051
914
1m633满41443867665571
WeH
5914
6O3
108012100
123
∞e杨205537
图20-5256和1K字节测试消息(跨主机通信)
·456·第20章 Netty架构剖析
202.2可靠性
作为一个高性能的异步通信框架,架构的可靠性是大家选择的一个重要依据。下面我
们探讨Nety架构的可靠性设计。
1.链路有效性检测
由于长连接不需要每次发送消息都创建链路,也不需要在消息交互完成时关闭链路,
因此相对于短连接性能更高。对于长连接,一旦链路建立成功便一直维系双方之间的链路,
直到系统退出
为了保证长连接的链路有效性,往往需要通过心跳机制周期性地进行链路检测。使用
周期性心跳的原因是:在系统空闲时,例如凌晨,往往没有业务消息。如果此时链路被防
火墙Hang住,或者遭遇网络闪断、网络单通等,通信双方无法识别出这类链路异常。等
到第二天业务高峰期到来时,瞬间的海量业务冲击会导致消息积压无法发送给对方,由于
链路的重建需要时间,这期间业务会大量失败(集群或者分布式组网情况会好一些)。为
了解决这个问题,需要周期性的心跳对链路进行有效性检测,一旦发生问题,可以及时关
闭链路,重建TCP连接。
当有业务消息时,无须心跳检测,可以由业务消息进行链路可用性检测。所以心跳消
息往往是在链路空闲时发送的
为了支持心跳,Nety提供了如下两种链路空闲检测机制。
◎读空闲超时机制:当连续周期T没有消息可读时,触发超时 Handler,用户可以
基于读空闲超时发送心跳消息,进行链路检测;如果连续N个周期仍然没有读取
到心跳消息,可以主动关闭链路。
◎写空闲超时机制:当连续周期T没有消息要发送时,触发超时 Handler,用户可
以基于写空闲超时发送心跳消息,进行链路检测:如果连续N个周期仍然没有接
收到对方的心跳消息,可以主动关闭链路。
为了满足不同用户场景的心跳定制,Net!y提供了空闲状态检测事件通知机制,用户
可以订阅空闲超时事件、写空闲超时事件、读或者写超时事件,在接收到对应的空闲事件
之后,灵活地进行定制
457·Nety权威指南(第2版)
2.内存保护机制
Netty提供多种机制对内存进行保护,包括以下几个方面。
⊙通过对象引用计数器对Net!y的 Byte Buf等内置对象进行细粒度的内存申请和释
放,对非法的对象引用进行检测和保护
◎通过内存池来重用 Byte Buf,节省内存。
可设置的内存容量上限,包括 Byte Buf、线程池线程数等
AbstractReference Counted Byte Buf的内存管理方法实现如图20-6、20-7所示
OVerride
public ByteBuf retain()[
for(::)(
int refCnt this, refCnti
if( refCnt=8)〖
throw new IllegalReferenceCount Exception(e, 1);
if (refCnt = Integer MA VALUE)(
throw new IllegalReferenceCountException(Integer. MAX VALUE, 1);
if (refcntUpdater compareAndset(this, refCnt, refCnt+ 1))(
return this;
图20-6对象引用
override
public final boolean release()(
for (i;)t
int refCnt this, refCntj
if (refCnt =s 0)I
throw new IllegalReference Count Exception(e,-1);
if (refCntUpdater compareAndSet(this, refCnt, refCnt-1))t
if (refCnt =s 1)(
deallocate
return true;
t
图20-7对象引用释放
Byte Buf的解码保护,防止非法码流导致内存溢出,代码如图20-8所示。
·458·第20章 Netty架构剖析
param maxFrameLength
the maximum length of the frame. If the length of the frame is
greater than this value, (elink TooLong Frame Exception will be
thrown.
Param lengthFieldoffset
the offset of the length field
param lengthFieldLength
the length of the length field
public LengthFieldBasedFrame Decoder(
int maxFrameLength,
int lengthFieldOffset, int lengthFieldLength)t
this(max Frame Length, lengthFieldoffset, lengthFieldLength, 0, o);
图20-8解码器单条消息最大长度上限保护
如果长度解码器没有单个消息最大报文长度限制,当解码错位或者读取到畸形码流
时,长度值可能是个超大整数值,例如4294967296,这很容易导致内存溢出。如果有上限
保护,例如单条消息最大不允许超过10MB,当读取到非法消息长度4294967296后,直接
抛出解码异常,这样就避免了大内存的分配
3.优雅停机
相比于Nety的早期版本,Nety5.0版本的优雅退出功能做得更加完善。优雅停机功
能指的是当系统退出时,JVM通过注册的 Shutdown hook拦截到退出信号量,然后执行退
岀操作,释放相关模块的资源占用,将缓冲区的消息处理完成或者清空,将待刷新的数据
持久化到磁盘或者数据库中,等到资源回收和缓冲区消息处理完成之后,再退出。
优雅停机往往需要设置个最大超时时间T,如果达到T后系统仍然没有退出,则通过
Kl-9pid强杀当前的进程。
Net!y所有涉及到资源回收和释放的地方都增加了优雅退出的方法,它们的相关接口
如表20-1所示。
表20-1Nety重要资源的优雅退出方法
EventExecutorGroup. shutdownGracefullyo
NIO线程优雅退出
Event Group. shutdown Gracefully(long quiet Period, long
NIO线程优雅退出,支持设置超时时间
timeout, TimeUnit unit
Channel closed
Channel的关闭
Unsafe. close( ChannelPromise promise)
Unsafe的关闭操作,可以设置可写的 Future
Unsafe.close()
Unsafe的强制关闭操作
459·Net!y权威指南(第2版)
续表
ChannelPipeline. close
ChannelPipeline的关闭
ChannelPipeline. close( ChannelPromise promise)
ChannelPipeline的关闭,可以设置可写的 Future
ChannelHandler. close( ChannelHandlerContext ctx, ChannelPromi
Channelhandler的关闭
promise
20.2.3可定制性
Netty的可定制性主要体现在以下几点。
◎責任链模式: Channelpipeline基于責仼链模式开发,便于业务逻辑的拦截、定制
和扩展。
◎基于接口的开发:关键的类库都提供了接口或者抽象类,如果Nety自身的实现
无法满足用户的需求,可以由用户自定义实现相关接口。
◎提供了大量工厂类,通过重载这些工厂类可以按需创建出用户实现的对象。
◎提供了大量的系统参数供用户按需设置,增强系统的场景定制性。
20.24可扩展性
基于Nety的基础Nlo框架,可以方便地进行应用层协议定制,例如HTTP协议栈、
Thrift协议栈、FTP协议栈等。这些扩展不需要修改Net!y的源码,直接基于Net!的二进
制类库即可实现协议的扩展和定制。
日前,业界存在大量的基于Nety框架开发的协议,例如基于Nety的HTTP协议、
Dubbo协议、 RocketMO内部私有协议等。
20.3总结
本章首先对Nety的逻辑架构进行了分层和介绍,让读者能够从架构的层面了解
Nety,随后对Nety的关键架构质量属性进行了详细分析和介绍。通过对Net!架构的剖
析和讲解,希望读者能够掌握如何设计髙性能、髙可靠性、可定制性和可扩展的软件架构。
460·第21章
Java多线程编程在 Netty
中的应用
作为异步事件驱动、高性能的NIO框架,Nety代码中大量运用了Java多线程编程技
巧。并发编程处理的恰当与否,将直接影响架构的性能。本章通过对Net!y源码的分析,
结合并发编程的常用技巧,来讲解多线程编程在Net中的应用。
本章主要内容包括
⑧Java内存模型与多线程编程
◎ Netty的并发编程剖析
211Java内存模型与多线程编程
21.1.1硬件的发展和多任务处理
随着硬件,特別是多核处理器的发展和价格的下降,多任务处理已经是所有操作系统
必备的一项基本功能。在同一个时刻让计算机做多件事情,不仅是因为处理器的并行计算Net!权威指南(第2版)
能力得到了很大提升,还有一个重要的原因是计算机的存储系统、网络通信等O性能与
CPU的计算能力差距太大,导致程序的很大一部分执行时间被浪费在 O wait上面,CPU
的强大运算能力没有得到充分地利用。
Java提供了很多类库和工具用于降低并发编程的门槛,提升开发效率,一些开源的第
三方软件也提供了额外的并发编程类库来方便Java开发者,使开发者将重心放在业务逻
辑的设计和实现上,而不是处处考虑线程的同步和锁。但是,无论并发类库设计得如何完
美,它都无法完全满足用户的需求。对于一个高级Java程序员来说,如果不懂得Java并
发编程的原理,只懂得使用一些简单的并发类库和工具,是无法完全驾驭Java多线程这
匹野马的。
21.1.2Java内存模型
JVM规范定义了Java内存模型( Java Memory Model)来屏蔽掉各种操作系统、虚拟
机实现厂商和硬件的内存访问差异,以确保Java程序在所有操作系统和平台上能够实现
次编写、到处运行的效果。
Java内存模型的制定既要严谨,保证语义无歧义,还要尽量制定得宽松一些,允许各
硬件和虚拟机实现厂商有足够的灵活性来充分利用硬件的特性提升Java的内存访冋性能。
随着JDK的发展,Java的内存模型已经逐渐成熟起来。
1.工作内存和主内存
Java内存模型规定所有的变量都存储在主内存中(JVM内存的一部分),每个线程有
自己独立的工作内存,它保存了被该线程使用的变量的主内存复制。线程对这些变量的操
作都在自己的工作内存中进行,不能直接操作主内存和其他工作内存中存储的变量或者变
量副本。线程间的变量访问需通过主内存来完成,三者的关系如图21-1所示。
线程1
工作内存1
内存
操作
主内存
线程2
工作内存2
指令
图21-1Java内存访问模型
462·第21章Java多线程编程在Net!中的应用
2.Java内存交互协议
Java内存模型定义了8种操作来完成主内存和工作内存的变量访问,具体如下。
◎lock:主内存变量,把一个变量标识为某个线程独占的状态
◎ unlock:主内存变量,把一个处于锁定状态变量释放出来,被释放后的变量才可
以被其他线程锁定。
◎read:主内存变量,把一个变量的值从主内存传输到线程的工作内存中,以便随
后的load动作使用
◎load:工作内存变量,把read读取到的主内存中的变量值放入工作内存的变量副
本中
◎use:工作内存变量,把工作内存中变量的值传递给Java虚拟机执行引擎,每当
虚拟机遇到一个需要使用到变量值的字节码指令时,将会执行该操作。
◎ assign:工作内存变量,把从执行引擎接收到的变量的值赋值给工作变量,每当
虚拟机遇到一个给变量赋值的字节码时,将会执行该操作
◎ store:工作内存变量,把工作内存中一个变量的值传送到主内存中,以便随后的
write操作使用。
◎ write:主内存变量,把 store操作从工作内存中得到的变量值放入主内存的变量中。
3.Java的线程
并发可以通过多种方式来实现,例如:单进程-单线程模型,通过在一台服务器上启
动多个进程来实现多任务的并行处理。但是在Java语言中,通常是通过单进程一多线程的
模型进行多任务的并发处理。因此,我们有必要熟悉一下Java的线程
大家都知道,线程是比进程更轻量级的调度执行单元,它可以把进程的资源分配和调
度执行分开,各个线程可以共享内存、Io等操作系统资源,但是又能够被操作系统发起
的内核线程或者进程执行。各线程可以独立地启动、运行和停止,实现任务的解耦。
主流的操作系统提供了线程实现,目前实现线程的方式主要有三种,分别如下
(1)内核线程(KLT)实现,这种线程由内核来完成线程切换,内核通过线程调度器
对线程进行调度,并负责将线程任务映射到不同的处理器上。
463Net!y权威指南(第2版
2)用户线程实现(UT),通常情况下,用户线程指的是完全建立在用户空间线程库
上的线程,用户线程的创建、启动、运行、销毁和切换完全在用户态中完成,不需要内核
的帮助,因此执行性能更高。
(3)混合实现,将内核线程和用户线程混合在一起使用的方式。
由于虛拟机规范并没有强制规定Java的线程必须使用哪种方式实现,因此,不同的
操作系统实现的方式也可能存在差异。对于SUN的JDK,在 Windows和 Linux操作系统
上采用了内核线程的实现方式,在 Solaris版本的JDK中,提供了一些专有的虚拟机线程
参数,用于设置使用哪种线程模型。
21.2 Netty的并发编程实践
212.1对共享的可变数据进行正确的同步
关键字 synchronized可以保证在同一时刻,只有一个线程可以执行某一个方法或者代
码块。同步的作用不仅仅是互斥,它的另一个作用就是共享可变性,当某个线程修改了可
变数据并释放锁后,其他线程可以获取被修改变量的最新值。如果没有正确的同步,这种
修改对其他线程是不可见的。
下面我们就通过对Nety源码的分析,看看Net!是如何对并发可变数据进行正确同
步的。
以 Server Bootstrap为例进行分析,首先看它的 option方法,如图21-2所示。
public <T> B option(ChannelOption<T> option. T value)i
if (or
null)
throw new NullPointerException ("option")
if (value
synchronized (options)
options. remove(option
S else I
synchronized(options)(
options put(option, value)
return(B)this
图21-2同步关键字的使用
464第21章Java多线程编程在 Netty中的应用
这个方法的作用是设置 ServerBootstrap的 ServerSocketchannel的 Socket属性,它的
属性集定义如下。
rivate final Mapcchanne1Option<?>, Cbject> options- new LinkedHas hMap<channe l0ptionc?>, object>():
由于是非线程安全的 LinkedHashMap,所以当多线程创建、访问和修改 LinkedHashMap
时,必须在外部进行必要的同步。 LinkedHash Map的 API DOC对于线程安全的说明如图
21-3所示。
山 stracBootstrapiava: Linked
A cAP
bAm事田 Tiu k c Linker
than for <tt>HashMap</tt>, as iteration times for this class are unaffected
pa
p><strong Note that this Implementation 1s not synchronized. </strong
ultiple threads access a linked hash map concurrently, and at leas
one of the threads modifies the map structurally, it <emmust</em> be
synchronized externally. This is typically accomplished by
synchronizing on some object that naturally encapsulates the map
图21-3 LinkedHash Map线程安全API说明
由于 Server Bootstrap是被外部使用者创建和使用的,我们无法保证它的方法和成员变
量不被并发访问,因此,作为成员变量的 options必须进行正确地同步。由于考虑到锁的
范围需要尽可能的小,我们对传参的 option和 value的合法性判断不需要加锁。因此,代
码才对两个判断分支独立加锁,保证锁的范围尽可能的细粒度。
Net!y加锁的地方非常多,大家在阅读代码的时候可能会有体会,为什么有的地方要
加锁,有的地方却不需要?如果不需要,为什么?当你对锁的使用原理足够理解以后,对
于这些锁的使用时机和技巧就会十分清楚了。
21.2.2正确使用锁
很多刚接触多线程编程的开发者,虽然意识到了并发访问可变变量需要加锁,但是对
于锁的范围、加锁的时机和锁的协同缺乏认识,往往会导致出现一些问题。下面笔者就结
合 Netty的代码来讲解下这方面的知识。
打开 Fork join task,我们学习一些多线程同步和协作方面的技巧。首先是当条件不满
足时阻塞某个任务,直到条件满足后再继续执行,代码如图21-4所示
重点看框线中的代码,首先通过循环检测的方式对状态变量 status进行判断,当它的
状态大于等于0时,执行waiO,阻塞当前的调度线程,直到 status小于0,唤醒所有被阻
塞的线程,继续执行。这个方法有以下三个多线程的编程技巧需要说明。
465·Nett权威指南(第2版)
private int externalAwait(
int s
ForkJoin Pool cp- ForkJoin Pool. common
if (s= status)>=0)I
if (cp l= null)I
if (this instanceof CountedCompleter)
s=cp. externalHelp Complete((Counted Completer?> )this)
else if (cp try ExternalUnpush( this)
s= doExec
if(s >=0 &&(s= status)>=0)
boolean interrupted= false
do i
if(u.compareandswapint(this,stAtus,s,SsigNal))(
synchronized (this)t
if(status >=0)(
y
wait(
y catch(Interrupted Exception ie)t
interrupted=true;
notify All:
y while ((s= status)>=0)
图21-4多线程协作
(1)wait方法用来使线程等待某个条件,它必须在同步块内部被调用,这个同步块通
常会锁定当前对象实例。下面是这个模式的标准使用方式。
synchronized (this)
While(condition)
Object.waiti
2)始终使用wait循环来调用wait方法,永远不要在循环之外调用wait方法。这样
做的原因是尽管并不满足被唤醒条件,但是由于其他线程调用 notify All)方法会导致被阻
塞线程意外唤醒,此时执行条件并不满足,它将破坏被锁保护的约定关系,导致约束失效,
引起意想不到的结果。
(3)唤醒线程,应该使用 notify还是 notifyAll?当你不知道究竟该调用哪个方法时,
保守的做法是调用 notifyAll唤醒所有等待的线程。从优化的角度看,如果处于等待的所有
线程都在等待同一个条件,而每次只有一个线程可以从这个条件中被唤醒,那么就应该选
择调用 notify
466·第21章Java多线程编程在Net!y中的应用
当多个线程共享同一个变量的时候,每个读或者写数据的操作方法都必须加锁进行同
步,如果没有正确的同步,就无法保证一个线程所做的修改被其他线程共享。未能同步共
享变量会造成程序的活性失败和安全性失败,这样的失败通常是难以调试和重现的,它们
可能间歇性地出问题,可能随着并发的线程个数增加而失败,也可能在不同的虚拟机或者
操作系统上存在不同的失败概率。因此,务必要保证锁的正确使用。下面这个案例,就是
个典型的错误应用。
int size=0:
public synchronized void increase(
sIze++:
public int current(
Return size:
2123 volatile的正确使用
长久以来大家对于 volatile如何正确使用有很多的争议,既便是一些经验丰富的Java
设计师,对于 volatile和多线程编程的认识仍然存在误区。其实, volatile的使用非常简单,
只要理解了Java的内存模型和多线程编程的基础知识,正确使用 volatile是不存在任何问
题的。下面我们结合Nety的源码,对 volatile的正确使用进行说明。
打开 NioEventLoop的代码,我们来看控制I/O操作和其他任务运行比例的 hoRatio,
它是int类型的变量,定义如下。
private volatile int- 50;
我们发现,它被定义为 volatile,为什么呢?我们首先对 volatile关键字进行说明,然
后再结合 Netty的代码进行分析。
关键字 volatile是Java提供的最轻量级的同步机制,Java内存模型对 volatile专门定
义了一些特殊的访问规则。下面我们就看它的规则
当一个变量被 volatile修饰后,它将具备以下两种特性。
⑧线程可见性:当一个线程修改了被 volatile修饰的变量后,无论是否加锁,其他
·467·Net!权威指南(第2版)
线程都可以立即看到最新的修改,而普通变量却做不到这点。
◎禁止指令重排序优化,普通的变量仅仅保证在该方法的执行过程中所有依赖赋值
结果的地方都能获取正确的结果,而不能保证变量赋值操作的顺序与程序代码的
执行顺序一致。举个简单的例子说明下指令重排序优化问题,如图21-5所示。
public class Thread StopExample
private static boolean stop
public static void main(Stringl args) throws InterruptedException
java. lang Thread work T hread = new java. lang Thread(new
Runnable()(
public void runo
inti=0:
while(Istop)
Time Unit. SECONDS sleep(1)
3 catch(InterruptedException e)(
eprintstackTrace(
work Thread. start()
TimeUnit, SECONDS sleep(3)
stop =t
图21-5指令重排序和优化导致线程无法退出
我们预期程序会在3s后停止,但是实际上它会一直执行下去,原因就是虚拟机对代
码进行了指令重排序和优化,优化后的指令如下。
if ( stop
While(true)
重排序后的代码是无法发现stop被主线程修改的,因此无法停止运行。要解决这个问
题,只要将stop前增加 volatile修饰符即可。代码修改如图21-6所示。
再次运行,我们发现3s后程序退出,达到了预期效果,使用 volatile解决了如下两个
向题。
main线程对stop的修改在 work Thread线程中可见,也就是说 work Thread线程立
即看到了其他线程对于stop变量的修改
◎禁止指令重排序,防止因为重排序导致的并发访问逻辑混乱
468·第21章Java多线程编程在Net!中的应用
些人认为使用 volatile可以代替传统锁,提升并发性能,这个认识是错误的。 volatile
仅仅解决了可见性的问题,但是它并不能保证互斥性,也就是说多个线程并发修改某个变
量时,依旧会产生多线程问题。因此,不能靠 volatile来完全替代传统的锁
public class ThreadStopExample
private volatile static boolean stop
public static void main(Stringl args) throws Interrupted Exception
java lang Thread work Thread new java. lang Thread(new
Runnable(
public void runo(
inti= 0
while(Istop)(
TimeUnit SECONDS sleep(1);
3 catch(Interrupted Exception e)i
eprintstackTrace(
)
work Thread. start(:
TimeUnit SECONDS sleep(3):
stop=true.
图21-6 volatile解决指令重排序和编译优化问题
根据经验总结, volatile最适合使用的是一个线程写,其他线程读的场合,如果有多
个线程并发写操作,仍然需要使用锁或者线程安全的容器或者原子变量来代替。
讲了 volatile的原理之后,我们继续对 Netty的源码做分析。上面讲到了 hoRatio被定
义成 volatile,下面看看代码为什么要这样定义。参见如图21-7所示代码。
final long io Time System, nano Time()-ioStartT ime
final int ioRatio this, ioRatio
nAllTasks(io Time*(100-io Ratio)/ioRatio):
图21-7 volatile在 NioEventLoop线程中的应用
通过代码分析我们发现,在 NioEventLoop线程中, io Ratio并没有被修改,它是只读
操作。既然没有修改,为什么要定义成 volatile呢?继续看代码,我们发现 NioEventLoop
提供了重新设置IO执行时间比例的公共方法,接口如图21-8所示。
469·Net!y权威指南(第2版)
public void seto Ratio(int ioRatio)(
if (ioRatio <=0 hoRatio > 100)I
throw new IllegalArgumentException("ioRatio: " ioRatio +"(expected: 0
hoRatio <100)"):
this, io Ratio ioR
图21-8修改 volatile变量
首先, NioEventLoop线程没有调用该方法,说明调整IO执行时间比例是外部发起的
操作,通常是由业务的线程调用该方法,重新设置该参数。这样就形成了一个线程写
个线程读。根据前面针对 volatile的应用总结,此时可以使用 volatile来代替传统的
synchronized关键字提升并发访问的性能。
Nety中大量使用了 volatile来修改成员变量,如果理解了 volatile的应用场景,读懂
Netty volatile的相关代码还是比较容易的。
2124CAS指令和原子类
互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能的额外损耗,因此这种
同步被称为阻塞冋步,它属于一种悲观的并发策略,我们称之为悲观锁。随着硬件和操作
系统指令集的发展和优化,产生了非阻塞同步,被称为乐观锁。简单地说,就是先进行操
作,操作完成之后再判断操作是否成功,是否有并发问题,如果有则进行失败补偿,如果
没有就算操作成功,这样就从根本上避免了同步锁的弊端。
日前,在Java中应用最广泛的非阻塞同步就是CAS,在IA64、X86指令集中通过
cmpxchg指令完成CAS功能,在 sparc-TSO中由case指令完成,在ARM和 PowerPC架
构下,需要使用一对 Idrex/strex指令完成。
从JDK1.5以后,可以使用CAS操作,该操作由sun. misc. Unsafe类里的
compare AndSwaplnt(和 compare AndSwapLongo等方法包装提供。通常情况下
sun. mIso. Unsafe类对于开发者是不可见的,因此,JDK提供了很多CAS包装类简化开发
者的使用,如 AtomicInteger
下面,结合Nety的源码,我们对原子类的正确使用进行详细说明。
打开 Channeloutbound Buffer的代码,看看如何对发送的总字节数进行计数和更新操
作,先看定义,如图21-9所示
·470·第21章Java多线程编程在 Netty中的应用
private static final AtomicLong FieldUpdater< channeloutbound Buffer?
TOTAL PENDING SIZE UPDATERE
AtomicLong Field Updater. newUpdater( Channeloutbound Buffer. class.
totalPendingsize:
private volatile long totalPending Size
图21-9原子类的应用
首先定义了一个 volatile的变量,它可以保证某个线程对于 totalPending Size的修改可
以被其他线程立即访问,但是,它无法保证多线程并发修改的安全性。紧接着又定义了
个 AtomicIntegerFieldupdater类型的变量 WTOTAL PENDING SIZE UPDATER,实现
totalPending Size的原子更新,也就是保证 totalPending Size的多线程修改并发安全性,我
们重点看 AtomicInteger FieldUpdater的API说明,如图21-10所示。
从API的说明可以看出,它主要用于实现 volatile修饰的int变量的原子更新操作,对
于使用者,必须通过类似 compareAndSet或者set或者与这些操作等价的原子操作来保证
更新的原子性,否则会导致问题。
A reflection-based utility that enables atomic updates to
designated (@code volatile long) fields of designated classes
This class is designed for use in atomic data structures in which
several fields of the same node are independently subject to atomic
<p>Note that the guarantees of the @code compare]
method in this class are weaker than in other atomic classes
Because this class cannot ensure that all uses of the field
re appropriate for purposes of atomic access. it can
guarantee atomicity only with respect to other invocations of
public abstract class AtomicLongFieldUpdater<T>i
图21-10 AtomicInteger FieldUpdater Java DOC说明
继续看代码,当执行 write操作外发消息的时候,需要对外发的消息字节数进行统计汇
总。由于调用 write操作的既可以是Io线程,也可以是业务的线程,还可能由业务线程池
多个工作线程同时执行发送任务,因此,统计操作是多线程并发的,这也就是为什么要将计
数器定义成 volatile并使用原子更新类进行原子操作。下面看计数的代码,如图21-11所示。
long oldvalue totalPendingsize
long newWrite Buffer Size old Value size
while(ITOTAL PENDING SIZE UPDATER. compare Andset(this
old Value, newWrite BufferSize))(
oldvalue= totalPendingsize
newWrite Buffer Size oldvalue size
图21-11通过自旋对计数器进行更新
471Net!权威指南(第2版
首先,我们发现计数操作并没有使用锁,而是利用CAS自旋操作,通过 TOTAL
PENDING SIZE UPDATER. compare AndSet(this, old value, new Write Buffer size)来判断本次
原子操作是否成功。如果成功则退出循环,代码继续执行;如果失败,说明在本次操作的
过程中计数器已经被其他线程更新成功,需要进入循环,首先对 old value进行更新,代码
如下。
oldvalue totalPendingsize;
然后重新对更新值进行计算。
newWriteBuffersize oldvalue size;
继续循环进行CAS操作,直到成功。它跟 AtomicInteger的 compareAndSet操作类似。
使用Java自带的 Atomic原子类,可以避免同步锁带来的并发访问性能降低的问题,
减少犯错的机会。因此,Nety中对于int、long、 boolean等成员变量大量使用其原子类,
减少了锁的应用,从而降低了频繁使用同步锁带来的性能下降。
2125线程安全类的应用
在JDK15的发行版本中,Java平台新增了 javautil.concurrent,这个包中提供了一系
列的线程安全集合、容器和线程池,利用这些新的线程安全类可以极大地降低Java多线
程编程的难度,提升开发效率
新的并发编程包中的工具可以分为如下4类。
◎线程池 Executor Framework以及定时任务相关的类库,包括 Timer等
◎并发集合,包括List、 Queue、Map和Set等。
◎新的同步器,例如读写锁 Read Write Lock等。
◎新的原子包装类,例如 AtomicInteger等。
在实际编码过程中,我们建议通过使用线程池、Task( Runnable/Callable)、原子类和
线程安全容器来代替传统的同步锁、wait和 notify,以提升并发访问的性能、降低多线程
编程的难度。
下面,针对新的线程并发包在 Netty中的应用进行分析和说明,以期为大家的学习和
应用提供指导。
·472·第21章Java多线程编程在Nett中的应用
首先看下线程安全容器在Nety中的应用。 Nio EventLoop是IO线程,负责网络读写
操作,同时也执行一些非O的任务。例如事件通知、定时任务执行等,因此,它需要一
个任务队列来缓存这些Task。它的任务队列定义如图21-12所示。
@override
protected Queue<Runnable> newTaskQueueOt
I/ This event loop never calls take Task(
return new ConcurrentLinked Queue<Runnable>(
图21-12线程任务队列定义
它是一个 ConcurrentLinked Queue,我们看它的API说明,如图21-13所示。
An unbounded thread-safe @linkplain Queue queue) based on linked
nodes
This queue orders elements FIFo(first-in-first-out
The <emshead <lem> of the queue is that element that has been on the
queue the longest time.
The <em>tails/em>of the queue is that element that has been on the
queue the shortest time. New elements
are inserted at the tail of the queue, and the queue retrieval
operations obtain elements at the head of the queue
AI@code ConcurrentLinkedQueue)is an appropriate choice when
many threads will share access to a common collection.
Like most other concurrent collection implementations, this class
does not permit the use of (@code null elements
图21-13 ConcurrentLinkedQueue线程安全文档
DoC文档明确说明这个类是线程安全的,因此,对它进行读写操作不需要加锁。下
面我们继续看下队列中增加一个任务,如图21-14所示。
protected void add Task( Runnable task)(
if(task = null)t
throw new NullPointerException(task):
if(is shutdown()
reject()
taskQueue. add(task:
图21-14 ConcurrentLinked Queue新增Task
读取任务,也不需要加锁,如图21-15所示。
473Nety权威指南(第2版
Blocking Queue<Runnable> task Queue=(Blocking Queue<Runnable>
this task queue.
or
ScheduledFuture Task<?> delayed Task delayedTaskQueue peek:
if (delayedTask = null)I
Runnable task null
try i
task= task Queue, take:
if(task = WAKEUP TASK)(
task null
1 catch(InterruptedException e)t
∥ Ignore
return task
图21-15 ConcurrentLinkedQueue读取Task
JDK的线程安全容器底层采用了CAS、 volatile和 Read WriteLock实现,相比于传统
重量级的同步锁,采用了更轻量、细粒度的锁,因此,性能会更高。合理地应用这些线程
安全容器,不仅能提升多线程并发访问的性能,还能降低开发难度。
下面我们看看线程池在 Netty中的应用,打开 Single Thread EventExecutor看它是如何
定义和使用线程池的
首先定义了一个标准的线程池用于执行任务,代码如下
private final Executor executor:
接着对它赋值并且进行初始化操作,代码如下。
this. addTaskWakesUp= addTaskWakesUp
this executor executor:
task Queue= new TaskQueueo
执行任务代码如图21-16所示。
public void execute( Runnable task)
if( task a= null)(
throw new NullPointerException(task")
boolean in Event
in EventLoop(
if (inEventLoop)(
addTask( task
)else
startThread(:
addTask(task
if (is Shutdown()&& remove Task(task))(
图21-16 Single Thread EventExecutor任务执行
474第21章Java多线程编程在 Netty中的应用
我们发现,实际上执行任务就是先把任务加入到任务队列中,然后判断线程是否已经
启动循环执行,如果不是则需要启动线程。启动线程代码如图21-17所示。
实际上就是执行当前线程的run方法,循环从任务队列中获取Task并执行,我们看它
的子类 Nio EventLoop的run方法就能一日了然,如图21-18所示。
如图21-19中框线内所示,循环从任务队列中获取任务并执行。
private void startThreadot
synchronized(stateLock)i
if(state = ST NOT STARTED)(
state ST STARTED
delayed TaskQueue. add(new ScheduledFuture Task<Voids
this, delayedTask Queue, Executors. <Void>callable(new
Purge ask(, null).
Scheduled Future Task. deadline Nanos(SCHEDULE PURGE INTERVAL).
SCHEDULE PURGE INTERVAL));
do startThreado
图21-17 Single Thread EventExecutor启动新的线程
if(selectedKeys I= null)i
process SelectedKeysOptimized(selectedKeys. flipO);
y else I
process SelectedKeysPlain(selector, selectedKeys()
final long io T ime= System. nano Time()-ioStartTime
final int io Ratio= this io Ratio
runAlITasks( tIme·(100· hoRatio)/| oRatio)
图21-18按照1O任务比例执行任务Task
protected boolean runAllTasks(long timeoutNanos)(
fetch FromDelayedQueuel)
Runnable task=poll ask(;
if(task =s null)(
return false:
final long deadline= Scheduled Future Task. nano Time(+ timeoutNanos
long run Tasks=0:
long lastExecution Time
for(:)4
try
task run);
1 catch(Throwable t)t
logger, warn("A task raised an exception. .t)
图21-19循环从任务队列中获取任务Task并执行
475·Nety权威指南(第2版
Netty对JDK的线程池进行了封装和改造,但是,本质上仍然是利用了线程池和线程
安全队列简化了多线程编程。
21.2.6读写锁的应用
JDK1.5新的并发编程工具包中新增了读写锁,它是个轻量级、细粒度的锁,合理地
使用读写锁,相比于传统的同步锁,可以提升并发访问的性能和吞吐量,在读多写少的场
景下,使用同步锁比同步块性能高一大截。
尽管在JDK1.6之后,随着JVM团队对JIT即时编译器的不断优化,同步块和读写锁
的性能差距缩小了很多,但是,读写锁的应用依然非常广泛。
下面对Nety中的读写锁应用进行分析,让大家掌握读写锁的用法。打开
Hashed wheeltimer代码,读写锁定义如下。
final int mask.
final ReadWriteLock lock new ReentrantReadWrite Lock(
当新增一个定时任务的时候使用了读锁(如图21-20),用于感知whel的变化。由于
读锁是共享锁,所以当有多个线程同时调用 new timeout时,并不会互斥,这样,就提升
了并发读的性能。
public Timeout new Timeout(Timer Task task, long delay, Time Unit unit)(
start
if (task = null)i
throw new NullPointerException( task");
if (unit = null)t
throw new NullPointerException(unit":
long deadline System nano Time (+ unit, toNanos(delay )-startT ime:
M Add the timeout to the wheel
HashedwheelTimeout timeout
kreadLock(). lock():
timeout =new HashedWheelTimeout(task, deadline)
if(worker State. get()== WORKER_ STATE SHUTDOWN)I
throw new IllegalState Exception("Cannot enqueue after shutdown")
wheel [timeout. stopIndex.add(timeout)
lock readLock).unlock(
图21-20 Read lock的使用
获取并删除所有过期的任务时,由于要从迭代器中删除任务,所以使用了写锁,如图
21-21所示
476第21章Java多线程编程在 Netty中的应用
现将读写锁的使用场景总结如下
◎主要用于读多写少的场景,用来替代传统的同步锁,以提升并发访问性能。
◎读写锁是可重入、可降级的,一个线程获取读写锁后,可以继续递归获取:从写
锁可以降级为读锁,以便快速释放锁资源。
◎ Reentrant Read writeLock支持获取锁的公平策略,在某些特殊的应用场景下,可
以提升并发访问的性能,同时兼顾线程等待公平性。
private void fetch Expired T imeouts(
ListsHashedwheelTimeout> expired Timeouts, long deadline)(
lock, writeLock(lockO
maskle. tetchExpired Timeouts(expiredTimeouts, wheel[(int)(tick
erator(). deadline)
I finally I
lock writeLock().unlock(;
图21-21 Write lock的使用
◎读写锁支持非阻塞的尝试获取锁,如果获取失败,直接返回 false,而不是同步阻
塞。这个功能在一些场景下非常有用。例如多个线程同步读写某个资源,当发生
异常或者需要释放资源的时候,由哪个线程释放是个难题。因为某些资源不能重
复释放或者重复执行,这样,可以通过 try Lock方法尝试获取锁,如果拿不到,
说明已经被其他线程占用,直接退出即可。
获取锁之后一定要释放锁,否则会发生锁溢出异常。通常的做法是通过 finally块
释放锁。如果是 try Lock,获取锁成功才需要释放锁。
21.2.7线程安全性文档说明
当一个类的方法或者成员变量被并发使用的时候,这个类的行为如何,是该类与其客
户端程序建立约定的重要组成部分。如果没有在这个类的文档中描述其行为的并发情况,
使用这个类的程序员不得不做出某种假设。如果这些假设是错误的,这个程序就缺少必要
的同步保护,会导致意想不到的并发问题,这些问题通常都是隐蔽和调试困难的。如果同
步过度,会导致意外的性能下降,无论是发生何种情况,缺少线程安全性的说明文档,都
会令开发人员非常沮丧,他们会对这些类库的使用小心翼翼,提心吊胆。
·477Net!权威指南(第2版
在 Netty中,对于一些关键的类库,给出了线程安全性的 API DOC(图21-22),尽管
Net!y的线程安全性并不是非常完善,但是,相比于一些做得更糟糕的产品,它还是迈出了
重要的一步。
ch3>Thread safety</h3>
A t@link ChannelHandlerl can be added or removed at any time because a
I@link ChannelPipeline) is thread safe
For example, you can insert an encryption handler when sensitive information
is about to be exchanged, and remove it
after the exchange
图21-22 ChannelPipeline的线程安全性说明
由于 ChannelPipeline的应用非常广泛,因此,在API中对它的线程安全性进行了详细
的说明,这样,开发者在调用 ChannelPipeline的API时,就不用再额外地考虑线程同步和
并发问题了。
21.28不要依赖线程优先级
当有多个线程同时运行的时候,由线程调度器来决定哪些线程运行、哪些等待以及线
程切换的时间点,由于各个操作系统的线程调度器实现大相径庭,因此,依赖JK自带
的线程优先级来设置线程优先级策略的方法是错误和非平台可移植的。所以,在任何情况
下,程序都不能依赖JDK自带的线程优先级来保证执行顺序、比例和策略。
Net!y中默认的线程工厂实现类,开放了包含设置线程优先级字段的构造函数。这是
个错误的决定,对于使用者来说,既然JDK类库提供了优先级字段,就会本能地认为它
被正确地执行,但实际上JDK的线程优先级是无法跨平台正确运行的。图21-23提供了一
个线程优先级的反面示例。
public DefaultThreadFactory(String poolName, boolean daemon, int priority)
if (pooIName =s null)(
throw new NullPointerException("poolName")j
if (priority Thread MIN PRIORITY II priority >Thread, MAX PRIORITn)
throw new IllegalArgument Exception(
iority:"+ priority +"(expected: Thread, MIN_PRIORITY <
+"priority <s Thread, MAX PRIORITY)")j
prefix poolName+-+pooLId.incrementAndGet(+-;
this, daemon e d
amon
thispriority priority;
图21-23线程优先级的反面示例
478·第21章Java多线程编程在 Netty中的应用
213总结
本章首先介绍了Java内存模型和多线程编程的基础知识,然后结合 Netty的源码分析
常用的多线程编程方法和技巧。
通过本章节的讲解,希望读者可以学以致用,在后续的工作中恰到好处地使用Java
并发编程技术,提高系统的并发处理能力,提升产品的性能。
479第22章
高性能之道
作为一个高性能的NO通信框架,Nεt!y被广泛应用于大数据处理、互联网消息中间
件、游戏和金融行业等。大多数应用场景对底层的通信框架都有很高的性能要求,作为综
合性能最高的NIO框架之一,Net!可以完全满足不同领域对高性能通信的需求。
木章我们将从架构层对Nety的高性能设计和关键代码实现进行剖析,看Net!y是如
何支撑高性能网络通信的。
本章主要内容包括:
◎RPC调用性能模型分析
◎ Netty高性能之道
③主流NIO通信框架性能对比
22.1RPC调用性能模型分析
22.1.1传统RPC调用性能差的三宗罪
“罪行”一:网络传输方式问题。传统的RPC框架或者基于RMI等方式的远程服务(过
程)调用采用了同步阻塞IO,当客户端的并发压力或者网络时延增大之后,同步阻塞LO第22章高性能之道
会由于频繁的wait导致IO线程经常性的阻塞,由于线程无法髙效的工作,IO处理能力
自然下降。
采用BⅠo通信模型的服务端,通常由一个独立的 Acceptor线程负责监听客户端的连
接,接收到客户端连接之后,为其创建一个新的线程处理请求消息,处理完成之后,返回
应答消息给客户端,线程销毁,这就是典型的一请求一应答模型。该架构最大的问题就是
不具备弹性伸缩能力,当并发访问量增加后,服务端的线程个数和并发访问数成线性正比,
由于线程是Java虚拟机非常宝贵的系统资源,当线程数膨胀之后,系统的性能急剧下降,
随着并发量的继续増加,可能会发生句柄溢岀、线程堆栈溢岀等问题,并导致服务器最终
宕机。
“罪行”二:序列化性能差。Java序列化存在如下几个典型问题:
(1)Java序列化机制是Java内部的一种对象编解码技术,无法跨语言使用。例如对
于异构系统之间的对接,Java序列化后的码流需要能够通过其他语言反序列化成原始对象
(副本),目前很难支持
2〕相比于其他开源的序列化框架,Java序列化后的码流太大,无论是网络传输还是
持久化到磁盘,都会导致额外的资源占用
(3)序列化性能差,资源占用率高(主要是CPU资源占用高)。
“罪行”三:线程模型问题。由于釆用同步阻塞I/O,这会导致每个TCP连接都占用1
个线程,由于线程资源是JVM虚拟机非常宝贵的资源,当IO读写阻塞导致线程无法及
时释放时,会导致系统性能急剧下降,严重的甚至会导致虚拟机无法创建新的线程。
22.1.21/O通信性能三原则
尽管影响ⅠO通信性能的因素非常多,但是从架构层面看主要有三个要素。
1)传输:用什么样的通道将数据发送给对方。可以选择BIO、NO或者AIO,IO
模型在很大程度上决定了通信的性能;
(2)协议:采用什么样的通信协议,HTTP等公有协议或者内部私有协议。协议的选
择不同,性能也不同。相比于公有协议,内部私有协议的性能通常可以被设计得更优;
3)线程:数据报如何读取?读取之后的编解码在哪个线程进行,编解码后的消息如
何派发, Reactor线程模型的不同,对性能的影响也非常大,
·481·Nett权威指南(第2版
222Nety高性能之道
222.1异步非阻塞通信
在I/O编程过程中,当需要同时处理多个客户端接入请求时,可以利用多线程或者I/O
多路复用技术进行处理。IO多路复用技术通过把多个IO的阻塞复用到同一个 select的阻
塞上,从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/
多进程模型比,IO多路复用的最大优势是系统开销小,系统不需要创建新的额外进程或
者线程,也不需要维护这些进程和线程的运行,降低了系统的维护工作量,节省了系统资
源
JDK1.4提供了对非阻塞lO(NO)的支持,JDK1.5 update0版本使用 epoll替代了
传统的 select/poll,极大地提升了NIO通信的性能。
与 Socket和 Seryer Socket类相对应,NIO也提供了 Socketchannel和
ServerSocketchannel两种不同的套接字通道实现。这两种新增的通道都支持阻塞和非阻塞
两种模式。阻塞模式使用非常简单,但是性能和可靠性都不好,非阻塞模式则正好相反
开发人员一般可以根据自己的需要来选择合适的模式,一般来说,低负载、低并发的应用
程序可以选择同步阻塞IO以降低编程复杂度。但是对于高负载、高并发的网络应用,需
要使用NIO的非阻塞模式进行开发。
Ne!y的lO线程 NioEventLoop由于聚合了多路复用器 Selector,可以同时并发处理
成百上千个客户端 Socketchannel由于读写操作都是非阻塞的,这就可以充分提升IO线
程的运行效率,避免由频繁的IO阻塞导致的线程挂起。另外,由于 Netty采用了异步通
信模式,一个ⅠO线程可以并发处理N个客户端连接和读写操作,这从根本上解决了传统
同步阻塞ⅠO一连接一线程模型,架构的性能、弹性伸缩能力和可靠性都得到了极大的提
升
22.2.2高效的 Reactor线程模型
常用的 Reactor线程模型有三种,分别如下。
(1) Reactor单线程模型;
·482·第22章高性能之道
(2) Reactor多线程模型;
(3)主从 Reactor多线程模型
Reactor单线程模型,指的是所有的IO操作都在同一个NO线程上面完成,NIO线
程的职责如下:
(1)作为NIO服务端,接收客户端的TCP连接;
2)作为NIO客户端,向服务端发起TCP连接;
3)读取通信对端的请求或者应答消息:
4)向通信对端发送消息请求或者应答消息。
由于 Reactor模式使用的是异步非阻塞lO,所有的O操作都不会导致阻塞,理论上
个线程可以独立处理所有IO相关的操作。从架构层面看,一个NIO线程确实可以完成
其承担的职責。例如,通过 Acceptor接收客户端的TCP连接请求消息,链路建立成功之
后,通过 Dispatch将对应的 Byte Buffer派发到指定的 Handler上进行消息解码。用户 Handler
可以通过NIO线程将消息发送给客户端。
对于一些小容量应用场景,可以使用单线程模型,但是对于高负载、大并发的应用却
不合适,主要原因如下。
(1)一个NIO线程同时处理成百上千的链路,性能上无法支撑。即便NIO线程的CPU
负荷达到100%,也无法满足海量消息的编码、解码、读取和发送:
2)当NIO线程负载过重之后,处理速度将变慢,这会导致大量客户端连接超时,超
时之后往往会进行重发,这更加重了NIO线程的负载,最终会导致大量消息积压和处理超
时,NIO线程会成为系统的性能瓶颈;
(3)可靠性问题。一旦NIO线程意外跑飞,或者进入死循环,会导致整个系统通信模
块不可用,不能接收和处理外部消息,造成节点故障。
为了解决这些问题,演进出了 Reactor多线程模型,下面我们一起学习下 Reactor多线
程模型。
Rector多线程模型与单线程模型最大的区别就是有一组NO线程处理LO操作,它的
特点如下。
(1)有一个专门的No线程—— Acceptor线程用于监听服务端,接收客户端的TCP
483·Netty权威指南(第2版)
连接请求;
2)网络IO操作——读、写等由一个NIO线程池负责,线程池可以采用标准的JDK
线程池实现,它包含一个任务队列和N个可用的线程,由这些NO线程负责消息的读取、
解码、编码和发送;
(3)1个NIO线程可以同时处理N条链路,但是1个链路只对应1个NO线程,防
止发生并发操作问题。
在绝大多数场景下, Reactor多线程模型都可以满足性能需求;但是,在极特殊应用
场景中,一个NIO线程负责监听和处理所有的客户端连接可能会存在性能问题。例如百万
客户端并发连接,或者服务端需要对客户端的握手消息进行安全认证,认证本身非常损耗
性能。在这类场景下,单独一个 Acceptor线程可能会存在性能不足问题,为了解决性能问
题,产生了第三种 Reactor线程模型——主从 Reactor多线程模型。
主从 Reactor线程模型的特点是:服务端用于接收客户端连接的不再是个1个单独的
NIO线程,而是一个独立的NIO线程池。 Acceptor接收到客户端TCP连接请求处理完成
后(可能包含接入认证等),将新创建的 Socketchannel注册到IO线程池( sub reactor线
程池)的某个IO线程上,由它负责 Socketchannel的读写和编解码工作。 Acceptor线程
池只用于客户端的登录、握手和安全认证,一旦链路建立成功,就将链路注册到后端
subReactor线程池的IO线程上,由IO线程负责后续的LO操作。
利用主从NI○线程模型,可以解决1个服务端监听线程无法有效处理所有客户端连接
的性能不足问题。因此,在Nety的官方Demo中,推荐使用该线程模型
事实上,Nety的线程模型并非固定不变,通过在启动辅助类中创建不同的
EventLoop Group实例并进行适当的参数配置,就可以支持上述三种 Reactor线程模型。正
是因为Nety对 Reactor线程模型的支持提供了灵活的定制能力,所以可以满足不同业务
场景的性能诉求。
Net!y单线程模型服务端代码示例如下。
EventLoopGroup reactorGroup- new NioEventLoopGroup (1)i
try i
ServerBootstrap b= new ServerBootstrap()i
b group(reactorGroup, reactorGroup)
channel(NioServer SocketChannel, class)
//后续代码省略…
·484·第22章高性能之道
Net!y多线程模型代码示例如下。
EventLoopGroup acceptorGroup= new NioEventLoopGroup(1)i
EventLoop Group IoGroup- new NioEventLoopGroup()i
try i
ServerBootstrap b= new ServerBootstrap()i
b group(acceptorGroup, IoGroup)
channel(NioServerSocketchannel. class)
//后续代码省略…
Netty主从线程模型代码示例如下。
EventLoopGroup acceptorGroup new NioEvent LoopGroup ()i
EventLoopGroup IOGroup new NioEventLoopGroup()i
try I
ServerBootstrap b- new ServerBootstrap();
b group(acceptorGroup, IOGroup)
channel(Nioserver SocketChannel. class)
//后续代码省略
从上面示例代码可以看出,构造方法的参数和线程组实例化个数不同,就能灵活地切
换到不同的 Reactor线程模型上,用户使用起来非常方便。事实上,并没有标准的最优线
程配置策略,用户需要在理解Net!线程模型的基础之上,根据业务的实际需求选择合适
的线程模型和参数。
22.2.3无锁化的串行设计
在大多数场景下,并行多线程处理可以提升系统的并发性能。但是,如果对于共享资
源的并发访问处理不当,会带来严重的锁竞争,这最终会导致性能的下降。为了尽可能地
避免锁竞争带来的性能损耗,可以通过串行化设计,即消息的处理尽可能在同一个线程内
完成,期间不进行线程切换,这样就避免了多线程竟争和同步锁。
为了尽可能提升性能,Nety.用了串行无锁化设计,在1O线程内部进行串行操作,
避免多线程竞争导致的性能下降。表面上看,串行化设计似乎CPU利用率不高,并发程
度不够。但是,通过调整NO线程池的线程参数,可以同时启动多个串行化的线程并行运
行,这种局部无锳化的串行线程设计相比一个队列—一多个工作线程模型性能更优。
Net!y的串行化设计工作原理图如图22-1所示。
485Netty权威指南(第2版)
d
Nio EventLoop
dedo Tog f encode
、一西
Handler Handler handler handler
te
图22-1Nety串行化设计工作原理
Net!y的 NioEventLoop读取到消息之后,直接调用 ChannelPipeline的
fire ChannelRead( Object msg),只要用户不主动切换线程,一直会由 NioEventLoop调用到
用户的 Handler,期间不进行线程切换。这种串行化处理方式避免了多线程操作导致的锁
的竞争,从性能角度看是最优的。
22.2.4高效的并发编程
Net!y的高效并发编程主要体现在如下几点。
(1) volatile的大量、正确使用;
(2)CAS和原子类的广泛使用;
(3)线程安全容器的使用;
(4)通过读写锁提升并发性能。
具体细节请参考“Java多线程编程在Nety中的应用”一章的内容
222.5高性能的序列化框架
影响序列化性能的关键因素总结如下。
(1)序列化后的码流大小(网络带宽的占用);
(2)序列化&反序列化的性能(CPU资源占用)
3)是否支持跨语言(异构系统的对接和开发语言切换)。
Net!y默认提供了对 Google Protobuf的支持,通过扩展Net!y的编解码接口,用户可
·486·第22章高性能之道
以实现其他的高性能序列化框架,例如 Thrift的压缩二进制编解码框架。
下面我们一起看下不同序列化&反序列化框架性能对比(耗时),如图22-2所示。
Ser Time+Deser Time(ns)
protostu-graph-runtime
boeil-tenalanon
Doss-marshalng-tIrO
stephenenalzaton
boss-marshahing-sonal
yamljackson/databnd
10000
20000
40000
50000
图22-2不同序列化&反序列化框架性能对比(耗时)
下面我们一起看下不同序列化&反序列化框架性能对比(序列化码流大小),如图22-3
所
size, compressed light] in bytes
protostuft-gmph
Drotostuff-oraph-runtime
boss. marshalting-fivere
hes影
sontlessordatahind
yamvacksonvGatabind
isman
boss marshalling-senLal
ava- frazer
boss serialization f
stephenerialuzation
300
6007o
10
图22-3不同序列化&反序列化框架性能对比(序列化码流大小)
不同的应用场景对序列化框架的需求也不同,对于高性能应用场景, Netty默认提供
了 Google的 Protobuf二进制序列化框架,如果用户对其他二进制序列化框架有需求,也
可以基于Nety提供的编解码框架扩展实现。
22.2.6零拷贝
很多用户都听说过Nety具有“零拷贝”功能,但是具体体现在哪里又说不清楚,本
487Nety权威指南(第2版)
小节就详细对Nety的“零拷贝”功能进行讲解
Netty的“零拷贝”主要体现在如下三个方面
第一种情况。Nety的接收和发送 Byte Buffer采用 DIRECT BUFFERS,使用堆外直接
内存进行 Socket读写,不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存(HEAP
BUFFERS)进行 Socket读写,JVM会将堆内存 Buffer拷贝一份到直接内存中,然后才写
入 Socket中。相比于堆外直接内存,消息在发送过程中多了一次缓冲区的内存拷贝。
JDK内存拷贝的代码如下。
static int write(FileDescriptor paramFileDescriptor, ByteBuffer
paramByteBuffer, long paramLong, NativeDispatcher paramNativeDispatcher)
throws IOException
if ((paramByteBuffer instanceof DirectBuffer))i
Return writeFromNativeBuffer(paramFileDescriptor, paramByteBuffer,
paramLong, paramNativeDispatcher)i
int i= paramByteBuffer position(
int 3= paramByteBuffer limit()i
assert (i <=3)i
int k =1 <=1 j
:0
ByteBuffer localByteBuffer Util getTemporaryDirectBuffer(k)i
localByteBuffer. put(paramByteBuffer)i
localByteBuffer. flip()i
paramByteBuffer position(i)i
int m writeFromNativeBuffer(paramFileDescriptor, localByteBuffer,
paramLong, paramNativeDi patcher)
if (m >0)
paramByteBuffer position(i m)i
return m:
I finally t
Util. offerFirstTemporaryDirectBuffer (localByteBuffer)i
下面我们对Nety收发数据报“零拷贝”相关代码进行分析。数据报读取代码如下。
488·第22章高性能之道
ByteBuf byteBuf
nu11;
int messages =0;
boolean close= false;
try f
int byteBufcapacity= allocHandle guess()i
int totalReadAmount=0:
byteBuf allocator ioBuffer(byteBufcapacity)i
int writable byteBuf. writableBytes()i
int localReadAmount doReadBytes(byteBuf)i
接收缓冲区 Byte Buffer的分配由 ChannelConfig负责,下面我们继续分析
ChannelConfig创建 Byte BufAllocator的代码。
private static final RecvByteBufAllocator DEFAULT RCVBUF ALLOCATOR
AdaptiveRecvByteBufAllocator. DEFAULT:
继续分析 AdaptiveRecv ByteBufAllocator的实现,查看它的内存分配接口,代码如下。
@override
public ByteBuf allocate(ByteBufAllocator alloc) I
return alloc. ioBuffer (nextReceiveBuffersize);
调用了 ByteBufA11 orator的 ioBuffer接口,下面我们看下 ioBuffer接口的 API DOC:
k Allocate a clink ByteBuf), preferably a direct buffer which is suitable
for I/o
为了提升IO操作的性能,默认使用 direct buffer,这就避免了读写数据报的二次内存
拷贝,实现了读写 Socket的“零拷贝”功能。
下面我们继续看第二种“零拷贝”的实现 Composite ByteBuf,它对外将多个 Byte Buf
封装成一个 ByteBuf,对外提供统一封装后的 Byte Buf接口,它的类定义如图22-4所示。
Type hierarchy of io. netty buffer. Compesi teBytelnf
Objest-. lans
9A ByteBuf- io netty buffer
a C Abstract ByteBuf-i0 netty buffer
B 94 AbstractRefereneeCountadBytaBuf-io, natty buffer
Composi teByt -io netty buffer
图22-4 Composite ByteBuf继承关系图
通过继承关系我们可以看出, Composite Byte Buf实际就是个 ByteBuf的装饰器,它将
·489·Net!y权威指南(第2版)
多个 ByteBuf组合成一个集合,然后对外提供统一的 Byte Buf接口,相关定义如下
public class CompositeByteBuf extends AbstractReferenceCountedByteBuf
private final ResourceLeak leak;
private final ByteBufAllocator alloc;
private final boolean direct:
private final List<component> components- new ArrayList<component>()i
private final int maxNumComponents:
添加 ByteBuf,不需要做内存拷贝,相关代码如下。
/ No need to consolidate -just add a component to the list
Component
new
Component(buffer order(Byteorder. BIG ENDIAN). slice ())i
if (cIndex = components size() I
components. add (c)i
if (cIndex ==0)
c. endoffset readableBytes
t else i
Component prev= components get (cIndex -1);
offset prev. endoffset:
endoffset =c offset readableBytes
y else i
components. add(cIndex, c)i
updateComponentoffsets(cIndex)i
第三种“零拷贝”就是文件传输,Net!y文件传输类 DefaultFileRegion通过 transferto
方法将文件发送到目标 Channe中,下面重点看 Filechannel的 transfer to方法,它的APl
DOC说明如图225所示。
1j.i.h1s.FCh助盘1, transferral0a君 position,ngct
TritableBrteChannel tar【et) throws I0夏 captian
Transfers bytes from this chahhel' s file to the given writable byte channel
An attempt is made to read up to count bytes starting at the given position in this channels Eile and
write them to the turget chanel. An inreeation af this method may or may mot trasfer all f the
requested bytes: whether or not it does se depends upen the natures and states of the channels,Fewer
than the requested lumbar of bytes are transferred if this channels file contains fewer than count
bytes starting at the given position, or if the target channel is non-blocking and it has fewer than
unt bytes free in its output buffer.
This ethod does not modify this channel s post tion. If the aiwen posi tion is greater than the file s
current sire then ne bytes are transferred If the tarcet channel
a position then bytes are written
tarting at that position und then the posi tion is incremented by the number of bytes ritten.
this method is potentially much mors .fficient than a simple loop that reads from this chanel and write
ke the tarat chand. Many operating systems cu transfer bytes directly from the filesystem cache te
yy copying then
图22-5 transferto方法的 API DOC说明
·490·第22章高性能之道
很多操作系统直接将文件缓冲区的内容发送到目标 Channel中,而不需要通过循环拷
贝的方式,这是一种更加高效的传输方式,提升了传输性能,降低了CPU和内存占用,
实现了文件传输的“零拷贝”。
2227内存池
随着JVM虚拟机和JT即时编译技术的发展,对象的分配和回收是个非常轻量级的
工作。但是对于缓冲区 Buffer,情况却稍有不同,特别是对于堆外直接内存的分配和回收
是一件耗时的操作。为了尽量重用缓冲区,Nety提供了基于内存池的缓冲区重用机制。
下面我们一起看下 Netty Byte Buf的实现,如图22-6所示
日e0 bject
ByteBuf- io netty buffer
E.CA Abstract ByteBuf-i0 netty buffer
t-C AbstractDerivedByteBuf-io netty buffer
B- AbstractReferenc eCountedByteBuf-io netty buffer
e Composi teByteBuf-ionettybuffer
ct Fixedcomposi teByteBuf-io netty buffer
A PooledByteBuf<I>-io, netty, buffer
C PooledDirectByteBuf-io. netty,buffer
CF PooledHe ap ByteBuf-ionetty buffer
G PooledUnsafeDirectByteBuf-ionetty buffer
Et-C ReadOnlyByteBufferBuf-io. netty, buffer
#-C UnpooledDirectByteBuf-io, netty, buffer
.C UnpgoledHeapBrteBuf-io, netty, buffer
C UnpooledUnsafeDirectByteBuf-io netty buffer
图22-6 Byte Buf内存池
Net!y提供了多种内存管理策略,通过在启动辅助类中配置相关参数,可以实现差异
化的定制。
下面通过性能测试,我们看下基于内存池循环利用的 ByteBuf和普通 Byte Buf的性能
差异
测试场景一:使用内存池分配器创建直接内存缓冲区,代码示例如下。
int1op=3000000;
long startTime- System. currentTimeMillis()i
ByteBuf poolBuffer s null
for (int i =0: i loop; 1++)
。。1 Buffer=P。。 edByteBufA1 locator. DEFAULT. directBuffer(1024);
poolBuffe
er, writeBytes(CONTENT)i
·491·Netty权威指南(第2版
poolBuffer. release ()i
测试场景二:使用非堆内存分配器创建的直接内存缓冲区。
long startTime2- System currentTimeMillis();
ByteBuf buffer null
for (int 1=0; i loop: 1++)(
buffer Unpooled, directBuffer (1024);
buffer writeBytes(contenT)i
各执行300万次,性能对比结果如下。
The PooledByteBuf execute 300w times writing operation cost time 19 412 5 ms
回回〓回〓〓〓三〓〓〓二二〓二〓〓〓二〓二〓二二〓二二二二二二二二二二二二二二=二二二二二〓血血
The unPoolecByteBuf execute 300w times writing operation cost time is 953 ms
性能测试表明,采用内存池的 Byte Buf相比于朝生夕灭的 Byte Buf,性能高23倍左右
性能数据与使用场景强相关)。
下面简单分析下 Netty内存池的内存分配关键代码。
@Override
public ByteBuf directBuffer(int initialCapacity, int maxCapacity) f
if (initialcapacity
0 & maxCapacity ==0)
return emptyBuf;
validate (initialcapacity, maxCapacity)i
return newDirectBuffer(initialCapacity, maxCapacity)i
继续看 new Direct Buffer方法,发现它是一个抽象方法,由 AbstractByte BufAllocator
的子类负责实现,子类实现代码如图22-7所示。
曰②0h)ect-)wa1ad
9 A AhstractByt.BufAllacater. n netty boffe
C PoledFrt ufAllocator-ie,nettybuffa
C UnpoolwdByteBufAllocator-io netty, buffer
FE雪
ByrteBut
REcs (int initialCapacity, int maxCapacity)
图22-7子类实现代码
492·第22章高性能之道
代码跳转到 Pooled Byte BufAllocator的 new Direct Buffer方法,从 Cache中获取内存区
域 PoolArena,调用它的 allocate方法进行内存分配。
protected ByteBuf newDirectBuffer(int initialcapacity, int max Capacity) t
PoolThreadCache cache threadCache get()i
PoolArena<ByteBuff
directArena a cache. directArena
ByteBuf buf
if (directArena ! null
buf directArena allocate(cache, initialCapacity, maxCapacity)i
y else i
if (PlatformDependent. hasUnsafe())
buf new UnpooledUnsafeDirectByteBuf(this, initialCapacity,
maxCapacity)i
e⊥se
buf
new UnpooledDirectByteBuf(this, initialcapacity
maxCapacity)i
return toLeakAwareBuffer(buf)i
rena
的
allocate
方法如下。
PooledByteBuf<T> allocate(Pool Threadcache cache, int reqCapacity, int
maxCapacity) t
PooledByteBuf<r> buf newByteBuf (max Capacity)i
allocate(cache, buf, regcapacity)i
return buf
重点分析 new ByteBut的实现,它同样是个抽象方法,由子类 DirectArena和 HeapArena
来实现不同类型的缓冲区分配,由于测试用例使用的是堆外内存,因此重点分析
Directarena的实现。如图22-8所示。
PooledByteBut<D newByteBuf(int maxCapacity);
Types inplenenting or defining'PoolArena(T>.ne-RyteBufCint)
日@0 bJect-jaa1ang
G-G PoolArena(T)-ionetty buffer
DirectArena-10. netty, buffer. PoolAreng
C HeapArens-io netty buffer PoolArena
图22-8 PoolArena继承关系图
·493·Net!y权威指南(第2版)
执行 PooledDirectByte Buf的 newInstance方法,代码如下。
static PooledDirectByteBuf new Instance(int maxCapacity) i
PooledDirectByteBuf buf RECYCLER geto
buf. setRefcnt(1);
buf. max Capacity(maxCapacity)i
return buf
通过 RECYCLER的get方法循环使用 ByteBuf对象,如果是非内存池实现,则直接
创建一个新的 ByteBuf对象。从缓冲池中获取 Byte Buf之后,调用
AbstractReference Counted Byte Buf的 setRefcnt方法设置引用计数器,用于对象的引用计数
和内存回收(类似JVM垃圾回收机制)。
2228灵活的TCP参数配置能力
合理设置TCP参数在某些场景下对于性能的提升可以起到显著的效果,例如
SORCⅤBUF和 SO SNDBUE。如果设置不当,对性能的影响是非常大的。下面我们总结
下对性能影响比较大的几个配置项。
(1) SO RCVBUF和 SO SNDBUF:通常建议值为128KB或者256KB;
(2) SO TCPNODELAY: NAGLE算法通过将缓冲区内的小封包自动相连,组成较大
的封包,阻止大量小封包的发送阻塞网络,从而提高网络应用效率。但是对于时延敏感的
应用场景需要关闭该优化算法;
3)软中断:如果 Linux内核版本支持RPS(2.6.35以上版本),开启RPS后可以实
现软中断,提升网络吞吐量。RPS根据数据包的源地址,目的地址以及目的和源端口,计
算出一个hash值,然后根据这个hash值来选择软中断运行的CPU。从上层来看,也就是
说将每个连接和CPU绑定,并通过这个hash值,来均衡软中断在多个CPU上,提升网络
并行处理性能。
Nely在启动辅助类中可以灵活的配置TCP参数,满足不同的用户场景。相关配置接
口定义如图22-9所示。
·494第22章高性能之道
C ALIDCATOR. Channelpti on< EyteBufAllecator
EFECVBUP_ALLDCATOR: ChannelOpti on< RecrEytelEAllocator>
「 SSSAGE SIZE⊥ ESTIUATOR:Chm410peiB图 sarasin里mt
eF CONNECT TIMEOUT MILLIS: Chaneloptiongnteger>
SF NAZ MESSAGES⊥ PER READ: Cherne10ytin①Br)
d TKTTE STTY_ COUNT: CharnalOptionGntegery
CF WETTE BUFFER HIGN WATER_MARK: Chathe10ptianIsteter>
e TRTTT BUFFER LOW YATER NARK: Chamne10ption (ntagwr>
oF ALLOT HALF CLOSURE. ChannelOption olean)
o AUTO READ ChannelotienqBeelen>
d S0_BEOAICAST: ChamelOptionGoolean)
oF S0 KEEP ALIVE: ChannelDptianGoelean:
!ssk: Channe0ptih①tg
oF 50 CVBUP: Cheneloptiondnteger>
50 REUSEADDR: Channelopti on olean
eF 50 BACKLDG: Channelopti on Integer>
LF 50_TTHzOIT: Channsl0pti on(Integer>
eF IP TOS: Chuml0ptignIntecer)
dI即 ULTICAST AIR: Channa10ptn可哪
c IP HULTICAST IF. ChanmelOptiwndetworkInterface>
dSF IP ULTICAST TTL: Chuut10ptien(Integer?
sFIP-MILTTCAST_IOOP_ nTSAHLED: ChannelOpti enBoolean>
e 5F ICP BODELAY: Chanm10ptigaoplsw>
图2-9 Netty TCP参数表
223主流NIO框架性能对比
无论是Nety的官方性能测试数据,还是携带业务实际场景的性能测试, Netty在各个NIO
框架中综合性能是最高的。下面,我们来看Ney官方提供的不同业务场景性能测试数据,如
图22-10、图22-11、图22-12、图22-13所示。
e民 e Loi pison between riu file比w
Size=64 Loopback
Size=64 Loopback
Netty Frmwrk A Frrmwrk8 Frmmwrt C Frmerk D
00
1
0858
0689
0779
0760
0617
3032
2511
1839
1281
2576
10
4902
z909
207
1.590
3.735
6.152
4581
3.782
277
2623
100
6562
542
3910
3331
3574
6668
4548
3.936
1000
1000
621
3987
4.555
3.539
0 000
5010105.0001a0
5000
4945
3285
3782
4369
2793
concurrent connectors
4828
359
38n2
4271
288
Ny· mwrA 9Frmrark自 Frmarkc FrmmrkD
Size=128 Loopback
Site=128 Loopback
Netty Frmwrk A Frmwrk B FrmwrkC Frmwrk D
1400
1245
119
1569
1.031
1054
5
665
479
3.717
3402
4810
10000
1010023
7428
4081
4637
501008
7573
4345
5287
2232
4D0
13274
8097
7819
6648
1000
11741
798
了223
8.342
7022
5000
9705
6814
7.397
8.759
5001005000Ia0
507
concurren correctons
9505
7267
7685
8384
6.181
■Mdy·F晶可 meak B t Frank C鲁FkD
图22-1064和128字节测试消息(本机网卡回环
495Netty权威指南(第2版)
Stne=256 Loopback
Size=256, Loopback
etty Frrmmwwrk A Frmnwrk B Frmwik C Frmnwrk D
2379
3.c
1973
2393
45000
12.04
7.18J
627
359
a879
124看
82吨
12157
26.1101752715072
8271
10647
15
2420521642
L6213
L6345
143
396
18876
9319
15.455
23003
17142
14565
1921
13490
5.000
19516
127e0
4786
17571
1100
50105Loo5010000
8827
14.b1a
1511
11354
Page 1
Performance Companson between Nio Frameworks
Size=102 Loopback
5izea1024, Loopback
Nety FrImHwTE A Frmwrk B Frrmrkc frrmmwrk D
12000
L
1253
115D
1000
1512892
100000
E.98
356西5
244
31697
s4518
R992
8]J53
5609
51790
45J石
;!:!
1022d9
739
626殖
61978
5833
7917
6359Q
59255
胎面
49
68738
568g
73469
5848
73138
59.755
56746
a PsE
45521
719958315863
65
唱254
c吧 n: crmnti
LW『wBC鲁
图22-11256和IK字节测试消息(本机网卡回环)
HiRe- 1b [thereat
szea64 IGb Ethenet
Netty Frmwrk A Fermwrk b Frmwpk c Frrwwrk D
03
0啁18
1353
1321
14口
14L
2238
2163
201
216g
5617
366
3.中2
4心0
5724
4457
6440
54?
47
5301
4S3
1000
4845
465
540
4438
5 UU
586
4533
386
5213
344
40000
4331
4.34
153
16毛
2.Ps0
rmcurTertannastisns
中吧181btte
Sre=28. 1Gb Ethernet
wr D
I-0
2496
237
192
;11
50
10.157
8G64d
7732
7933垂a
12034
10难33
10214
9348
50
119
84
10.5
9143
:m·
100o
10526
9157
9682
1101
8873
5000
889
7741
.591
1-0 10804
1E5
427
312
c目▲F新D
图22-1264和128字节测试消息(跨主机通信)
Siasi IEb L thernet
Sies256 ich Ethernet
Netty Frmiwwrk A frmwwrk B Frmwrk C Frmwrk D
1473
1417
1596
1222
1391
5187
520
4 61
4711
843
25P
3
ANTI
150
正6
们题8
1当
131D2
10U
555
21
192
189F
98
=
和J1822:m1184
230a
22417512
214871
16108
201
154D7
103001a
10ta
1268
17262
14④
err心hEAs
Parformance compais bew NN Framewoks
正1024 I GE Ethernet
Srtem1024 1G5 Ethenet
PIty Frwk A Frmwni B Frrmwrh t
20
825
465
17214
12J8右L2
n532672076527457051591
633
了或9
66F63
5009424P077759
2,568
66033
77630647852M8163A05
P
e71
8121
7716
55377
ERIFCUIl PLIF LMRPEIIHs
图22-13256和1K字节测试消息〔跨主机通信)
·496第22章高性能之道
224总结
本章首先对影响网络通信性能的三要素进行了分析说明,然后通过对Nety架构性能
模型和设计细节的分析,了解Nety是如何做到高性能的。最后,通过对流行的NO框架
进行性能对比,用实际的性能测试数据来验证Nety的高性能。
·497第23章
可靠性
作为一个基础的NO通信框架,Net被广泛应用于大数据处理、互联网消息中间件、
游戏和金融行业等。不同的行业对软件的可靠性需求不同,例如对通信软件的可靠性要求
往往需要达到5个9。
本章我们将从架构层对Nety的可靠性设计和关键代码实现进行剖析,看Net是如
何做到高可靠性的。
本章主要内容包括:
◎可靠性需求
◎ Netty高可靠性设计
◎优化建议
231可靠性需求
23.1.1宕机的代价
毕马威国际( KPMG International)在对46个国家的74家运营商进行调查后发现,第23章可靠性
全球通信行业每年的收益流失约为400亿美元,占总收入的1%~3%。导致收益流失的因
素有多种,主要原因就是计费BUG和各类宕机导致的业务中断。
美国太平洋时间8月16日下午3点50分到3点55分(北京时间8月17日6点50
分到6点5分),谷歌遭遇了宕机。根据事后统计,短短的5分钟,谷歌损失了54.5万美
元。也就是服务每中断一分钟,损失就达10.8万美元。
2013年,从美国东部时间8月19日下午2点45分开始,有用户率先发现了亚马逊网
站出现宕机,大约在20多分钟后又恢复正常。此次宕机让亚马逊每分钟损失近6.7万美元,
在宕机期间,消费者无法通过Amazon.com、亚马逊移动端以及Amazon.ca等网站进行购物。
从以上几个案例可以看出,宕机事故对企业的正常运营和利润已经带来了非常大的挑
战,随着业务的发展和软件规模的不断膨胀,对软件的可靠性要求越来越高。
231.2 Netty可靠性需求
我们从Nety的主要应用场景和Nety的运行环境两个维度分析 Netty的可靠性需求。
首先分析Nety的主要应用场景。
Netty的主要应用场景如下。
1.RPC框架的基础网络通信框架:主要用于分布式节点之间的通信和数据交换,在
各个业务领域均有典型的应用,例如阿里的分布式服务框架 Dubbo、消息队列 RocketMQ、
大数据处理 Hadoop的基础通信和序列化框架Avro
2.私有协议的基础通信框架:例如 Thrift协议、 Dubbo协议等。
3.公有协议的基础通信框架:例如HTTP协议、SMPP协议等。
从运行环境上看,基于Nety开发的应用面临的是网络环境也不同,手游服务运行的
GSM3 G/WIFI网络环境可靠性差,偶尔会出现闪断、网络单通等问题。互联网应用在业务高
峰期会出现网络拥堵,而且各地用户的网终环境差别也很大,部分地区网速和网络质量不髙。
从应用场景看,Net!y是基础的通信框架,一旦出现Bug,轻则需要重启应用,重则
可能导致整个业务中断。它的可靠性会影响整个业务集群的数据通信和交换,在当今以分
布式为主的软件架构体系中,通信中断就意味着整个业务中断,分布式架构下对通信的可
靠性要求非常高
499·Net!y权威指南(第2版)
从运行环境看, Netty会面临恶劣的网络环境,这就要求它自身的可靠性要足够好,
平台能够解决的可靠性问题需要由 Netty自身来解决,否则会导致上层用户关注过多的底
层故障,这将降低 Netty的易用性,同时增加用户的开发和运维成本。
Net!y的可靠性是如此重要,它的任何故障都可能会导致业务中断,蒙受巨大的经济
损失。因此,Nety在版本的迭代中不断加入新的可靠性特性来满足用户日益增长的高可
靠和健壮性需求。
下一节我们将带你一起揭秘 Netty的高可靠性设计并分析核心代码的实现
232 Netty高可靠性设计
23.2.1网络通信类故障
2321.1客户端连接超时
在传统的同步阻塞编程模式下,客户端Sσcket发起网络连接,往往需要指定连接超时
时间,这样做的目的主要有两个。
1.在同步阻塞ⅠO模型中,连接操作是同步阻塞的,如果不设置超时时间,客户端
IO线程可能会被长时间阻塞,这会导致系统可用IO线程数的减少
2.业务层需要:大多数系统都会对业务流程执行时间有限制,例如WEB交互类的响
应时间要小于3S。客户端设置连接超时时间是为了实现业务层的超时。
JDK原生的 Socket连接接口定义如下:
Connects this socket to the server with a specified timeout value
* timeout of zero is interpreted as an infinite timeout. The connection
will then block until established or an error occurs
param endpoint the <code>SocketAddress</ code>
@param timeout the timeout value to be used in milliseconds
throws IOException if an error occurs during the connection
@throws SocketTimeoutException if timeout expires before connecting
Throws java nio channels. IllegalBlockingModeException
500第23章可靠性
if this socket has an associated channel
and the channel is in non-blocking mode
throws IllegalArgumentException if endpoint is null or is a
SocketAddress subclass not supported by this socket
since 1. 4
espeC JSR-51
public void connect ( SocketAddress endpoint, int timeout) throws
IOException
用户调用 Socket的 connect方法将被阻塞,直到连接成功或者发生连接超时等异常。
对于NIO的 Socketchannel,在非阻塞模式下,它会直接返回连接结果,如果没有连
接成功,也没有发生IO异常,则需要将 Socketchannel注册到 Selector上监听连接结果
所以,异步连接的超时无法在API层面直接设置,而是需要通过定时器来主动监测。
下面我们首先看下 JDK NIO类库的 Socketchannel连接接口定义:
Connects this channels socket
x <p> If this channel is in non-blocking mode then an invocation of this
method initiates a non-blocking connection operation. If the
connection
is established immediately, as can happen with a local connection, then
this method returns <tt>true</tt>, otherwise this method returns
<tt>false</tt> and the connection operation must later be completed by
invoking the flink #finishconnect finishConnect) method
public abstract boolean connect SocketAddress remote) throws
IOException;
从上面的接口定义可以看出,NIO类库并没有现成的连接超时接口供用户直接使用,
如果要在NIO编程中支持连接超时,往往需要NIO框架或者用户自己封装实现。
下面我们看下Nety是如何支持连接超时的,首先,在创建NIO客户端的时候,可以
配置连接超时参数
EventLoopGroup group- new NioEventLoopGroup();
try
Bootstrap b= new Bootstrap()i
b group(group). channel(NioSocketchannel class)
option( Channeloption TCP NODELAY, true)
option( ChannelOption. CONNECT TIMEOUT MILLIS, 3000)
501Nety权威指南〔第2版)
设置完连接超时之后, Netty在发起连接的时候,会根据超时时间创建 Scheduled future
挂载在 Reactor线程上,用于定时监测是否发生连接超时,相关代码如下:
/ Schedule connect timeout
int connectrimeoutMillis config().getConnectrimeoutMillis();
if (connectTimeoutMillis >0)f
nnec七me。u七Eu七ue
eventI。。P(). schedule(new
Runnable()f
oVerride
public void run()[
Channelpromise
connectpromise
AbstractNiochannel, this, connectpromise
ConnectTimeoutException cause
new ConnectTimeoutException ("connection
timed out: # remoteAddress)
i f
( connectPromise
null
connectPromise. tryFailure(cause)) i
close(voidPromise())i
I, connectrimeoutMillis, TimeUnit MILLISECONDS);
创建连接超时定时任务之后,会由 NioEventLoop负责执行。如果已经连接超时,但
是服务端仍然没有返回TCP握手应答,则关闭连接,代码如上所示
如果在超时期限内处理完成连接操作,则取消连接超时定时任务,相关代码如下:
override
public void finishConnect([
//以上代码省略...,
g finally
// Check for null as the connectrimeoutFuture is only created
if a connecttimeoutMillis >0 is used
if (connectTimeoutFuture ! null
connectTimeoutFuture. cancel(false);
connect Promise nulli
Net!y的客户端连接超时参数与其他常用的TCP参数一起配置,使用起来非常方便,
502·第23章可靠性
上层用户不用关心底层的超时实现机制。这既满足了用户的个性化需求,又实现了故障的
分层隔离。
23212通信对端强制关闭连接
在客户端和服务端正常通信过程中,如果发生网络闪断、对方进程突然宕机或者其他
非正常关闭链路事件时,TCP链路就会发生异常。由于TCP是全双工的,通信双方都需
要关闭和释放 Socket句柄才不会发生句柄的泄漏
在实际的NIO编程过程中,我们经常会发现由于句柄没有被及时关闭导致的功能和可
靠性问题。究其原因总结如下
1.IO的读写等操作并非仅仅集中在 Reactor线程内部,用户上层的一些定制行为可
能会导致IO操作的外逸,例如业务自定义心跳机制。这些定制行为加大了统一异常处理
的难度,IO操作越发散,故障发生的概率就越大;
2.一些异常分支没有考虑到,由于外部环境诱因导致程序进入这些分支,就会引起
故障。
下面我们通过故障模拟,看Nety是如何处理对端链路强制关闭异常的。首先启动
Net’r服务端和客户端,TCP链路建立成功之后,双方维持该链路,査看链路状态,结果
如图23-1所示
:\Docunents and Sett ings \Admin istratop>netstat -ano ifind8080
TGP日,团,E,因:898
LISTENING
5g32
TCP127,g.B,1:34L8
127,,8。1:8g8g
ESTABLISHED
3848
TGP127,8..1:8g88
12?.8,.1:3418
ESTABLISHED
5832
图23-1查看链路状态
强制关闭客户端,模拟客户端宕机,服务端控制台打印如图23-2所示异常。
,1 eXception:远程主机强关用了一个现有的接
at gun. nio ch, SocletDispatcher reado (Native Method]
at suna aio ch. SocketDispatehet, read(SocketD1Epotcher,hawa: 43)
at sun M10, ch, IoUcll readIntoNat 1veBurter(IoUt11 JavA:223)
at sun nio ch, Ioutil tend(tout.lava: 192
at sum nio ch. Socketchanne Imp I resd (Soeketchannelimpl J8v8: 379)
at 10, nect.bufter. Unpoo tedUnsntepitect ByteBuf set Bytes( UnpooledUnsefebirect ByteBuf, java: 446
at 10. nettburter. bstract Byte Bur. uE IceEytes( Abstract ByteBur lava:8711
at ionett y, channel, socket. nia. NioSocketChanne I. do ReadBytes INi0SocketChanne 1 iava: 208
at 10. net ty channel,nto. RhstractNioBytechanne I SN10ByteUnsare, read t AhstractN10Bytechanne IJava:119)
at i0netty channeL nio. NioEventLoop-processse lectedkey(NioEventLoap java: 405)
盘t1, net.. L.nL, NioEven Laop,pteeeasse Leered累?Q号 MieEYerLLoop,1yaat521
at 1o-netty.channel-nto, NioLvent LoDp-cun (NioEvent LooP. Java:346)
at 10.netty, utll concurrent. singleTnreadEvent Executor$ 5. run(sing lc ThreadEvent Executor3
aE)a当.1ang,Ted,E山n( Theed,1y:79吗)
图23-2模拟TCP链路故障
●503·Netty权威指南(第2版)
从堆栈信息可以判断,服务端已经监控到客户端强制关闭了连接,下面我们看下服务
端是否已经释放了连接句柄,再次执行 netstat命令,执行结果如图23-3所示
DOcuments and Settings \ Adninistrator>netstat - ano if ind"8088
TGP
日...:88
LISTENING
4112
图23-3查看故障链路状态
从执行结果可以看出,服务端已经关闭了和客户端的TCP连接,句柄资源正常释放。
由此可以得出结论, Netty底层已经自动对该故障进行了处理。
下面我们一起看下Net!y是如何感知到链路关闭异常并进行正确处理的,查看
AbstractByte Buf的 writeBytes方法,它负责将指定 Channel的缓冲区数据写入到 Byte Buf
中,详细代码如下
oVerride
IEA ublic int writeBytes(ScatteringBytechannel in, int length) throws
ception I
ensurewritable (length)i
int writtenBytes setBytes(writerIndexr in, length)
if (writtenBytes >0)i
writerlnd
rittenBytes
return writtenBytes,
在调用 Socketchannel的read方法时发生了 IOException,从 Channel中读取数据报道
缓冲区中的代码如下:
Transfers the content of the specified source channel to this buffer
starting at the specified absolute i@code index h
This method does not modify f(code readerIndex or i@code writerIndex) of
this buffer
param length the maximum number of bytes to transfer
return the actual number of bytes read in from the specified channel
[ ecode -1] if the specified channel is closed
lengty ublic abstract int setBytes(int index, ScatteringByteChannel in, int
throws IOException;
504·第2
可靠性
为了保证IO异常被统一处理,该异常向上抛,由 Nio Unsafe进行统一异常处理,
代码如下:
private void closeOnRead ChannelPipeline pipeline) i
SelectionKey key selectionKey()i
setInput shutdown()i
if (isopen() I
if
(Boolean TRUE equals(config(). getOption( ChannelOption ALLOW HALF CLOSURE)))[
key interestors (key interestors()& readInterestop)i
pipeline. fireUserEventTriggered( Channe l InputshutdownEvent. INSTANCE);
g else i
close(voidPromise());
232.1.3链路关闭
对于短连接协议,例如HTTP协议,通信双方数据交互完成之后,通常按照双方的约
定由服务端关闭连接,客户端获得TCP连接关闭请求之后,关闭自身的 Socket连接,双
方正式断开连接。
在实际的NO编程过程中,经常存在一种误区:认为只要是对方关闭连接,就会发生
IO异常,捕获IO异常之后再关闭连接即可。实际上,连接的合法关闭不会发生IO异常,
它是一种正常场景,如果遗漏了该场景的判断和处理就会导致连接句柄泄漏。
下面我们一起模拟故障,看Net!y是如何处理的。测试场景设计如下:改造下Nety
客户端,双发链路建立成功之后,等待120S,客户端正常关闭链路。看服务端是否能够
感知并释放句柄资源。
首先启动Nety客户端和服务端,双方TCP链路连接正常,如图23-4所示。
C: \Docunents and Settings NAdninistratorynetstat-anoifind8080"
TCP目.B.日.E:8g8
因.。。:
LISTENING5032
12?.日.1:3418
127。8,,1:8e8日
ESIABLISHED
3848
TGP127.8..1:888
127.B.日.1:3418
ES TABLI SHED
532
图23-4TCP连接状态正常
120S之后,客户端关闭连接,进程退出,为了能够看到整个处理过程,我们在服务
505Nety权威指南(第2版
端的 Reactor线程处设置断点,先不做处理,此时链路状态如图23-5所示
C: \Documents and Settings\dmin istiator>netstat -ano :"8080"
TGP,8..g:8888
.E..:
LISTENING
38E
TcP127..4.1:8988
127,8。日,1:3879
CLOSE WAIT
38
图23-5TCP连接句柄等待释放
从上图可以看出,此时服务端并没有关闭 Socket连接,链路处于 CLOSE WAIT状态,
放开代码让服务端执行完,结果如图23-6所示。
\Documents and Settings \Administrator)netstat -ano lf ind 8088"
TCP
日..8.:88因
LISTENING
3g8因
图23-6TCP连接句柄正常释放
下面我们一起看下服务端是如何判断出客户端关闭连接的,当连接被对方合法关闭
后,被关闭的 Socket channe会处于就绪状态, Socketchannel的read操作返回值为-1,说
明连接已经被关闭, NioByteUnsafe的read0代码片段如下:
int localReadAmount doReadBytes (byteBuf)i
if (localReadAmount < 0)[
// not was read release the buffer
byteBuf. release()
c1。se=1。 calReadAmount<0
breaki
如果 Socketchannel被设置为非阻塞,则它的read操作可能返回三个值:
1.大于0:表示读取到了字节数;
2.等于0:没有读取到消息,可能TCP处于 Keep-Alive状态,接收到的是TCP握手
消息;
3.-1:连接已经被对方关闭。
Ney通过判断 Channel read操作的返回值进行不同的逻辑处理,如果返回-1,说明链
路已经关闭,则调用 closeOnRead方法关闭句柄,释放资源,代码如下:
if(close)(
closeOnRead (pipeline);
close s false:
506·第23章可靠性
己方或者对方主动关闭链接并不属于异常场景,因此不会产生 Exception事件通知
Pipeline.
232.1.4定制O故障
在大多数场景下,当底层网络发生故障的时候,应该由底层的NO框架负责释放资源,
处理异常等。上层的业务应用不需要关心底层的处理细节。但是,在一些特殊的场景下,
用户可能需要感知这些异常,并针对这些异常进行定制处理,例如:
1.客户端的断连重连机制:
2.消息的缓存重发;
3.接口日志中详细记录故障细节
4.运维相关功能,例如告警、触发邮件/短信等
Nety的处理策略是发生IO异常,底层的资源由它负责释放,同时将异常堆栈信息
以事件的形式通知给上层用户,由用户对异常进行定制。这种处理机制既保证了异常处理
的安全性,也向上层提供了灵活的定制能力。
具体接口定义以及默认实现( ChannelHandlerAdapter类)如下:
sKip
override
public void exceptioncaught (ChannelHandlerContext ctx, Throwable cause
throws Exception t
ctx. fireExceptionCaught(cause)i
2322链路的有效性检测
当网络发生单通、连接被防火墙Hang住、长时间GC或者通信线程发生非预期异常
时,会导致链路不可用且不易被及时发现。特别是异常发生在凌晨业务低谷期间,当早晨
业务高峰期到来时,由于链路不可用会导致瞬间的大批量业务失败或者超时,这将对系统
的可靠性产生重大的威胁。
从技术层面看,要解决链路的可靠性问题,必须周期性的对链路进行有效性检测。目
前最流行和通用的做法就是心跳检测。
507·Nety权威指南(第2版
心跳检测机制分为三个层面:
TCP层面的心跳检测,即TCP的Keep- Alive机制,它的作用域是整个TCP协议栈;
2.协议层的心跳检测,主要存在于长连接协议中。例如SMPP协议;
3.应用层的心跳检测,它主要由各业务产品通过约定方式定时给对方发送心跳消息
实现。
心跳检测的目的就是确认当前链路可用,对方活着并且能够正常接收和发送消息。做
为高可靠的NO框架, Netty也提供了心跳检测机制,下面我们一起熟悉下心跳的检测原
理
心跳检测的原理示意图如图23-7所示。
Pon
客广端
服务端
Hear
Pong
Heart
周心獸露常
He
心跳常
Pong
图23-7心跳检测的原理示意图
不同的协议,心跳检测机制也存在差异,归纳起来主要分为两类
1.Ping-Pong型心跳:由通信一方定时发送Ping消息,对方接收到Ping消息之后,
立即返回Pong应答消息给对方,属于请求-响应型心跳。
2.Ping-Ping型心跳:不区分心跳请求和应答,由通信双方按照约定定时向对方发送
心跳Ping消息,它属于双向心跳
心跳检测策略如下:
1.连续N次心跳检测都没有收到对方的Pong应答消息或者Ping请求消息,则认为
链路已绎发生逻辑失效,这被称作心跳超时。
2.读取和发送心跳消息的时候如何直接发生了IO异常,说明链路已经失效,这被称
508·第23章可靠性
为心跳失败
无论发生心跳超时还是心跳失败,都需要关闭链路,由客户端发起重连操作,保证链
路能够恢复正常。
Netty的心跳检测实际上是利用了链路空闲检测机制实现的,相关代码包路径如图
23-8所示
日netr5.0.0
1I仓tty
由国国国回
图 bootstrap
出
出ch
由
由
由1°ging
田ss1
出 stream
母 timer
① Restate.,java
D IdleStateEventjava
+J IdleStateHandlerjava
package-int。j
t ReadTimeoutExcepti on java
+ D ReadTimeoutHandler java
T
t-D YriteTineoutExceptionjava
① nriterimeouthandl
er,189a
由 traffic
出ui1
图23-8相关代码包路径
Net提供的空闲检测机制分为三种
1.读空闲,链路持续时间t没有读取到任何消息;
2.写空闲,链路持续时间t没有发送任何消息
3.读写空闲,链路持续时间t没有接收或者发送任何消息。
Net!y的默认读写空闲机制是发生超时异常,关闭连接,但是,我们可以定制它的超
时实现机制,以便支持不同的用户场景。
Write Timeouthandler的超时接口如下
protected void writeTimedout(ChannelHandlerContext ctx) throws Exception I
if(! closed) 1
509Net!y权威指南(第2版)
ctx. fireExceptionCaught(WriteTimeoutException INSTANCE);
ctx. close(i
closed true;
ReadTimeouthandler的超时接口实现如下
protected void readTimedout(ChannelHandlerContext ctx) throws Exception
if ( closed) i
ctx. fireExceptionCaught(ReadTimeoutException, INSTANCE);
ctx. closed;
closed true:
链路空闲的接口实现如下:
protected void channelIdle(ChannelHandler Context ctx, IdlestateEvent evt)
throws Exception I
ctx. fireUserEventTriggered(evt)i
链路空闲的时候并没有关闭链路,而是触发 Idle stateEvent事件,用户订阅
Idlestate event事件,用于自定义逻辑处理,例如关闭链路、客户端发起重新连接、告警和
打印日志等。利用Nety提供的链路空闲检测机制,可以非常灵活的实现协议层的心跳检
测
23.2.3 Reactor线程的保护
Reactor线程是IO操作的核心,NIO框架的发动机,一旦出现故障,将会导致挂载在
其上面的多路用复用器和多个链路无法正常工作。因此它的可靠性要求非常高
笔者就曾经遇到过因为异常处理不当导致 Reactor线程跑飞,大量业务请求处理失败
的故障。下面我们一起看下 Netty是如何有效提升 Reactor线程的可靠性的。
232.3.1异常处理要谨慎
尽管 Reactor线程主要处理IO操作,发生的异常通常是IO异常,但是,实际上在一
510第23章可靠性
些特殊场景下会发生非IO异常,如果仅仅捕获IO异常可能就会导致 Reactor线程跑飞
为了防止发生这种意外,在循环体内一定要捕获 Throwable,而不是IO异常或者 Exception。
Netty的 NioEventLoop代码如下:
protected void run() i
for (ii)
oldwakenup= wakeuP. getAndSet(false)
try i
此处代码省略
1 catch (Throwable t)(
logger, warn("Unexpected exception in the selector loop. " t)i
try I
Thread. sleep (1000)i
s catch (InterruptedException e)[
// Ignore
捕获 Throwable之后,即便发生了意外未知对异常,线程也不会跑飞,它休眠1S,防
止死循环导致的异常绕接,然后继续恢复执行。这样处理的核心理念就是:
某个消息的异常不应该导致整条链路不可用;
2.某条链路不可用不应该导致其他链路不可用;
某个进程不可用不应该导致其他集群节点不可用
232.3.2规避N|OBUG
通常情况下,死循环是可检测、可预防但是无法完全避兔的。 Reactor线程通常处理
的都是1O相关的操作,因此我们重点关注IO层面的死循环。
JDK NIO类库最著名的就是 epoll bug了,它会导致 Selector空轮询,IO线程CPU
100%,严重影响系统的安全性和可靠性。
SUN在JKDl.6 update8版本声称解决了该BUG,但是根据业界的测试和大家的反馈,
直到JDK1.7的早期版本,该BUG依然存在,并没有完全被修复。发生该BUG的主机资
源占用图如图23-9所示。
511Nety权威指南(第2版)
a 6 stu
1215t产eod
6.净,6.3,6.13
BEK user, 13:37 sys, 55.76x idle SharedLtbs
Menfegtons: 922- total, 4194 resident, b private, ?6IH shared, Prys: 164M wiNhd,
421Gvsize,1026'fromeworkvsize,1377904640)pains,5483724(@).pageouts.Netorks:
Ds:16619/21s6
be的1231/9986 writter
BPOKT BEGS RPWT RSHID RSLTE WHO
2131M
1a14a2110059.2118112,铺思3124
58e9
ee:a1.6511
图23-9 epoll bug CPU空轮询
SUN在解决该BUG的问题上不给力,直到JDK17版本也没有完全修复。使用者只
能从NIO框架层面进行问题规避,下面我们看下Ney是如何解决该问题的。
Netty的解决策略:
1.根据该BUG的特征,首先侦测该BUG是否发生;
2.将问题 Selector上注册的 Channel转移到新建的 Selector上;
3.老的问题 Selector关闭,使用新建的 Selector替换。
下面具体看下代码,首先检测是否发生了该BUG( NioEventLoop的 select()
for (i:)I
/以上代码省略
int selectedKeys selector select(timeoutMillis)i
select Cnt++
if (selectedkeys ! =0 oldwakenUp wakeuP get() I
hasTasks()) t
break;
if (SELECTOR AUTO REBUILD THRESHOLD>0&&
selectcnt >=SELECTOR AUTO REBUILD THRESHOLD )[//Bug
发生,处理
旦检测发生该BUG,则重建 Selector,代码如下:
iE (SELECTOR AUTO REBUILD THRESHOLD >0&&
selectCnt > SELECTOR AUTO REBUILD THRESHOLD)
/ The selector returned prematurely many times in a row
/ Rebuild the selector to work around the problem
logger, warn(
I Selector. select() returned prematurely f times in
a row: rebuilding selector.",
selecton)
512第23章可靠性
rebuildselector ()i
//此处代码省略..
重建完成之后,替换老的 Selector,代码如下:
final Selector new Selector
if (oldselector = null) i
return
tr
Y
newSelector=∞ preSelector();//打开新的 Selector
j catch (Exception e) f
logger. warn("Failed to create a new Selector. e)i
return
//此处代码省略
selector newSelector
try
o1dse1ect。x,c1。se();
1 catch (Throwable t) i
if (logger.isWarnEnabled()t
logger. warn("Failed to close the old Selector ",t)i
经过大量生产系统的运行验证,Nety的规避策略可以解决 epoll bug导致的IO线程
CPU死循环问题。
23.24内存保护
NIO通信的内存保护主要集中在如下几点:
1.链路总数的控制:每条链路都包含接收和发送缓冲区,链路个数太多容易导致内
存溢出
2.单个缓冲区的上限控制:防止非法长度或者消息过大导致内存溢出;
3.缓冲区内存释放:防止因为缓冲区使用不当导致的内存泄露;
4.NO消息发送队列的长度上限控制
513Nety权威指南(第2版)
23.24.1缓冲区的内存泄漏保护
为了提升内存的利用率,Nety提供了内存池和对象池。但是,基于缓存池实现以后
需要对内存的申请和释放进行严格的管理,否则很容易导致内存泄漏。
如果不采用内存池技术实现,每次对象都是以方法的局部变量形式被创建,使用完成
之后,只要不再继续引用它,JVM会自动释放。但是,一旦引入内存池机制,对象的生命
周期将由内存池负责管理,这通常是个全局引用,如果不显式释放JVM是不会回收这部
分内存的。
对于Nety的用户而言,使用者的技术水平差异很大,一些对JVM内存模型和内存泄
漏机制不了解的用户,可能只记得申请内存,忘记主动释放内存,特别是JAVA程序员。
为了防止因为用户遗漏导致内存泄漏,Net!y在 Pipe line的尾 Handler中自动对内存
进行释放, TailHandler的内存回收代码如下:
override
public void channelRead( ChannelHandlerContext ctx, Object msg) throws
Except
try
logger debug(
Discarded inbound message i that reached at the tail
of the pipeline
Please check your pipeline configuration.", msg)i
1 finally
ReferenceCountutil. release(msg)i
对于内存池,实际就是将缓冲区重新放到内存池中循环使用, Pooled Byte Buf的内存
回收代码如下:
protected final void deallocate()(
if (handle >=0)1
final long handle= this, handle
this handle =-1
memory = nulli
chunk. arena. free(chunk, handle);
recycLe(
514第23章可靠性
对于实现了 AbstractReference Counted Byte Buf的 ByteBuf,内存申请、使用和释放的
时候Net都会自动进行引用计数检测,防止非法使用内存。
232.4.2缓冲区溢出保护
做过协议栈的读者都知道,当我们对消息进行解码的时候,需要创建缓冲区。缓冲区
的创建方式通常有两种:
1.容量预分配,在实际读写过程中如果不够再扩展;
2.根据协议消息长度创建缓冲区
在实际的商用环境中,如果遇到畸形码流攻击、协议消息编码异常、消息丢包等问题
时,可能会解析到一个超长的长度字段。笔者曾经遇到过类似问题,报文长度字段值竟然
是2G多,由于代码的一个分支没有对长度上限做有效保护,结果导致内存溢出。系统重
启后儿秒内再次内存溢出,幸好及时定位出问题根因,险些酿成严重的事故。
Nety提供了编解码框架,因此对于解码缓冲区的上限保护就显得非常重要。下面,
我们看下 Netty是如何对缓冲区进行上限保护的:
首先,在内存分配的时候指定缓冲区长度上限
Allocate a [@link ByteBuf) with the given initial capaci ty and the given
maximal capacity. If it is a direct or heap buffer depends on the actual
implementat
ByteBuf buffer (int initialCapacity, int maxCapacity)i
其次,在对缓冲区进行写入操作的时候,如果缓冲区容量不足需要扩展,首先对最大
容量进行判断,如果扩展后的容量超过上限,则拒绝扩展:
oVerride
public ByteBuf capacity(int newCapacity) I
ensureAccessible()i
if (newCapacity <o II newCapacity max Capacity())i
throw
new
IllegalArgumentException("newCapacity:
newCapacity)i
在消息解码的时候,对消息长度进行判断,如果超过最大容量上限,则抛出解码异常,
·515·Net!y权威指南(第2版)
拒绝分配内存,以 Length field Based frame Decoder的 decode方法为例进行说明:
if (frameLength maxFrameLength) t
long discard frameLength- in. readableBytes(
tooLong FrameLength frameLength:
f (discard 0)(
in, skipBytes((int) frameLength)i
e⊥se
discardingTooLong Frame truei
bytesToDiscard discardi
in. skipBytes(in. readableBytes())i
failIfNecessary(true)i
return null;
232.5流量整形
大多数的商用系统都有多个网元或者部件组成,例如参与短信互动,会涉及手机、基站
短信中心、短信网关、SPCP等网元。不同网元或者部件的处理性能不同。为了防止因为浪
涌业务或者下游网元性能低导致下游网元被压垮,有时候需要系统提供流量整形功能。
下面我们一起看下流量整形( traffic shaping)的定义:流量整形( Traffic Shaping)是
种主动调整流量输出速率的措施。一个典型应用是基于下游网络结点的TP指标来控制本
地流量的输岀。流量整形亐流量监管旳主要区别在于,流量整形对流量监管中需要丢弃的
报文进行缓存——通常是将它们放入缓冲区或队列内,也称流量整形( Traffic Shaping,
简称TS)。当令牌桶有足够的令牌时,再均匀的向外发送这些被缓存的报文。流量整形与
流量监管的另一区别是,整形可能会增加延迟,而监管几乎不引入额外的延迟。
流量整形的原理示意图如图23-10所示。
输入
海量报文消息
整彩后的出
列
图23-10流量整形的原理示意图
·516·第23章可靠性
作为高性能的NO框架, Netty的流量整形有两个作用:
防止由于上下游网元性能不均衡导致下游网元被压垮,业务流程中断;
2.防止由于通信模块接收消息过快,后端业务线程处理不及时导致的“撑死”问题
下面我们就具体学习下Nety的流量整形功能。
232.5.1全局流量整形
全局流量整形的作用范围是进程级的,无论你创建了多少个 Channel,它的作用域针
对所有的 Channel
用户可以通过参数设置:报文的接收速率、报文的发送速率、整形周期。
GlobalTraffic Shaping Handler的接口定义如下所示:
public GlobaITrafficShapingHandler(ScheduledExecutorservice executor
long writelimitr
long readLimit, long checkInterval)
super(writeLimit, readLimit, checkInterval)i
createGlobalTrafficCounter (executor)i
Net!y流量整形的原理是:对每次读取到的 Byte Buf可写字节数进行计算,获取当前
的报文流量,然后与流量整形阈值对比。如果已经达到或者超过了阈值。则计算等待时间
delay,将当前的 Byte Buf放到定时任务Task中缓存,由定时任务线程池在延迟 delay之后
继续处理该 Byte Buf。相关代码如下
public void channelRead (final ChannelHandlerContext ctx, final Object msg)
throws Exception t
long size= calculatesize(msg)i
long curtime System currentTimeMillis()i
if (trafficCounter ! null) I
trafficCounter. bytesRecvFlowControl(size)i
f (readLimit
0)
// no action
ctx. fireChannelRead (msg)i
return
/后续代码省略.....
517·Nety权威指南(第2版)
如果达到整形阈值,则对新接收的 Byte Buf进行缓存,放入线程池的消息队列中,稍
后处理,代码如下:
else t
Runnable bufferUpdateTask- new Runnable() t
oVerride
public void run()
ctx. fireChannelRead (msg)i
ctx executor(). schedule(bufferUpdaterask,
waitr
TimeUnit MILLISECONDS);
return
定时仼务的延时时间根据检测周期T和流量整形阈值计算得来,代码如下:
private static long getTimeTowait(long limit, long bytes, long lastTime
long curtime) 1
long interval- curtime lastTimei
if (interval <=0)[
// Time is too short, so just lets continue
return 0:
return (bytes *1000/ limit interval)/10 * 10
需要指岀的是,流量整形的阈值limⅱt越大,流量整形的精度越高,流量整形功能是
可靠性的一种保障,它无法做到100%的精确。这个跟后端的编解码以及缓冲区的处理策
咯相关,此处不再赘述。感兴趣的朋友可以思考下, Netty为什么不做到100%的精确
流量整形与流控的最大区別在于流控会拒绝消息,流量整形不拒绝和丢弃消息,无论
接收量多大,它总能以近似恒定的速度下发消息,跟变压器的原理和功能类似。
232.52链路级流量整形
除了全局流量整形,Nety也支持链路级的流量整形, Channel TrafficShaping Handler
接口定义如下:
public ChannelTrafficShapingHandler (long writeLimit
long readLimit, long checkInterval)
●518·第23章可靠性
super(writelimitr readLimit, checkInterval)i
单链路流量整形与全局流量整形的最大区別就是它以单个链路为作用域,可以对不同
的链路设置不同的整形策略
它的实现原理与全局流量整形类似,我们不再赘述。值得说明的是,Net!支持用户
自定义流量整形策略,通过继承 AbstractTrafficShaping Handler的 acCounting方法可以
定制整形策略。相关接口定义如下:
protected void doAccounting(TrafficCounter counter)
// NooP by default
232.6优雅停机接口
Java的优雅停机通常通过注册JDK的 Shutdownhook来实现,当系统接收到退出指令
后,首先标记系统处于退出状态,不再接收新的消息,然后将积压的消息处理完,最后调
用资源回收接口将资源销毁,最后各线程退出执行,
通常优雅退出有个时间限制,例如30S,如果到达执行时间仍然没有完成退出前的操
作,则由监控脚本直接kl-9pid,强制退出。
Netty的优雅退出功能随着版本的优化和演进也在不断的增强,下面我们一起看下
Netty5的优雅退出。
首先看下 Reactor线程和线程组,它们提供了优雅退出接口。 EventExecutor Group的
接口定义如下:
/★
Signals this executor that the caller wants the executor to be shut
down. Once this method is called,
dclink #isShutting Down()) starts to return decode truel, and the
executor prepares to shut itself down
Unlike alink #shutdown()), graceful shutdown ensures that no tasks
are submitted for <i>'the quiet period'</i>
(usually a couple seconds) before it shuts itself down. If a task is
submitted during the quiet period,
it is guaranteed to be accepted and the quiet period will start over
519·Net!y权威指南(第2版)
Futures?> shutdownGracefully (long quietperiod, long timeout, TimeUnit
unit)
NIOEventLoop的资源释放接口实现:
override
protected void cleanup() i
try
selector. close()i
9 catch (IOException e) i
logger. warn("Failed to close a selector. , e)i
Channelpipeline的关闭接口如图23-1l所示。
●c1ot0; Channel futu
●1 se[ChinelPronlse] ChieF曰ur
图23-11 ChannelPipeline的关闭接口
目前Nety向用户提供的主要接口和类库都提供了资源销毁和优雅退出的接口,用户
的自定义实现类可以继承这些接口,完成用户资源的释放和优雅退出。
23.3优化建议
尽管 Netty的可靠性已经做得非常出色,但是在生产实践中还是发现了一些待优化点,
本小节将进行简单说明。希望后续的版本中可以解决,当然用户也可以根据自己的实际需
要决定自行优化。
23.3.1发送队列容量上限控制
Net!y的NIO消息发送队列 Channeloutbound Buffer并没有容量上限控制,它会随着消
息的积压自动扩展,直到达到0x7fft
如果网络对方处理速度比较慢,导致TCP滑窗长时间为0;或者消息发送方发送速度
过快,或者一次批量发送消息量过大,都可能会导致 Channeloutbound Buffer的内存膨胀,
这可能会导致系统的内存溢出
建议优化方式如下:在启动客户端或者服务端的时候,通过启动项的 ChannelOption
520·第23章可靠性
设置发送队列的长度,或者通过-D启动参数配置该长度。
23.32回推发送失败的消息
当网络发生故障的时候,Net!y会关闭链路,然后循环释放待未发送的消息,最后通
知监听 listener
这样的处理策略值得商榷,对于大多数用户而言,并不关心底层的网络ⅠO异常,他
们希望链路恢复之后可以自动将尚未发送的消息重新发送给对方,而不是简单的销毁
Net!y销毁尚未发送的消息,用户可以通过监听器来得到消息发送异常通知,但是却
无法获取原始待发送的消息。如果要实现重发,需要自己缓存消息,如果发送成功,自己
删除,如果发送失败,重新发送。这对于大多数用户而言,非常麻烦,用户在开发业务代
码的同时,还需要考虑网络IO层的异常并为之做特殊的业务逻辑处理。
下面我们看下Mina的实现,当发生链路异常之后,Mina会将尚未发送的整包消息队
列封装到异常对象中,然后推送给用户 Handler,由用户来决定后续的处理策略。相比于
Nety的“野蛮”销毁策略,Mina的策略更灵活和合理,由用户自己决定发送失败消息的
后续处理策略。
大多数场景下,业务用户会使用RPC框架,他们通常不需要直接针对Nety编程,如
果Ne!y提供了发送失败消息的回推功能,RP℃框架就可以进行封装,提供不同的策略给
业务用户使用,例如:
1.缓存重发策略:当链路发生异常之后,尚未发送成功的消息自动缓存,待链路恢
复正常之后重发失败的消息;
2.失败删除策略:当链路发生异常之后,尚未发送成功的消息自动销毁,它可能是
非重要消息,例如日志消息,也可能是由业务直接监听异常并做特殊处理;
3.其他策略.
234总结
本章首先对Nety的可靠性需求进行了分析说明,接着从架构和代码两个层面对 Netty
的高可靠性进行了剖析,最后对Net!的待优化点进行了分析,并给出了自己的优化建议。
·521·第24章
安全性
2014年影响最为深远的软件安全事件应该就是 OpenSSL Heart bleed漏洞,因其破坏
性之大和影响的范围之广,堪称网络安全里程碑事件。
作为基础的NO通信类库,Nety也同样面临着严峻的网络通信安全问题,本章针对
Nety架构层面的安全性设计、安全性相关的核心代码剖析,了解和掌握Net!网络安全相
关的特性和代码实现,以及如何使用这些安全特性保护自己的应用程序
本章主要内容包括:
严峻的安全形势
Netty SsL安全特性
◎ Netty SSL源码分析
Net!y扩展的安全特性
24.1严峻的安全形势
24.1.1 Open SsL Heart bleed漏洞
2014年上半年对网络安全影响最大的问题就是 OpenSsL Heart bleed漏洞,来自第24章安全性
Codenomicon和谷歌安全部门的研究人员发现 OpenSsL的源代码中存在一个漏洞,可以让
攻击者获得服务器上64K内存中的数据内容。该漏洞在国内被译为” OpenSSL心脏出血
漏洞”,因其破坏性之大和影响的范围之广,堪称网络安全里程碑事件
OpenSSL是为网络通信提供安全及数据完整性的一种安全协议,囊括了主要的密码算
法、常用的密钥和证书封裝管理功能以及SSL协议.多数SSL加密网站是用名为 OpenSSL
的开源软件包,由于这也是互联网应用最广泛的安全传输方法,被网银、在线支付、电商
网站、门户网站、电子邮件等重要网站广泛使用,所以漏洞影响范围广大,
全球第一个被攻击通告的案例是加拿大税务局确认 OpenSSL Heart bleed漏洞导致了
900个纳税人的社会保障号被盗,这900个纳税人的社保号被攻击者在系统中完全删除了
24.12安全漏洞的代价
任何网络攻击都能够给企业造成破坏,但是如何将这些破坏具体量化成金融数据呢?
2013年,B2 B International联合卡巴斯基实验室基于对全球企业的调查结果,计算出网络
攻击平均造成的损失。
根据调查报告得出的结论,当企业遭遇网络攻击后平均损失为649000美元。损失主
要包括两方面
安全事件本身造成的损失,即由重要数据泄漏、业务连续性以及安全修复专家费
用相关成本;
2.为列入计划的”响应”成本,用于阻止未来发生类似的攻击事件,包括雇佣、培
训员工成本以及硬件、软件和其他基础设施安全升级成本。
24.13Nett面临的安全风险
作为一个高性能的NO通信框架,基于Net!y的行业应用非常广泛,不同的行业、不
同的应用场景,面临的安全挑战也不同,下面我们根据Nett的典型应用场景,分析下Nety
面临的安全挑战。
应用场景1:仅限内部使用的RPC通信框架。随着业务的发展,网站规模的扩大,传
统基于MⅤC的垂直架构已经无法应对业务的快速发展。需要对数据和业务进行水平拆分,
基于RPC的分布式服务框架成为最佳选择。
·523·Net!y权威指南(第2版)
业务水平拆分之后,内部的各个模块需要进行高性能的通信,传统基于RM和 Hession
的同步阻塞式通信已经无法满足性能和可靠性要求。因此,高性能的NIO框架成为构建分
布式服务框架的基石。
髙性能的RPC框架,各模块之间往往采用长连接通信,通过心跳检测保证链路的可
靠性。由于RPC框架通常是在内部各模块之间使用,运行在授信的内部安全域中,不直
接对外开放接口。因此,不需要做握手、黑白名单、SSL/TLS等,正所谓是“防君子不防
小人”。
在这种应用场景下,Nety的安全性是依托企业的防火墙、安全加固操作系统等系统
级安全来保障的,它自身并不需要再做额外的安全性保护工作。
应用场景2:对第三方开放的通信框架。如果使用Nety做RPC框架或者私有协议栈,
RPC框架面向非授信的第三方开放,例如将内部的一些能力通过服务对外开放出去,此时
就需要进行安全认证,如果开放的是公网IP,对于安全性要求非常高的一些服务,例如在
线支付、订购等,需要通过SSL/TLS进行通信。
它的原理图如图24-1所示。
非授信域
授信域
三方
第三方
内部服胥
安全队证机制
第三万
直连
第三方
SSLTLS
开放服务1
第三万
三方
图24-1对第三方开放的通信框架
对第三方开放的通信框架的接口调用存在三种场景:
1.在企业内网,开放给内部其他模块调用的服务,通常不需要进行安全认证和
SSL/TLS传输
2.在企业内网,被外部其他模块调用的服务,往往需要利用IP黑白名单、握手登陆
等方式进行安全认证,认证通过之后双方使用普通的 Socket进行通信,如果认证失败,则
拒绝客户端连接;
3.开放给企业外部第三方应用访问的服务,往往需要监听公网IP(通常是防火墙的
●524第24章安全性
IP地址),由于对第三方服务调用者的监管存在诸多困难,或者无法有效监管,这些第三
方应用实际是非授信的。为了有效应对安全风险,对于敏感的服务往往需要通过SSL/TLS
进行安全传输。
应用场景3:应用层协议的安全性。作为高性能、异步事件驱动的NO框架,Net!y
非常适合构建上层的应用层协议,相关原理,如图24-2所示。
Transpart servaces
Protocol Support
Socket i
HIIP E
Sii starTs
Datagram
webcache
HIP Tunne
/
arge File
In VH Ppe
Legacy Text Binary Protocols
wth Unit Testability
E斌 cEnt Hodr
Universal Communication Apt
Tero Copy Capable Rich byte Buffer
图24-2基于Net!y构建应用层协议
由于绝大多数应用层协议都是公有的,这意味着底层的Nety需要向上层提供通信层
的安全传输,也就是需要支持SSL/TLS。
JDK的安全类厍提供了 javax. net. ssl. SSLSocket和 Javax. net. ssL SSLServer Socket类库用
于支持SSL/TLS安全传输,对于NIO非阻塞 Socket通信,JDK并没有提供现成可用的类
库简化用户开发。
Netty通过JDK的 SSLEngine,以 SsIHandler的方式提供对 SSL/TLS安全传输的支持,
极大的简化了用户的开发工作量,降低开发难度。对于Nety默认提供的HTTP协议,Nery
利用 SsIHandler,同样支持 Https协议。
242 Netty SSL安全特性
Net!y通过 SslHandler提供了对SSL的支持,它支持的SSL协议类型包括:SSLⅤ2
SSLV3和TLS。
24.2.1SSL单向认证
单向认证,即客户端只验证服务端的合法性,服务端不验证客户端。下面我们通过
525Net!y权威指南(第2版)
Net!y的SSL单向认证代码开发来掌握基于Nety的SSL单向认证。
242.1.1单向认证开发
首先,利用JDK的 keytool工具, Netty服务端依次生成服务端的密钥对和证书仓库
服务端自签名证书。
生成Nety服务端私钥和证书仓库命令
keytool -genkey -alias securechat -keysize 2048 -validity 365
keyalg RSA -dname"CN=localhost -keypass sNetty -storepass
SHetty -keystore sChat. ks
生成Net服务端自签名证书:
keytool-export -alias securechat -keystore sChat ]ks -storepass
sNetty -file schat cer
生成客户端的密钥对和证书仓库,用于将服务端的证书保存到客户端的授信证书仓库
中,命令如下:
keytool -genkey -alias smcc -keysize 2048 -validity 365 -keyalg
RSA -dname CN==localhost -keypass cNetty -storepass nEtty
keystore chat, iks
随后,将Nety服务端的证书导入到客户端的证书仓库中,命令如下:
keytool -import -trustcacerts -alias securechat -file schatcer
storepass cNetty -keystore chat. jks
上述工作完成之后,我们就开始编写SSL服务端和客户端的代码,下面我们对核心代
码进行讲解。
因为是客户端认证服务端,因此服务端需要正确的设置和加载私钥仓库 Key Store,相
关代码如下
KeyManagerFactory kmf nulli
if (pkPath ! null) i
KeyStore ks= KeyStore getInstance ("UKS")i
in new FileInputStream(pkPath)i
526第24章安全性
ks load(in,sNetty. tocharArray ())i
kmf KeyManagerFactory getInstance("SunX509)
kmf init(ks, "sNetty'. tocharArray())i
初始化 KeyManagerFactory之后,创建 SSLContext并初始化,代码如下;
SERVER CONTEXT- SSLContext getInstance(PROTOCOl)i
if (SSLMODE CA tostring().equals(tIsMode))
SERVER CONTEXT. init(knf. getKeyManagers(), null, null)i
由于是单向认证,服务端不需要验证客户端的合法性,因此, TrustManager为空,安
全随机数不需要设置,使用JDK默认创建的即可。
服务端的 SSLContext创建完成之后,利用 SSLContext创建SSL引擎 SSLEngine,设
置 SSLEngine为服务端模式,由于不需要对客户端进行认证,因此 NeedClientAuth不需要
额外设置,使用默认值 False。相关代码如下:
engine, setUseClientMode (false)
SSL服务端创建完成之后,下面继续看客户端的创建,它的原理同服务端类似,也是
在初始化TCP链路的时候创建并设置 SSLEngine,代码如下
KeyManagerFactory kmf nulli
if(pkPath ! null) i
Keystore ks= Keystore getInstance("JKS")i
in= new FileInputstream(pkPath)i
ks load(in,CNetty. tocharArray())i
//ks load(in, 123456".tocharArray())
kmf- KeyManagerFactory, getInstance("SunX509")i
kmf init(ks, cNetty. tocharArray())i
// kmfinit(ks," 123456". tocharArray())i
由于是客户端认证服务端,因此,客户端只需要加载存放服务端CA的证书仓库即可。
加载证书仓库完成之后,初始化 SSLContext,代码如下:对于客户端只需要设置信任
证书 Trust Manager:
CLIENT CONTEXT SSLContext getInstance(PROTOCOL);
if (SSLMODE CA tostring(),equals(tlsMode))
CLIENT CONTEXT.init(null
tf == null null tf, getTrustManagers(), null)i
客户端 SSLContext初始化完成之后,创建 SSLEngine并将其设置为客户端工作模式,
527·Net!权威指南(第2版)
代码如下:
engine, setUseClientMode( true)i
将 SsIHandler添加到 pipeline中,利用 SsIHandler实现 Socket安全传输,代码如下:
pipeline addLast(ssl", new SslHandler(engine))i
客户端和服务端创建完成之后,测试下SSL单向认证功能是否OK,为了查看SSL握
手过程,我们打开SSL握手的调测日志, Eclipse设置如图24-3所示。
Name: SeeureChatServer
Gin的gmt画1甲50m圆Enx0 ment Common
Program argunents
C
ar⊥4b1垂s,,,
tl-Djavax net debug=ssl, handshake
Variables
图243打开SSL调测日志
分别运行服务端和客户端,运行结果如图24-4和图24-5所示。
Server write Iv:
o00:D8F1BFo9B0B02E07ECAB1c2A732173..,,,,,,,,,,"s!s
nioEventLoopGroup-2-1, URITE: TLSv1 Change cipher spec, length =1
青; Finished
ver1 ry data:223;76,1母1,105;177,81;145r163:113,号5;5,119
nioEventLoopGroup-2-1, WRITE: TLSV1 Handshake, length =48
nioEventLoopGroup-2-1, READ: TLSv1 Change Cipher Spec, length =1
nioEventLoopGroup-2-1, READ: TLSv1 Handshake, length =48
曹 Finished
ver1 y data:(14日,63,125,105,96,3,2,245,33,227,95,106}
i+ Cached client session: [Session-1, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA]
Me come to oUHHDLFDTRocxYi secure chat service
Your session is protected by TLs ECDHE RSA WITH AES 128 CBC SHA cipher suite
图24-4客户端SSL握手日志
528·第24章安全性
靠吉 Finished
verify data:(223,76,141,106;177;81,146;163,143,45,5r119}
古雪青
nioEventLoopGroup-3-1, URITE: TLSV1 Change cipher Spec, length =1
吉需F1 ighed
ver1 cy data:(148,63,125,105,96,3,2,245,33,227,95,106
nioEventLoopGroup-3-1, URITE: TLSv1 Handshake, length =48
&i Cached server session: [Session-lr TLS ECDHE RSA WITH AES 128 CBC SHA
nioEvent LoopGroup-3-1, WRITE: TLSv1 Application Data, length =48
nioEventLoop Group-3-1, WRITE: TLSv1 Application Data, length-1
nioEventLoopGroup-3-1r URITE: TLSv1 Application Datar length =77
图24-5服务端SSL握手日志
在客户端输入信息,服务端原样返回,测试结果如图24-6所示
netty
mioEventLoopGroup-2-1, URITE: TLSv1 Application Data, length-19
you]nety权威指南
图24-6SSL版本Echo程序
到此, Netty SSL单向认证已经开发完成,下个小节我们将结合SSL握手日志,详细
解读下SSL单冋认证的原理。
24.2.1.2单向认证原理
SSL单向认证的过程总结如下:
l.SSL客户端向服务端传送客户端SSL协议的版本号、支持的加密算法种类、产生
的随机数,以及其他可选信息
2.服务端返回握手应答,向客户端传送确认SSL协议的版本号、加密算法的种类
随机数以及其他相关信息:
3.服务端向客户端发送自己的公钥;
4.客户端对服务端的证书进行认证,服务端的合法性校验包括:证书是否过期、发
行服务器证书的CA是否可靠、发行者证书的公钥能否正确解开服务器证书的“发行者的
数字签名”、服务器证书上的域名是否和服务器的实际域名相匹配等;
5.客户端随机产生一个用于后面通讯的“对称密码”,然后用服务端的公钥对其加密,
将加密后的“预主密码”传给服务端
6.服务端将用自己的私钥解开加密的“预主密码”,然后执行一系列步骤来产生主密码;
529·Nett!权威指南(第2版)
7.客户端向服务端发出信息,指明后面的数据通讯将使用主密码为对称密钥,同时
通知服务器客户端的握手过程结束;
8.服务端向客户端发出信息,指明后面的数据通讯将使用主密码为对称密钥,同时
通知客户端服务器端的握手过程结束
9.SSL的握手部分结束,SSL安全通道建立,客户端和服务端开始使用相同的对称
密钥对数据进行加密,然后通过 Socket进行传输,
下面,我们结合JDK的SSL工作原理对Ney的SsL单向认证过程进行讲解,首先,
我们看下 JDK SSL单向认证的流程图如图24-7所示。
ssL客户端
ssL服务端
ssL单向认证流
I clientHellg
2、 ServerHellc
3、cert⊥且 cate chain
Sk serverHelloDone
6. ECDHclientkeyExchange
P⊥ nighed
0、 Finisher
图24-7SSL单向认证流程图
下面结合 JDK SSL引擎的调测日志信息我们对SSL单向认证的流程进行详细讲解,
对于比较简单的流程会进行步骤合并。
步骤1:客户端使用TLS协议版本发送一个 Clienthello消息,这个消息包含一个随机
数、建议的加密算法套件和压缩方法列表,如下所示:
ClientHello, TlSvl
Randorncookie:GMT:1389796107 bytes=(125,107,13B,150,226,182,23日,75,
150,222,147,127,35,36,149,172,128,152,34,110,104,176,34,180,
118,185,55
session ID: IH
cipher
suites
ITLS ECDHE ECDSA WITH AES 128 CBC SHA,
TLS ECDHE RSA WITH AES 128 CBC SHA, TLS RSA WITH AES 12B CBC SHAr
TLS EMPTY RENEGOTIATION INEO SCSi
sect193rl, seet193r2, secp224kI, gect239k1, secp256kll
Extension ec point formats, formats: [uncompressed
530第24章安全性
步骤2:服务端使用 Serverhello消息来响应,这个消息包含由客户提供的信息基础上
的另一个随机数和一个可选的会话ID,以及服务端选择的加密套件算法,响应消息如下:
★ Servere11o,TLSv1
Randomcookie:GMT:138979610 8 bytes={27,170,76,238,56,58,
172,146,41,159,249,213,16,214,53,167,50,74,39,107,
121,63,80,26,210,149,249,194}
省略
步骤3:服务端发送自签名的证书消息,包含完整的证书链:
Certificate cha
chain [o]=[
Version: V3
Subject: CN=localhost
Signature
Algorithm
SHAlwithRSA
OID
1,2,840.113549,1,1,5
省略
步骤4:服务端向客户端发送自己的公钥信息,最后发送 Serverhellodone:
* ECDh Serverkeyexchange
Server key: Sun EC public key, 256 bits
public
coord:
112463902918630779107945902338321922977565892046706979058886
85651118114908704
public
coords
141615584302183983661360241749252580028319381566531570740584
92642854053163673
parameters: secp256r1 [NIST P-256, x9.62 prime256v1l
1.2.840.10045.3.1.7)
害* Serverhellodone
步骤5:客户端对服务端自签名的证书进行认证,如果客户端的信任证书列表中包含
了服务端发送的证书,对证书进行合法性认证,相关信息如下:
531·Nety权威指南(第2版)
Found trusted certificate
Version: V3
Subject: CN-localhost
Signature Algorithm: SHAlwithRSA, OID=1.2.840.113549.1.1.5
Key: Sun RSA public key, 2048 bits
modulus
180074092335949740506599932729136061127910704822256890304785
省略
步骤6:客户端通知服务器改变加密算法,通过 Change Cipher Spec消息发给服务端,
随后发送 Finished消息,告知服务器请检査加密算法的变更请求:
nioEventLoopGroup-2-1, WRITE: TLSv1 Change Cipher Spec, length
步骤7:服务端读取到 Change Cipher Spec变更请求消息,向客户端返回确认密钥变
更消息,最后通过发送 Finished消息表示SSL/TLS握手结束。
nioEventLoopGroup-3-1, READ: TLSv1 Change Cipher Spec, length
nioEventLoopGroup-3-1, READ: TLSv1 Handshake, length =48
★ Finished
verify data:{157,255,187,52;139;16;20,190,11,35;79,
0}
nidEventLoopGroup-3-1, WRITE: TLSv1 Change Cipher Spec, length
1
★ Finished
24.2.2SSL双向认证
与单向认证不同的是服务端也需要对客户端进行安全认证。这就意味着客户端的自签
●532·第24章安全性
名证书也需要导入到服务端的数字证书仓库中
2422.1双向认证开发
首先,生成客户端的自签名证书:
keytool -export -alias smcc -keystore chat jks -storepass
cNetty -file chat.cer
然后将客户端的自签名证书导入到服务端的信任证书仓库中:
keytool -import -trustcacerts -alias smce-file cHatcer
-storepass sNetty -keystore schat jks
证书导入之后,需要对SSL客户端和服务端的代码同时进行修改,首先我们看下服务
端如何修改。
由于服务端需要对客户端进行验证,因此在初始化服务端 SSLContext的时候需要加
载证书仓库。首先需要对 TrustManager Factory进行初始化,代码如下;
TrustManagerFactory tf nulli
if (caPath ! null)[
KeyStore tks Keystore getInstance(UKS")i
tIN new FileInputstream(caPath)i
tks load(tIN, sNetty. tocharArray())i
tf= TrustManagerFactory. getInstance("SunX509");
tf init(tks)i
初始化 SSLContext的时候根据 TrustManager Factory获取 TrustManager数组,代码如下
else if (SSLMODE CSA tostring(). equals(tlsMode))[
SERVER CONTEXT.init(kmt. getReyManagers()r
tf. getTrustManagers (), null)i
最后,创建 SSLEngine之后,设置需要进行客户端认证,代码如下
if (SSLMODE CSA tostring().equals(tlsMode)
engine. setNeedclientAuth(true);
完成服务端修改之后,再回头看下客户端的修改,由于服务端需要认证客户端的证书
因此,需要初始化和加载私钥仓库,向服务端发送公钥,初始化 Key Store的代码如下:
·533Nety权威指南(第2版)
KeyManager Factory kmf null
if (pkPath ! null)
Keystore ks- Keystore getInstance(JKS")i
new FileInputstream(pkPath)i
ksload(in,"cNetty'. tocharArray())i
kmf KeyManagerFactory, getInstance("SunX509")i
kmf init(ks, Netty. toCharArray())i
初始化 SSLContext的时候需要传入 KeyManager数组,代码如下:
else if (SSLMODE CSA tostring(). equals(tlsMode))[
CLIENT CONTEXT. init(kmf. getKeyManagers(),
tf. getTrustManagers()r null)i
客户端开发完成之后,测试下程序是否能够正常工作,运行结果如下所示
客户端运行结果如图24-8所示
里里Cet生型1在七eVeE且
nioEventLoopGroup-2-1 URITE: TLSv1 Handshake, length =262
n1 sEventH。。pGr。1p-2-1, WRITE:TLsv1 Change cipher spec, length=1
t** Finished
veE1 y data:B1;178,246;18,147;113,117,100,201,183,62,136
nioEvent LoopGroup-2-1, WRITE: TLSv1 Handshake, length 4
nioEvent Loop Group-2-1, READ: TLSv1 Change Cipher spec, length-1
nioEventLoopGroup-2-1, READ: TLSv1 Handshake, length 48
百酒F11he
verify data:(228,152,B8,130,91,217,179,s8,148,226,205,67
si Cached client session: [session-1, TLS ECDHE RSA WITH AES 128 CBC SHA
Ge cone to QUHHDLFDTAOCXrU secure chat service l
Your session 1s protected by Tls ECDHE RSA WITH AES 12B CBC SHA cipher suite
图24-8 Netty SSL双向认证客户端运行结果
服务端运行结果如图24-9所示。
Certificates工1y
nioEventLoopGroup-3-1, READ: TLSv1 Change Cipher spec, length =1
nioEvenc LoopGroup-3-1, READ: TLSv1 Handshake, length 48
青害F1n1shed
verify data:(1,178,z46,1B,147,113,117;100,z01,183,6z,136
nioEventloopGroup-3-l, RITE: TLSvI Change Cipher spec, length =1
害F111hed
verify data:(228,152,88,130,91,217,179,58,14,226,20567
mioEventLoopGroup-3-lt RITE: TLSv1 Handshake, length =48
图24-9 Netty SSL双向认证服务端运行结果
534·第24章安全性
在客户端控制台进行输入,看SSL传输是否正常,如图24-10所示。
Welcome to QUHHDLFDTAorxYu secure chat service i
Your session is protected by TLs ECDHE RSA UITH AES 128 CBC SHA cipher suite
欢迎参加C1南京蛄活动
hioEventLoopGroup-2-1, URITE: TLSv1 Application Data, length=34
you]欢迎参加clu南京站活动
图24-10 Netty SSL安全传输测试
24222双向认证原理
SSL双向认证相比单向认证,多了一步服务端发送认证请求消息给客户端,客户端发
送自签名证书给服务端进行安全认证的过程。下面,我们结合 Netty SsL调测日志,对双
向认证的差异点进行分析。
相比于客户端,服务端在发送 Serverhello时携带了要求客户端认证的请求信息,如
下所
*** CertificateRequest
Cert Types: RSA, DSS, ECDSA
Cert Authorities
<CN=localhost>
<CN-localhost>
客户端接收到服务端要求客户端认证的请求消息之后,发送自己的证书信息给服务
端,信息如下:
matching alias: smcc
+★ Certificate chain
chain [0]
Version: v3
subject: CN=localhost
signature
Algorithm
SHAlwithRSAr
o工D
1.2.840.113549.1.1.5
Key: Sun RSA public key, 2048 bits
.省略
535·Netty权威指南(第2版)
服务端对客户端的自签名证书进行认证,信息如下:
Found trusted certificate
Version: V3
Subject: CN=localhost
.省略
24.2.3第三方CA认证
使用 jdk keytool生成的数字证书是自签名的。自签名就是指证书只能保证自己是完整
且没有经过非法修改,但是无法保证这个证书是属于谁的。为了对自签名证书进行认证,
需要每个客户端和服务端都交换自己自签名的私有证书,对于一个大型网站或者应用服务
器,这种工作量是非常大的。
基于自签名的SsL双向认证,只要客户端或者服务端修改了密钥和证书,就需要重新
进行签名和证书交换,这种调试和维护工作量是非常大的。因此,在实际的商用系统中往
往会使用第三方CA证书颁发机构进行签名和验证。我们的浏览器就保存了几个常用的
CA ROOT。每次连接到网站时只要这个网站的证书是经过这些 CA ROOT签名过的。就
可以通过验证了。
CA数字证书认证服务往往是收费的,国内有很多数字认证中心都提供相关的服务,
有需要的可以通过这些商业机构获取认证。
作为示例,我们自己生成一个 CA ROOT的密钥对,部署应用时,把这个 CA ROOT
的私钥部署在所有需要SsSL传输的节点就可以完成安全认证。作为示例,如果要生成
CA_ROOT,我们使用开源的 OpenSSL。
在 Windows上安装和使用 OpenSsL网上有很多教程,也不是本文的重点,因此,
OpenSsL的安装和使用本文不详细介绍
下面我们对基于第三方CA认证的步骤进行详细介绍。
536·第24章安全性
24.2.3.1服务端证书制作
步骤1:利用 OpenSsL生成CA证书
openssl reg -new -x509-keyout ca key -out ca crt -days 365
步骤2:生成服务端密钥对:
keytool-genkey -alias securechat -keysize 2048 -validity 365
keyalg RSA -dname CN=localhost"-keypass sNetty -storepass
sNetty -keystore schat jks
步骤3:生成证书签名请求:
keytool-certreg -alias securechat -sigalg MD5withRSA -file
sChat. csr-keypass sNetty -storepass sNetty-keystore
schat·ks
步骤4:用CA私钥进行签名:
openssl ca -in sChat csr -out sChat crt -cert ca crt
keyfile ca, key -ntext
步骤5:导入信任的CA根证书到 keystore
keytool -import -v-trustcacerts -alias ca root-file
ca crt -storepass sNetty -keystore sChat jks
步骤6:将CA签名后的 server端证书导入 keystore
keytool -import -v -alias securechat -file server. crt -keypass
sNetty -storepass sHetty -keystore sChat jks
242.32客户端证书制作
步骤1:生成客户端密钥对:
keytool -genkey -alias smcc -keysize 2048 -validity 365
-keyalg RSA -dname "CN=localhost"-keypass cNetty -storepass
CNetty -keystore chat. jks
步骤2:生成证书签名请求
537·Nety权威指南(第2版)
keytool -certreg -alias smcc -sigalg MDSwithRSA -file
cChat. csr -keypass CNetty -storepass CNetty -keystore
cHat. iks
步骤3:用CA私钥进行签名:
openssl ca -in cHat, csr -out cNetty crt -cert ca, crt
keyfile ca key -ntext
步骤4:导入信任的CA根证书到 keystore
keytool -import -v-trustcacerts -alias ca root -file
ca crt -storepass cNetty -keystore chat jks
步骤5:将CA签名后的 client端证书导入 keystore:
keytool -import -v -alias smcc -file cNetty crt -keypass
CNetty -storepass cNetty -keystore cHat, jks
基于CA认证的开发和测试与SSL双向和单向认证代码相同,此处不再赘述。
243 Netty SSL源码分析
24.3.1客户端
当客户端和服务端的TCP链路建立成功之后, SslHandler的 channelactive被触发,
sSL客户端通过SSL引擎发起握手请求消息,代码如下:
private Future<channel> handshake () t
....以上代码省略
try i
engine. beginHandshake()i
wrapNonAppData(ctx, false)i
ctx. flush()i
i catch (Exception e) t
notifyHandshakeFailure(e)i
return handshakepromise
538·第24章安全性
发起握手请求之后,需要将 SSLEngine创建的握手请求消息进行SSL编码,发送给服
务端,因此,握手之后立即调用 wrapNonAppData方法,下面具体对该方法进行分析:
private void wrapNonAppData(ChannelHandlerContext ctx, boolean inUnwrap)
throws SSlException I
ByteBuf out nulli
try i
for (i)
if (out = null) t
out ctx alloc () buffer(max PacketBuffersize)i
SSLEngineResult result= wrap(engine, Unpooled EMPTY BUFFER,
out)i
if (result. bytesProduced()>0) t
ctx. write (out)i
if (inUnwrap) f
needsflush
true i
out nulli
因为只需要发送握手请求消息,因此 Source Byte Buf为空,下面看下wrap方法的具
体实现:
private SSLEngineResult wrap(SSLEngine engine, ByteBuf in, ByteBuf out
throws SSLException I
ByteBuffer ino in. nioBuffer()i
for(;;){
ByteBuffer
◎ut0
out. nioBuffer (out. writerIndex()
out. writableBytes())i
SSLEngineResult result engine wrap(ino, out0)i
in. skipBytes (result. bytesConsumed())i
out. writerIndex(out. writerIndex()+ result. bytesProduced())i
后续代码省略
将SSL引擎中创建的握手请求消息编码到目标 Byte Buffer中,然后对写索引进行更新
判断写入操作是否越界,如果越界说明out容量不足,需要调用 ensure writable对 ByteBuf
进行动态扩展,扩展之后继续尝试编码操作。如果编码成功,返回SSL引擎操作结果。
539Nety权威指南(第2版
对编码结果进行判断,如果编码字节数大于0,则将编码后的结果发送给服务端,然
后释放临时变量out
判断SSL引擎的操作结果,SSL引擎的操作结果定义如下
1. FINISHED: SSLEngine已经完成握手
2. NEED TASK: SSLEngine在继续进行握手前需要一个(或多个)代理任务的结果
3. NEED UNWRAP:在继续进行握手前, SSLEngine需要从远端接收数据,所以应
带调用 SSLEngine unwrap(;
4. NEED WRAP:在继续进行握手前, SSLEngine必须向远端发送数据,所以应该调
用 SSLEngine. wrap()
5. NOT HANDSHAKⅠ NG: SSLEngine当前没有进行握手。
下面我们分别对5种操作的代码进行分析:
switch (result. getHandshakeStatus()) t
case FINIshed
setHandshakesuccess()i
breaki
case Need TasK
run DelegatedTasks()i
break
case NEED UNWRAP:
f ( inUnwrap) I
unwrap(ctx)i
break;
case NeeD Wrap
break:
case Not handshaking
if (i inUnwrap) t
unwrap(ctx)i
breaki
default
throw new IllegalstateException(Unknown handshake
status: " result. getHandshakeStatus ())i
·540第24章安全性
如果握手成功,则设置 handshake Promise的操作结果为成功,同时发送
SsIHandshake Completion Event. SUCCES给SSL监听器,代码如下
private void setHandshake Success() f
if (handshakePromise trySuccess(ctx channel()))f
ctx. fireUserEventTriggered(SslHandshakeCompletionEvent. SUCCESS)
如果是 NEED TASK,说明异步执行 SSL Task,完成后续可能耗时的操作或者任务,
Net!y封装了一个任务立即执行线程池专门处理SSL的代理任务,代码如下:
private void runDelegatedTasks() I
for (i:)
Runnable task engine get De legatedTask()i
if (task = null)
breaki
delegatedTaskExecutor, execute(task)i
如果是 NEED UNWRAP,则判断是否由 UNWRAP发起,如果不是则执行 UNWRAP
操作
如果是 NOT HANDSHAKING,则调用 unwrap,继续接收服务端的消息。
服务端应答消息的接收跟服务端接收客户端的代码类似,唯一不同之处在于SSL引擎
的客户端模式设置不同,一个是服务端,一个是客户端。上层的代码处理是相同的,下面
我们在SsL服务端章节分析握手消息的接收。
24.3.2服务端
SSL服务端接收客户端握手请求消息的入口方法是 decode方法,下面对它进行详细
分析
首先获取接收缓冲区的读写索引,并对读取的偏移量指针进行备份:
541Net!权威指南(第2版)
protected void decode( ChannelHandlerContext ctx, ByteBuf in, List<object>
out) throws SSLException i
final int startoffset in. reader Index()i
final int endoffset in, writerIndex()i
int offset startoffset:
对半包标识进行判断,如果上一个消息是半包消息,则判断当前可读的字节数是否小
于整包消息的长度,如果小于整包长度,则说明本次读取操作仍然没有把SSL整包消息读
取完整,需要返回IO线程继续读取,代码如下:
if (packetLength >0)(
if (endoffset startoffset packetlength) t
returni
代码省略
如果消息读取完整,则修改偏移量:同时置位半包长度标识。
else t
offset + packetLengthi
packetLength= 0
下面在for循环中读取SSL消息,因为TCP存在拆包和粘包,因此一个 Byte Buf可能
包含多条完整的SSL消息。
首先判断可读的字节数是否小于协议消息头长度,如果是则退出循环继续由IO线程
接收后续的报文:
for(;;){
final int readableBytes endoffset offset;
if (readableBytes 5) t
break;
..,,后续代码省略
获取SSL消息包的报文长度,具体算法不再介绍,可以参考SSL的规范文档进行解
读,代码如下:
if (tls) t
int majorVersion= buffer. getUnsignedByte (offset 1)i
·542·第24章安全性
if (majorversion ==3)
packetLength buffer getUnsignedshort(offset +3)+51
if (packetLength <=5)1
tls= false;
t else
t1s=fa⊥se;
对长度进行判断,如果SSL报文长度大于可读的字节数,说明是个半包消息,将半包
标识长度置位,返回IO线程继续读取后续的数据报,代码如下:
if (packetLength >0)t
if (endoffset startoffset packetlength)
return:
y else I
offset + packetLengthi
acketleng th
对消息进行解码,将SSL加密的消息解码为加密前的原始数据, unwrap方法如下:
private static SSLEngineResult unwrap(SSLEngine engine, ByteBuffer in,
ByteBuf out) throws SsLException I
int overflows =0
for(:;){
ByteBuffer
outo
out. nioBuffer(out. writerIndex()r
out. writableBytes())i
SSLEngineResult result engine unwrap(in, outo)i
out. writerIndex(out. writerIndex ()+ result. bytesProduced());
后续代码省略
调用 SSLEngine的 unwrap方法对SSL原始消息进行解码,对解码结果进行判断,如
果越界,说明out缓冲区不够,需要进行动态扩展。如果是首次越界,为了尽量节约内存,
使用SSL最大缓冲区长度和SSL原始缓冲区可读的字节数中较小的。如果再次发生缓冲
区越界,说明扩张后的缓冲区仍然不够用,直接使用SSL缓冲区的最大长度,保证下次解
543·Nety权威指南(第2版
码成功。
解码成功之后,对SSL引擎的操作结果进行判断:如果需要继续接收数据,则继续执
行解码操作;如果需要发送握手消息,则调用 wrapNonAppData发送握手消息;如果需要
异步执行SSL代理任务,则调用立即执行线程池执行代理任务;如果是握手成功,则设置
SSL操作结果,发送SSL握手成功事件;如果是应用层的业务数据,则继续执行解码操作
其他操作结果,抛出操作类型异常。
需要指出的是,SSL客户端和服务端接收对方SSL握手消息的代码是相同的,那为什么
SSL服务端和客户端发送的握手消息不同呢?这些是SSL引擎负责区分和处理的,我们在创
建SSL引擎的时候设置了客户端模式,SSL引擎就是根据这个来进行区分的,代码如下
engine. setUseClientMode(false l true)i
24.3.3消息读取
SSL的消息读取实际就是 Byte ToMessageDecoder将接收到的SSL加密后的报文解码
为原始报文,然后将整包消息投递给后续的消息解码器,对消息做二次解码。基于SSL
的消息解码模型如下:
Byte ToMessage Decoder
SslHandler
业务解码器
SSL消息读取的入口都是 decode,因为是非握手消息,它的处理非常简单,就是循环
调用引擎的 unwrap方法,将SSL报文解码为原始的报文,代码如下:
private static SslEngineResult unwrap(SSLEngine engine, ByteBuffer in,
ByteBuf out) throws SSLException i
int overflows =0;
for(冫;){
ByteBuffer
outo
out. nioBuffer(out. writerindex()
out. writableBytes ());
SSLEngineResult result engineunwrap(in, out0)i
out. writerIndex (out. writerIndex()+ result. bytes Produced())i
,.,,后续代码省略
握手成功之后的所有消息都是应用数据,因此它的操作结果为 NOT HANDSHAKING,
遇到此标识之后继续读取消息,直到没有可读的字节,退出循环,代码如下:
·544·第24章安全性
if (status = Status BUFFER UNDERFLOW II consumed ==0 & produced ==0)t
break:
如果读取到了可用的字节,则将读取到的缓冲区加到输出结果列表中,代码如下:
finally
if(tota⊥ Produced>0)
ByteBuf decodeOut this. decodeOuti
this. decodeout null
out. add(decodeout);
Byte ToMessage Decoder判断解码结果List,如果非空,则循环调用后续的 Handler,
由后续的解码器对解密后的报文进行二次解码
24.3.4消息发送
SSL消息发送时,由 SsIHandler对消息进行编码,编码后的消息实际就是SSL加密后
的消息,它的入口是ush方法,代码如下:
public void flush(ChannelHandlerContext ctx) throws Exception i
if (startris & sentFirstMessage)i
此处代码省略
wrap(ctx, false)i
ctx. flush()i
从待加密的消息队列中弹出消息,调用SSL引擎的wrap方法进行编码,代码如下:
for(冫;)
PendingWrite pending pendingUnencryptedwrites peek();
if (pending== null) I
break
if (out
nu11){
out ctx, alloc(), buffer(max PacketBufferSize)i
if (!(pending. msg() instanceof ByteBuf))
ctx. write(pending. msg(
ChannelPromise)
545Net!t权威指南(第2版)
pending. recycleAndGet())i
pendingUnencryptedWrites. remove()i
continue
ByteBuf buf =(ByteBuf) pending. msg()i
SSLEngineResult result wrap(engine, buf, out)i
wrap方法很简单,就是调用ssL引擎的编码方法,然后对写索引进行修改,如果缓
冲区越界,则动态扩展缓冲区。对SSL操作结果进行判断,因为已经握手成功,因此返回
的结果是 NOT HANDSHAKING,执行 finish Wrap方法,调用 ChannelHandlerContext的
write方法,将消息写入发送缓冲区中,如果待发送的消息为空,则构造空的 ByteBuf写入
private void finishWrap( ChannelHandlerContext ctx, ByteBuf out
Channelpromise promise, boolean inUnwrap) i
if (out = null)[
out Unpooled EMPTY BUFFER;
F else if (!out. isReadable())I
out release(
out = Unpooled EMPTY BUFFER;
if (promise . null) I
ctx, write(out, promise);
else
ctx. write(out)i
if (inUnwrap) I
needs Flush true;
编码后,调用 ChannelHandlerContext的fush方法消息发送给对方,即可完成消息的
SSL加密发送。
244 Netty扩展的安全特性
利用Nety的 Channelhandler接口提供的网络切面,用户可以非常容易的扩展Net!y
的安全策略,下面对比较典型的安全扩展特性进行讲解。
546·第24章安全性
24.4.1|P地址黑名单机制
IP地址黑名单是比较常用的弱安全保护策略,它的特点就是服务端在与客户端通信的
过程中,对客户端的IP地址进行校验,如果发现对方IP在黑名单列表中,则拒绝与其通
信,关闭链路。
下面我们对基于IP地址的黑名单在Nety中的实现进行介绍。
首先定义 Blacklist handler继承自 ChannelHandler Adapter,然后定义IP地址黑名单列
表,如下所示:
private final List<InetAddress> blacklist- new CopyonWriteArrayList
<InetAddress>(i
提供对 public的黑名单管理接口,用于设置黑名单、删除或者添加黑名单,示例代码
如下:
public void setBlacklist(InetAddress[] addresses) [//TODO K
public boolean removeBlacklist(InetAddress address) //TODO]
public boolean addBlacklist(InetAddress address) f//TODO H
public void clearBlacklist()[//TODO H
链路注册、链路激活、消息读取、消息发送的时候对对端的IP地址进行校验,如果
在黑名单列表中,则拒绝当前操作,并关闭链路,打印日志,相关伪代码如下:
public void channelRegistered ( ChannelHandlercontext ctx) throws Exception
If(//在黑名单列表中)
//打印日志
ctx.c1ose();//关闭链路
return.
//其他代码
public void channelActive( ChannelHandlercontext ctx) throws Exception
If(//在黑名单列表中)
//打印日志
ctx.c1ose();//关闭链路
return;
547·Nety权威指南(第2版)
//其他代码
public void channelRead( ChannelHandlercontext ctx, Object msg) throws
Exception t
If(//在黑名单列表中)
//打印日志
ctx. close();//关闭链路
return:
//其他代码
public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise
promise) throws Exception t
If(//在黑名单列表中)
//打印日志
ctx.c1ose();//关闭链路
return
//其他代码
为什么要在消息读取和发送的时候也要对黑名单进行判断呢?原因是黑名单支持动
态添加策略,一些黑名单是通过业务逻辑判断和执行过程中动态添加进去的,如果是长链
接,只在链路首次建立的时候判断是不够的。
24.4.2接入认证
接入认证策略非常多,通常是较强的安全认证策略,例如基于用户名+密码的认证,
认证内容往往采用加密的方式,例如Base64+AES等。
在Nety中如果要支持安全认证,往往是通过定制 ChannelHandler接口来实现,具体
策略如下:
1.在链路首次激活的时候,客户端发送认证信息给服务端,伪代码如下:
public void channelActive(ChannelHandlerContext ctx) throws Exception t
//发送认证信息给服务端
548·第24章安全性
2.服务端接收到客户端消息之后,根据消息内容进行判断,如果是首次接入的认证
消息,则进行认证,认证失败,打印日志,关闭链接;认证成功,继续业务逻辑处理,伪
代码如下:
public void channelRead(ChannelHandler Context ctx, Object msg) throws
Exception
If(//接入认证消息)
//接入认证
If(//认证失败)
//打印异常日志
//关闭链路
return
else
//业务逻辑处理
3.客户端接收到服务端消息,对消息类型进行判断,对于认证应答消息,如果认证
成功,则继续业务逻辑处理;如果认证失败,则关闭链路,打印异常日志:
public void channelRead(ChannelHandlerContext ctx Object msg) throws
Exception i
If(//接入认证应答消息)
If(//认证失败)
//打印异常日志
//关闭链路
returni
el se
//业务逻辑处理
通常情况下,接入认证失败服务端都会返回认证失败应答消息,给出错误码或者认证
失败原因,如果服务端不返回失败应答而是直接关闭链路,客户端接收到链路关闭通知之
后直接关闭链路即可。
549·Net!y权威指南(第2版)
244总结
本章首先对网络通信安全面临的严峻挑战进行了介绍,然后结合 Netty的安全特性进
行了针对性的讲解,对Net!yssL的开发、设计原理和源码进行了深入剖析,以期读者能
够快速上手并掌握 Netty SSL安全特性。最后,对 Netty安全性的扩展方案和策略进行了
讲解,以方便用户按需定制,满足个性化的安全需求。
550·第25章
Netty耒来展望
作为本书的结尾章节,和读者朋友们一起展望下 Netty的未来
本章主要内容包括
◎应用范围
◎技术演进
◎社区活跃度
o Road Map
25.1应用范围
随着大数据、互联网和云计算的发展,传统的垂直架构逐渐将被分布式、弹性伸缩的
新架构替代
系统只要分布式部署,就存在多个节点之间通信的问题,由于是内部通信,同时强调
高可扩展性和髙性能,因此往往会选择高性能的通信方式,利用Nety+二进制编解码承
载这些内部私有协议,已经逐渐成为业界主流的用法。例如阿里的分布式服务框架 Dubbo、
RocketMC、 Hadoop的Avro等。Net!y权威指南(第2版)
随着JDK7的逐渐普及,Java的原生NlO类库已经升级到了NIO2.0,未来越来越多
基于传统 Socket编程的应用程序会切换到新的NIO类库上,考虑到切换和维护成本,大
多数公司将会选择Nety或者Mina作为高性能的NIO框架来实现异步通信。
可以预见在未来2~3年内,基于NO的异步通信将成为Java网络编程的主流,未来
Net!y的应用范围将会越来越广。
25.2技术演进
随着JDK8的推出, ORACLE公司也加大了JDK7的推广力度,并给出了JDK6的
deadline。 Netty的5.X系列版本将紧跟JDK的发展潮流,可以预测,越来越多JDK7的新
特性将被Net!y5.X系列版本使用,最引人注目的一个就是NIO2.0类库中AIO的使用。
让我们拭目以待Nety5.0正式版本的推出吧。
25.3社区活跃度
Net!y的社区一直非常活跃,APl文档和开发指南内容也比较全面,Bug的修复速度相
对较快,这些因素促进了Nety社区的良性发展。
25.4 Road Map
Net!y的版本更新节奏非常快,主要原因如下。
◎Bug的修正速度较快。
◎新特性的推出速度快。
下面我们一起看下 Netty4X系列的版本更新情况,如图25-1所示。
2013年12月22日, Netty推出了新的 Netty.0.0. Alpha,这预示着2014年Ne!将
会不断推出50系列的公测和正式版本,可以预测,5.0系列的第一个Fina版本可能会在
2014年底推出,届时,“赶时髦”的读者朋友们就可以考虑是否使用和升级最新的Net!y5.0
552第25章 Netty未来展望
系列版本,体验更多的新特性和新功能。参见图25-1。
Netty 4. 0. 18. Final released on 01-Apr-14
Netty 4.0. 17 Final released on 25-Feb-14
Netty 40. 15. Final released on 21-Jan-14
Netty 40. 13.Final released on 02-Dec-13y
Three releases a day. 5.0.0 Alpha1, 4.0.14. and 3.9, 0 on 22-Dec-13
Netty 4.0. 11. Final released on 21-0ct-13
Netty 4. 0. 10. Final released on 03-0ct-13
Netty 4.0, 9 Final released on 06-Sep-13
Netty 3. 0. Final released on 05-Sep-13
Netty adopts the modified Semantic versioning on 27-Aug-13
Netty 4.0. 8 Final released on 26-Aug-13
Netty 4.0, 7. Final released on 08-Aug-13
Netty 4.0.6. Final released on 01-Aug-13
Netty 4.0 4 Final released on 23-JuI-13
Netty 4. 0.2.Final released on 17-JuF-13
Netty 4. 0. 1. Final released on 16-JuI-13
Netty 4.0.0 Final released on 16-Jul-13
Netty 4.0.0.CR9 released on 02-Juk-13
Netty 4.0.0. CR6 released on 21-Jun-13
Netty 4. 0. 0. CR5 released with nem-new API on 18-Jun-13
Netty 3.6.6 Final released on 15-May-13
Netty 4.0.0. CR2 released on 08-May. 13
Netty 3.6.5. Final released on 09-Apr-13
Netty 3.6. 4.Final released on 05-Apr-13
Netty 4.0. 0. RC1 released on 22-Mar-13
N己A自白2ri。a凸nn1ME12
图25-1Ne!y4X系列的版本更新一览表
255总结
作为本书的最后一个章节,我们一起展望了Nety的美好未来,作为最有影响力的NlO
框架,Nety得到了众多架构师和程序员的喜爱。希望在未来的工作中,读者能够把 Netty
用起来,用好它,让它为你的项目、你的公司创造更大的价值。
553附录 a Netty参数配置表
配置参数名
功能说明
内存池堆内存内存区域的个数。默认值:
1o. netty allocator, numHeaparenas
Math. min(runtime avai lableProcessorso
Runtime. getRuntime(). max Memory(/ defaultChunkSize/2/3
内存池直接内存内存区域的个数。默认值:
io netty allocator num DirectArenas
Math. min(runtime. available Processors)
Runtime. getRuntime(). max Memory(/ default Chunk Size /2/3)
1o. netty allocator. page Size
个page的内存大小,默认值8192
用于计算内存池中一个 Chunk内存的大小:
io netty allocator. maxOrder
默认值11,计算公式如下
I Chunk=8192<<11=16MB
io netty, allocator chunk Size
一个 Chunk内存的大小,如果没有设置,默认值为 page Size<< max order=16M
Ney的 JDK SelectionKey优化开关,默认关闭,设置tue开启,性能优化开关,
io netty, nokeySetOptimization
对上层用户不感知
io netty selector Threshold
重建 selector的阈值,修复JKNO多路复用器死循环问题。默认值为512
io netty thread Local BufferSize
线程本地变量直接内存缓冲区大小,默认64KB
io netty machined
用户设置的机器id,默认会根据MAC地址自动生成
io netty processed
用户设置的流程ID,默认会使用随机数生成
io netty. eventLoop Threads
Reactor线程 NioEventLoop的个数,默认值CPU个数x2
ionetty no JdkzlibDecoder
是否使用 JDK Zlib压缩解码器,默认不使用
io netty. noPrefer Direct
是否允许通过底层API直接访问直接内存。默认值:允许
是否允许使用 sun.misc. Unsafe,默认允许。
1o. netty. noUnsafe
注意:使用sun的私有类库存在平台可移植问题:另外, sun. mlse. Unsafe类是不
安全的,如果操作失败,不是抛出异常,而是虚拟机 core dump。不建议使用 Unsafe
ionetty.noJavassist
是否允许使用 Javassist类库,默认允许
io, netty. initialSeedUniquifier
本地线程相关的随机种子初始值,默认值为0