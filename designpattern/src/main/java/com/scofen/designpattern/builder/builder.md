一：建造者模式的定义

　　使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建
型模式，它提供了一种创建对象的最佳方式。

　　一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。

二：适配器模式的结构

　　意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。

　　主要解决：主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，
其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的
各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。

　　何时使用：一些基本部件不会变，而其组合经常变化的时候。

　　如何解决：将变与不变分离开。

　　关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。

　　应用实例： 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是
经常变化的，生成出所谓的"套餐"。 2、JAVA 中的 StringBuilder。

　　优点： 1、建造者独立，易扩展。 2、便于控制细节风险。

　　缺点： 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。

　　使用场景： 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。

　　注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。

　　业务场景：当我们需要创建一个复杂的对象时，使用静态工厂或者构造器的方式就显得特别笨拙和丑陋，
因为它们有个共同的局限性：它们都不能很好地扩展到大量的可选参数。考虑用一个Person类来描述一个人，
除了姓名，性别，生日，邮箱等必要的属性外，还有很多可选的属性，
比如：身高，学历，绰号，体重，通讯地址等等。对于这样的类，我们应该如何创建对象呢？
无论是常见的重叠构造器模式还是JavaBeans模式，它们都不能很好地解决这类问题


　　不直接生成想要的对象，而是让客户端利用 所有必要的参数 构造一个Builder对象，
然后在此基础上，调用类似于Setter的方法来设置每个可选参数，
最后通过调用无参的build()方法来生成不可变对象。一般地，所属Builder是它所构建类的静态成员类。


    Person类的构造方法是私有的: 也就是说，客户端不能直接创建User对象；
    Person类是不可变的: 所有的属性都被final修饰，在构造方法中设置参数值，并且不对外提供setters方法;
    Builder模式的高可读性： Builder模式使用了链式调用，可读性更佳。
    Builder对象与目标对象的异同： Person与Builder拥有共同的属性，并且Builder内部类构造方法中只接收必传的参数，
    同时只有这些必传的参数使用了final修饰符。
