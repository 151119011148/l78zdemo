　　JDK 自带的动态代理

     java.lang.reflect.Proxy:生成动态代理类和对象；
     java.lang.reflect.InvocationHandler（处理器接口）：可以通过invoke方法实现对真实角色的代理访问。

　　每次通过 Proxy 生成的代理类对象都要指定对应的处理器对象。


　　Cglib 动态代理是针对代理的类, 动态生成一个子类, 然后子类覆盖代理类中的方法, 如果是private
或是final类修饰的方法,则不会被重写。

　　CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理
提供了很好的补充。通常可以使用Java的动态代理创建代理，但当要代理的类没有实现接口或者为了
更好的性能，CGLIB是一个好的选择。

　　CGLIB作为一个开源项目，其代码托管在github，地址为：https://github.com/cglib/cglib

　　Cglib 与 JDK动态代理的运行性能比较，地址为：ttps://www.cnblogs.com/haiq/p/4304615.html

　　都说 Cglib 创建的动态代理的运行性能比 JDK 动态代理能高出大概 10 倍

　　jdk6 下，在运行次数较少的情况下，jdk动态代理与 cglib 差距不明显，甚至更快一些；而当调用次数增加之后，
 cglib 表现稍微更快一些，然而仅仅是“稍微”好一些，远没达到 10 倍差距
 
 　　jdk7 下，情况发生了逆转！在运行次数较少（1,000,000）的情况下，jdk动态代理比 cglib 快了差不多30%；而当
 调用次数增加之后(50,000,000)， 动态代理比 cglib 快了接近1倍。
 
 　　 jdk8 下，延续了 JDK7 下的惊天大逆转！不过还观察另外有一个细微的变化，从绝对值来看 cglib 在 jdk8 下
 的表现似乎比 jdk7 还要差一点点，尽管只是一点点，但经过反复多次的执行仍然是这个趋势

　　结论：从 jdk6 到 jdk7、jdk8 ，动态代理的性能得到了显著的提升，而 cglib 的表现并未跟上，甚至可能
会略微下降。传言的 cglib 比 jdk动态代理高出 10 倍的情况也许是出现在更低版本的 jdk 上吧。

　　以上测试用例虽然简单，但揭示了 jdk 版本升级可能会带来一些新技术改变，会使我们以前的经验
失效。放在真实业务场景下时，还需要按照实际情况进行测试后才能得出特定于场景的结论。

　　总之，实践出真知，还要与时俱进地去检视更新一些以往经验。